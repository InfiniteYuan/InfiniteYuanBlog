<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>InfiniteYuan</title>
  
  
  <link href="/InfiniteYuanBlog/atom.xml" rel="self"/>
  
  <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/"/>
  <updated>2020-07-23T08:03:09.471Z</updated>
  <id>https://infiniteyuan.github.io/InfiniteYuanBlog/</id>
  
  <author>
    <name>InfiniteYuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ESP32 开发笔记（十五）使用 LittlevGL 实现 2048 小游戏</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2020/05/17/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E4%BD%BF%E7%94%A8%20LittlevGL%20%E5%AE%9E%E7%8E%B0%202048%20%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2020/05/17/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E4%BD%BF%E7%94%A8%20LittlevGL%20%E5%AE%9E%E7%8E%B0%202048%20%E5%B0%8F%E6%B8%B8%E6%88%8F/</id>
    <published>2020-05-17T14:43:38.000Z</published>
    <updated>2020-07-23T08:03:09.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-LittlevGL-实现-2048-小游戏"><a href="#使用-LittlevGL-实现-2048-小游戏" class="headerlink" title="使用 LittlevGL 实现 2048 小游戏"></a>使用 LittlevGL 实现 2048 小游戏</h1><p>2048 这款益智小游戏，游戏的规则十分简单，简单易上手的数字小游戏，但又十分虐心。曾经也是风靡一时。</p><p>现在我们在 ESP32 上自己动手实现 2048 这款小游戏吧。</p><a id="more"></a><h2 id="1-使用-LittlevGL"><a href="#1-使用-LittlevGL" class="headerlink" title="1 使用 LittlevGL"></a>1 使用 LittlevGL</h2><p>esp32-lvgl-gui 仓库已经适配了 LittlevGL V5.3，并适配了几款屏幕(ILI9341、ST7789、SSD1306、NT35510) 和 触摸驱动(FT5X06、XPT2046)。</p><p>使用时，在 <code>menuconfig</code> 中选择你所使用的 屏幕 和 触摸驱动。</p><p>编译代码：</p><ol><li>添加头文件：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lvgl includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iot_lvgl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* game include */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"game.h"</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>初始化 LittlevGL：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Initialize LittlevGL */</span></span><br><span class="line">    lv_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tick interface， Initialize a Timer for 1 ms period and in its interrupt call*/</span></span><br><span class="line">    <span class="comment">// esp_register_freertos_tick_hook(lv_tick_task_callback);</span></span><br><span class="line">    lvgl_tick_timer = xTimerCreate(</span><br><span class="line">        <span class="string">"lv_tickinc_task"</span>,</span><br><span class="line">        <span class="number">1</span> / portTICK_PERIOD_MS,            <span class="comment">//period time</span></span><br><span class="line">        pdTRUE,                            <span class="comment">//auto load</span></span><br><span class="line">        (<span class="keyword">void</span> *)<span class="literal">NULL</span>,                      <span class="comment">//timer parameter</span></span><br><span class="line">        lv_tick_task_callback);            <span class="comment">//timer callback</span></span><br><span class="line">    xTimerStart(lvgl_tick_timer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Display interface */</span></span><br><span class="line">    lvgl_lcd_display_init();           <span class="comment">/*Initialize your display*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Input device interface */</span></span><br><span class="line">    input_device = lvgl_indev_init();                     <span class="comment">/*Initialize your indev*/</span></span><br><span class="line"></span><br><span class="line">    lvgl_timer = xTimerCreate(</span><br><span class="line">        <span class="string">"lv_task"</span>,</span><br><span class="line">        <span class="number">10</span> / portTICK_PERIOD_MS,           <span class="comment">//period time</span></span><br><span class="line">        pdTRUE,                            <span class="comment">//auto load</span></span><br><span class="line">        (<span class="keyword">void</span> *)<span class="literal">NULL</span>,                      <span class="comment">//timer parameter</span></span><br><span class="line">        lvgl_task_time_callback);          <span class="comment">//timer callback</span></span><br><span class="line">    xTimerStart(lvgl_timer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2048 game init</span></span><br><span class="line">    game_init(<span class="number">480</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// game logic handle task</span></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        user_task,   <span class="comment">//Task Function</span></span><br><span class="line">        <span class="string">"user_task"</span>, <span class="comment">//Task Name</span></span><br><span class="line">        <span class="number">1024</span>*<span class="number">4</span>,      <span class="comment">//Stack Depth</span></span><br><span class="line">        <span class="literal">NULL</span>,        <span class="comment">//Parameters</span></span><br><span class="line">        <span class="number">1</span>,           <span class="comment">//Priority</span></span><br><span class="line">        <span class="literal">NULL</span>);       <span class="comment">//Task Handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2048-游戏逻辑"><a href="#2-2048-游戏逻辑" class="headerlink" title="2 2048 游戏逻辑"></a>2 2048 游戏逻辑</h2><h3 id="2-1-界面初始化"><a href="#2-1-界面初始化" class="headerlink" title="2.1 界面初始化"></a>2.1 界面初始化</h3><p>将游戏相关界面初始化分为以下几步：</p><ol><li>Step 1: 画游戏背景</li><li>Step 2: 画游戏分数显示框</li><li>Step 3: 画游戏网格</li><li>Step 4: 画游戏网格中每个单元格的内容</li></ol><h3 id="2-2-滑动处理"><a href="#2-2-滑动处理" class="headerlink" title="2.2 滑动处理"></a>2.2 滑动处理</h3><h4 id="2-2-1-判断滑动方向"><a href="#2-2-1-判断滑动方向" class="headerlink" title="2.2.1 判断滑动方向"></a>2.2.1 判断滑动方向</h4><p>通过调用 LittlevGL 的 API 读取触摸状态(抬起/按下、坐标点)，计算水平/竖直方向滑动的差值，判断为哪个方向上的滑动(上/下/左/右)，执行相应的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">lv_indev_drv_t</span> input_device;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">user_task</span><span class="params">(<span class="keyword">void</span> *pvParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> pressing = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">lv_indev_data_t</span> touchpad_data;</span><br><span class="line">    <span class="keyword">lv_point_t</span> last_data;</span><br><span class="line">    <span class="keyword">int16_t</span> x_diff, y_diff;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(<span class="number">50</span> / portTICK_PERIOD_MS);</span><br><span class="line">        input_device.<span class="built_in">read</span>(&amp;touchpad_data); <span class="comment">// 读取触摸驱动的值</span></span><br><span class="line">        <span class="keyword">if</span> (touchpad_data.state == LV_INDEV_STATE_REL) &#123; <span class="comment">// 当前为 `抬起` 状态</span></span><br><span class="line">            pressing = <span class="literal">false</span>; <span class="comment">// 计算坐标偏移量</span></span><br><span class="line">            x_diff = touchpad_data.<span class="built_in">point</span>.x - last_data.x;</span><br><span class="line">            y_diff = touchpad_data.<span class="built_in">point</span>.y - last_data.y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(x_diff) &gt; SENSITIVE || <span class="built_in">fabs</span>(y_diff) &gt; SENSITIVE) &#123; <span class="comment">// 判断滑动距离是否超过判断阈值</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(x_diff) &gt; <span class="built_in">fabs</span>(y_diff)) &#123; <span class="comment">// 判断是否为水平滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (x_diff &gt; <span class="number">0</span>) &#123; <span class="comment">// 判单是否为向右滑动</span></span><br><span class="line">                        move_right();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向左滑动</span></span><br><span class="line">                        move_left();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 竖直方向滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (y_diff &gt; <span class="number">0</span>) &#123; <span class="comment">// 判单是否为向下滑动</span></span><br><span class="line">                        move_down();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向上滑动</span></span><br><span class="line">                        move_up();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last_data.x = touchpad_data.<span class="built_in">point</span>.x;</span><br><span class="line">            last_data.y = touchpad_data.<span class="built_in">point</span>.y;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (touchpad_data.state == LV_INDEV_STATE_PR) &#123; <span class="comment">// 当前为 `按下` 状态</span></span><br><span class="line">            <span class="keyword">if</span> (!pressing) &#123; <span class="comment">// 按下状态，记录初次按下的坐标点</span></span><br><span class="line">                last_data.x = touchpad_data.<span class="built_in">point</span>.x;</span><br><span class="line">                last_data.y = touchpad_data.<span class="built_in">point</span>.y;</span><br><span class="line">                pressing = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-滑动逻辑处理"><a href="#2-2-2-滑动逻辑处理" class="headerlink" title="2.2.2 滑动逻辑处理"></a>2.2.2 滑动逻辑处理</h4><ol><li>判断同一行/列滑动方向上是否存在相等的数值</li><li>相同的单元格，数值相加为相邻单元格中的后一个(滑动方向上)的数值</li><li>画出总的得分</li><li>判断游戏是否结束</li><li>刷新界面上的单元格</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> num_matrix[<span class="number">5</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 保存所有的单元格中的数值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> score_num = <span class="number">0</span>; <span class="comment">// 总得分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_up</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t, nx = <span class="number">-1</span>, ny = <span class="number">0</span>, nn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i)</span><br><span class="line">        tmp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num_matrix[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[++k] = num_matrix[i][j];</span><br><span class="line">                num_matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &lt;= k - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[t] == tmp[t + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t] *= <span class="number">2</span>;</span><br><span class="line">                tmp[t + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                score_num += tmp[t];</span><br><span class="line">                <span class="keyword">if</span> (nx == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nx = t;</span><br><span class="line">                    ny = j;</span><br><span class="line">                    nn = tmp[t];</span><br><span class="line">                &#125;</span><br><span class="line">                t += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t++;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            <span class="keyword">if</span> (tmp[i])</span><br><span class="line">                num_matrix[t++][j] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画总分</span></span><br><span class="line">    draw_score_num(score_num);</span><br><span class="line">    <span class="comment">// 刷新网格中单元格的内容</span></span><br><span class="line">    gen_num();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>GitHub 源码：<a href="https://github.com/InfiniteYuan/esp32-lvgl-gui/tree/master/lvgl_2048" target="_blank" rel="noopener">esp32-lvgl-gui</a></li><li>Twitter 视频：<a href="https://twitter.com/InfiniteYuan/status/1048106496649641985?s=20" target="_blank" rel="noopener">Twitter</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-LittlevGL-实现-2048-小游戏&quot;&gt;&lt;a href=&quot;#使用-LittlevGL-实现-2048-小游戏&quot; class=&quot;headerlink&quot; title=&quot;使用 LittlevGL 实现 2048 小游戏&quot;&gt;&lt;/a&gt;使用 LittlevGL 实现 2048 小游戏&lt;/h1&gt;&lt;p&gt;2048 这款益智小游戏，游戏的规则十分简单，简单易上手的数字小游戏，但又十分虐心。曾经也是风靡一时。&lt;/p&gt;
&lt;p&gt;现在我们在 ESP32 上自己动手实现 2048 这款小游戏吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十四）ESP32 I2C Slave 实现</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89ESP32%20I2C%20Slave%20%E5%AE%9E%E7%8E%B0/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89ESP32%20I2C%20Slave%20%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-11-22T01:24:44.000Z</published>
    <updated>2020-07-23T08:03:09.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文章将介绍使用 ESP32 作为 I2C 实现 Random Read/Write 和  Sequential Read/Write 时序。</p><p>首先通过下面的图了解下 Random Read 时序，I2C Master 通过这个时序读取任意数据地址开始的数据。<br><img src="https://img-blog.csdnimg.cn/20191123145556881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="Random Read"></p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">___________________________________________________________________________________________________________________________________________________</span><br><span class="line">| start | slave_addr + write_bit + ack | data address |start | slave_addr + read_bit + ack |  <span class="built_in">read</span> n<span class="number">-1</span> bytes + ack | <span class="built_in">read</span> <span class="number">1</span> <span class="keyword">byte</span> + nack | <span class="built_in">stop</span> |</span><br></pre></td></tr></table></figure><blockquote><p><strong>RANDOM READ</strong>: A random read requires a “dummy” byte write sequence to load in the data word address. Once the device address word and data word address are clocked in and acknowledged by the EEPROM, the microcontroller must generate another start condition.<br>The microcontroller now initiates a current address read by sending a device address with the read/write select bit high. The EEPROM acknowledges the device address and serially clocks out the data word. The microcontroller does not respond with a zero but does generate a following stop condition </p></blockquote><ul><li>现有的 I2C Slave 无法实现类似 Random Read 时序<ul><li>原因分析：esp-idf 提供的 <code>i2c_slave_write_buffer</code> <code>i2c_slave_read_buffer</code> API 都是操作 RingBuffer 实现，而 Random Read 需要 Slave 在 接收到 <code>slave_addr + read_bit + data address</code> 前将数据放入 I2C 的硬件 FIFO 中。若是通过 API 进行判断当前 Master 想要操作的 数据地址，会因为这个 API 都是操作 RingBuffer 而有所延迟，导致 Master 接收到错误的数据（因为此时硬件 FIFO 还没有数据）。</li><li>解决办法：<ul><li>在接收到 <code>slave_addr + write_bit + data address</code> 时将可能需要发送到主机的数据放入 TX FIFO 中，当主机继续发送 <code>slave_addr + read_bit + data address</code> 并 提供读数据时钟 时，I2C Slave 硬件会将 TX FIFO 中的数据发送到 Master。若主机不再发送 <code>slave_addr + read_bit + data address</code>，就将 FIFO 清空避免在之后的操作中造成错误。</li><li>通过自定义中断处理程序，在相应的中断中进行处理</li></ul></li></ul></li></ul><h1 id="I2C-中断介绍"><a href="#I2C-中断介绍" class="headerlink" title="I2C 中断介绍"></a>I2C 中断介绍</h1><ol><li>想要针对某个 I2C 或者 某种模式，使用自定义的中断处理程序，需要修改 <code>esp-idf/components/driver/i2c.c</code> 中的代码，这里仅仅针对 master 使用驱动中提供的中断处理程序，当模式为 Slave 时，使用自定义的中断处理程序。</li></ol><blockquote><p>在 release/3.2 中，无法直接使用 <code>i2c_isr_register</code> 覆盖之前的中断处理程序。通过简单修改驱动源文件，并在应用程序中调用 <code>i2c_isr_register</code> 实现使用自定义的中断处理程序。</p></blockquote><p>修改 <code>esp-idf/components/driver/i2c.c</code> 文件中 <code>i2c_driver_install</code>  函数中的这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == I2C_MODE_MASTER) &#123;</span><br><span class="line">    <span class="comment">//hook isr handler</span></span><br><span class="line">    i2c_isr_register(i2c_num, i2c_isr_handler_default, p_i2c_obj[i2c_num], intr_alloc_flags, &amp;p_i2c_obj[i2c_num]-&gt;intr_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用程序中使用自定义的中断处理程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> IRAM_ATTR <span class="title">i2c_slave_isr_handler_default</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief i2c slave initialization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">i2c_slave_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i2c_slave_port = I2C_SLAVE_NUM;</span><br><span class="line">    <span class="keyword">i2c_config_t</span> conf_slave;</span><br><span class="line">    conf_slave.sda_io_num = I2C_SLAVE_SDA_IO;</span><br><span class="line">    conf_slave.sda_pullup_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf_slave.scl_io_num = I2C_SLAVE_SCL_IO;</span><br><span class="line">    conf_slave.scl_pullup_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf_slave.mode = I2C_MODE_SLAVE;</span><br><span class="line">    conf_slave.slave.addr_10bit_en = <span class="number">0</span>;</span><br><span class="line">    conf_slave.slave.slave_addr = ESP_SLAVE_ADDR;</span><br><span class="line">    i2c_param_config(i2c_slave_port, &amp;conf_slave);</span><br><span class="line">    i2c_driver_install(i2c_slave_port, conf_slave.mode, I2C_SLAVE_RX_BUF_LEN, I2C_SLAVE_TX_BUF_LEN, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i2c_isr_register(I2C_SLAVE_NUM, i2c_slave_isr_handler_default, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>) != ESP_OK) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"i2c_isr_register error"</span>);</span><br><span class="line">        <span class="keyword">return</span> ESP_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Slave-中断处理程序"><a href="#Slave-中断处理程序" class="headerlink" title="Slave 中断处理程序"></a>Slave 中断处理程序</h1><p>需要使用的几个中断：</p><ul><li><strong>I2C_SLAVE_TRAN_COMP_INT</strong>：从机收到设备地址和数据地址时将触发（device address + W/R bit + data address），在这里需要判断 Write/Read。若是 Write，需要清空 TX FIFO，并提前将需要操作的数据放入 TX FIFO 中（根据数据地址），尽可能放满 TX FIFO</li><li><strong>I2C_TRANS_COMPLETE_INT</strong>：从机检测到 STOP 时将触发，这个中断中需要将 RX FIFO 中的数据取到数据缓冲区中</li><li><strong>I2C_TXFIFO_EMPTY_INT</strong>：硬件 TX FIFO 为空时将触发，（PS：实际测试触发时，FIFO 大小为 27 byte），将可能操作的数据继续放入 TX FIFO 中</li><li><strong>I2C_RXFIFO_FULL_INT</strong>：硬件 RX FIFO 满时将触发，将 RX FIFO 中的数据取到数据缓冲区中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> IRAM_ATTR <span class="title">i2c_slave_isr_handler_default</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i2c_num = I2C_SLAVE_NUM;</span><br><span class="line">    <span class="keyword">uint32_t</span> status = I2C_INSTANCE[i2c_num]-&gt;int_status.val;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    portBASE_TYPE HPTaskAwoken = pdFALSE;</span><br><span class="line">    <span class="keyword">while</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        status = I2C_INSTANCE[i2c_num]-&gt;int_status.val;</span><br><span class="line">        <span class="keyword">if</span> (status &amp; I2C_ACK_ERR_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"ae\n"</span>);</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_ena.ack_err = <span class="number">0</span>;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.ack_err = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_TRANS_COMPLETE_INT_ST_M) &#123; <span class="comment">// receive data after receive device address + W/R bit and data address</span></span><br><span class="line">            <span class="comment">// ets_printf("tc, ");</span></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.trans_complete = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> rx_fifo_cnt = I2C_INSTANCE[i2c_num]-&gt;status_reg.rx_fifo_cnt;</span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                <span class="comment">// ets_printf("R\n");</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                <span class="comment">// ets_printf("W ");</span></span><br><span class="line">                ets_printf(<span class="string">"Slave Recv"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; rx_fifo_cnt; idx++) &#123;</span><br><span class="line">                    slave_data[w_r_index++] = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">                &#125;</span><br><span class="line">                ets_printf(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_full = <span class="number">1</span>;</span><br><span class="line">            slave_event = SLAVE_IDLE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_SLAVE_TRAN_COMP_INT_ST_M) &#123; <span class="comment">// slave receive device address + W/R bit + data address</span></span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                ets_printf(<span class="string">"sc, Slave Send\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                <span class="comment">// ets_printf("sc W\n");</span></span><br><span class="line">                w_r_index = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">                <span class="keyword">switch</span> (slave_event) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SLAVE_IDLE:</span><br><span class="line">                        ets_printf(<span class="string">"sc, I2W\n"</span>);</span><br><span class="line">                        <span class="comment">// reset tx fifo to avoid send last byte when master send read command next.</span></span><br><span class="line">                        i2c_reset_tx_fifo(i2c_num);</span><br><span class="line"></span><br><span class="line">                        slave_event = SLAVE_WRITE;</span><br><span class="line">                        slave_send_index = w_r_index;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> tx_fifo_rem = I2C_FIFO_LEN - I2C_INSTANCE[i2c_num]-&gt;status_reg.tx_fifo_cnt;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tx_fifo_rem; i++) &#123;</span><br><span class="line">                            WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), slave_data[slave_send_index++]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        I2C_INSTANCE[i2c_num]-&gt;int_ena.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                        I2C_INSTANCE[i2c_num]-&gt;int_clr.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.slave_tran_comp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_TXFIFO_EMPTY_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"tfe, "</span>);</span><br><span class="line">            <span class="keyword">int</span> tx_fifo_rem = I2C_FIFO_LEN - I2C_INSTANCE[i2c_num]-&gt;status_reg.tx_fifo_cnt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                ets_printf(<span class="string">"R\r\n"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tx_fifo_rem; i++) &#123;</span><br><span class="line">                    WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), slave_data[slave_send_index++]);</span><br><span class="line">                &#125;</span><br><span class="line">                I2C_INSTANCE[i2c_num]-&gt;int_ena.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                I2C_INSTANCE[i2c_num]-&gt;int_clr.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                ets_printf(<span class="string">"W\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_RXFIFO_OVF_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"rfo\n"</span>);</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_ovf = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_RXFIFO_FULL_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"rff\n"</span>);</span><br><span class="line">            <span class="keyword">int</span> rx_fifo_cnt = I2C_INSTANCE[i2c_num]-&gt;status_reg.rx_fifo_cnt;</span><br><span class="line">            <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; rx_fifo_cnt; idx++) &#123;</span><br><span class="line">                slave_data[w_r_index++] = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">            &#125;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_full = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ets_printf("%x\n", status);</span></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.val = status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//We only need to check here if there is a high-priority task needs to be switched.</span></span><br><span class="line">    <span class="keyword">if</span>(HPTaskAwoken == pdTRUE) &#123;</span><br><span class="line">        portYIELD_FROM_ISR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h1><ul><li><a href="https://github.com/InfiniteYuan/ESP32-I2C-Slave/tree/master" target="_blank" rel="noopener">ESP32-I2C-Slave</a></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf" target="_blank" rel="noopener">I2C Specification</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这篇文章将介绍使用 ESP32 作为 I2C 实现 Random Read/Write 和  Sequential Read/Write 时序。&lt;/p&gt;
&lt;p&gt;首先通过下面的图了解下 Random Read 时序，I2C Master 通过这个时序读取任意数据地址开始的数据。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191123145556881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70&quot; alt=&quot;Random Read&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十三）ESP32 ping 功能</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89ESP32%20ping%20%E5%8A%9F%E8%83%BD/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89ESP32%20ping%20%E5%8A%9F%E8%83%BD/</id>
    <published>2019-11-22T01:23:18.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">pingResults</span><span class="params">(<span class="keyword">ping_target_id_t</span> msgType, esp_ping_found * pf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"AvgTime:%.1fmS Sent:%d Rec:%d min(mS):%d max(mS):%d Resp(mS):%d Timeouts:%d Total Time:%d\n"</span>, (<span class="keyword">float</span>)pf-&gt;total_time/pf-&gt;recv_count, pf-&gt;send_count, pf-&gt;recv_count,  pf-&gt;min_time, pf-&gt;max_time ,pf-&gt;resp_time, pf-&gt;timeout_count, pf-&gt;total_time);</span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start_Ping_ESP32</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">uint32_t</span> ip_pinG = ipaddr_addr(<span class="string">"163.177.151.109"</span>);<span class="comment">//百度IP地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_count = <span class="number">2000</span>;<span class="comment">//ping的次数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_timeout = <span class="number">1000</span>; <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_delay = <span class="number">2000</span>; <span class="comment">//ping 的间隔</span></span><br><span class="line">    ping_deinit();</span><br><span class="line">    esp_ping_set_target(PING_TARGET_IP_ADDRESS_COUNT, &amp;ping_count, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_RCV_TIMEO, &amp;ping_timeout, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_DELAY_TIME, &amp;ping_delay, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_IP_ADDRESS, &amp;ip_pinG, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_RES_FN, &amp;pingResults, <span class="keyword">sizeof</span>(pingResults));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span> res = <span class="number">0</span>;</span><br><span class="line">    res = ping_init();</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"PING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error:%d\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ping&quot;&gt;&lt;a href=&quot;#ping&quot; class=&quot;headerlink&quot; title=&quot;ping&quot;&gt;&lt;/a&gt;ping&lt;/h1&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十二）LittlevGL 添加自定义字体和物理按键</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2019/05/12/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89LittlevGL%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E7%89%A9%E7%90%86%E6%8C%89%E9%94%AE/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2019/05/12/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89LittlevGL%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E7%89%A9%E7%90%86%E6%8C%89%E9%94%AE/</id>
    <published>2019-05-12T20:05:34.000Z</published>
    <updated>2020-07-23T08:03:09.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LittlevGL-添加自定义字体"><a href="#LittlevGL-添加自定义字体" class="headerlink" title="LittlevGL 添加自定义字体"></a>LittlevGL 添加自定义字体</h1><ol><li>获取字库 <code>ttf</code> 文件<br>可以从一些网站上获取字库文件，比如<blockquote><p>请注意字体许可证</p></blockquote></li><li>生成源文件<br>使用 LittlevGL 提供的字库文件<a href="https://littlevgl.com/ttf-font-to-c-array" target="_blank" rel="noopener">转换工具</a>，将 <code>ttf</code> 字库文件转换为源文件。</li></ol><a id="more"></a><ol start="3"><li>将生成的源文件添加到 LittlevGL 工程中，添加以下代码声明字体：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern lv_font_t my_font_name;</span><br></pre></td></tr></table></figure>或者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LV_FONT_DECLARE(my_font_name);</span><br></pre></td></tr></table></figure>源代码中使用这个字体可以：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style.text.font &#x3D; &amp;my_font_name;</span><br></pre></td></tr></table></figure>或者将这个字体添加到当前使用的字体中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_font_add(&amp;my_font_name, &amp;current_use);</span><br></pre></td></tr></table></figure></li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LV_FONT_DECLARE(my_font_name);</span><br><span class="line"></span><br><span class="line">void lv_chinese_fonts1(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*Concatenate the fonts into one*&#x2F;</span><br><span class="line">&#x2F;&#x2F;    lv_font_add(&amp;arial_cyrillic_20, &amp;arial_ascii_20); 相同高度才可以添加到一起</span><br><span class="line">&#x2F;&#x2F;    lv_font_add(&amp;arial_math_20, &amp;arial_ascii_20);</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 创建一个新的样式，并且修改新样式的文本字体 *&#x2F;</span><br><span class="line">    static lv_style_t style1; </span><br><span class="line">    lv_style_copy(&amp;style1, &amp;lv_style_plain);</span><br><span class="line">    style1.text.font &#x3D; &amp;my_font_name; &#x2F;* 设置自定义字体 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;*Create a label and set new text*&#x2F;</span><br><span class="line">    lv_obj_t * label &#x3D; lv_label_create(lv_scr_act(), NULL); &#x2F;* 创建标签 *&#x2F;</span><br><span class="line">    lv_obj_set_pos(label, 10, 10);       &#x2F;* 设置相对位置 *&#x2F;</span><br><span class="line">    lv_label_set_style(label, &amp;style1);  &#x2F;* 设置样式 *&#x2F;</span><br><span class="line">    lv_label_set_text(label, &quot;Hello World!\n 世界你好,我是littleVGL!&quot;);      &#x2F;* 显示汉字 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LittlevGL-添加自定义符号"><a href="#LittlevGL-添加自定义符号" class="headerlink" title="LittlevGL 添加自定义符号"></a>LittlevGL 添加自定义符号</h1><p>流程：</p><ul><li>寻找合适的 <code>ttf</code> 文件（包含目标符号，可在 linux 下通过 FontForge 软件打开 <code>ttf</code> 文件，查看包含那些字符）</li><li>使用 LittlevGL 提供的字库文件<a href="https://littlevgl.com/ttf-font-to-c-array" target="_blank" rel="noopener">转换工具</a>，将选中的符号转换为 <code>c</code> 源文件。在转换的页面 <code>Range</code> 中输入目标符号的 Unicode 编码，怎么查询可以通过百度</li><li>将源文件添加到工程中，和上面添加字体类似，首先声明字体，然后添加到字体中或者直接使用。</li><li>定义一个宏指向这个目标符号，宏的内容需要为 <code>UTF-8编码</code>，通过 <a href="https://www.qqxiuzi.cn/bianma/Unicode-UTF.php" target="_blank" rel="noopener">Unicode和UTF编码转换</a> 可以进行转换</li></ul><p>例如：<br><img src="https://img-blog.csdnimg.cn/20190515163138800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="摄氏度符号"></p><p>这样就需要在程序中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* MACROS *&#x2F;</span><br><span class="line">#define SYMBOL_TEMP &quot;\xE2\x84\x83&quot; &#x2F;&#x2F; E28483</span><br><span class="line"></span><br><span class="line">&#x2F;* STATIC VARIABLES *&#x2F;</span><br><span class="line">LV_FONT_DECLARE(tempreture_symbol_40);</span><br><span class="line"></span><br><span class="line">&#x2F;* Add font to current font *&#x2F;</span><br><span class="line">lv_font_add(&amp;tempreture_symbol_40, &amp;lv_font_dejavu_40);</span><br><span class="line"></span><br><span class="line">&#x2F;* Use this symbol *&#x2F;</span><br><span class="line">lv_label_set_text(temp_l, &quot;21.5 &quot;SYMBOL_TEMP);</span><br></pre></td></tr></table></figure><h1 id="LittlevGL-添加物理按键"><a href="#LittlevGL-添加物理按键" class="headerlink" title="LittlevGL 添加物理按键"></a>LittlevGL 添加物理按键</h1><p>注册物理按键驱动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">uint8_t my_btn_read()</span><br><span class="line">&#123;</span><br><span class="line">    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool my_input_read(lv_indev_data_t *data)</span><br><span class="line">&#123;</span><br><span class="line">    static int8_t last_btn &#x3D; 0;    &#x2F;* Store the last pressed button *&#x2F;</span><br><span class="line">    int8_t btn_pr &#x3D; my_btn_read(); &#x2F;* Get the ID (0,1,2...) of the pressed button *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (btn_pr &gt; 0)</span><br><span class="line">    &#123;                                    &#x2F;* Is there a button press? *&#x2F;</span><br><span class="line">        last_btn &#x3D; btn_pr;               &#x2F;* Save the ID of the pressed button *&#x2F;</span><br><span class="line">        data-&gt;state &#x3D; LV_INDEV_STATE_PR; &#x2F;* Set the pressed state *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        data-&gt;state &#x3D; LV_INDEV_STATE_REL; &#x2F;* Set the released state *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data-&gt;btn &#x3D; last_btn; &#x2F;* Set the last button *&#x2F;</span><br><span class="line"></span><br><span class="line">    return false; &#x2F;* No buffering so no more data read *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">void my_button_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static lv_indev_t *indev;</span><br><span class="line">    lv_indev_drv_t indev_drv;</span><br><span class="line"></span><br><span class="line">    lv_indev_drv_init(&amp;indev_drv);</span><br><span class="line"></span><br><span class="line">    indev_drv.read &#x3D; my_input_read;</span><br><span class="line">    indev_drv.type &#x3D; LV_INDEV_TYPE_BUTTON;</span><br><span class="line">    indev &#x3D; lv_indev_drv_register(&amp;indev_drv);</span><br><span class="line"></span><br><span class="line">    &#x2F;*points_array: these points will be assigned to the buttons to press a specific point on the screen.*&#x2F;</span><br><span class="line">    static lv_point_t points_array[] &#x3D; &#123;&#123;20, 20&#125;&#125;;</span><br><span class="line">    lv_indev_set_button_points(indev, points_array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个按键，保证上面的点在按钮的区域内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static lv_obj_t *btn &#x3D; lv_btn_create(lv_scr_act(), NULL);  </span><br><span class="line">lv_obj_set_size(btn, 40, 40);</span><br><span class="line">lv_obj_set_pos(btn, 0, 0);</span><br><span class="line">lv_btn_set_action(btn, LV_BTN_ACTION_CLICK, btn_click_action);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LittlevGL-添加自定义字体&quot;&gt;&lt;a href=&quot;#LittlevGL-添加自定义字体&quot; class=&quot;headerlink&quot; title=&quot;LittlevGL 添加自定义字体&quot;&gt;&lt;/a&gt;LittlevGL 添加自定义字体&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;获取字库 &lt;code&gt;ttf&lt;/code&gt; 文件&lt;br&gt;可以从一些网站上获取字库文件，比如&lt;blockquote&gt;
&lt;p&gt;请注意字体许可证&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;生成源文件&lt;br&gt;使用 LittlevGL 提供的字库文件&lt;a href=&quot;https://littlevgl.com/ttf-font-to-c-array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转换工具&lt;/a&gt;，将 &lt;code&gt;ttf&lt;/code&gt; 字库文件转换为源文件。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十一）使用 ESP32 做为 WebServer</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2019/04/28/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32%20%E5%81%9A%E4%B8%BA%20WebServer/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2019/04/28/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32%20%E5%81%9A%E4%B8%BA%20WebServer/</id>
    <published>2019-04-28T19:34:34.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-ESP32-做为-WebServer"><a href="#使用-ESP32-做为-WebServer" class="headerlink" title="使用 ESP32 做为 WebServer"></a>使用 ESP32 做为 WebServer</h1><p>在某些场景，我们可能需要在手机上或者其他移动终端访问 ESP32 的数据，这个时候我们需要在手机上展示 ESP32 设备的相关信息，这个时候可以用 APP 在手机上展示数据，或者在手机浏览器中打开存储在 ESP32 上的网页。或者其他的方式。</p><p>这篇文章我们将介绍第二种方式。在 ESP32 上存储网页文件，将 ESP32 做为一个简单的 WebServer。</p><p>工作流程：(第一种方式)</p><ol><li>首先通过 gzip 将 HTML 文件压缩为 <code>.gz</code> 文件</li><li>使用 filetoarray 工具将 <code>.gz</code> 文件转为头文件</li><li>在 ESP32 程序中将头文件中的数组发送出去</li></ol><p>工作流程：(第二种方式)</p><ol><li>首先通过 gzip 将 HTML 文件压缩为 <code>.gz</code> 文件</li><li>使用 ESP32 构建系统中的<a href="https://blog.csdn.net/qq_27114397/article/details/81152448#_449" target="_blank" rel="noopener">嵌入二进制数据</a>的方式，将其添加到 Flash 中的 <code>.rodata</code> 部分</li><li>在 ESP32 程序中将 Flash 中的数组发送出去</li></ol><a id="more"></a><h2 id="filetoarray-工具"><a href="#filetoarray-工具" class="headerlink" title="filetoarray 工具"></a>filetoarray 工具</h2><p>使用这个工具将 <code>.gz</code> 文件转换为包含十六进制数组和其长度的头文件。</p><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span>;</span><br><span class="line">    <span class="keyword">long</span> flen;</span><br><span class="line">    <span class="keyword">char</span> *fname;</span><br><span class="line">    <span class="keyword">char</span> pname[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( argc == <span class="number">2</span> ) &#123;</span><br><span class="line">        fname = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(pname, fname);</span><br><span class="line">        <span class="keyword">char</span> *dot = <span class="built_in">strchr</span>(pname, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">while</span> (dot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *dot = <span class="string">'_'</span>;</span><br><span class="line">            dot = <span class="built_in">strchr</span>(pname, <span class="string">'.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Filename not supplied\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(fname, <span class="string">"rb"</span>);</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    flen = ftell(fp);</span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buffer</span> = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((flen + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    fread(<span class="built_in">buffer</span>, flen, <span class="number">1</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n//File: %s, Size: %lu\n"</span>, fname, flen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"#define %s_len %lu\n"</span>, pname, flen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const uint8_t %s[] PROGMEM = &#123;\n"</span>, pname);</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; flen; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 0x%02X"</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="built_in">buffer</span>[i]));</span><br><span class="line">        <span class="keyword">if</span> (i &lt; (flen - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">16</span>) == <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n&#125;;\n\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">buffer</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTML-文件到头文件"><a href="#HTML-文件到头文件" class="headerlink" title="HTML 文件到头文件"></a>HTML 文件到头文件</h2><p>使用方式：</p><ol><li>使用 gzip 将 HTML 文件转换为 <code>.gz</code> 文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip index.html</span><br></pre></td></tr></table></figure><ol start="2"><li>编译 <code>filetoarray.c</code> 源文件，生成可执行文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc filetoarray.c -o filetoarray</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 filetoarray 将  <code>.gz</code> 文件转为头文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filetoarray index.html.gz &gt; index.h</span><br></pre></td></tr></table></figure><h2 id="HTML-文件到-Flash"><a href="#HTML-文件到-Flash" class="headerlink" title="HTML 文件到 Flash"></a>HTML 文件到 Flash</h2><p>使用方式：</p><ol><li>使用 gzip 将 HTML 文件转换为 <code>.gz</code> 文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip index.html</span><br></pre></td></tr></table></figure><ol start="2"><li>在工程 <code>main</code> 目录下的 <code>component.mk</code> 中添加</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_EMBED_FILES := www/index.html.gz</span><br></pre></td></tr></table></figure><ol start="3"><li>在工程源码中这样使用</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_start[] <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_start"</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_end[]   <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_end"</span>);</span><br><span class="line"><span class="keyword">size_t</span> index_html_gz_len = index_html_gz_end - index_html_gz_start;</span><br><span class="line"></span><br><span class="line">httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz_start, index_html_gz_len);</span><br></pre></td></tr></table></figure><h2 id="在-ESP32-中启动-HTTP-Server"><a href="#在-ESP32-中启动-HTTP-Server" class="headerlink" title="在 ESP32 中启动 HTTP Server"></a>在 ESP32 中启动 HTTP Server</h2><p>第一种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"index.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">index_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span>&#123;</span><br><span class="line">    httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">    httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    <span class="keyword">return</span> httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz, index_html_gz_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">index_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_start[] <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_start"</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_end[]   <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_end"</span>);</span><br><span class="line"><span class="keyword">size_t</span> index_html_gz_len = index_html_gz_end - index_html_gz_start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">    httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    <span class="keyword">return</span> httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz_start, index_html_gz_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"app_httpd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"esp_http_server.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_httpd_main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">httpd_handle_t</span> camera_httpd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">httpd_config_t</span> <span class="built_in">config</span> = HTTPD_DEFAULT_CONFIG();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">httpd_uri_t</span> index_uri = &#123;</span><br><span class="line">        .uri       = <span class="string">"/"</span>,</span><br><span class="line">        .method    = HTTP_GET,</span><br><span class="line">        .handler   = index_handler,</span><br><span class="line">        .user_ctx  = <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Starting web server on port: '%d'"</span>, <span class="built_in">config</span>.server_port);</span><br><span class="line">    <span class="keyword">if</span> (httpd_start(&amp;camera_httpd, &amp;<span class="built_in">config</span>) == ESP_OK) &#123;</span><br><span class="line">        httpd_register_uri_handler(camera_httpd, &amp;index_uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ul><li><a href="https://github.com/espressif/esp-who/blob/master/examples/single_chip/camera_web_server/main/app_httpd.c" target="_blank" rel="noopener">web server</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-ESP32-做为-WebServer&quot;&gt;&lt;a href=&quot;#使用-ESP32-做为-WebServer&quot; class=&quot;headerlink&quot; title=&quot;使用 ESP32 做为 WebServer&quot;&gt;&lt;/a&gt;使用 ESP32 做为 WebServer&lt;/h1&gt;&lt;p&gt;在某些场景，我们可能需要在手机上或者其他移动终端访问 ESP32 的数据，这个时候我们需要在手机上展示 ESP32 设备的相关信息，这个时候可以用 APP 在手机上展示数据，或者在手机浏览器中打开存储在 ESP32 上的网页。或者其他的方式。&lt;/p&gt;
&lt;p&gt;这篇文章我们将介绍第二种方式。在 ESP32 上存储网页文件，将 ESP32 做为一个简单的 WebServer。&lt;/p&gt;
&lt;p&gt;工作流程：(第一种方式)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先通过 gzip 将 HTML 文件压缩为 &lt;code&gt;.gz&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;使用 filetoarray 工具将 &lt;code&gt;.gz&lt;/code&gt; 文件转为头文件&lt;/li&gt;
&lt;li&gt;在 ESP32 程序中将头文件中的数组发送出去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;工作流程：(第二种方式)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先通过 gzip 将 HTML 文件压缩为 &lt;code&gt;.gz&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;使用 ESP32 构建系统中的&lt;a href=&quot;https://blog.csdn.net/qq_27114397/article/details/81152448#_449&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;嵌入二进制数据&lt;/a&gt;的方式，将其添加到 Flash 中的 &lt;code&gt;.rodata&lt;/code&gt; 部分&lt;/li&gt;
&lt;li&gt;在 ESP32 程序中将 Flash 中的数组发送出去&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十）使用 ESP32+Camera 二维码识别</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2019/03/14/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32+Camera%20%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2019/03/14/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32+Camera%20%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%AF%86%E5%88%AB/</id>
    <published>2019-03-14T15:16:37.000Z</published>
    <updated>2020-07-23T08:03:09.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-ESP32-Camera-进行二维码识别"><a href="#使用-ESP32-Camera-进行二维码识别" class="headerlink" title="使用 ESP32 Camera 进行二维码识别"></a>使用 ESP32 Camera 进行二维码识别</h1><ul><li>GitHub: <a href="https://github.com/InfiniteYuan/esp32-camera-qr-recoginize/tree/master/examples/single_chip/qrcode_recoginize" target="_blank" rel="noopener">esp32-camera-qr-recoginize</a></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li><a href="https://github.com/espressif/esp-who" target="_blank" rel="noopener">ESP-WHO</a></li><li><a href="https://github.com/espressif/esp-idf" target="_blank" rel="noopener">ESP-IDF</a></li></ul><a id="more"></a><h2 id="使用-quirc-二维码识别库"><a href="#使用-quirc-二维码识别库" class="headerlink" title="使用 quirc 二维码识别库"></a>使用 quirc 二维码识别库</h2><ul><li><a href="https://github.com/dlbeer/quirc" target="_blank" rel="noopener">quirc</a></li></ul><h2 id="摄像头初始化"><a href="#摄像头初始化" class="headerlink" title="摄像头初始化"></a>摄像头初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_PIXEL_FORM PIXFORMAT_GRAYSCALE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_FRAME_SIZE FRAMESIZE_VGA</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_CAMERA_MODEL_CUSTOM</span></span><br><span class="line">    <span class="comment">/* IO13, IO14 is designed for JTAG by default,</span></span><br><span class="line"><span class="comment">     * to use it as generalized input,</span></span><br><span class="line"><span class="comment">     * firstly declair it as pullup input */</span></span><br><span class="line">    <span class="keyword">gpio_config_t</span> conf;</span><br><span class="line">    conf.mode = GPIO_MODE_INPUT;</span><br><span class="line">    conf.pull_up_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf.pull_down_en = GPIO_PULLDOWN_DISABLE;</span><br><span class="line">    conf.intr_type = GPIO_INTR_DISABLE;</span><br><span class="line">    conf.pin_bit_mask = <span class="number">1L</span>L &lt;&lt; <span class="number">13</span>;</span><br><span class="line">    gpio_config(&amp;conf);</span><br><span class="line">    conf.pin_bit_mask = <span class="number">1L</span>L &lt;&lt; <span class="number">14</span>;</span><br><span class="line">    gpio_config(&amp;conf);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">config</span>.ledc_channel = LEDC_CHANNEL_0;</span><br><span class="line">    <span class="built_in">config</span>.ledc_timer = LEDC_TIMER_0;</span><br><span class="line">    <span class="built_in">config</span>.pin_d0 = Y2_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d1 = Y3_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d2 = Y4_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d3 = Y5_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d4 = Y6_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d5 = Y7_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d6 = Y8_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d7 = Y9_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_xclk = XCLK_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_pclk = PCLK_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_vsync = VSYNC_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_href = HREF_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_sscb_sda = SIOD_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_sscb_scl = SIOC_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_pwdn = PWDN_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_reset = RESET_GPIO_NUM;</span><br><span class="line">    <span class="comment">// Only support 10 MHz current. Camera will output bad image when XCLK is 20 MHz.</span></span><br><span class="line">    <span class="built_in">config</span>.xclk_freq_hz = <span class="number">10000000</span>;</span><br><span class="line">    <span class="built_in">config</span>.pixel_format = CAMERA_PIXEL_FORM;</span><br><span class="line">    <span class="built_in">config</span>.frame_size = CAMERA_FRAME_SIZE;</span><br><span class="line">    <span class="built_in">config</span>.jpeg_quality = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">config</span>.fb_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera init</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_camera_init(&amp;<span class="built_in">config</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Camera init failed with error 0x%x"</span>, err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create QR-code recognize task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    app_qr_recognize(&amp;<span class="built_in">config</span>);</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Free heap: %u"</span>, xPortGetFreeHeapSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a>二维码识别</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr_recoginze</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">camera_config_t</span> *camera_config = (<span class="keyword">camera_config_t</span> *)parameter;</span><br><span class="line">    <span class="comment">// Use VGA Size currently, but quirc can support other frame size.(eg: FRAMESIZE_SVGA,FRAMESIZE_VGA，</span></span><br><span class="line">    <span class="comment">// FRAMESIZE_CIF,FRAMESIZE_QVGA,FRAMESIZE_HQVGA,FRAMESIZE_QCIF,FRAMESIZE_QQVGA2,FRAMESIZE_QQVGA,etc)</span></span><br><span class="line">    <span class="keyword">if</span> (camera_config-&gt;frame_size &gt; FRAMESIZE_VGA) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Camera Frame Size err %d"</span>, (camera_config-&gt;frame_size));</span><br><span class="line">        vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save image width and height, avoid allocate memory repeatly.</span></span><br><span class="line">    <span class="keyword">uint16_t</span> old_width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> old_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct a new QR-code recognizer.</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Construct a new QR-code recognizer(quirc)."</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quirc</span> *<span class="title">qr_recognizer</span> = <span class="title">quirc_new</span>();</span></span><br><span class="line">    <span class="keyword">if</span> (!qr_recognizer) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Can't create quirc object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">camera_fb_t</span> *fb = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> *<span class="built_in">image</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> id_count = <span class="number">0</span>;</span><br><span class="line">    UBaseType_t uxHighWaterMark;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入口处检测一次 */</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"uxHighWaterMark = %d"</span>, uxTaskGetStackHighWaterMark( <span class="literal">NULL</span> ));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">"uxHighWaterMark = %d"</span>, uxTaskGetStackHighWaterMark( <span class="literal">NULL</span> ));</span><br><span class="line">        <span class="comment">// Capture a frame</span></span><br><span class="line">        fb = esp_camera_fb_get();</span><br><span class="line">        <span class="keyword">if</span> (!fb) &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">"Camera capture failed"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old_width != fb-&gt;<span class="built_in">width</span> || old_height != fb-&gt;<span class="built_in">height</span>) &#123;</span><br><span class="line">            ESP_LOGD(TAG, <span class="string">"Recognizer size change w h len: %d, %d, %d"</span>, fb-&gt;<span class="built_in">width</span>, fb-&gt;<span class="built_in">height</span>, fb-&gt;len);</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">"Resize the QR-code recognizer."</span>);</span><br><span class="line">            <span class="comment">// Resize the QR-code recognizer.</span></span><br><span class="line">            <span class="keyword">if</span> (quirc_resize(qr_recognizer, fb-&gt;<span class="built_in">width</span>, fb-&gt;<span class="built_in">height</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">"Resize the QR-code recognizer err."</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                old_width = fb-&gt;<span class="built_in">width</span>;</span><br><span class="line">                old_height = fb-&gt;<span class="built_in">height</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** These functions are used to process images for QR-code recognition.</span></span><br><span class="line"><span class="comment">         * quirc_begin() must first be called to obtain access to a buffer into</span></span><br><span class="line"><span class="comment">         * which the input image should be placed. Optionally, the current</span></span><br><span class="line"><span class="comment">         * width and height may be returned.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * After filling the buffer, quirc_end() should be called to process</span></span><br><span class="line"><span class="comment">         * the image for QR-code recognition. The locations and content of each</span></span><br><span class="line"><span class="comment">         * code may be obtained using accessor functions described below.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">image</span> = quirc_begin(qr_recognizer, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">image</span>, fb-&gt;buf, fb-&gt;len);</span><br><span class="line">        quirc_end(qr_recognizer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the number of QR-codes identified in the last processed image.</span></span><br><span class="line">        id_count = quirc_count(qr_recognizer);</span><br><span class="line">        <span class="keyword">if</span> (id_count == <span class="number">0</span>) &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">"Error: not a valid qrcode"</span>);</span><br><span class="line">            esp_camera_fb_return(fb);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print information of QR-code</span></span><br><span class="line">        dump_info(qr_recognizer, id_count);</span><br><span class="line">        esp_camera_fb_return(fb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Destroy QR-Code recognizer (quirc)</span></span><br><span class="line">    quirc_destroy(qr_recognizer);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Deconstruct QR-Code recognizer(quirc)"</span>);</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例结果"><a href="#示例结果" class="headerlink" title="示例结果"></a>示例结果</h2><p><img src="https://img-blog.csdnimg.cn/20190315190639946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="示例结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-ESP32-Camera-进行二维码识别&quot;&gt;&lt;a href=&quot;#使用-ESP32-Camera-进行二维码识别&quot; class=&quot;headerlink&quot; title=&quot;使用 ESP32 Camera 进行二维码识别&quot;&gt;&lt;/a&gt;使用 ESP32 Camera 进行二维码识别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;GitHub: &lt;a href=&quot;https://github.com/InfiniteYuan/esp32-camera-qr-recoginize/tree/master/examples/single_chip/qrcode_recoginize&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;esp32-camera-qr-recoginize&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/espressif/esp-who&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP-WHO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/espressif/esp-idf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP-IDF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（十六）ESP-MESH 编程指南</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2019/03/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89ESP-MESH%20%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2019/03/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89ESP-MESH%20%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</id>
    <published>2019-03-02T19:03:45.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP-MESH-编程指南"><a href="#ESP-MESH-编程指南" class="headerlink" title="ESP-MESH 编程指南"></a>ESP-MESH 编程指南</h1><p>这是 ESP-MESH 的编程指南，包括 API 参考和编码示例。本指南分为以下几部分：</p><ul><li>ESP-MESH 编程模型</li><li>编写 ESP-MESH 应用程序</li><li>自组织网络</li><li>应用实例</li><li>API 参考</li></ul><p>有关 ESP-MESH 协议的文档，请参阅 <a href="https://mp.csdn.net/postedit/86743079" target="_blank" rel="noopener">ESP-MESH API 指南</a>。</p><a id="more"></a><h2 id="ESP-MESH-编程模型"><a href="#ESP-MESH-编程模型" class="headerlink" title="ESP-MESH 编程模型"></a>ESP-MESH 编程模型</h2><h3 id="软件栈"><a href="#软件栈" class="headerlink" title="软件栈"></a>软件栈</h3><p>ESP-MESH 软件栈构建在 Wi-Fi 驱动/FreeRTOS 之上，并且在某些情况下可以使用 LwIP 栈（即根节点）。下图说明了 ESP-MESH 软件栈。<br><img src="https://img-blog.csdnimg.cn/2019030215595528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 软件栈"></p><h3 id="系统事件"><a href="#系统事件" class="headerlink" title="系统事件"></a>系统事件</h3><p>应用程序通过 ESP-MESH 事件与 ESP-MESH 交互。由于 ESP-MESH 构建在 Wi-Fi 栈的顶部，因此应用程序也可以通过 Wi-Fi 事件任务与 Wi-Fi 驱动交互。下图说明了 ESP-MESH 应用程序中各种系统事件的接口。<br><img src="https://img-blog.csdnimg.cn/20190302162721734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 系统事件"><br><code>mesh_event_id_t</code> 定义所有可能的  ESP-MESH 系统事件，并且可以指示诸如父/子的连接/断开之类的事件。在可以使用 ESP-MESH 系统事件之前，应用程序必须通过 <code>esp_mesh_set_config()</code> 注册 Mesh 事件回调。 回调用于从 ESP-MESH 栈以及 LwIP 栈接收事件，并且应包含与应用程序相关的每个事件的处理程序。</p><p>系统事件的典型用例包括使用诸如 <code>MESH_EVENT_PARENT_CONNECTED</code> 和 <code>MESH_EVENT_CHILD_CONNECTED</code> 之类的事件来指示节点何时可以分别开始上游和下游传输数据。 同样，<code>MESH_EVENT_ROOT_GOT_IP</code> 和 <code>MESH_EVENT_ROOT_LOST_IP</code> 可用于指示根节点何时能够和不能将数据传输到外部 IP 网络。</p><blockquote><p>在自组织模式下使用 ESP-MESH 时，用户必须确保不会调用 Wi-Fi API。这是因为自组织模式将在内部进行 Wi-Fi API 调用以连接/断开/扫描等。来自应用程序的任何 Wi-Fi 调用（包括来自回调函数和 Wi-Fi 事件处理程序的调用）可能干扰 ESP-MESH 的自组织行为。因此，在调用 <code>esp_mesh_start()</code> 之后，并且在调用 <code>esp_mesh_stop()</code> 之前，用户不应该调用 Wi-Fi API。</p></blockquote><h3 id="LwIP-amp-ESP-MESH"><a href="#LwIP-amp-ESP-MESH" class="headerlink" title="LwIP &amp; ESP-MESH"></a>LwIP &amp; ESP-MESH</h3><p><strong>应用程序可以直接访问 ESP-MESH 栈，而无需通过 LwIP 栈。仅根节点需要 LwIP 栈向/从外部 IP 网络发送/接收数据。</strong> 但是，由于每个节点都可能成为根节点（由于自动根节点选择），每个节点仍必须初始化 LwIP 栈。</p><p><strong>每个节点都需要通过调用 <code>tcpip_adapter_init()</code> 来初始化 LwIP 栈。为了防止非根节点访问 LwIP 栈，应用程序应在 LwIP 栈初始化后停止以下服务</strong>：</p><ul><li>SoftAP 接口上的 DHCP 服务器服务。</li><li>Station 接口上的 DHCP 客户端服务。</li></ul><p>以下代码段演示了如何为 ESP-MESH 应用程序初始化 LwIP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*  tcpip initialization *&#x2F;</span><br><span class="line">tcpip_adapter_init();</span><br><span class="line">&#x2F;*</span><br><span class="line"> * for mesh</span><br><span class="line"> * stop DHCP server on softAP interface by default</span><br><span class="line"> * stop DHCP client on station interface by default</span><br><span class="line"> *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA));</span><br><span class="line">&#x2F;* do not specify system event callback, use NULL instead. *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_event_loop_init(NULL, NULL));</span><br></pre></td></tr></table></figure><blockquote><p>ESP-MESH 要求根节点与路由器连接。因此，如果节点成为根节点，则相应的处理程序必须启动 DHCP 客户端服务并立即获取 IP 地址。这样做将允许其他节点开始向/从外部 IP 网络发送/接收分组。但是，如果使用静态 IP 设置，则不需要此步骤。</p></blockquote><h2 id="编写-ESP-MESH-应用程序"><a href="#编写-ESP-MESH-应用程序" class="headerlink" title="编写 ESP-MESH 应用程序"></a>编写 ESP-MESH 应用程序</h2><p><strong>启动 ESP-MESH 的先决条件是初始化 LwIP 和 Wi-Fi。</strong> 以下代码片段演示了初始化 ESP-MESH 之前必要的先决条件步骤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tcpip_adapter_init();</span><br><span class="line">&#x2F;*</span><br><span class="line"> * for mesh</span><br><span class="line"> * stop DHCP server on softAP interface by default</span><br><span class="line"> * stop DHCP client on station interface by default</span><br><span class="line"> *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA));</span><br><span class="line">&#x2F;* do not specify system event callback, use NULL instead. *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_event_loop_init(NULL, NULL));</span><br><span class="line"></span><br><span class="line">&#x2F;*  Wi-Fi initialization *&#x2F;</span><br><span class="line">wifi_init_config_t config &#x3D; WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_init(&amp;config));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_start());</span><br></pre></td></tr></table></figure><p>初始化 LwIP 和 Wi-Fi 后，启动和运行 ESP-MESH 网络的过程可归纳为以下三个步骤：</p><ul><li>初始化 Mesh</li><li>配置 ESP-MESH 网络</li><li>启动 Mesh</li></ul><h3 id="初始化-Mesh"><a href="#初始化-Mesh" class="headerlink" title="初始化 Mesh"></a>初始化 Mesh</h3><p>以下代码段演示了如何初始化 ESP-MESH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*  mesh initialization *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_init());</span><br></pre></td></tr></table></figure><h3 id="配置-ESP-MESH-网络"><a href="#配置-ESP-MESH-网络" class="headerlink" title="配置 ESP-MESH 网络"></a>配置 ESP-MESH 网络</h3><p><strong>ESP-MESH 通过 <code>esp_mesh_set_config()</code> 配置，它使用 <code>mesh_cfg_t</code> 结构接收其参数。</strong> 该结构包含用于配置 ESP-MESH 的以下参数：</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Channel</td><td>Range from 1 to 14</td></tr><tr><td>Event Callback</td><td>Callback for Mesh Events, see mesh_event_cb_t</td></tr><tr><td>Mesh ID</td><td>ID of ESP-MESH Network, see mesh_addr_t</td></tr><tr><td>Router</td><td>Router Configuration, see mesh_router_t</td></tr><tr><td>Mesh AP</td><td>Mesh AP Configuration, see mesh_ap_cfg_t</td></tr><tr><td>Crypto Functions</td><td>Crypto Functions for Mesh IE, see mesh_crypto_funcs_t</td></tr></tbody></table><p>以下代码段演示了如何配置 ESP-MESH。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Enable the Mesh IE encryption by default *&#x2F;</span><br><span class="line">mesh_cfg_t cfg &#x3D; MESH_INIT_CONFIG_DEFAULT();</span><br><span class="line">&#x2F;* mesh ID *&#x2F;</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.mesh_id, MESH_ID, 6);</span><br><span class="line">&#x2F;* mesh event callback *&#x2F;</span><br><span class="line">cfg.event_cb &#x3D; &amp;mesh_event_handler;</span><br><span class="line">&#x2F;* channel (must match the router&#39;s channel) *&#x2F;</span><br><span class="line">cfg.channel &#x3D; CONFIG_MESH_CHANNEL;</span><br><span class="line">&#x2F;* router *&#x2F;</span><br><span class="line">cfg.router.ssid_len &#x3D; strlen(CONFIG_MESH_ROUTER_SSID);</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len);</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.router.password, CONFIG_MESH_ROUTER_PASSWD,</span><br><span class="line">       strlen(CONFIG_MESH_ROUTER_PASSWD));</span><br><span class="line">&#x2F;* mesh softAP *&#x2F;</span><br><span class="line">cfg.mesh_ap.max_connection &#x3D; CONFIG_MESH_AP_CONNECTIONS;</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD,</span><br><span class="line">       strlen(CONFIG_MESH_AP_PASSWD));</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_set_config(&amp;cfg));</span><br></pre></td></tr></table></figure><h3 id="启动-Mesh"><a href="#启动-Mesh" class="headerlink" title="启动 Mesh"></a>启动 Mesh</h3><p>以下代码段演示了如何启动 ESP-MESH。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* mesh start *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_start());</span><br></pre></td></tr></table></figure><p><strong>启动 ESP-MESH 后，应用程序应检查 ESP-MESH 事件以确定它何时连接到网络。连接后，应用程序可以使用 <code>esp_mesh_send()</code> 和 <code>esp_mesh_recv()</code> 通过 ESP-MESH 网络开始发送和接收数据包。</strong></p><h2 id="自组织网络"><a href="#自组织网络" class="headerlink" title="自组织网络"></a>自组织网络</h2><p>自组织网络是 ESP-MESH 的一项功能，节点可以自动扫描/选择/连接/重新连接到其他节点和路由器。此功能允许 ESP-MESH 网络通过使网络对动态网络拓扑和条件具有鲁棒性来实现高度自治。启用自组织网络后，ESP-MESH 网络中的节点无需自主执行以下操作：</p><ul><li>选择或选择根节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-building-a-network" target="_blank" rel="noopener">构建网络</a>中的自动根节点选择）</li><li>选择首选父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-building-a-network" target="_blank" rel="noopener">构建网络</a>中的父节点选择）</li><li>检测到断开连接时自动重新连接（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-managing-a-network" target="_blank" rel="noopener">管理网络</a>中的中间父节点故障）</li></ul><p>启用自组织网络后，ESP-MESH 栈将在内部调用 Wi-Fi 驱动程序 API。因此，应用层不应对 Wi-Fi 驱动程序 API 进行任何调用，同时启用自组织网络，否则可能会干扰 ESP-MESH。</p><h3 id="切换自组织网络"><a href="#切换自组织网络" class="headerlink" title="切换自组织网络"></a>切换自组织网络</h3><p>应用程序在运行时通过调用 <code>esp_mesh_set_self_organized()</code> 函数可以启用或禁用自组织网络。该函数具有以下两个参数：</p><ul><li><code>bool enable</code> 指定是启用还是禁用自组织网络。</li><li><code>bool select_parent</code> 指定在启用自组织网络时是否应选择新的父节点。根据节点类型和节点的当前状态，选择新父级具有不同的效果。禁用自组织网络时，此参数未使用。</li></ul><h3 id="禁用自组织网络"><a href="#禁用自组织网络" class="headerlink" title="禁用自组织网络"></a>禁用自组织网络</h3><p>以下代码段演示了如何禁用自组织网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Disable self organized networking</span><br><span class="line">esp_mesh_set_self_organized(false, false);</span><br></pre></td></tr></table></figure><p>当禁用自组织网络时，ESP-MESH 将尝试维持节点当前的 Wi-Fi 状态。</p><ul><li>如果节点先前已连接到其他节点，则它将保持连接状态。</li><li>如果节点先前已断开连接并且正在扫描父节点或路由器，则它将停止扫描。</li><li>如果节点先前尝试重新连接到父节点或路由器，它将停止重新连接。</li></ul><h3 id="启用自组织网络"><a href="#启用自组织网络" class="headerlink" title="启用自组织网络"></a>启用自组织网络</h3><p>在启用自组织网络时，ESP-MESH 将尝试维持节点当前的 Wi-Fi 状态。但是，根据节点类型以及是否选择了新父节点，节点的 Wi-Fi 状态可能会发生变化。下表显示了启用自组织网络的效果。</p><p><img src="https://img-blog.csdnimg.cn/20190302173636709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以下代码演示了如何启用自组织网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Enable self organized networking and select a new parent</span><br><span class="line">esp_mesh_set_self_organized(true, true);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Enable self organized networking and manually reconnect</span><br><span class="line">esp_mesh_set_self_organized(true, false);</span><br><span class="line">esp_mesh_connect();</span><br></pre></td></tr></table></figure><h3 id="调用-Wi-Fi-驱动程序-API"><a href="#调用-Wi-Fi-驱动程序-API" class="headerlink" title="调用 Wi-Fi 驱动程序 API"></a>调用 Wi-Fi 驱动程序 API</h3><p>应用程序可能希望在使用 ESP-MESH 时直接调用 Wi-Fi 驱动程序 API 的情况。例如，应用程序可能想要手动扫描相邻的 AP。但是，<strong>在应用程序调用任何 Wi-Fi 驱动程序 API 之前，必须禁用自组织网络。</strong> 这将阻止 ESP-MESH 栈尝试调用任何 Wi-Fi 驱动程序 API ，ESP-MESH 栈的这些调用可能干扰应用程序的调用。</p><p>因此，<strong>应该在调用 <code>esp_mesh_set_self_organized()</code> 进行禁用和启用自组织网络之间放置对 Wi-Fi 驱动程序 API 的调用。</strong> 以下代码段演示了应用程序在使用 ESP-MESH 时如何安全地调用 <code>esp_wifi_scan_start()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Disable self organized networking</span><br><span class="line">esp_mesh_set_self_organized(0, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Stop any scans already in progress</span><br><span class="line">esp_wifi_scan_stop();</span><br><span class="line">&#x2F;&#x2F;Manually start scan. Will automatically stop when run to completion</span><br><span class="line">esp_wifi_scan_start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Process scan results</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if still connected</span><br><span class="line">esp_mesh_set_self_organized(1, 0);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if non-root and disconnected</span><br><span class="line">esp_mesh_set_self_organized(1, 1);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if root and disconnected</span><br><span class="line">esp_mesh_set_self_organized(1, 0);  &#x2F;&#x2F;Don&#39;t select new parent</span><br><span class="line">esp_mesh_connect();                 &#x2F;&#x2F;Manually reconnect to router</span><br></pre></td></tr></table></figure><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>ESP-IDF 包含这些 ESP-MESH 示例项目：</p><p><a href="https://github.com/espressif/esp-idf/tree/ebdcbe8c6/examples/mesh/internal_communication" target="_blank" rel="noopener">内部通信示例</a>演示了如何设置 ESP-MESH 网络并让根节点向网络中的每个节点发送数据包。</p><p><a href="https://github.com/espressif/esp-idf/tree/ebdcbe8c6/examples/mesh/manual_networking" target="_blank" rel="noopener">手动网络示例</a>演示了如何在没有自组织功能的情况下使用 ESP-MESH。此示例显示如何对节点进行编程以手动扫描潜在父节点列表，并根据自定义条件选择父节点。</p><h2 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul><li>esp32/include/esp_mesh.h</li></ul><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ul><li>esp_err_tesp_mesh_init(void)</li><li>esp_err_tesp_mesh_deinit(void)</li><li>esp_err_tesp_mesh_start(void)</li><li>esp_err_tesp_mesh_stop(void)</li><li>esp_err_tesp_mesh_send(constmesh_addr_t *to, constmesh_data_t *data, int flag, constmesh_opt_topt[], int opt_count)</li><li>esp_err_tesp_mesh_recv(mesh_addr_t *from, mesh_data_t *data, int timeout_ms, int *flag, mesh_opt_topt[], int opt_count)</li><li>esp_err_tesp_mesh_recv_toDS(mesh_addr_t *from, mesh_addr_t *to, mesh_data_t *data, int timeout_ms, int *flag, mesh_opt_topt[], int opt_count)</li><li>esp_err_tesp_mesh_set_config(constmesh_cfg_t *config)</li><li>esp_err_tesp_mesh_get_config(mesh_cfg_t *config)</li><li>esp_err_tesp_mesh_set_router(constmesh_router_t *router)</li><li>esp_err_tesp_mesh_get_router(mesh_router_t *router)</li><li>esp_err_tesp_mesh_set_id(constmesh_addr_t *id)</li><li>esp_err_tesp_mesh_get_id(mesh_addr_t *id)</li><li>esp_err_tesp_mesh_set_type(mesh_type_ttype)</li><li>mesh_type_tesp_mesh_get_type(void)</li><li>esp_err_tesp_mesh_set_max_layer(int max_layer)</li><li>int esp_mesh_get_max_layer(void)</li><li>esp_err_tesp_mesh_set_ap_password(const uint8_t *pwd, int len)</li><li>esp_err_tesp_mesh_set_ap_authmode(wifi_auth_mode_tauthmode)</li><li>wifi_auth_mode_tesp_mesh_get_ap_authmode(void)</li><li>esp_err_tesp_mesh_set_ap_connections(int connections)</li><li>int esp_mesh_get_ap_connections(void)</li><li>int esp_mesh_get_layer(void)</li><li>esp_err_tesp_mesh_get_parent_bssid(mesh_addr_t *bssid)</li><li>bool esp_mesh_is_root(void)</li><li>esp_err_tesp_mesh_set_self_organized(bool enable, bool select_parent)</li><li>bool esp_mesh_get_self_organized(void)</li><li>esp_err_tesp_mesh_waive_root(constmesh_vote_t *vote, int reason)</li><li>esp_err_tesp_mesh_set_vote_percentage(float percentage)</li><li>float esp_mesh_get_vote_percentage(void)</li><li>esp_err_tesp_mesh_set_ap_assoc_expire(int seconds)</li><li>int esp_mesh_get_ap_assoc_expire(void)</li><li>int esp_mesh_get_total_node_num(void)</li><li>int esp_mesh_get_routing_table_size(void)</li><li>esp_err_tesp_mesh_get_routing_table(mesh_addr_t *mac, int len, int *size)</li><li>esp_err_tesp_mesh_post_toDS_state(bool reachable)</li><li>esp_err_tesp_mesh_get_tx_pending(mesh_tx_pending_t *pending)</li><li>esp_err_tesp_mesh_get_rx_pending(mesh_rx_pending_t *pending)</li><li>int esp_mesh_available_txupQ_num(constmesh_addr_t *addr, uint32_t *xseqno_in)</li><li>esp_err_tesp_mesh_set_xon_qsize(int qsize)</li><li>int esp_mesh_get_xon_qsize(void)</li><li>esp_err_tesp_mesh_allow_root_conflicts(bool allowed)</li><li>bool esp_mesh_is_root_conflicts_allowed(void)</li><li>esp_err_tesp_mesh_set_group_id(constmesh_addr_t *addr, int num)</li><li>esp_err_tesp_mesh_delete_group_id(constmesh_addr_t *addr, int num)</li><li>int esp_mesh_get_group_num(void)</li><li>esp_err_tesp_mesh_get_group_list(mesh_addr_t *addr, int num)</li><li>bool esp_mesh_is_my_group(constmesh_addr_t *addr)</li><li>esp_err_tesp_mesh_set_capacity_num(int num)</li><li>int esp_mesh_get_capacity_num(void)</li><li>esp_err_tesp_mesh_set_ie_crypto_funcs(const mesh_crypto_funcs_t *crypto_funcs)</li><li>esp_err_tesp_mesh_set_ie_crypto_key(const char *key, int len)</li><li>esp_err_tesp_mesh_get_ie_crypto_key(char *key, int len)</li><li>esp_err_tesp_mesh_set_root_healing_delay(int delay_ms)</li><li>int esp_mesh_get_root_healing_delay(void)</li><li>esp_err_tesp_mesh_set_event_cb(constmesh_event_cb_tevent_cb)</li><li>esp_err_tesp_mesh_fix_root(bool enable)</li><li>bool esp_mesh_is_root_fixed(void)</li><li>esp_err_tesp_mesh_set_parent(constwifi_config_t *parent, constmesh_addr_t *parent_mesh_id, mesh_type_tmy_type, int my_layer)</li><li>esp_err_tesp_mesh_scan_get_ap_ie_len(int *len)</li><li>esp_err_tesp_mesh_scan_get_ap_record(wifi_ap_record_t *ap_record, void *buffer)</li><li>esp_err_tesp_mesh_flush_upstream_packets(void)</li><li>esp_err_tesp_mesh_get_subnet_nodes_num(constmesh_addr_t *child_mac, int *nodes_num)</li><li>esp_err_tesp_mesh_get_subnet_nodes_list(constmesh_addr_t *child_mac, mesh_addr_t *nodes, int nodes_num)</li><li>esp_err_tesp_mesh_disconnect(void)</li><li>esp_err_tesp_mesh_connect(void)</li><li>esp_err_tesp_mesh_flush_scan_result(void)</li><li>esp_err_tesp_mesh_switch_channel(const uint8_t *new_bssid, int csa_newchan, int csa_count)</li><li>esp_err_tesp_mesh_get_router_bssid(uint8_t *router_bssid)</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/network/esp_mesh.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP-MESH-编程指南&quot;&gt;&lt;a href=&quot;#ESP-MESH-编程指南&quot; class=&quot;headerlink&quot; title=&quot;ESP-MESH 编程指南&quot;&gt;&lt;/a&gt;ESP-MESH 编程指南&lt;/h1&gt;&lt;p&gt;这是 ESP-MESH 的编程指南，包括 API 参考和编码示例。本指南分为以下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ESP-MESH 编程模型&lt;/li&gt;
&lt;li&gt;编写 ESP-MESH 应用程序&lt;/li&gt;
&lt;li&gt;自组织网络&lt;/li&gt;
&lt;li&gt;应用实例&lt;/li&gt;
&lt;li&gt;API 参考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关 ESP-MESH 协议的文档，请参阅 &lt;a href=&quot;https://mp.csdn.net/postedit/86743079&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP-MESH API 指南&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（十五）ESP-MESH</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2019/02/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89ESP-MESH/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2019/02/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89ESP-MESH/</id>
    <published>2019-02-01T17:17:30.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP-MESH"><a href="#ESP-MESH" class="headerlink" title="ESP-MESH"></a>ESP-MESH</h1><p>本指南提供有关 ESP-MESH 协议的信息。有关 API 使用的更多信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/network/esp_mesh.html" target="_blank" rel="noopener">MESH API 参考</a>。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-MESH 是一种基于 Wi-Fi 协议构建的网络协议。ESP-MESH 允许在大的物理区域（室内和室外）上分布的多个设备（以下称为节点）在单个 WLAN（无线局域网）下互连。ESP-MESH 具有自组织和自我修复功能，意味着网络可以自主构建和维护。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://img-blog.csdnimg.cn/20190201111240103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="传统的 Wi-Fi 网络架构"><br>传统的 Wi-Fi 网络是一点对多点网络，其中称为接入点（AP）的单个中心节点直接连接到所有其他节点（station）。AP 负责仲裁和转发节点之间的传输。一些 AP 还通过路由器中继与外部 IP 网络的传输。传统的 Wi-Fi 网络由于要求每个站必须在一定范围内以直接与 AP 连接而具有有限覆盖区域的缺点。此外，传统的 Wi-Fi 网络易于过载，因为网络中允许的最大站数受到 AP 容量的限制。</p><p><img src="https://img-blog.csdnimg.cn/20190201113539338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>ESP-MESH 与传统的 Wi-Fi 网络的不同之处在于节点不需要连接到中心节点。相反，允许节点与相邻节点连接。节点相互负责传递彼此的传输。这允许 ESP-MESH 网络具有更大的覆盖区域，因为节点仍然可以实现互连而无需在中心节点的范围内。同样，ESP-MESH 也不易受到过载的影响，因为网络上允许的节点数量不再受单个中心节点的限制。</p><a id="more"></a><h2 id="ESP-MESH概念"><a href="#ESP-MESH概念" class="headerlink" title="ESP-MESH概念"></a>ESP-MESH概念</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td>节点</td><td>任何属于或可以属于 ESP-MESH 网络的设备</td></tr><tr><td>根节点</td><td>网络中的顶级节点</td></tr><tr><td>子节点</td><td>当节点 X 连接到另一节点 Y 时，节点 X 是子节点，其中连接使节点 X 比根节点更远离节点 Y（就连接数而言）。</td></tr><tr><td>父节点</td><td>子节点的相反概念</td></tr><tr><td>子孙节点</td><td>通过从父节点到子节点重复进行都可以访问的任何节点（例：父-&gt;子-&gt;子孙）</td></tr><tr><td>同级节点</td><td>共享同一父节点的节点</td></tr><tr><td>连接</td><td>AP 与站之间的传统 Wi-Fi 关联。ESP-MESH 中的节点将使用其工作站接口与另一个节点的 SoftAP 接口关联，从而形成连接。连接过程包括 Wi-Fi 中的认证和关联过程。</td></tr><tr><td>上游连接</td><td>从节点到其父节点的连接</td></tr><tr><td>下游连接</td><td>从节点到其子节点之一的连接</td></tr><tr><td>无线跳数</td><td>源节点和目标节点之间的路径部分，对应于单个无线连接。遍历单个连接的数据包称为单跳，而遍历多个连接称为多跳。</td></tr><tr><td>子网</td><td>一个子网是 ESP-MESH 网络的细分，它由一个节点及其所有后代节点组成。因此，根节点的子网由 ESP-MESH 网络中的所有节点组成。</td></tr><tr><td>MAC 地址</td><td>媒体访问控制地址，用于唯一标识 ESP-MESH 网络中的每个节点或路由器。</td></tr><tr><td>DS</td><td>分配系统（外部 IP 网络）</td></tr></tbody></table><h3 id="树状网络拓扑结构"><a href="#树状网络拓扑结构" class="headerlink" title="树状网络拓扑结构"></a>树状网络拓扑结构</h3><p>ESP-MESH 基于 Wi-Fi 协议构建，可以被视为将许多单独的 Wi-Fi 网络组合到单个 WLAN 中的网络协议。在 Wi-Fi 中，Station 在任何时候都限于与 AP（上游连接）的单个连接，而 AP 可以同时连接到多个 Station（下游连接）。然而，ESP-MESH 允许节点同时充当 Station 和 AP。因此，ESP-MESH 中的节点可以使用其 SoftAP 接口具有多个下游连接，同时使用其 Station 接口具有单个上游连接。这就是具有由多个层组成的父子层次结构的树状网络拓扑结构。</p><p><img src="https://img-blog.csdnimg.cn/20190201114600123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 树状网络拓扑结构"><br>ESP-MESH 是多跳网络，意味着节点可以通过一个或多个无线“跳跃”将数据包发送到网络中的其他节点。因此，ESP-MESH 中的节点不仅传输自己的数据包，还同时用作其他节点的中继。如果物理层上的任何两个节点之间存在路径（通过一个或多个无线跳），则 ESP-MESH 网络内的 <strong>任何两个节点（节点对）</strong> 都可以进行通信。</p><blockquote><p>ESP-MESH 网络中的大小（节点总数）取决于网络中允许的最大层数，以及每个节点可以拥有的最大下游连接数。可以通过配置这两个变量限制网络的大小。</p></blockquote><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p><img src="https://img-blog.csdnimg.cn/20190201115649174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 节点类型"><br><strong>根节点：</strong> 根节点是网络中的顶级节点，并且是 ESP-MESH 网络和外部 IP 网络之间的唯一接口。 根节点连接到传统的 Wi-Fi 路由器，并将数据包中继到外部 IP 网络或从中继到 ESP-MESH 网络内的节点。 ESP-MESH 网络中只能有一个根节点，根节点的上游连接只可能与路由器连接。参考上图，节点 A 是网络的根节点。</p><p><strong>叶节点：</strong> 叶节点是不允许具有任何子节点（没有下游连接）的节点。因此，叶子节点只能发送或接收自己的数据包，但不能转发其他节点的数据包。如果节点位于网络的最大允许层上，则将其指定为叶节点。这可以防止节点形成任何下游连接，从而确保网络不会添加额外的层。由于需要为任何下游连接提供 SoftAP 接口，因此一些没有 SoftAP 接口（仅限 Station）的节点也将被指定为叶节点。参考上图，节点 L/M/N 位于网络最大允许层上，因此已被指定为叶节点。</p><p><strong>中间父节点：</strong> 既不是根节点也不是叶节点的连接节点是中间父节点。中间父节点必须具有单个上游连接（单个父节点），但可以具有零到多个下游连接（零到多个子节点）。因此，中间父节点可以发送和接收数据包，但也可以转发从其上游和下游连接发送的数据包。参考上图，节点 B 到 J 是中间父节点。没有下游连接的中间父节点（例如节点 E/F/G/I/J）不等同于叶节点，因为它们在将来仍然允许形成下游连接。</p><p><strong>空闲节点：</strong> 尚未加入网络的节点被指定为空闲节点。空闲节点将尝试与中间父节点形成上游连接，或尝试在正确的情况下成为根节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>）。参考上图，节点 K 和 O 是空闲节点。</p><h3 id="信标帧-Beacon-帧-和-RSSI-阈值"><a href="#信标帧-Beacon-帧-和-RSSI-阈值" class="headerlink" title="信标帧(Beacon 帧)和 RSSI 阈值"></a>信标帧(Beacon 帧)和 RSSI 阈值</h3><p>ESP-MESH 中能够形成下游连接（即具有 SoftAP 接口）的每个节点将<strong>周期性地发送 Wi-Fi 信标帧</strong>。节点使用信标帧来允许其他节点检测其存在并知道其状态。空闲节点将监听信标帧以生成潜在父节点的列表，空闲节点将与其中一个形成上游连接。<strong>ESP-MESH 使用信标帧中的供应商信息（Vendor IE）元素来存储（传输）元数据</strong>，例如：</p><ul><li>节点类型（根节点，中间父节点，叶节点，空闲节点）</li><li>当前节点层</li><li>网络中允许的最大层数</li><li>当前子节点数</li><li>要接受的最大下游连接数</li></ul><p>潜在上游连接的信号强度由潜在父节点的信标帧的 RSSI（接收信号强度指示）表示。为了防止节点形成弱上游连接，ESP-MESH 为信标帧实现了 RSSI 阈值机制。如果节点检测到 RSSI 低于预先配置的阈值的信标帧，则在形成上游连接时将忽略发送该信标帧的节点。</p><p><img src="https://img-blog.csdnimg.cn/20190201120120285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="RSSI 阈值的影响"><br>上图中的面板 A 展示了 RSSI 阈值如何影响空闲节点具有的候选父节点的数量。</p><p>上图中的面板 B 展示了 RF 屏蔽对象如何降低潜在父节点的 RSSI。由于 RF 屏蔽对象，节点 X 的 RSSI 高于阈值的区域显着减小。这导致空闲节点忽略节点 X，即使节点 X 在物理上相邻。由于更强的 RSSI，空闲节点将改为与物理上远的节点Y形成上游连接。</p><blockquote><p>节点在技术上仍然接收 MAC 层上的所有信标帧。RSSI 阈值是 ESP-MESH 功能，它只是过滤掉所有接收到的低于预先配置阈值的信号帧。</p></blockquote><h3 id="首选父节点"><a href="#首选父节点" class="headerlink" title="首选父节点"></a>首选父节点</h3><p>当空闲节点具有多个候选父节点（潜在父节点）时，空闲节点将与首选父节点形成上游连接。<strong>首选父节点基于以下标准确定</strong>：</p><ul><li>候选父节点位于哪个层</li><li>候选父节点当前具有的下游连接（子节点）的数量</li></ul><p>首选父节点的选择将始终优先考虑网络最浅层（包括根节点）上的候选父节点。这有助于在形成上游连接时最小化ESP-MESH网络中的层总数。例如，给定第二层节点和第三层节点，第二层节点将始终是首选的。</p><p>如果在同一层内存在多个候选父节点，则具有最少子节点的候选父节点将是首选的。该标准具有平衡同一层的节点之间的下游连接数的效果。</p><p><img src="https://img-blog.csdnimg.cn/20190201140919219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="首选父节点"><br>上图中的面板 A 展示了在给定五个候选父节点 B/C/D/E/F 的情况下空闲节点 G 如何选择首选父节点的示例。最浅层上的节点是首选的，因此节点 B/C 优先选择做为父节点，因为它们是第二层节点，而节点 D/E/F 在第三层上。选择节点 C 作为首选父节点，因为与节点 B 相比，它具有更少的下游连接（更少的子节点）。</p><p>上图中的面板 B 展示了根节点在空闲节点 G 的范围内的情况。换句话说，当节点 G 接收时，根节点的信标帧高于 RSSI 阈值。根节点始终是最浅节点，因此，在 ESP-MESH网络中，给定多个候选父节点时，根节点总是首选的父节点。</p><blockquote><p>用户还可以定义自己的算法以选择首选父节点，或强制节点仅与特定父节点连接（请参阅<a href="https://github.com/espressif/esp-idf/tree/2790d4a/examples/mesh/manual_networking" target="_blank" rel="noopener">手动 MESH 网络示例</a>）。</p></blockquote><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>ESP-MESH 网络中的每个节点将单独维护自己的路由表，用于将 ESP-MESH 数据包（请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#esp-mesh-packet" target="_blank" rel="noopener">ESP-MESH 数据包</a>）正确路由到正确目标节点。特定节点的路由表将包括特定节点的子网内所有节点的 MAC 地址（包括特定节点本身的 MAC 地址）。每个路由表在内部划分为多个子表，每个子表对应于每个子节点的子网。</p><p><img src="https://img-blog.csdnimg.cn/20190201142029243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH路由表示例"><br>使用上面的图作为示例，节点 B 的路由表将包括节点 B 到 I 的 MAC 地址（即，等同于节点 B 的子网）。节点 B 的路由表在内部划分为两个子表，包含节点 C 到 F 和节点 G 到 I（即分别等同于节点 C 和 G 的子网）。</p><p><strong>ESP-MESH 利用路由表来确定是否应根据以下规则向上游或下游转发 ESP-MESH 数据包。</strong></p><ol><li>如果数据包的目标 MAC 地址在当前节点的路由表中并且不是当前节点，请选择包含目标 MAC 地址的子表，并将数据包下游转发到与子表对应的子节点。</li><li>如果目标 MAC 地址不在当前节点的路由表中，则将数据包上游转发到当前节点的父节点。重复执行此操作将导致数据包到达根节点，其中路由表应包含网络中的所有节点。</li></ol><blockquote><p>用户可以调用 <code>esp_mesh_get_routing_table()</code> 来获取节点的路由表，或者调用 <code>esp_mesh_get_routing_table_size()</code> 来获取节点的路由表的大小。<br><code>esp_mesh_get_subnet_nodes_list()</code> 可用于获取特定子节点的相应子表。同样，<code>esp_mesh_get_subnet_nodes_num()</code> 可用于获取子表的大小。</p></blockquote><h2 id="构建-ESP-MESH-网络"><a href="#构建-ESP-MESH-网络" class="headerlink" title="构建 ESP-MESH 网络"></a>构建 ESP-MESH 网络</h2><h3 id="一般过程"><a href="#一般过程" class="headerlink" title="一般过程"></a>一般过程</h3><blockquote><p>在 ESP-MESH 网络构建过程开始之前，配置的某些部分必须在网络中的每个节点上保持一致（请参阅 <code>mesh_cfg_t</code>）。每个节点必须配置相同的 Mesh 网络 ID，路由器配置和 SoftAP 配置。</p></blockquote><p>ESP-MESH 网络构建过程涉及根节点选择，然后逐层形成下游连接，直到所有节点都加入网络。网络的确切布局可以取决于诸如根节点选择，父节点选择和异步上电复位等因素。但是，ESP-MESH 网络构建过程可以概括为以下步骤：</p><p><img src="https://img-blog.csdnimg.cn/2019020114281399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 网络构建过程"></p><ol><li><p>根节点选择</p><p><strong>根节点可以在配置期间指定</strong>（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#user-designated-root-node" target="_blank" rel="noopener">用户指定的根节点部分</a>），或者<strong>根据每个节点和路由器之间的信号强度动态选择</strong>（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>）。选择后，根节点将与路由器连接并开始允许形成下游连接。参考上图，节点 A 被选择为根节点，因此节点 A 与路由器形成上游连接。</p></li><li><p>第二层形成</p><p>一旦根节点连接到路由器，根节点范围内的空闲节点将开始与根节点连接，从而形成网络的第二层。连接后，第二层节点成为中间父节点（假设允许的最大层数 &gt; 2），因此形成下一层。参考上图，节点 B 到 D 在根节点的范围内。因此，节点 B 到 D 与根节点形成上游连接，并成为中间父节点。</p></li><li><p>形成剩余层</p><p>剩余的空闲节点将与范围内的中间父节点连接，从而在网络中形成新层。连接后，空闲节点将成为中间父节点或叶节点，具体取决于网络允许的最大层数。重复该步骤，直到网络中不再有空闲节点或者直到达到网络的最大允许层为止。参考上图，节点 E/F/G 分别与节点 B/C/D 连接，并成为中间父节点本身。</p></li><li><p>限制树深度</p><p>为防止网络超出允许的最大层数，最大层上的节点一旦连接就会自动成为叶子节点。这防止任何其他空闲节点与叶节点连接，从而防止形成新的层形式。但是，如果空闲节点没有其他可能的父节点，它将无限期地保持空闲状态。参考上图，网络的最大允许层数设置为 4。因此，当节点 H 连接时，它成为叶节点以防止形成任何下游连接。</p></li></ol><h3 id="自动根节点选择"><a href="#自动根节点选择" class="headerlink" title="自动根节点选择"></a>自动根节点选择</h3><p><strong>根节点的自动选择涉及所有空闲节点之间基于其与路由器的信号强度的选举过程。每个空闲节点将通过 Wi-Fi 信标帧发送其 MAC 地址和路由器 RSSI 值</strong>。MAC 地址用于唯一地标识网络中的每个节点，而路由器 RSSI 用于指示节点参考路由器的信号强度。</p><p>然后，<strong>每个节点将同时扫描来自其他空闲节点的信标帧</strong>。<strong>如果节点检测到具有更强路由器 RSSI 的信标帧，则该节点将开始发送该信标帧的内容</strong>（即，对具有更强路由器 RSSI 的节点进行投票）。<strong>传输和扫描的过程将重复预先配置的最小迭代次数</strong>（默认为 10 次迭代），<strong>这将导致具有最强路由器 RSSI 的信标帧在整个网络中传播</strong>。</p><p>在所有迭代之后，每个节点将单独检查其投票百分比（投票数/参与选举的节点数）以确定它是否应该成为根节点。<strong>如果节点的投票百分比大于预配置的阈值（默认为 90％），则该节点将成为根节点</strong>。</p><p>下图演示了在自动选择根节点时如何构建 ESP-MESH 网络。</p><p><img src="https://img-blog.csdnimg.cn/20190201144333598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="根节点选择示例"></p><ol><li>在上电复位时，每个节点开始发送由其自己的 MAC 地址和路由器 RSSI 组成的信标帧。</li><li>在多次传输和扫描迭代中，具有最强路由器 RSSI 的信标帧在整个网络中传播。节点 C 具有最强的路由器RSSI（-10db），因此其信标帧在整个网络中传播。参与选举的所有节点都对节点 C 进行投票，从而给节点 C 一个 100％ 的投票百分比。因此，节点 C 成为根节点并与路由器连接。</li><li>一旦节点 C 与路由器连接，节点 A/B/D/E 就与节点 C 连接，因为它是首选的父节点（即最浅节点）。节点 A/B/D/E 构成网络的第二层。</li><li>节点 F 和 G 分别与节点 D 和 E 连接，网络构建过程完成。</li></ol><blockquote><p>可以使用 <code>esp_mesh_set_attempts（）</code> 配置选举过程的最小迭代次数。用户应该基于网络内的节点数量来调整迭代次数（即，网络越大，所需的扫描迭代次数越多）。</p></blockquote><blockquote><p>也可以使用 <code>esp_mesh_set_vote_percentage()</code> 配置投票百分比阈值。设置低投票百分比阈值可导致两个或更多节点成为同一 ESP-MESH 网络内的根节点，从而导致建立多个网络。如果是这种情况，ESP-MESH 具有自主解决根节点冲突的内部机制。多个根节点的网络将组合成具有单个根节点的单个网络。但是，根节点冲突，其中两个或多个根节点具有相同的路由器 SSID 但不处理不同的路由器 BSSID。</p></blockquote><h3 id="用户指定根节点"><a href="#用户指定根节点" class="headerlink" title="用户指定根节点"></a>用户指定根节点</h3><p><strong>根节点也可以由用户指定，这将使指定的根节点直接与路由器连接并放弃选举过程。当指定根节点时，网络中的所有其他节点也必须放弃选举过程以防止发生根节点冲突。</strong> 下图演示了当用户指定根节点时如何构建 ESP-MESH 网络。</p><p><img src="https://img-blog.csdnimg.cn/20190201145101139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="指定根节点示例（根节点= A，最大层数= 4）"></p><ol><li>节点 A 被用户指定为根节点，因此直接与路由器连接。所有其他节点放弃选举过程。</li><li>节点 C/D 连接节点 A 作为其首选父节点。两个节点构成网络的第二层。</li><li>同样，节点 B/E 与节点 C 连接，节点 F 与节点 D 连接。节点 B/E/F 构成网络的第三层。</li><li>节点 G 与节点 E 连接，形成网络的第四层。但是，此网络中允许的最大层数配置为 4，因此节点 G 成为叶节点以防止形成任何新层。</li></ol><blockquote><p>在指定根节点时，根节点应调用 <code>esp_mesh_set_parent()</code> 以直接与路由器连接。同样，所有其他节点应调用 <code>esp_mesh_fix_root()</code> 以放弃选举过程。</p></blockquote><h3 id="父节点选择"><a href="#父节点选择" class="headerlink" title="父节点选择"></a>父节点选择</h3><p>默认情况下，ESP-MESH 是自组织的，这意味着每个节点将自动选择与哪个潜在父节点形成上游连接。自主选择的父节点称为首选父节点。用于选择首选父节点的标准旨在减少 ESP-MESH 网络中的层数，并平衡潜在父节点之间的下游连接数（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#preferred-parent-node" target="_blank" rel="noopener">首选父节点</a>）。</p><p>但是，ESP-MESH 还允许用户禁用自组织行为，这将允许用户定义自己的父节点选择标准，或配置节点以具有指定的父节点（请参阅<a href="https://github.com/espressif/esp-idf/tree/2790d4a/examples/mesh/manual_networking" target="_blank" rel="noopener">手动 MESH 网络示例</a>）。</p><h3 id="异步上电复位"><a href="#异步上电复位" class="headerlink" title="异步上电复位"></a>异步上电复位</h3><p>ESP-MESH 网络建设可能受节点上电顺序的影响。如果网络中的某些节点异步上电（即相隔几分钟），则网络的最终结构可能与所有节点同步通电的理想情况不同。上电延迟的节点将遵循以下规则：</p><p>规则1：如果网络中已存在根节点，则延迟节点将不会尝试选择新的根节点，即使它与路由器具有更强的 RSSI。通过连接首选父节点，延迟节点将像任何其他空闲节点一样加入网络。如果延迟节点是指定的根节点，则网络中的所有其他节点将保持空闲，直到延迟节点通电。</p><p>规则2：如果延迟节点形成上游连接并成为中间父节点，则它也可以成为其他节点的新首选父节点（即，是较浅的节点）。这将导致其他节点切换其上游连接以与延迟节点连接（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#parent-node-switching" target="_blank" rel="noopener">父节点切换</a>）。</p><p>规则3：如果空闲节点具有在通电时被延迟的指定父节点，则空闲节点将不会在没有其指定的父节点的情况下尝试形成任何上游连接。空闲节点将无限期地保持空闲，直到其指定的父节点上电为止。</p><p>以下示例演示了异步上电对网络构建的影响。</p><p><img src="https://img-blog.csdnimg.cn/20190201150942611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="基于异步电源的网络构建示例"></p><ol><li>节点 A/C/D/F/G/H 同步上电，通过广播其 MAC 地址和路由器 RSSI 开始根节点选举过程。节点 A 被选为根节点，因为它具有最强的 RSSI。</li><li>一旦节点 A 成为根节点，其余节点就开始逐层形成具有其首选选父节点的上游连接。结果是一个有五层的网络。</li><li>节点 B/E 在上电时被延迟但是没有尝试成为根节点，即使它们具有比节点 A 更强的路由器 RSSI（-20db 和 -10db）。相反，两个延迟节点形成与其首选父节点的上游连接。节点 A 和 C 分别。连接后，两个节点 B/E 都成为中间父节点。</li><li>节点 D/G 切换它们的上游连接，因为节点 B 是新的首选父节点，因为它位于较浅的层（第二层节点）上。由于切换，所得到的网络具有三层而不是原始的五层。</li></ol><p>同步上电：如果所有节点同步上电，节点 E 将成为根节点，因为它具有最强的路由器 RSSI（-10db）。与在异步通电条件下形成的网络相比，这将导致显着不同的网络布局。但是，如果用户手动切换根节点，仍然可以达到同步开机网络布局（请参阅 <code>esp_mesh_waive_root()</code> ）。</p><blockquote><p>由异步上电引起的父节点选择的差异在 ESP-MESH 中在某种程度上被自动校正（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#parent-node-switching" target="_blank" rel="noopener">父节点切换</a>）</p></blockquote><h3 id="环路避免，检测和处理"><a href="#环路避免，检测和处理" class="headerlink" title="环路避免，检测和处理"></a>环路避免，检测和处理</h3><p>环路是特定节点与其后代节点之一（特定节点的子网内的节点）形成上游连接的情况。这导致圆形连接路径，从而破坏树状网络拓扑结构。ESP-MESH 通过排除在选择节点的路由表中已存在的节点（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#routing-tables" target="_blank" rel="noopener">路由表</a>）来防止在父节点选择期间产生环路，从而防止特定节点尝试连接到其子网内的任何节点。</p><p>在发生环路的情况下，ESP-MESH利用路径验证机制和能量传输机制来检测环路发生。导致环路的上游连接的父节点将通知子节点环路并启动断开连接。</p><h2 id="管理网络"><a href="#管理网络" class="headerlink" title="管理网络"></a>管理网络</h2><p>ESP-MESH 是一个自我修复网络，意味着它可以检测并纠正网络路由中的故障。当具有一个或多个子节点的父节点发生故障或父节点与其子节点之间的连接变得不稳定时，会发生故障。ESP-MESH 中的子节点将自动选择新的父节点并与其形成上游连接以维持网络互连。ESP-MESH 可以处理根节点故障和中间父节点故障。</p><h3 id="根节点故障"><a href="#根节点故障" class="headerlink" title="根节点故障"></a>根节点故障</h3><p><strong>如果根节点发生故障，与其连接的节点（第二层节点）将立即检测到根节点的故障。第二层节点最初将尝试与根节点重新连接。但是，在多次尝试失败后，第二层节点将初始化新一轮的根节点选举。具有最强路由器 RSSI 的第二层节点将被选为新的根节点，而剩余的第二层节点将与新的根节点（或相邻的父节点，如果不在范围内）形成上游连接。</strong></p><p>如果根节点和多个下游层同时发生故障（例如，根节点，第二层和第三层），仍然起作用的最浅层将初始化根节点选举。以下示例说明了从根节点分解的自我修复示例。</p><p><img src="https://img-blog.csdnimg.cn/20190201153541569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="从根节点故障中自我修复"></p><ol><li>节点 C 是网络的根节点。节点 A/B/D/E 是连接到节点 C 的第二层节点。</li><li>节点 C 发生故障。在多次尝试重新连接失败后，第二层节点通过广播其路由器 RSSI 开始选举过程。节点 B 具有最强的路由器 RSSI。</li><li>节点 B 被选为根节点并开始接受下游连接。剩余的第二层节点 A/D/E 形成与节点 B 的上游连接，因此网络被修复并且可以继续正常操作。</li></ol><blockquote><p>如果指定的根节点发生故障，则其余节点将不会自主地尝试选择新的根节点，因为在使用指定的根节点时将永远不会尝试选举过程。</p></blockquote><h3 id="中间父节点故障"><a href="#中间父节点故障" class="headerlink" title="中间父节点故障"></a>中间父节点故障</h3><p><strong>如果中间父节点发生故障，则断开连接的子节点将首先尝试与父节点重新连接。在多次尝试重新连接失败后，每个子节点将开始扫描潜在的父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#beacon-frames-rssi-thresholding" target="_blank" rel="noopener">信标帧和 RSSI 阈值</a>）。</strong></p><p>如果其他可能的父节点可用，则每个子节点将单独选择新的首选父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#preferred-parent-node" target="_blank" rel="noopener">首选父节点</a>）并与其形成上游连接。如果特定子节点没有其他潜在父节点，则它将无限期保持空闲状态。</p><p>下图说明了从中间父节点分解的自我修复的示例。</p><p><img src="https://img-blog.csdnimg.cn/20190201153956675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="从中间父节点故障中自我修复"></p><ol><li>网络的以下分支由节点 A 到 G 组成。</li><li>节点 C 发生故障。 节点 F/G 检测到故障并尝试与节点 C 重新连接。多次尝试重新连接失败后，节点 F/G 开始选择新的首选父节点。</li><li>节点 G 超出任何其他父节点的范围，因此暂时保持空闲。节点 F 在节点 B/E 的范围内，但是节点 B 被选择，因为它是较浅的节点。节点 F 在与节点 B 连接之后成为中间父节点，因此节点 G 可以与节点 F 连接。网络被修复，但是网络路由已经受到影响并且添加了额外的层。</li></ol><blockquote><p>如果子节点具有指定的父节点，则子节点将不会尝试连接新的父节点。子节点将无限期保持空闲状态。</p></blockquote><h3 id="根节点切换"><a href="#根节点切换" class="headerlink" title="根节点切换"></a>根节点切换</h3><p><strong>除非根节点发生故障，否则 ESP-MESH 不会自动切换根节点。即使根节点的路由器 RSSI 降级到断开点，根节点也将保持不变</strong>。根节点切换是明确开始新选举的行为，使得具有更强路由器 RSSI 的节点将被选为新的根节点。这可以是适应降低根节点性能的有用方法。</p><p><strong>要触发根节点切换，当前根节点必须显式调用 <code>esp_mesh_waive_root()</code> 以触发新选举</strong>。当前根节点将发信号通知网络内的所有节点开始发送和扫描信标帧（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>），同时保持连接到网络（即，不空闲）。如果另一个节点收到的选票多于当前根节点，则将启动根节点切换。否则，根节点将保持不变。</p><p>新选择的根节点向当前根节点发送切换请求，该当前根节点将以确认响应，表示两个节点都准备切换。一旦收到确认，新选出的根节点将与其父节点断开连接，并迅速与路由器形成上游连接，从而成为网络的新根节点。先前的根节点将断开与路由器的连接，同时保持其所有下游连接并进入空闲状态。然后，先前的根节点将开始扫描潜在的父节点并选择首选父节点。</p><p>下图说明了根节点切换的示例。</p><p><img src="https://img-blog.csdnimg.cn/20190201160040642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="根节点切换示例"></p><ol><li>节点 C 是当前的根节点，但路由器的信号强度降低（-85db）。节点 C 触发新的选举，并且所有节点在仍然连接的同时开始发送和扫描信标帧。</li><li>经过多轮传输和扫描后，节点 B 被选为新的根节点。节点 B 向节点 C 发送切换请求，节点 C 以确认响应。</li><li>节点 B 与其父节点断开连接，并与路由器连接，成为网络新的根节点。节点 C 与路由器断开连接，进入空闲状态，并开始扫描并选择新的首选父节点。节点 C 在整个过程中维护其所有下游连接。</li><li>节点 C 选择节点 B 作为其首选父节点，形成上游连接，并成为第二层节点。交换根节点后网络布局类似，因为节点 C 仍保持相同的子网。但是，由于交换根节点，节点 C 的子网中的每个节点都被放置了一层。如果任何节点由于根节点切换而具有新的优选父节点，则父节点切换可以随后调整网络布局。</li></ol><blockquote><p>根节点切换必须要求选举，因此仅在使用自组织 ESP-MESH 网络时才支持。换句话说，如果使用指定的根节点，则不能发生根节点切换。</p></blockquote><h3 id="父节点切换"><a href="#父节点切换" class="headerlink" title="父节点切换"></a>父节点切换</h3><p><strong>父节点切换需要子节点将其上游连接切换到较浅层的另一个父节点。父节点切换自动发生，这意味着如果较浅层的潜在父节点变得可用（即，由于<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#asynchronous-power-on-reset" target="_blank" rel="noopener">异步上电复位</a>），子节点将自动改变其上游连接。</strong></p><p>所有潜在的父节点周期性地发送信标帧（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#beacon-frames-rssi-thresholding" target="_blank" rel="noopener">信标帧和 RSSI 阈值</a>），允许子节点扫描较浅的父节点的可用性。由于父节点切换，自组织的 ESP-MESH 网络可以动态调整其网络布局，以确保每个连接具有良好的 RSSI 并且网络中的层数最小化。</p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="ESP-MESH数据包"><a href="#ESP-MESH数据包" class="headerlink" title="ESP-MESH数据包"></a>ESP-MESH数据包</h3><p>ESP-MESH 网络数据传输使用 ESP-MESH 数据包。ESP-MESH 数据包完全包含在 Wi-Fi 数据帧的帧体内。ESP-MESH 网络中的多跳数据传输将涉及通过不同的 Wi-Fi 数据帧在每个无线跳上承载的单个 ESP-MESH 数据包。</p><p>下图显示了 ESP-MESH 数据包的结构及其与 Wi-Fi 数据帧的关系。</p><p><img src="https://img-blog.csdnimg.cn/20190201162512352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 数据包"><br>ESP-MESH 数据包的包头包含源节点和目标节点的 MAC 地址。选项字段包含与特殊类型的 ESP-MESH 数据包有关的信息，例如组传输或源自外部 IP 网络的数据包（请参阅 <code>MESH_OPT_SEND_GROUP</code> 和 <code>MESH_OPT_RECV_DS_ADDR</code>）。</p><p>ESP-MESH 数据包的有效负载包含实际的应用程序数据。此数据可以是原始二进制数据，也可以在应用程序层协议（如 HTTP，MQTT 和 JSON）下编码（请参阅 <code>mesh_proto_t</code>）。</p><blockquote><p>将 ESP-MESH 数据包发送到外部 IP 网络时，包头的目标地址字段将包含目标服务器的 IP 地址和端口，而不是节点的 MAC 地址（请参阅 <code>mesh_addr_t</code>）。此外，根节点将处理输出 TCP/IP 数据包的形成。</p></blockquote><h3 id="组控制和多播"><a href="#组控制和多播" class="headerlink" title="组控制和多播"></a>组控制和多播</h3><p>多播是一种允许将单个 ESP-MESH 数据包同时传输到网络中的多个节点的功能。ESP-MESH 中的多播可以通过指定目标节点列表或指定预先配置的节点组来实现。两种多播方法都是通过 <code>esp_mesh_send()</code> 调用的。</p><p>要通过指定目标节点列表进行多播，用户必须首先将 ESP-MESH 数据包的目标地址设置为多播组地址（01:00:5E:xx:xx:xx）。这表示 ESP-MESH 数据包是具有一组地址的多播数据包，并且该地址应从头选项中获取。然后，用户必须将目标节点的 MAC 地址列为选项（请参阅 <code>mesh_opt_t</code> 和 <code>MESH_OPT_SEND_GROUP</code>）。这种多播方法不需要事先设置，但可能产生大量开销数据，因为每个目标节点的 MAC 地址必须列在数据包包头的选项字段中。</p><p>按组进行多播允许将 ESP-MESH 数据包传输到预先配置的节点组。每个组由唯一 ID 标识，并且可以通过 <code>esp_mesh_set_group_id()</code> 将节点放入组中。对组进行组播涉及将 ESP-MESH 数据包中的目的地址设置为目标组 ID。此外，必须设置 <code>MESH_DATA_GROUP</code> 标志。使用组进行多播会产生较少的开销，但需要先前将节点添加到组中。</p><blockquote><p>在多播期间，网络中的所有节点仍然在 MAC 层上接收 ESP-MESH 数据包。但是，未包含在 MAC 地址列表或目标组中的节点将简单地过滤掉该数据包。</p></blockquote><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播是一种允许单个 ESP-MESH 数据包同时传输到网络中所有节点的功能。每个节点基本上将广播包转发到其所有上游和下游连接，使得广播包尽可能快地在整个网络中传播。但是，ESP-MESH 利用以下方法避免在广播期间浪费带宽。</p><ol><li>当中间父节点从其父节点接收广播包时，它将广播包转发到其每个子节点，同时为其自身存储广播包的副本。</li><li>当中间父节点是广播的源节点时，它将向上游发送广播包到父节点并且向下游发送广播包到每个子节点。</li><li>当中间父节点从其子节点之一接收广播包时，它将广播包转发到其父节点及其剩余的每个子节点，同时为其自身存储广播包的副本。</li><li>当叶节点是广播的源节点时，它将直接将数据包传输到其父节点。</li><li>当根节点是广播的源节点时，根节点将数据包传输到其所有子节点。</li><li>当根节点从其子节点之一接收广播包时，它将广播包转发到其剩余的每个子节点，同时为其自身存储广播包的副本。</li><li>当节点接收到源地址与其自己的 MAC 地址匹配的广播包时，该节点将丢弃该广播包。</li><li>当中间父节点从其父节点接收到最初从其子节点之一发送的广播包时，它将丢弃广播包。</li></ol><h3 id="上游流量控制"><a href="#上游流量控制" class="headerlink" title="上游流量控制"></a>上游流量控制</h3><p>ESP-MESH 依靠父节点来控制其直接子节点的上游数据流。为了防止父节点的消息缓冲区由于上游传输的过载而溢出，父节点将为其每个子节点分配用于上游传输的配额，称为接收窗口。<strong>每个子节点必须在允许向上游传输之前申请接收窗口。</strong> 可以动态调整接收窗口的大小。从子节点到父节点的上游传输包括以下步骤：</p><ol><li>在每次传输之前，子节点向其父节点发送窗口请求。窗口请求由序列号组成，该序列号对应于待传输的子节点的数据包。</li><li>父节点接收窗口请求，并将序列号与子节点发送的先前数据包的序列号进行比较。该比较用于计算发送回子节点的接收窗口的大小。</li><li>子节点根据父节点指定的窗口大小发送数据包。如果子节点耗尽其接收窗口，则必须通过在允许继续发送之前发送请求来获得另一个接收窗口。</li></ol><blockquote><p>ESP-MESH 不支持任何下游流量控制。</p></blockquote><blockquote><p>由于父节点切换，在上游传输期间可能发生数据包丢失。</p></blockquote><p>由于根节点充当外部 IP 网络的唯一接口，因此下游节点了解根节点与外部 IP 网络的连接状态至关重要。如果不这样做，可能会导致节点在与 IP 网络断开连接时尝试将数据上行传递到根节点。这导致不必要的传输和数据包丢失。ESP-MESH 通过提供一种机制来解决此问题，该机制基于根节点和外部 IP 网络之间的连接状态来稳定传出数据的吞吐量。根节点可以通过调用 <code>esp_mesh_post_toDS_state()</code> 将其外部 IP 网络连接状态广播到所有其他节点。</p><h3 id="双向数据流"><a href="#双向数据流" class="headerlink" title="双向数据流"></a>双向数据流</h3><p>下图说明了 ESP-MESH 双向数据流中涉及的各种网络层。</p><p><img src="https://img-blog.csdnimg.cn/20190201165440991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 双向数据流"><br>由于使用了<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#routing-tables" target="_blank" rel="noopener">路由表</a>，ESP-MESH 能够完全在网状层上处理包转发。仅当根节点向/从外部 IP 网络发送/接收数据包时，才需要 TCP/IP 层。</p><h2 id="信道切换"><a href="#信道切换" class="headerlink" title="信道切换"></a>信道切换</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在传统的 Wi-Fi 网络中，信道是预定的频率范围。在基本服务集（BSS）中，服务 AP 及其连接的 Station 必须在相同信道（1 至 14）上发送信标。在同一信道上运行的物理上相邻的 BSS（基本服务集）可能会导致干扰并降低性能。</p><p>为了使 BSS 适应不断变化的物理层条件并保持性能，Wi-Fi 包含用于网络信道切换的机制。网络信道切换是尝试将 BSS 移动到新的操作信道，同时在此过程中最小化对 BSS 的干扰。然而，应该认识到，在将所有 Station 移动到新的操作信道时，信道切换可能是不成功的。</p><p>在 Wi-Fi 网络中，AP 触发网络信道切换，目的是使 AP 和所有连接的 Station 同步切换到新信道。通过在 AP 的周期性发送的信标帧内嵌入信道切换公告（CSA）元素来实现网络信道切换。CSA 元素用于向所有连接的站点通告关于即将到来的网络信道切换，并且将被包括在多个信标帧中直到切换发生。</p><p>CSA 元素包含关于新信道号和信道切换计数的信息，其指示在网络信道切换发生之前剩余的信标帧间隔（TBTT）的数量。因此，每个信标帧递减信道切换计数，并允许连接的 Station 将其信道切换与 AP 同步。</p><h3 id="ESP-MESH-网络信道切换"><a href="#ESP-MESH-网络信道切换" class="headerlink" title="ESP-MESH 网络信道切换"></a>ESP-MESH 网络信道切换</h3><p>ESP-MESH 网络信道切换还利用包含 CSA 元素的信标帧。然而，作为多跳网络使得 ESP-MESH 中的切换过程更复杂，因为信标帧可能无法到达网络内的所有节点（即，在单跳中）。因此，ESP-MESH 网络依靠节点转发 CSA 元素，以便它在整个网络中传播。</p><p>当具有一个或多个子节点的中间父节点接收到包含 CSA 的信标帧时，该节点将通过将该元素包括在其下一个发送的信标帧中（即，具有相同的新信道号和信道切换计数）来转发 CSA 元素。鉴于 ESP-MESH 网络内的所有节点都接收相同的 CSA，节点可以使用信道切换计数来同步其信道切换，尽管由于 CSA 元素转发而导致短的延迟。</p><p>ESP-MESH 网络信道切换可以由路由器或根节点触发。</p><h3 id="根节点触发"><a href="#根节点触发" class="headerlink" title="根节点触发"></a>根节点触发</h3><p>只有当 ESP-MESH 网络未连接到路由器时，才会发生根节点触发的信道切换。通过调用 <code>esp_mesh_switch_channel()</code>，根节点将设置初始信道切换计数值并开始在其信标帧中包含 CSA 元素。然后，每个 CSA 元素由第二层节点接收，并在它们自己的信标帧中向下游转发。</p><h3 id="路由器触发"><a href="#路由器触发" class="headerlink" title="路由器触发"></a>路由器触发</h3><p>当 ESP-MESH 网络连接到路由器时，整个网络必须使用与路由器相同的信道。因此，当根节点连接到路由器时，将不允许根节点触发通道切换。</p><p>当根节点从路由器接收包含 CSA 元素的信标帧时，根节点将 CSA 元素中的信道切换计数值设置为自定义值，然后通过信标帧向下游转发。它还将相对于自定义值递减后续 CSA 元素的通道切换计数。此自定义值可以基于诸如网络层数，当前节点数等因素。</p><p>将信道切换计数值设置为自定义值是由于 ESP-MESH 网络及其路由器可能具有不同且变化的信标间隔。因此，路由器提供的信道切换计数值与 ESP-MESH 网络无关。通过使用自定义值，ESP-MESH 网络中的节点能够相对于 ESP-MESH 网络的信标间隔同步切换信道。但是，这也会导致 ESP-MESH 网络的信道切换与路由器及其连接站的信道切换不同步。</p><h3 id="网络信道切换的影响"><a href="#网络信道切换的影响" class="headerlink" title="网络信道切换的影响"></a>网络信道切换的影响</h3><ul><li>由于 ESP-MESH 网络信道切换与路由器的信道切换不同步，ESP-MESH 网络和路由器之间将存在临时信道差异。<ul><li>ESP-MESH 网络的信道切换时间取决于 ESP-MESH 网络的信标间隔和根节点的自定义信道切换计数值。</li><li>通道差异可防止在 ESP-MESH 网络切换期间根节点与路由器之间的任何数据交换。</li><li>在 ESP-MESH 网络中，根节点和中间父节点将请求其连接的子节点停止传输，直到通过将 CSA 元素中的信道切换模式字段设置为 1 来进行信道切换。</li><li>频繁路由器触发的网络信道切换会降低 ESP-MESH 网络的性能。请注意，这可能是由 ESP-MESH 网络本身引起的（例如，由于与 ESP-MESH 网络的无线媒体争用）。如果是这种情况，用户应禁用路由器上的自动信道切换，并使用指定的信道。</li></ul></li><li>当存在临时信道差异时，根节点在技术上保持与路由器的连接。<ul><li>在根节点未能通过固定数量的路由器信标间隔从路由器接收任何信标帧或探测响应之后发生断开连接。</li><li>断开连接后，根节点将自动重新扫描所有通道以查找是否存在路由器。</li></ul></li><li>如果根节点无法接收任何路由器的 CSA 信标帧（例如，由于路由器给出的切换时间短），路由器将在没有 ESP-MESH 网络知识的情况下切换信道。<ul><li>路由器切换通道后，根节点将无法再接收路由器的信标帧和探测响应，并在固定数量的信标间隔后导致断开连接。</li><li>断开连接后，根节点将重新扫描路由器的所有通道。</li><li>根节点将在整个过程中维护下游连接。</li></ul></li></ul><blockquote><p>尽管 ESP-MESH 网络信道切换旨在将网络内的所有节点移动到新的操作信道，但应该认识到信道切换可能不能成功地移动所有节点（例如，由于诸如节点故障的原因）。</p></blockquote><h3 id="通道和路由器切换配置"><a href="#通道和路由器切换配置" class="headerlink" title="通道和路由器切换配置"></a>通道和路由器切换配置</h3><p>ESP-MESH 允许通过配置启用/禁用自主通道切换。同样，也可以通过配置启用/禁用自主路由器切换（即，当根节点自主连接到另一个路由器时）。自主信道切换和路由器切换取决于以下配置参数和运行时条件。</p><p><strong>允许通道切换：</strong> 此参数通过 <code>mesh_cfg_t</code> 结构的 <code>allow_channel_switch</code> 字段设置，并允许 ESP-MESH 网络在设置时动态切换通道。</p><p><strong>预设信道：</strong> 通过将 <code>mesh_cfg_t</code> 结构的信道字段设置为所需的信道号，ESP-MESH 网络可以拥有预设信道。如果未设置此字段，则会覆盖 <code>allow_channel_switch</code> 参数，以便始终允许通道切换。</p><p><strong>允许路由器切换：</strong> 此参数通过 <code>mesh_router_t</code> 的 <code>allow_router_switch</code> 字段设置，并允许 ESP-MESH 在设置时动态切换到其他路由器。</p><p><strong>预设路由器BSSID：</strong> ESP-MESH 网络可以通过将 <code>mesh_router_t</code> 结构的 <code>bssid</code> 字段设置为所需路由器的 BSSID 来具有预设路由器。如果未设置此字段，则会覆盖 <code>allow_router_switch</code> 参数，以便始终允许路由器切换。</p><p><strong>根节点存在：</strong> 根节点的存在还会影响是允许还是允许通道或路由器切换。</p><p>下表说明了参数/条件的不同组合如何影响是否允许信道切换和/或路由器切换。请注意，X 表示参数的“不关心”。</p><p><img src="https://img-blog.csdnimg.cn/20190201171947753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>可以基于多个指标评估 ESP-MESH 网络的性能，例如：</p><p><strong>网络构建时间：</strong> 从头开始构建 ESP-MESH 网络所需的时间。</p><p><strong>恢复时间：</strong> 网络检测节点故障所需的时间，并执行适当的操作来修复网络（例如生成新的根节点或形成新的连接）。</p><p><strong>每跳延迟：</strong> 通过一个无线跳数据传输的延迟。换句话说，将数据包从父节点传输到子节点所花费的时间，反之亦然。</p><p><strong>网络节点容量：</strong> ESP-MESH 网络可以同时支持的节点总数。<strong>此数字由节点可接受的最大下游连接数和网络中允许的最大层数确定。</strong></p><p>下表列出了 ESP-MESH 网络的常见性能数据。但是，用户应注意，基于网络配置和操作环境的安装之间的性能数字可能会有很大差异。</p><blockquote><p>使用以下测试条件产生上述性能数据。</p><ul><li>测试设备数量：100</li><li>要接受的最大下游连接数：6</li><li>最大允许层数：6</li></ul></blockquote><blockquote><p>吞吐量取决于数据包错误率和跳数。</p></blockquote><blockquote><p>根节点访问外部IP网络的吞吐量直接受 ESP-MESH 网络中节点数量和路由器带宽的影响。</p></blockquote><h2 id="进一步说明"><a href="#进一步说明" class="headerlink" title="进一步说明"></a>进一步说明</h2><ul><li>数据传输使用 Wi-Fi WPA2-PSK 加密</li><li>网状网络 IE 使用 AES 加密</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP-MESH&quot;&gt;&lt;a href=&quot;#ESP-MESH&quot; class=&quot;headerlink&quot; title=&quot;ESP-MESH&quot;&gt;&lt;/a&gt;ESP-MESH&lt;/h1&gt;&lt;p&gt;本指南提供有关 ESP-MESH 协议的信息。有关 API 使用的更多信息，请参阅 &lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/network/esp_mesh.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MESH API 参考&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ESP-MESH 是一种基于 Wi-Fi 协议构建的网络协议。ESP-MESH 允许在大的物理区域（室内和室外）上分布的多个设备（以下称为节点）在单个 WLAN（无线局域网）下互连。ESP-MESH 具有自组织和自我修复功能，意味着网络可以自主构建和维护。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190201111240103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70&quot; alt=&quot;传统的 Wi-Fi 网络架构&quot;&gt;&lt;br&gt;传统的 Wi-Fi 网络是一点对多点网络，其中称为接入点（AP）的单个中心节点直接连接到所有其他节点（station）。AP 负责仲裁和转发节点之间的传输。一些 AP 还通过路由器中继与外部 IP 网络的传输。传统的 Wi-Fi 网络由于要求每个站必须在一定范围内以直接与 AP 连接而具有有限覆盖区域的缺点。此外，传统的 Wi-Fi 网络易于过载，因为网络中允许的最大站数受到 AP 容量的限制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190201113539338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;ESP-MESH 与传统的 Wi-Fi 网络的不同之处在于节点不需要连接到中心节点。相反，允许节点与相邻节点连接。节点相互负责传递彼此的传输。这允许 ESP-MESH 网络具有更大的覆盖区域，因为节点仍然可以实现互连而无需在中心节点的范围内。同样，ESP-MESH 也不易受到过载的影响，因为网络上允许的节点数量不再受单个中心节点的限制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（九）使用 VS Code 快速开发 ESP32</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/12/17/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BD%BF%E7%94%A8%20VS%20Code%20%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%20ESP32/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/12/17/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BD%BF%E7%94%A8%20VS%20Code%20%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%20ESP32/</id>
    <published>2018-12-17T18:28:16.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-VS-Code-快速开发-ESP32"><a href="#使用-VS-Code-快速开发-ESP32" class="headerlink" title="使用 VS Code 快速开发 ESP32"></a>使用 VS Code 快速开发 ESP32</h1><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><ul><li>根据<a href="https://blog.csdn.net/qq_27114397/article/details/79078449" target="_blank" rel="noopener">官方文档</a>进行 <code>esp-idf</code> 开发环境搭建</li><li>安装 <a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">VS Code</a> </li></ul><h2 id="在-VS-Code-中进行开发"><a href="#在-VS-Code-中进行开发" class="headerlink" title="在 VS Code 中进行开发"></a>在 VS Code 中进行开发</h2><ul><li>将 <code>esp-idf</code> 中的模板工程 <a href="https://github.com/espressif/esp-idf/tree/master/examples/get-started/hello_world" target="_blank" rel="noopener">hello_world</a> 在 VS Code 中打开</li><li>在 VS Code 中开发项目</li></ul><a id="more"></a><h2 id="VS-Code-任务、快捷键配置"><a href="#VS-Code-任务、快捷键配置" class="headerlink" title="VS Code 任务、快捷键配置"></a>VS Code 任务、快捷键配置</h2><h3 id="任务配置"><a href="#任务配置" class="headerlink" title="任务配置"></a>任务配置</h3><ul><li>按下 <code>Ctrl+Shift+P</code></li><li>输入、选择 <code>Tasks: Configure Task</code>(任务：配置任务)</li><li>使用模板创建 <code>tasks.json</code> 文件</li><li>选择 <code>others</code></li><li>可使用下面的的任务配置模板（实现：快捷编译、下载、擦除 flash、清除编译、打开 monitor、menuconfig）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="string">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"build app"</span>, <span class="comment">// f5</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make -j8"</span>,</span><br><span class="line">            <span class="string">"group"</span>: &#123;</span><br><span class="line">                <span class="string">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="string">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"flash app"</span>, <span class="comment">// f6</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make -j8 flash"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"monitor"</span>, <span class="comment">// f7</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make monitor"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"clean app"</span>, <span class="comment">// f8</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make clean"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"erase flash"</span>, <span class="comment">// f9</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make erase_flash"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"menuconfig"</span>, <span class="comment">// f10</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make menuconfig"</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细配置过程：<img src="https://img-blog.csdnimg.cn/20181217181209238.gif" alt="详细配置过程"></p><h3 id="快捷键配置"><a href="#快捷键配置" class="headerlink" title="快捷键配置"></a>快捷键配置</h3><p>接下来我们给这些编译命令增加快捷键。</p><ul><li>按下：<code>Ctrl+Shift+P</code></li><li>输入、选择 <code>Preferences: Open Keyboard Shortcuts(JSON)</code> (首选项:打开键盘快捷方式)</li><li>高级自定义请打开和编辑 <code>keybindings.json</code></li><li>填充参数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Override key bindings by placing them into your key bindings file.</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f5"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"build app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f6"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"flash app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f7"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"monitor"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f8"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"clean app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f9"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"erase flash"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f10"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"menuconfig"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样我们就可通过快捷键进行编译、下载等</p><table><thead><tr><th>快捷键</th><th>执行的命令</th><th>功能</th></tr></thead><tbody><tr><td>F5</td><td><code>make -j8</code></td><td>编译</td></tr><tr><td>F6</td><td><code>make -j8 flash</code></td><td>编译、下载</td></tr><tr><td>F7</td><td><code>make monitor</code></td><td>监视器</td></tr><tr><td>F8</td><td><code>make clean</code></td><td>清除编译</td></tr><tr><td>F9</td><td><code>make erase_flash</code></td><td>擦除 flash</td></tr><tr><td>F10</td><td><code>make menuconfig</code></td><td>打开 menuconfig</td></tr></tbody></table><blockquote><p>NOTE: 这些命令都应该在工程的 <code>main</code> 目录下的文件中执行，例如： 在 VS Code 中打开了 hello_world 工程中 main 目录下的 <code>hello_world_main.c</code> 文件，可以按快捷键 <code>F6</code> 进行编译、下载。暂不支持在其他目录下进行。</p></blockquote><p>详细配置过程：<br><img src="https://img-blog.csdnimg.cn/20181217182915118.gif" alt="详细配置过程"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-VS-Code-快速开发-ESP32&quot;&gt;&lt;a href=&quot;#使用-VS-Code-快速开发-ESP32&quot; class=&quot;headerlink&quot; title=&quot;使用 VS Code 快速开发 ESP32&quot;&gt;&lt;/a&gt;使用 VS Code 快速开发 ESP32&lt;/h1&gt;&lt;h2 id=&quot;搭建开发环境&quot;&gt;&lt;a href=&quot;#搭建开发环境&quot; class=&quot;headerlink&quot; title=&quot;搭建开发环境&quot;&gt;&lt;/a&gt;搭建开发环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;根据&lt;a href=&quot;https://blog.csdn.net/qq_27114397/article/details/79078449&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;进行 &lt;code&gt;esp-idf&lt;/code&gt; 开发环境搭建&lt;/li&gt;
&lt;li&gt;安装 &lt;a href=&quot;https://code.visualstudio.com/Download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VS Code&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;在-VS-Code-中进行开发&quot;&gt;&lt;a href=&quot;#在-VS-Code-中进行开发&quot; class=&quot;headerlink&quot; title=&quot;在 VS Code 中进行开发&quot;&gt;&lt;/a&gt;在 VS Code 中进行开发&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;esp-idf&lt;/code&gt; 中的模板工程 &lt;a href=&quot;https://github.com/espressif/esp-idf/tree/master/examples/get-started/hello_world&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hello_world&lt;/a&gt; 在 VS Code 中打开&lt;/li&gt;
&lt;li&gt;在 VS Code 中开发项目&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（十四）RF 校准</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/12/09/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89RF%20%E6%A0%A1%E5%87%86/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/12/09/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89RF%20%E6%A0%A1%E5%87%86/</id>
    <published>2018-12-09T23:45:16.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RF-校准"><a href="#RF-校准" class="headerlink" title="RF 校准"></a>RF 校准</h1><p>ESP32 在 RF 初始化期间支持三种 RF 校准方法：</p><ol><li>部分校准</li><li>完全校准</li><li>没有校准</li></ol><a id="more"></a><h2 id="部分校准"><a href="#部分校准" class="headerlink" title="部分校准"></a>部分校准</h2><p>在 RF 初始化期间，默认情况下使用部分校准方法进行 RF 校准。 它基于存储在 NVS 中的完整校准数据完成。 要使用此方法，请到 <code>menuconfig</code> 并启用 <code>CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE</code>。</p><h2 id="完全校准"><a href="#完全校准" class="headerlink" title="完全校准"></a>完全校准</h2><p>在以下条件下触发完全校准：</p><ol><li>NVS  不存在。</li><li>用于存储校准数据的  NVS  分区被擦除。</li><li>硬件 MAC  地址已更改。</li><li>PHY 库版本已更改。</li><li>从 NVS 分区加载的 RF 校准数据被破坏。</li></ol><p>需要大约  100 ms, 比部分校准用的时间多。如果启动持续时间不重要，建议使用完整的校准方法。要切换到完整校准方法，请转到 <code>menuconfig</code> 并禁用 <code>CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE</code>。如果使用 RF 校准的默认方法，有两种方法可以添加触发完全校准功能作为最后的补救措施。</p><ol><li>如果您不介意删除存储在  NVS  分区中的所有数据，请擦除 NVS 分区。</li><li>在基于某些条件（例如，在某些诊断模式中提供的选项）初始化 WiFi  和 BT/BLE 之前调用 <code>esp_phy_erase_cal_data_in_nvs（）</code>。在这种情况下，仅擦除 NVS 分区的 phy 命名空间。</li></ol><h2 id="没有校准"><a href="#没有校准" class="headerlink" title="没有校准"></a>没有校准</h2><p>ESP32 从深度睡眠中醒来时，不会使用校准方法。</p><h2 id="PHY-初始化数据"><a href="#PHY-初始化数据" class="headerlink" title="PHY 初始化数据"></a>PHY 初始化数据</h2><p>PHY 初始化数据用于 RF 校准。 有两种方法可以获得 PHY 初始化数据。</p><ol><li>一个是默认的初始化数据，它位于头文件 <code>components/esp32/phy_init_data.h</code> 中。 它在编译后嵌入到应用程序二进制文件中，然后存储到只读存储器（DROM）中。 要使用默认初始化数据，请到 <code>menuconfig</code> 并禁用 <code>CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</code>。</li><li>另一种是存储在分区中的初始化数据。 使用自定义分区表时，请确保包含 PHY 数据分区（类型：数据，子类型：phy）。 使用默认分区表，这是自动完成的。 如果初始化数据存储在分区中，则必须在那里闪存，否则将发生运行时错误。 要切换到存储在分区中的初始化数据，请到 <code>menuconfig</code> 并启用 <code>CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</code>。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/RF_calibration.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RF-校准&quot;&gt;&lt;a href=&quot;#RF-校准&quot; class=&quot;headerlink&quot; title=&quot;RF 校准&quot;&gt;&lt;/a&gt;RF 校准&lt;/h1&gt;&lt;p&gt;ESP32 在 RF 初始化期间支持三种 RF 校准方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;部分校准&lt;/li&gt;
&lt;li&gt;完全校准&lt;/li&gt;
&lt;li&gt;没有校准&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（一）开发环境搭建</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/11/20/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/11/20/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2018-11-20T12:13:11.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP32-开发环境搭建"><a href="#ESP32-开发环境搭建" class="headerlink" title="ESP32 开发环境搭建"></a>ESP32 开发环境搭建</h1><p>ESP32 整体的开发资料相对比较多,官方网站在 github 上提供了详细的开发环境搭建步骤:<a href="https://esp-idf.readthedocs.io/en/latest/index.html#" target="_blank" rel="noopener">ESP-IDF Programming Guide</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP32-开发环境搭建&quot;&gt;&lt;a href=&quot;#ESP32-开发环境搭建&quot; class=&quot;headerlink&quot; title=&quot;ESP32 开发环境搭建&quot;&gt;&lt;/a&gt;ESP32 开发环境搭建&lt;/h1&gt;&lt;p&gt;ESP32 整体的开发资料相对比较多,官方网站在 github 上提供了详细的开发环境搭建步骤:&lt;a href=&quot;https://esp-idf.readthedocs.io/en/latest/index.html#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP-IDF Programming Guide&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二）GPIO &amp; RTC GPIO</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/11/20/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89GPIO%20&amp;%20RTC%20GPIO/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/11/20/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89GPIO%20&amp;%20RTC%20GPIO/</id>
    <published>2018-11-20T12:13:11.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPIO-amp-RTC-GPIO"><a href="#GPIO-amp-RTC-GPIO" class="headerlink" title="GPIO &amp; RTC GPIO"></a>GPIO &amp; RTC GPIO</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 芯片具有 40 个物理 GPIO pads (焊盘).某些 GPIO pad 既不能使用,在芯片封装上也没有相应的引脚(请参阅技术参考手册).所以只有 34 个物理 GPIO pads 可供使用.每个 pad 都可用作一个通用 IO,或连接一个内部的外设信号.IO_MUX、RTC IO_MUX 和 GPIO 交换矩阵用于将信号从外设传输至 GPIO pad.这些模块共同组成了芯片的 IO 控制.</p><p>注意:</p><ul><li>管脚 SCK/CLK,SDO/SD0,SDI/SD1,SHD/SD2,SWP/SD3,和 SCS/CMD,即 GPIO6 至 GPIO11 用于连接模组上集成的 SPI flash,不建议用于其他功能.</li><li>ESP32-D2WD 的管脚 GPIO16,GPIO17,SD_CMD,SD_CLK,SD_DATA_0 和 SD_DATA_1 用于连接嵌入式 Flash,不建议用于其他功能.</li><li>GPIO 34-39 只能设置为输入模式,没有软件上拉或下拉功能.</li><li>这 34 个物理 GPIO pad 的序列号为:0-19, 21-23, 25-27, 32-39.其中 GPIO 34-39 仅用作输入管脚,其他的既可以作为输入又可以作为输出管脚.</li></ul><a id="more"></a><p>当 GPIO 被连接到 “RTC” 低功耗和模拟子系统时,还有独立的 “RTC GPIO” 支持. 这些引脚功能可在深度睡眠,<a href="https://esp-idf.readthedocs.io/zh_CN/latest/api-guides/ulp.html" target="_blank" rel="noopener">超低功耗协处理器</a>运行时或使用 ADC/DAC/等 模拟功能时使用.</p><p>下图描述了数字 pad(控制信号:FUNC_SEL、IE、OE、WPU、WDU 等)和 162 个外设输入以及 176 个外设输出信号(控制信号:SIG_IN_SEL、SIG_OUT_SEL、IE、OE 等)和快速外设输入/输出信号(控制信号:IE、OE 等)以及 RTC IO_MUX 之间的信号选择和连接关系.<br><img src="https://img-blog.csdn.net/20180811133142567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图1: IO_MUX、RTC IO_MUX 和GPIO 交换矩阵结构框图"></p><center>图1: IO_MUX、RTC IO_MUX 和GPIO 交换矩阵结构框图</center><ol><li>IO_MUX 中每个 GPIO pad 有一组寄存器.每个 pad 可以配置成 GPIO 功能(连接 GPIO 交换矩阵)或者直连功能(旁路 GPIO 交换矩阵,快速信号如以太网、SDIO、SPI、JTAG、UART 等会旁路 GPIO 交换矩阵以实现更好的高频数字特性.所以高速信号会直接通过 IO_MUX 输入和输出.)</li><li>GPIO 交换矩阵是外设输入和输出信号和 pad 之间的全交换矩阵.<ul><li>芯片输入方向:162 个外设输入信号都可以选择任意一个 GPIO pad 的输入信号.</li><li>芯片输出方向:每个 GPIO pad 的输出信号可来自 176 个外设输出信号中的任意一个.</li></ul></li><li>RTC IO_MUX 用于控制 GPIO pad 的低功耗和模拟功能.只有部分 GPIO pad 具有这些功能.</li></ol><h2 id="通过-GPIO-交换矩阵的外设输入"><a href="#通过-GPIO-交换矩阵的外设输入" class="headerlink" title="通过 GPIO 交换矩阵的外设输入"></a>通过 GPIO 交换矩阵的外设输入</h2><p>为实现通过 GPIO 交换矩阵接收外设输入信号,需要配置 GPIO 交换矩阵从 34 个 GPIO(0-19,21-23,25-27,32-39)中获取外设输入信号的索引号(0-18,23-36,39-58,61-90,95-124,140-155,164-181,190-195,198-206).</p><p>输入信号通过 IO_MUX 从 GPIO pad 中读取.IO_MUX 必须设置相应 pad 为 GPIO 功能.这样 GPIO pad 的输入信号就可进入 GPIO 交换矩阵然后通过 GPIO 交换矩阵进入选择的外设输入.<br><img src="https://img-blog.csdn.net/20180811135015590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图2: 通过IO_MUX、GPIO 交换矩阵的外设输入"></p><center>图2: 通过IO_MUX、GPIO 交换矩阵的外设输入</center><h2 id="通过-GPIO-交换矩阵的外设输出"><a href="#通过-GPIO-交换矩阵的外设输出" class="headerlink" title="通过 GPIO 交换矩阵的外设输出"></a>通过 GPIO 交换矩阵的外设输出</h2><p>为实现通过 GPIO 交换矩阵输出外设信号,需要配置 GPIO 交换矩阵将输出索引号为 0-18,23-37,61-121,140-215,224-228 的外设信号输出到 28 个 GPIO (0-19, 21-23, 25-27, 32-33).</p><p>输出信号从外设输出到 GPIO 交换矩阵,然后到达 IO_MUX.IO_MUX 必须设置相应 pad 为 GPIO 功能.这样输出 GPIO 信号就能连接到相应 pad.</p><p>图3 所示为 176 个输出信号中的某一个信号通过 GPIO 交换矩阵到达 IO_MUX 然后连接到某个 pad.<br><img src="https://img-blog.csdn.net/20180811135319400?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图3: 通过GPIO 交换矩阵输出信号"></p><center>图3: 通过GPIO 交换矩阵输出信号</center><h2 id="IO-MUX-的直接-I-O-功能"><a href="#IO-MUX-的直接-I-O-功能" class="headerlink" title="IO_MUX 的直接 I/O 功能"></a>IO_MUX 的直接 I/O 功能</h2><p>快速信号如以太网、SDIO、SPI、JTAG、UART 等会使用直连功能(旁路 GPIO 交换矩阵)以实现更好的高频数字特性.所以高速信号会直接通过 IO_MUX 输入和输出.</p><p>这样比使用 GPIO 交换矩阵的灵活度要低,即每个 GPIO pad 的 IO_MUX 寄存器只有较少的功能选择,但可以实现更好的高频数字特性.</p><p>为实现外设 I/O 旁路 GPIO 交换矩阵必须配置两个寄存器:</p><ul><li>GPIO pad 的 IO_MUX 必须设置为相应的 pad 功能,表1列出了 pad 功能.</li><li>对于输入信号,必须置位 SIG_IN_SEL 寄存器,直接将输入信号输出到外设.</li></ul><p><img src="https://img-blog.csdn.net/20180811140112726?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="IO_MUX Pad 列表"></p><center>表1: IO_MUX Pad 列表</center><h2 id="RTC-IO-MUX-的低功耗和模拟-I-O-功能"><a href="#RTC-IO-MUX-的低功耗和模拟-I-O-功能" class="headerlink" title="RTC IO_MUX 的低功耗和模拟 I/O 功能"></a>RTC IO_MUX 的低功耗和模拟 I/O 功能</h2><p>18 个 GPIO 管脚具有低功耗(低功耗 RTC)性能和模拟功能,由 ESP32 的 RTC 子系统控制.这些功能不使用 IO_MUX 和 GPIO 交换矩阵,而是使用 RTC_MUX 将 I/O 指向 RTC 子系统.</p><p>当这些管脚被配置为 RTC GPIO 管脚,作为输出管脚时仍然能够在芯片处于 Deep-sleep 睡眠模式下保持输出电平值或者作为输入管脚使用时可以将芯片从 Deep-sleep 中唤醒.</p><p>每个 pad 的模拟和 RTC 功能是由 RTC_GPIO_PINx 寄存器中的 RTC_IO_TOUCH_PADx_TO_GPIO 位控制的.此位默认置为 1,通过 IO_MUX 子系统输入输出信号,如前文所述.</p><p>如果清零 RTC_IO_TOUCH_PADx_TO_GPIO 位,则输入输出信号会经过 RTC 子系统.在这种模式下,RTC_GPIO_PINx 寄存器用于数字 I/O,pad 的模拟功能也可以实现.</p><h2 id="Light-sleep-模式管脚功能"><a href="#Light-sleep-模式管脚功能" class="headerlink" title="Light-sleep 模式管脚功能"></a>Light-sleep 模式管脚功能</h2><p>当 ESP32 处于 Light-sleep 模式时管脚可以有不同的功能.如果某一 GPIO pad 的 IO_MUX 寄存器中 GPIOxx_SLP_SEL 位置为 1,芯片处于 Light-sleep 模式下将由另一组不同的寄存器控制 pad.</p><p>如果 GPIOxx_SLP_SEL 置为 0,则芯片在正常工作和 Light-sleep 模式下,管脚的功能一样.</p><h2 id="Pad-Hold-特性"><a href="#Pad-Hold-特性" class="headerlink" title="Pad Hold 特性"></a>Pad Hold 特性</h2><p>每个 IO pad(包括 RTC pad)都有单独的 hold 功能,由 RTC 寄存器控制.pad 的 hold 功能被置上后,pad 在置上 hold 那一刻的状态被强制保持,无论内部信号如何变化,修改 IO_MUX 配置或者 GPIO 配置,都不会改变 pad 的状态.应用如果希望在看门狗超时触发内核复位和系统复位时或者 Deep-sleep 时 pad 的状态不被改变,就需要提前把 hold 置上.</p><ul><li>对于数字 pad 而言, 若要在深度睡眠掉电之后保持 pad 输入输出的状态值,需要在掉电之前把寄存器 REG_DG_PAD_FORCE_UNHOLD 设置成 0.对于 RTC pad 而言,pad 的输入输出值,由寄存器 RTC_CNTL_HOLD_FORCE_REG 中相应的位来控制 Hold 和 Unhold pad 的值.</li><li>在芯片被唤醒之后,若要关闭 Hold 功能,将寄存器 REG_DG_PAD_FORCE_UNHOLD 设置成 1.若想继续保持 pad 的值,可把 RTC_CNTL_HOLD_FORCE_REG 寄存器中相应的位设置成1.</li></ul><p>示例：</p><p>RTC GPIO （deep sleep）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rtc_gpio_init(27);</span><br><span class="line">rtc_gpio_set_direction(27, RTC_GPIO_MODE_OUTPUT_ONLY);</span><br><span class="line">rtc_gpio_set_level(27, 1);</span><br><span class="line">rtc_gpio_pullup_en(27);</span><br><span class="line">rtc_gpio_hold_en(27);</span><br></pre></td></tr></table></figure><p>Digital GPIO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * The state of digital gpio cannot be held during Deep-sleep, and it will resume the hold function</span><br><span class="line">  * when the chip wakes up from Deep-sleep. If the digital gpio also needs to be held during Deep-sleep,</span><br><span class="line">  * &#96;gpio_deep_sleep_hold_en&#96; should also be called.</span><br><span class="line">  *</span><br><span class="line">  * Power down or call gpio_hold_dis will disable this function.</span><br><span class="line">  *&#x2F;</span><br><span class="line">gpio_pad_select_gpio(26);</span><br><span class="line">gpio_set_direction(26, GPIO_MODE_OUTPUT);</span><br><span class="line">gpio_set_level(26, 1);</span><br><span class="line"></span><br><span class="line">gpio_hold_en(26);</span><br><span class="line">gpio_deep_sleep_hold_en();</span><br></pre></td></tr></table></figure><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>GPIO 输出/输入中断示例:<a href="https://github.com/espressif/esp-idf/tree/f9a4496/examples/peripherals/gpio" target="_blank" rel="noopener">peripherals/gpio</a>.</p><h2 id="API-Reference-Normal-GPIO"><a href="#API-Reference-Normal-GPIO" class="headerlink" title="API Reference - Normal GPIO"></a>API Reference - Normal GPIO</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul><li><a href="https://github.com/espressif/esp-idf/blob/f9a4496/components/driver/include/driver/gpio.h" target="_blank" rel="noopener">driver/include/driver/gpio.h</a></li></ul><h2 id="API-Reference-RTC-GPIO"><a href="#API-Reference-RTC-GPIO" class="headerlink" title="API Reference - RTC GPIO"></a>API Reference - RTC GPIO</h2><h3 id="Header-File-1"><a href="#Header-File-1" class="headerlink" title="Header File"></a>Header File</h3><ul><li><a href="https://github.com/espressif/esp-idf/blob/7abed5f/components/driver/include/driver/rtc_io.h" target="_blank" rel="noopener">driver/include/driver/rtc_io.h</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/gpio.html" target="_blank" rel="noopener">GPIO &amp; RTC GPIO</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GPIO-amp-RTC-GPIO&quot;&gt;&lt;a href=&quot;#GPIO-amp-RTC-GPIO&quot; class=&quot;headerlink&quot; title=&quot;GPIO &amp;amp; RTC GPIO&quot;&gt;&lt;/a&gt;GPIO &amp;amp; RTC GPIO&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ESP32 芯片具有 40 个物理 GPIO pads (焊盘).某些 GPIO pad 既不能使用,在芯片封装上也没有相应的引脚(请参阅技术参考手册).所以只有 34 个物理 GPIO pads 可供使用.每个 pad 都可用作一个通用 IO,或连接一个内部的外设信号.IO_MUX、RTC IO_MUX 和 GPIO 交换矩阵用于将信号从外设传输至 GPIO pad.这些模块共同组成了芯片的 IO 控制.&lt;/p&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管脚 SCK/CLK,SDO/SD0,SDI/SD1,SHD/SD2,SWP/SD3,和 SCS/CMD,即 GPIO6 至 GPIO11 用于连接模组上集成的 SPI flash,不建议用于其他功能.&lt;/li&gt;
&lt;li&gt;ESP32-D2WD 的管脚 GPIO16,GPIO17,SD_CMD,SD_CLK,SD_DATA_0 和 SD_DATA_1 用于连接嵌入式 Flash,不建议用于其他功能.&lt;/li&gt;
&lt;li&gt;GPIO 34-39 只能设置为输入模式,没有软件上拉或下拉功能.&lt;/li&gt;
&lt;li&gt;这 34 个物理 GPIO pad 的序列号为:0-19, 21-23, 25-27, 32-39.其中 GPIO 34-39 仅用作输入管脚,其他的既可以作为输入又可以作为输出管脚.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（八）ESP32 MP3 播放器</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/11/20/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89ESP32%20MP3%20%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/11/20/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89ESP32%20MP3%20%E6%92%AD%E6%94%BE%E5%99%A8/</id>
    <published>2018-11-20T12:13:11.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP32-MP3-播放器"><a href="#ESP32-MP3-播放器" class="headerlink" title="ESP32 MP3 播放器"></a>ESP32 MP3 播放器</h1><p>源码地址：<a href="https://github.com/InfiniteYuan/esp32-MP3" target="_blank" rel="noopener">GitHub</a></p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>开发框架：<a href="https://github.com/espressif/esp-idf" target="_blank" rel="noopener">ESP-IDF</a>、<a href="https://github.com/espressif/esp-adf" target="_blank" rel="noopener">ESP-ADF</a><br>Embedded GUI: <a href="https://github.com/littlevgl/lvgl" target="_blank" rel="noopener">LittlevGL</a></p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li>ESP-IDF:<a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/index.html" target="_blank" rel="noopener">搭建步骤</a></li><li>ESP-ADF:<a href="https://docs.espressif.com/projects/esp-adf/en/latest/get-started/index.html#setup-esp-idf" target="_blank" rel="noopener">搭建步骤</a></li></ul><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><ul><li>克隆仓库</li><li>进入 esp32-MP3 目录</li><li><code>make -j8 flash</code> 编译下载</li></ul><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><ul><li><a href="https://twitter.com/InfiniteYuan/status/1063739310275350528" target="_blank" rel="noopener">Twitter Video</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP32-MP3-播放器&quot;&gt;&lt;a href=&quot;#ESP32-MP3-播放器&quot; class=&quot;headerlink&quot; title=&quot;ESP32 MP3 播放器&quot;&gt;&lt;/a&gt;ESP32 MP3 播放器&lt;/h1&gt;&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/InfiniteYuan/esp32-MP3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h2&gt;&lt;p&gt;开发框架：&lt;a href=&quot;https://github.com/espressif/esp-idf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP-IDF&lt;/a&gt;、&lt;a href=&quot;https://github.com/espressif/esp-adf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP-ADF&lt;/a&gt;&lt;br&gt;Embedded GUI: &lt;a href=&quot;https://github.com/littlevgl/lvgl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LittlevGL&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（十三）外部 RAM</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%A4%96%E9%83%A8%20RAM/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%A4%96%E9%83%A8%20RAM/</id>
    <published>2018-09-02T17:03:34.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外部-RAM"><a href="#外部-RAM" class="headerlink" title="外部 RAM"></a>外部 RAM</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ESP32 有几百 KiB 的内部 RAM，与 ESP32 的其余部分位于同一个芯片上。 出于某些目的，这是不够的，因此ESP32还能够使用高达 4MB 的外部 SPI RAM 存储器作为存储器。 外部存储器包含在存储器映射中，并且在某些限制内，可以与内部数据 RAM 相同的方式使用。</p><a id="more"></a><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>ESP32 支持与 SPI Flash 芯片并联的SPI（P）SRAM。 虽然 ESP32 能够支持多种类型的 RAM 芯片，但 ESP32 SDK 目前仅支持 ESP-PSRAM32 芯片。</p><p>ESP-PSRAM32 芯片是 1.8V 器件，只能与 1.8V 闪存器件并联使用。 确保在启动时将 MTDI 引脚设置为高信号电平，或者将 ESP32 中的保险丝编程为始终使用 1.8V 的 VDD_SIO 电平。 不这样做有损坏 PSRAM 和/或 Flash 芯片的风险。</p><p><strong>要将 ESP-PSRAM 芯片连接到 ESP32D0W *，请连接以下信号：</strong></p><ul><li>PSRAM /CE (pin 1) - ESP32 GPIO 16</li><li>PSRAM SO (pin 2) - flash DO</li><li>PSRAM SIO[2] (pin 3) - flash WP</li><li>PSRAM SI (pin 5) - flash DI</li><li>PSRAM SCLK (pin 6) - ESP32 GPIO 17</li><li>PSRAM SIO[3] (pin 7) - flash HOLD</li><li>PSRAM Vcc (pin 8) - ESP32 VCC_SDIO</li></ul><p>ESP32D2W * 芯片的连接是 TBD。</p><blockquote><p>Espressif 销售 ESP-WROVER 模块，该模块包含 ESP32,1.8V Flash 和集成在模块中的 ESP-PSRAM32，可以包含在最终产品 PCB 中。</p></blockquote><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p><strong>ESP-IDF 完全支持将外部存储器集成到您的应用程序中。 ESP-IDF 可以配置为以多种方式处理外部 RAM：</strong></p><ul><li>只初始化 RAM。 这允许应用程序通过解除指向外部 RAM 存储器区域（0x3F800000 及以上）的指针来手动放置数据。</li><li>初始化 RAM 并将其添加到功能分配器。 这允许程序使用 <code>heap_caps_malloc（size，MALLOC_CAP_SPIRAM）</code> 专门分配一块外部 RAM。 可以使用此内存，然后使用正常的 <code>free（）</code> 调用释放。</li><li>初始化 RAM，将其添加到功能分配器，并将内存添加到可由 <code>malloc（）</code> 返回的 RAM 池中。 这允许任何应用程序使用外部 RAM 而无需重写代码以使用 <code>heap_caps_malloc</code>。</li></ul><p>可以从 menuconfig 菜单中选择所有这些选项。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p><strong>使用外部 RAM 有一些限制：</strong></p><ul><li>禁用闪存缓存时（例如，因为正在写闪存），外部 RAM 也变得无法访问;对它的任何读取或写入都将导致非法的缓存访问异常。这也是 ESP-IDF 永远不会在外部 RAM 中分配任务堆栈的原因。</li><li>外部 RAM 不能用作存储 DMA 事务描述符的位置，也不能用作 DMA 传输的读取或写入缓冲区。必须使用 <code>heap_caps_malloc（size，MALLOC_CAP_DMA）</code> 分配将与 DMA 结合使用的任何缓冲区（并且可以使用标准的 <code>free（）</code> 调用释放。）</li><li>外部 RAM 使用与外部闪存相同的缓存区域。这意味着外部 RAM 中经常访问的变量几乎可以像内部 RAM 一样快速地读取和修改。但是，当访问大块数据（&gt;32K）时，缓存可能不足，速度将回落到外部 RAM 的访问速度。此外，访问大块数据可以“推出”缓存的闪存，可能会使代码执行速度变慢。</li><li>外部 RAM 不能用作任务堆栈内存;因此，<code>xTaskCreate</code> 和类似函数将始终为堆栈和任务 TCB 分配内部存储器，而 <code>xTaskCreateStatic</code> 类型函数将检查传递的缓冲区是否是内部的。但是，对于不以任何方式直接或间接调用 ROM 中的代码的任务， menuconfig 选项 <code>CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY</code> 将消除 <code>xTaskCreateStatic</code> 中的检查，从而允许外部 RAM 中的任务堆栈。但是，不建议使用此方法。</li></ul><p>因为有一些对内部存储器有特定需求的情况，但也可以使用 <code>malloc（）</code> 来耗尽内部存储器，因此有一个专门为无法从外部存储器中解析的请求而保留的池;分配任务堆栈，DMA 缓冲区和在禁用缓存时仍可访问的内存从此池中提取。此池的大小可在 menuconfig 中配置。</p><h2 id="芯片版本"><a href="#芯片版本" class="headerlink" title="芯片版本"></a>芯片版本</h2><p>ESP32 的某些修订存在一些问题，这些问题会对外部 RAM 的使用产生影响。 这些内容记录在 ESP32 ECO 文档中。 特别是， ESP-IDF 以下列方式处理提到的错误：</p><h3 id="ESP32-rev-v0"><a href="#ESP32-rev-v0" class="headerlink" title="ESP32 rev v0"></a>ESP32 rev v0</h3><p>ESP-IDF 没有针对此版本硅片中的错误的解决方法，它不能用于将外部 PSRAM 映射到 ESP32s 主存储器映射中。</p><h3 id="ESP32-rev-v1"><a href="#ESP32-rev-v1" class="headerlink" title="ESP32 rev v1"></a>ESP32 rev v1</h3><p>当某些机器指令序列在外部存储器位置 （ESP32 ECO 3.2） 上运行时，此芯片版本中的错误会带来危险。 为了解决这个问题，编译 ESP-IDF 的 gcc 编译器已经扩展了一个标志： -mfix-esp32-psram-cache-issue。 将此标志传递给命令行上的 gcc，编译器可以解决这些序列，并只输出可以安全执行的代码。</p><p>在 ESP-IDF 中，当您选择 <code>CONFIG_SPIRAM_CACHE_WORKAROUND</code> 时，将启用此标志。 ESP-IDF 还采取其他措施确保不使用 PSRAM 访问和违规指令集的组合：它链接到使用 gcc 标志重新编译的 Newlib 版本，不使用某些 ROM 函数并为 WiFi 分配静态内存叠加。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/external-ram.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;外部-RAM&quot;&gt;&lt;a href=&quot;#外部-RAM&quot; class=&quot;headerlink&quot; title=&quot;外部 RAM&quot;&gt;&lt;/a&gt;外部 RAM&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;ESP32 有几百 KiB 的内部 RAM，与 ESP32 的其余部分位于同一个芯片上。 出于某些目的，这是不够的，因此ESP32还能够使用高达 4MB 的外部 SPI RAM 存储器作为存储器。 外部存储器包含在存储器映射中，并且在某些限制内，可以与内部数据 RAM 相同的方式使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（十二）Bootloader (引导加载程序)</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89Bootloader%20(%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F)/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89Bootloader%20(%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F)/</id>
    <published>2018-09-02T16:44:58.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h1><p>引导加载程序执行以下功能：</p><ol><li>内部模块的最初初始配置;</li><li>根据分区表和 ota_data(如果有),选择要引导的应用程序分区;</li><li>将此映像加载到  RAM(IRAM 和 DRAM) 并将管理传输到它.</li></ol><p>引导加载程序位于 Flash 中的地址 0x1000.</p><a id="more"></a><h2 id="恢复出厂设置"><a href="#恢复出厂设置" class="headerlink" title="恢复出厂设置"></a>恢复出厂设置</h2><p>用户可以编写基本工作固件并将其加载到 factory 分区.接下来,通过 OTA(无线)更新固件.更新的固件将加载到 OTA 应用程序分区位置,并更新 OTA 数据分区以从此分区引导.如果您希望能够回滚到出厂固件并清除设置,则需要设置 <code>CONFIG_BOOTLOADER_FACTORY_RESET</code>.恢复出厂设置机制允许将设备重置为 factory 设置：</p><ul><li>清除一个或多个数据分区.</li><li>从 “factory” 分区启动.</li></ul><p><code>CONFIG_BOOTLOADER_DATA_FACTORY_RESET</code> 允许客户选择在执行恢复出厂设置时将擦除哪些数据分区.可以通过逗号分隔的可选空格指定分区的名称以便于阅读. (像这样：“nvs,phy_init,nvs_custom,……”).确保分区表中指定的名称和此处的名称相同.此处无法指定 “app” 类型的分区.</p><p><code>CONFIG_BOOTLOADER_OTA_DATA_ERASE</code> - 设备将在恢复出厂设置后从 “factory” 分区启动. OTA 数据分区将被清除.</p><p><code>CONFIG_BOOTLOADER_NUM_PIN_FACTORY_RESET</code> - 用于恢复出厂设置的 GPIO 输入数用于触发恢复出厂设置,此 GPIO 必须在复位时拉低以触发此操作.</p><p><code>CONFIG_BOOTLOADER_HOLD_TIME_GPIO</code> - 这是 GPIO 保持复位/测试模式的时间(默认为 5 秒).复位后,GPIO 必须在此段时间内保持低电平,然后才能执行恢复出厂设置或测试分区引导(如果适用).</p><p>分区表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,   Size, Flags</span><br><span class="line"># Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild</span><br><span class="line">nvs,      data, nvs,     0x9000,   0x4000</span><br><span class="line">otadata,  data, ota,     0xd000,   0x2000</span><br><span class="line">phy_init, data, phy,     0xf000,   0x1000</span><br><span class="line">factory,  0,    0,       0x10000,  1M</span><br><span class="line">test,     0,    test,    ,         512K</span><br><span class="line">ota_0,    0,    ota_0,   ,         512K</span><br><span class="line">ota_1,    0,    ota_1,   ,         512K</span><br></pre></td></tr></table></figure><h2 id="从-TEST-固件启动"><a href="#从-TEST-固件启动" class="headerlink" title="从 TEST 固件启动"></a>从 TEST 固件启动</h2><p>用户可以编写一个特殊的固件用于生产中的测试,并根据需要运行它. 分区表还需要一个专用分区用于此测试固件(请参阅分区表). 要触发测试应用,您需要设置 <code>CONFIG_BOOTLOADER_APP_TEST</code>.</p><p><code>CONFIG_BOOTLOADER_NUM_PIN_APP_TEST</code> - 引导TEST 分区的 GPIO 输入的编号. 选定的 GPIO 将配置为启用内部上拉的输入. 要触发测试应用程序,必须在复位时将此 GPIO 拉低. 停用 GPIO 输入并重启设备后,旧应用程序将启动(工厂或任何 OTA 位置的应用程序).</p><p><code>CONFIG_BOOTLOADER_HOLD_TIME_GPIO</code> - 这是 GPIO 的复位/测试模式保持时间(默认为 5 秒). 复位后,GPIO 必须在此段时间内保持低电平,然后才能执行恢复出厂设置或测试分区引导(如果适用).</p><h2 id="自定义引导加载程序"><a href="#自定义引导加载程序" class="headerlink" title="自定义引导加载程序"></a>自定义引导加载程序</h2><p>当前的引导加载程序实现允许客户覆盖它. 为此,您必须复制文件夹 <code>/esp-idf/components/bootloader</code>,然后编辑 <code>/your_project/components/bootloader/subproject/main/bootloader_main.c</code>. 在引导加载程序空间中,您无法使用其他组件的驱动程序和函数. 如有必要,则应将所需功能放在文件夹引导程序中(请注意,这会增加其大小). 有必要监视其大小,因为内存中可能存在覆盖层,导致损坏. 目前,引导加载程序仅限于地址 0x8000 的分区表.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/bootloader.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Bootloader&quot;&gt;&lt;a href=&quot;#Bootloader&quot; class=&quot;headerlink&quot; title=&quot;Bootloader&quot;&gt;&lt;/a&gt;Bootloader&lt;/h1&gt;&lt;p&gt;引导加载程序执行以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内部模块的最初初始配置;&lt;/li&gt;
&lt;li&gt;根据分区表和 ota_data(如果有),选择要引导的应用程序分区;&lt;/li&gt;
&lt;li&gt;将此映像加载到  RAM(IRAM 和 DRAM) 并将管理传输到它.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;引导加载程序位于 Flash 中的地址 0x1000.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（十一）高级中断</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E9%AB%98%E7%BA%A7%E4%B8%AD%E6%96%AD/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E9%AB%98%E7%BA%A7%E4%B8%AD%E6%96%AD/</id>
    <published>2018-09-02T16:29:25.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级中断"><a href="#高级中断" class="headerlink" title="高级中断"></a>高级中断</h1><p>Xtensa 架构支持 32 个中断,分为 8 个级别,以及各种异常. 在 ESP32 上,中断复用器允许使用<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/intr_alloc.html" target="_blank" rel="noopener">中断分配器</a>将大多数中断源路由到这些中断. 通常,中断将以 C 语言写入,但 ESP-IDF 也允许在汇编中写入高级中断,从而允许非常低的中断延迟.</p><a id="more"></a><h2 id="中断级别"><a href="#中断级别" class="headerlink" title="中断级别"></a>中断级别</h2><table><thead><tr><th align="center">级别</th><th align="center">标识</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">N/A</td><td align="center">异常和0级中断. 由 ESP-IDF 处理</td></tr><tr><td align="center">2-3</td><td align="center">N/A</td><td align="center">中级中断. 由 ESP-IDF 处理</td></tr><tr><td align="center">4</td><td align="center">xt_highint4</td><td align="center">通常由 ESP-IDF 调试逻辑使用</td></tr><tr><td align="center">5</td><td align="center">xt_highint4</td><td align="center">随意使用</td></tr><tr><td align="center">NMI</td><td align="center">xt_nmi</td><td align="center">随意使用</td></tr><tr><td align="center">dbg</td><td align="center">xt_debugexception</td><td align="center">调试异常. 被称为例如 BREAK 指令.</td></tr></tbody></table><p>使用这些标识是通过创建一个程序集文件(后缀 .S)并定义命名符号来完成的,如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    .section .iram1,&quot;ax&quot;</span><br><span class="line">    .global     xt_highint5</span><br><span class="line">    .type       xt_highint5,@function</span><br><span class="line">    .align      4</span><br><span class="line">xt_highint5:</span><br><span class="line">    ... your code here</span><br><span class="line">    rsr     a0, EXCSAVE_5</span><br><span class="line">    rfi     5</span><br></pre></td></tr></table></figure><p>有关实际示例,请参阅 <code>components/esp32/panic_highint_hdl.S</code> 文件; Panic 处理程序中断在那里实现.</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>不要从高级别中断调用 C 代码; 因为这些中断仍然在关键部分运行,这可能会导致崩溃. (恐慌处理程序中断会调用正常的C代码,但这没关系,因为之后无意返回正常的代码流.)</p></li><li><p>确保汇编代码被链接.如果中断处理程序符号是代码中其余代码使用的唯一符号,则链接器将采用默认的ISR,而不是将程序集文件链接到最终项目. 要解决此问题,请在汇编文件中定义符号,如下所示：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     .global ld_include_my_isr_file</span><br><span class="line">ld_include_my_isr_file:</span><br></pre></td></tr></table></figure></li></ul><p>(此符号在此处称为 <code>ld_include_my_isr_file</code>,但可以具有未在其他任何位置定义的任意名称.)然后,在 <code>component.mk</code> 中,将此文件作为未解析的符号添加到 ld 命令行参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_ADD_LDFLAGS :&#x3D; -u ld_include_my_isr_file</span><br></pre></td></tr></table></figure><p>这应该导致链接器始终包含定义 <code>ld_include_my_isr_file</code> 的文件,从而导致始终链接 ISR.</p><ul><li>可以使用 <code>esp_intr_alloc</code> 和相关函数路由和处理高级中断. 但是,<code>esp_intr_alloc</code> 的处理程序和处理程序参数必须为 NULL.</li><li>理论上,中等优先级中断也可以这种方式处理. 目前, ESP-IDF 不支持这一点.</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/hlinterrupts.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高级中断&quot;&gt;&lt;a href=&quot;#高级中断&quot; class=&quot;headerlink&quot; title=&quot;高级中断&quot;&gt;&lt;/a&gt;高级中断&lt;/h1&gt;&lt;p&gt;Xtensa 架构支持 32 个中断,分为 8 个级别,以及各种异常. 在 ESP32 上,中断复用器允许使用&lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/intr_alloc.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中断分配器&lt;/a&gt;将大多数中断源路由到这些中断. 通常,中断将以 C 语言写入,但 ESP-IDF 也允许在汇编中写入高级中断,从而允许非常低的中断延迟.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（十）线程局部存储</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8/</id>
    <published>2018-09-02T15:59:35.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>线程局部存储 (TLS) 是一种机制,通过该机制分配变量,使每个现存线程有一个变量实例. ESP-IDF 提供了三种利用这些变量的方法:</p><p><a href="#freertos-%E5%8E%9F%E7%94%9F-api">FreeRTOS 原生 API</a>: ESP-IDF FreeRTOS 原生 API.<br><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-api">多线程 API</a>:ESP-IDF 的多线程 API.<br><a href="#c11-%E6%A0%87%E5%87%86">C11 标准</a>:C11 标准引入了特殊关键字来将变量声明为线程局部.</p><a id="more"></a><h2 id="FreeRTOS-原生-API"><a href="#FreeRTOS-原生-API" class="headerlink" title="FreeRTOS 原生 API"></a>FreeRTOS 原生 API</h2><p>ESP-IDF FreeRTOS 提供以下 AP I来管理线程局部变量:</p><ul><li>vTaskSetThreadLocalStoragePointer()</li><li>pvTaskGetThreadLocalStoragePointer()</li><li>vTaskSetThreadLocalStoragePointerAndDelCallback()</li></ul><p>在这种情况下,可分配的最大变量数受 <code>configNUM_THREAD_LOCAL_STORAGE_POINTERS</code> 宏的限制. 变量保存在任务控制块 (TCB) 中,并通过索引访问. 请注意,索引 0 保留用于 ESP-IDF 内部使用. 使用该 API,用户可以分配任意大小的线程局部变量,并将它们分配给任意数量的任务. 不同的任务可以有不同的 TLS 变量集. 如果变量的大小超过 4 个字节,则用户负责为其分配/释放内存. 变量的释放由 FreeRTOS 在删除任务时启动,但用户必须提供函数(回调)才能进行适当的清理.</p><h2 id="多线程-API"><a href="#多线程-API" class="headerlink" title="多线程 API"></a>多线程 API</h2><p>ESP-IDF提供以下 多线程 API 来管理线程局部变量:</p><ul><li>pthread_key_create()</li><li>pthread_key_delete()</li><li>pthread_getspecific()</li><li>pthread_setspecific()</li></ul><p>此 API 具有上述 API 的所有优点,但消除了一些限制. 变量的数量仅受堆上可用内存大小的限制. 由于动态特性,与原生 API 相比,此 API 引入了额外的性能开销.</p><h2 id="C11-标准"><a href="#C11-标准" class="headerlink" title="C11 标准"></a>C11 标准</h2><p>ESP-IDF FreeRTOS 支持根据 C11 标准的线程局部变量(使用 <code>__thread</code> 关键字指定的变量). 有关此 GCC 功能的详细信息,请参阅<a href="https://gcc.gnu.org/onlinedocs/gcc-5.5.0/gcc/Thread-Local.html#Thread-Local" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-5.5.0/gcc/Thread-Local.html#Thread-Local</a>. 这种变量的存储在任务堆栈上分配. 请注意,程序中所有此类变量的区域将分配到系统中每个任务的堆栈上,即使该任务根本不使用此类变量也是如此. 例如, ESP-IDF 系统任务(如 <code>ipc</code>, <code>timer</code> 任务等)也将分配额外的堆栈空间. 因此应谨慎使用此功能. 有一个权衡: C11 线程局部变量在编程中非常方便,只需使用几个 Xtensa 指令即可访问,但这个好处与系统中所有任务的额外堆栈使用成本有关. 由于变量的静态性质,系统中的所有任务都具有相同的 C11 线程局部变量集.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/thread-local-storage.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程局部存储&quot;&gt;&lt;a href=&quot;#线程局部存储&quot; class=&quot;headerlink&quot; title=&quot;线程局部存储&quot;&gt;&lt;/a&gt;线程局部存储&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;线程局部存储 (TLS) 是一种机制,通过该机制分配变量,使每个现存线程有一个变量实例. ESP-IDF 提供了三种利用这些变量的方法:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#freertos-%E5%8E%9F%E7%94%9F-api&quot;&gt;FreeRTOS 原生 API&lt;/a&gt;: ESP-IDF FreeRTOS 原生 API.&lt;br&gt;&lt;a href=&quot;#%E5%A4%9A%E7%BA%BF%E7%A8%8B-api&quot;&gt;多线程 API&lt;/a&gt;:ESP-IDF 的多线程 API.&lt;br&gt;&lt;a href=&quot;#c11-%E6%A0%87%E5%87%86&quot;&gt;C11 标准&lt;/a&gt;:C11 标准引入了特殊关键字来将变量声明为线程局部.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（九）ESP-IDF FreeRTOS SMP Changes</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B9%9D%EF%BC%89ESP-IDF%20FreeRTOS%20SMP%20Changes/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B9%9D%EF%BC%89ESP-IDF%20FreeRTOS%20SMP%20Changes/</id>
    <published>2018-09-02T12:00:02.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP-IDF-FreeRTOS-SMP-Changes"><a href="#ESP-IDF-FreeRTOS-SMP-Changes" class="headerlink" title="ESP-IDF FreeRTOS SMP Changes"></a>ESP-IDF FreeRTOS SMP Changes</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>vanilla FreeRTOS 是设计运行在单核上. 但 ESP32 是双核的,包含 Protocol CPU (称为 <strong>CPU 0</strong> 或<strong>PRO_CPU</strong>)和 Application CPU (称为 <strong>CPU 1</strong> 或 <strong>APP_CPU</strong>). 这两个核实际上是相同的,并且共享相同的内存. 这允许任务在两个核之间交替运行.</p><p>ESP-IDF FreeRTOS 是 vanilla FreeRTOS 的修改版本,支持对称多处理 (SMP). ESP-IDF FreeRTOS 基于 FreeRTOS v8.2.0 的 Xtensa 端口. 本指南概述了 vanilla FreeRTOS 和 ESP-IDF FreeRTOS 之间的主要区别. 可以通过 <a href="http://www.freertos.org/a00106.html" target="_blank" rel="noopener">http://www.freertos.org/a00106.html</a> 找到 vanilla FreeRTOS 的 API 参考.</p><p>有关 ESP-IDF FreeRTOS 独有功能的信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/freertos_additions.html" target="_blank" rel="noopener">ESP-IDF FreeRTOS 附加功能</a>.</p><p><a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7">反向移植特性</a>:虽然 ESP-IDF FreeRTOS 基于 FreeRTOS v8.2.0 的 Xtensa 端口,但许多 FreeRTOS v9.0.0 功能已被移植到 ESP-IDF.</p><p><a href="#%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA">任务和任务创建</a>:使用 <code>xTaskCreatePinnedToCore()</code> 或 <code>xTaskCreateStaticPinnedToCore()</code> 在 ESP-IDF FreeRTOS 中创建任务.这两个函数的最后一个参数是 xCoreID.此参数指定任务运行在那个核上.  <strong>PRO_CPU</strong> 为 0, <strong>APP_CPU</strong> 为 1,或者 tskNO_AFFINITY 允许任务在两者上运行.</p><p>循环调度:ESP-IDF FreeRTOS 调度器将在 Ready 状态下具有相同优先级的多个任务之间实施循环调度时跳过任务.要避免此行为,请确保这些任务进入阻塞状态,或者分布在更广泛的优先级中.</p><p>挂起调度器:在 ESP-IDF 中挂起调度器 FreeRTOS 只会影响调用核上的调度器.换句话说,在 <strong>PRO_CPU</strong> 上调用 <code>vTaskSuspendAll()</code> 不会阻止 <strong>APP_CPU</strong> 进行调度,反之亦然.使用临界区或信号量代替同时访问保护.</p><p><a href="#%E6%BB%B4%E7%AD%94%E4%B8%AD%E6%96%AD%E5%90%8C%E6%AD%A5">滴答中断同步</a>:<strong>PRO_CPU</strong> 和 <strong>APP_CPU</strong> 的滴答中断不同步. 不要期望使用 <code>vTaskDelay()</code> 或 <code>vTaskDelayUntil()</code> 作为在两个核之间同步任务执行的准确方法. 使用计数信号量,因为它们的上下文切换不会因抢占而与滴答中断相关联.</p><p><a href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E7%A6%81%E7%94%A8%E4%B8%AD%E6%96%AD">临界区和禁用中断</a>:在 ESP-IDF FreeRTOS 中,临界区是使用互斥锁实现的.进入临界区涉及获取互斥锁,然后禁用调度器和调用核的中断.然而,另一个核不受影响.如果另一个核尝试使用相同的互斥锁,它将自旋直到调用核通过退出临界区释放互斥锁.</p><p><a href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97">浮点运算</a>:ESP32 支持单精度浮点运算 (<code>float</code>) 的硬件加速.然而,硬件加速的使用导致 ESP-IDF FreeRTOS 中的一些行为限制.因此,如果没有这样做,使用 float 的任务将自动固定到核.此外, float 不能用于中断服务程序.</p><p><a href="#%E4%BB%BB%E5%8A%A1%E5%88%A0%E9%99%A4">任务删除</a>:任务删除行为已从 FreeRTOS v9.0.0 反向移植并修改为 SMP 兼容.调用 <code>vTaskDelete()</code> 时,将立即释放任务内存,以删除当前未运行且未固定到其他核的任务.否则,释放任务存储器仍将被委托给空闲任务.</p><p><a href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%8C%87%E9%92%88%E5%92%8C%E5%88%A0%E9%99%A4%E5%9B%9E%E8%B0%83">线程本地存储指针和删除回调</a>:ESP-IDF FreeRTOS 已经反向移植了线程本地存储指针 (TLSP) 功能.但是,添加了删除回调的额外功能.在删除任务期间会自动调用删除回调,并用于释放 TLSP 指向的内存.调用 <code>vTaskSetThreadLocalStoragePointerAndDelCallback()</code> 来设置 TLSP 和删除回调.</p><p><a href="%E9%85%8D%E7%BD%AE-esp-idf-freertos">配置 ESP-IDF FreeRTOS</a>:可以使用 <code>make meunconfig</code> 配置 ESP-IDF FreeRTOS 的几个方面,例如在 Unicore 模式下运行 ESP-IDF,或配置每个任务将具有的线程本地存储指针的数量.</p><a id="more"></a><h2 id="反向移植特性"><a href="#反向移植特性" class="headerlink" title="反向移植特性"></a>反向移植特性</h2><p>以下功能已从 FreeRTOS v9.0.0 反向移植到 ESP-IDF.</p><h3 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h3><p>此特性已从 FreeRTOS v9.0.0 反向移植到 ESP-IDF. 必须在 menuconfig 中启用 <code>CONFIG_SUPPORT_STATIC_ALLOCATION</code> 选项才能使静态分配功能可用. 启用后,可以调用以下函数…</p><ul><li><code>xTaskCreateStatic()</code> (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li><li><code>xQueueCreateStatic</code></li><li><code>xSemaphoreCreateBinaryStatic</code></li><li><code>xSemaphoreCreateCountingStatic</code></li><li><code>xSemaphoreCreateMutexStatic</code></li><li><code>xSemaphoreCreateRecursiveMutexStatic</code></li><li><code>xTimerCreateStatic()</code> (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li><li><code>xEventGroupCreateStatic()</code></li></ul><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li><code>vTaskSetThreadLocalStoragePointer()</code>  (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li><li><code>pvTaskGetThreadLocalStoragePointer()</code>  (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li><li><code>vTimerSetTimerID()</code></li><li><code>xTimerGetPeriod()</code></li><li><code>xTimerGetExpiryTime()</code></li><li><code>pcQueueGetName()</code></li><li><code>uxSemaphoreGetCount</code></li></ul><h3 id="反向移植记录"><a href="#反向移植记录" class="headerlink" title="反向移植记录"></a>反向移植记录</h3><ol><li><code>xTaskCreateStatic()</code> 以与 <code>xTaskCreate()</code> 类似的方式与 SMP 兼容(请参阅<a href="#%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA">任务和任务创建</a>). 因此也可以调用 <code>xTaskCreateStaticPinnedToCore()</code>.</li><li>尽管 vanilla FreeRTOS 允许静态分配 Timer 功能的守护进程任务,但守护进程任务总是在 ESP-IDF 中动态分配. 因此,在 ESP-IDF FreeRTOS 中使用静态分配的计时器时,不需要定义 <code>vApplicationGetTimerTaskMemory</code>.</li><li>在 ESP-IDF FreeRTOS 中修改了线程本地存储指针功能,以包括删除回调(请参阅<a href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%8C%87%E9%92%88%E5%92%8C%E5%88%A0%E9%99%A4%E5%9B%9E%E8%B0%83">线程本地存储指针和删除回调</a>). 因此,也可以调用函数 <code>vTaskSetThreadLocalStoragePointerAndDelCallback()</code>.</li></ol><h2 id="任务和任务创建"><a href="#任务和任务创建" class="headerlink" title="任务和任务创建"></a>任务和任务创建</h2><p>ESP-IDF FreeRTOS 中的任务设计为在特定核上运行,因此通过将 <code>PinnedToCore</code> 附加到 vanilla FreeRTOS 中的任务创建功能的名称,ESP-IDF FreeRTOS 中添加了两个新的任务创建功能. <code>xTaskCreate()</code> 和 <code>xTaskCreateStatic()</code> 的 vanilla FreeRTOS 函数导致在 ESP-IDF FreeRTOS 中添加了 <code>xTaskCreatePinnedToCore()</code> 和 <code>xTaskCreateStaticPinnedToCore()</code> (参见<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7">反向移植特性</a>).</p><p>有关更多详细信息,请参阅 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/freertos/task.c" target="_blank" rel="noopener">freertos/task.c</a></p><p>除了称为 <code>xCoreID</code> 的额外参数外,ESP-IDF FreeRTOS 任务创建功能几乎与它们的vanilla对应物相同. 此参数指定应在其上运行任务的核,并且可以是以下值之一.</p><ul><li><code>0</code> 将任务固定在 <strong>PRO_CPU</strong> 上运行</li><li><code>1</code> 将任务固定在 <strong>APP_CPU</strong> 上运行</li><li><code>tskNO_AFFINITY</code>允许在两个 CPU 上运行任务</li></ul><p>例如,<code>xTaskCreatePinnedToCore(tsk_callback,“APP_CPU Task”,1000,NULL,10,NULL,1)</code> 创建优先级为 10 的任务,该堆栈大小为 1000 字节运行在 <strong>APP_CPU</strong> 上. 应该注意的是,vanilla FreeRTOS 中的 <code>uxStackDepth</code> 参数根据字数指定任务的堆栈深度,而 ESP-IDF FreeRTOS 以字节的形式指定堆栈深度.</p><p>请注意,vanilla FreeRTOS函数 <code>xTaskCreate()</code> 和 <code>xTaskCreateStatic()</code> 已在 ESP-IDF FreeRTOS 中定义为内联函数,它们分别使用 tskNO_AFFINITY 作为 xCoreID 值调用 <code>xTaskCreatePinnedToCore()</code> 和 <code>xTaskCreateStaticPinnedToCore()</code>.</p><p>ESP-IDF 中的每个任务控制块 (TCB) 将 <code>xCoreID</code> 存储为成员. 因此,当每个核调用调度器选择要运行的任务时,<code>xCoreID</code> 成员将允许调度器确定是否允许让任务在调用调度器的核上运行.</p><h2 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h2><p>vanilla FreeRTOS 在 <code>vTaskSwitchContext()</code> 函数中实现调度. 此函数负责从处于就绪状态的任务列表中选择要执行的最高优先级任务,称为就绪任务列表(将在下一节中介绍). 在 ESP-IDF FreeRTOS 中,每个核将独立调用 <code>vTaskSwitchContext()</code>以从两个核之间共享的就绪任务列表中选择要运行的任务. vanilla 和 ESP-IDF FreeRTOS 之间的调度行为存在一些差异,例如 循环调度调度,调度程序暂停和滴答中断同步的差异.</p><h3 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h3><p>鉴于 Ready 状态和优先级相同的多个任务,vanilla FreeRTOS 在每个任务之间实现循环调度. 这将导致每次调用调度程序时轮流运行这些任务(例如每个滴答中断). 另一方面,当循环调度具有相同优先级的多个 Ready 状态任务时,ESP-IDF FreeRTOS 调度器可以跳过任务.</p><p>循环调度期间跳过任务的问题源于在 FreeRTOS 中实现就绪任务列表的方式. 在 vanilla FreeRTOS 中,<code>pxReadyTasksList</code> 用于存储处于 Ready 状态的任务列表. 该列表实现为长度为 <code>configMAX_PRIORITIES</code> 的数组,其中数组的每个元素都是链表. 每个链表都是 <code>List_t</code> 类型,并包含处于 Ready 状态的相同优先级任务的 TCB. 下图说明了 <code>pxReadyTasksList</code> 结构.</p><p><img src="https://img-blog.csdn.net/20180902140458206?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="pxReadyTasksList"><br> <center> Illustration of FreeRTOS Ready Task List Data Structure</center></p><p>每个链表还包含一个 <code>pxIndex</code>,它指向查询列表时返回的最后一个 TCB. 该索引允许 <code>vTaskSwitchContext()</code> 在 <code>pxIndex</code> 之后立即开始遍历 TCB 上的列表,从而在相同优先级的任务之间实现循环调度.</p><p>在 ESP-IDF FreeRTOS 中,就绪任务列表在核之间共享,因此 <code>pxReadyTasksList</code> 将包含固定到不同核的任务. 当核调用调度程序时,它能够查看列表中每个 TCB 的 <code>xCoreID</code> 成员,以确定是否允许在调用调度程序的核上运行该任务. ESP-IDF FreeRTOS <code>pxReadyTasksList</code> 如下图所示.</p><p><img src="https://img-blog.csdn.net/20180902140927284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Illustration of FreeRTOS Ready Task List Data Structure in ESP-IDF"><br> <center> Illustration of FreeRTOS Ready Task List Data Structure in ESP-IDF </center> </p><p>因此,当 <strong>PRO_CPU</strong> 调用调度程序时,它只会将任务视为蓝色或紫色. 而当 <strong>APP_CPU</strong> 调用调度程序时,它只会考虑橙色或紫色的任务.</p><p>虽然每个 TCB 在 ESP-IDF FreeRTOS 中都有一个 <code>xCoreID</code>,但每个优先级的链表只有一个 <code>pxIndex</code>. 因此,当从特定核调用调度程序并遍历链接列表时,它将跳过固定到另一个核的所有 TCB,并将 <code>pxIndex</code> 指向所选任务. 如果另一个核接着调用调度程序,它将在 <code>pxIndex</code> 之后立即遍历从 TCB 开始的链表. 因此,<strong>在当前调度程序调用中不会考虑从由其他核先前调用调度程序跳过的 TCB</strong>. 下图说明了此问题.</p><p><img src="https://img-blog.csdn.net/20180902141125129?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Illustration of pxIndex behavior in ESP-IDF FreeRTOS"><br> <center>Illustration of pxIndex behavior in ESP-IDF FreeRTOS </center></p><p>参考上面的图示,假设优先级 9 是最高优先级,并且优先级9中的任何任务都不会被阻塞,因此将始终处于运行或就绪状态.</p><ol><li><strong>PRO_CPU</strong> 调用调度程序并选择要运行的任务 A,因此将 <code>pxIndex</code> 移动到指向任务 A.</li><li><strong>APP_CPU</strong> 调用调度程序并在作为任务 B 的 <code>pxIndex</code> 之后开始遍历任务.但是没有选择任务 B 运行,因为它没有固定到 <strong>APP_CPU</strong> 因此它被跳过并且选择了任务 C.  <code>pxIndex</code> 现在指向任务 C.</li><li><strong>PRO_CPU</strong> 调用调度程序并开始从任务 D 开始遍历.它跳过任务 D 并选择任务 E 运行并将 <code>pxIndex</code> 指向任务 E.请注意,任务 B 未被遍历,因为最后一次 <strong>APP_CPU</strong> 调用调度程序时它被跳过遍历清单.</li><li>如果 <strong>APP_CPU</strong> 再次调用调度程序,则会发生与任务 D 相同的情况,因为 <code>pxIndex</code> 现在指向任务E</li></ol><p>任务跳过问题的一个解决方案是确保每个任务都进入阻塞状态,以便从就绪任务列表中删除它们.另一种解决方案是跨多个优先级分配任务,以便不给予给定优先级多个固定到不同核的任务.</p><h3 id="挂起调度器"><a href="#挂起调度器" class="headerlink" title="挂起调度器"></a>挂起调度器</h3><p>在 vanilla FreeRTOS 中,通过 <code>vTaskSuspendAll()</code> 挂起调度程序将阻止 <code>vTaskSwitchContext</code> 从上下文切换调用,直到调度程序已使用 <code>xTaskResumeAll()</code> 恢复.但是仍然允许为 ISR 提供服务.因此,在恢复调度程序之前,将不会执行由当前正在运行的任务或 ISRS 导致的任务状态的任何更改. vanilla FreeRTOS 中的调度程序暂停是一种常见的保护方法,可以同时访问任务之间共享的数据,同时仍允许对 ISR 进行服务.</p><p>在 ESP-IDF FreeRTOS 中,<code>xTaskResumeAll()</code> 只会阻止调用 <code>vTaskSwitchContext()</code> 来切换调用挂起的核上下文.因此,如果 <strong>PRO_CPU</strong> 调用 <code>vTaskSuspendAll()</code>, <strong>APP_CPU</strong> 仍然可以切换上下文.如果数据在固定到不同核的任务之间共享,则调度程序暂停不是防止同时访问的有效方法.在保护 ESP-IDF FreeRTOS 中的共享资源时,请考虑使用关键部分(禁用中断)或信号量(不禁用中断).</p><p>通常,最好使用其他 RTOS 原语(如互斥信号量)来防止任务之间共享的数据,而不是 <code>vTaskSuspendAll()</code>.</p><h3 id="滴答中断同步"><a href="#滴答中断同步" class="headerlink" title="滴答中断同步"></a>滴答中断同步</h3><p>在 ESP-IDF FreeRTOS 中,由于来自每个核的调度程序调用是独立的,因此在相同的滴答计数上取消阻塞的不同核上的任务可能不会在完全相同的时间运行,并且每个核的滴答中断是不同步的.</p><p>在 vanilla FreeRTOS 中,滴答中断触发对 <code>xTaskIncrementTick()</code> 的调用,该调用负责增加滴答计数器,检查调用 <code>vTaskDelay()</code> 的任务是否已经完成延迟时间,并将这些任务从 Delayed Task List 移动​​到 Ready Task 名单.如果需要上下文切换,则滴答中断将调用调度程序.</p><p>在 ESP-IDF FreeRTOS 中,由于 <strong>PRO_CPU</strong> 负责增加共享滴答计数,因此参考 <strong>PRO_CPU</strong> 上的滴答中断来解除延迟任务的阻塞.但是,每个核的滴答中断可能不会同步(频率相同但异相),因此当 <strong>PRO_CPU</strong> 收到滴答中断时, <strong>APP_CPU</strong> 可能尚未收到它.因此,如果相同优先级的多个任务在相同的滴答计数上被解除阻塞,则固定到 <strong>PRO_CPU</strong> 的任务将立即运行,而固定到 <strong>APP_CPU</strong> 的任务必须等到 <strong>APP_CPU</strong> 收到其不同步滴答中断.收到滴答中断后, <strong>APP_CPU</strong> 将调用上下文切换,最后将上下文切换到新解锁的任务.</p><p>因此,不应将任务延迟用作 ESP-IDF FreeRTOS 中任务之间的同步方法.相反,请考虑使用计数信号量同时取消阻止多个任务.</p><h2 id="临界区和禁用中断"><a href="#临界区和禁用中断" class="headerlink" title="临界区和禁用中断"></a>临界区和禁用中断</h2><p>Vanilla FreeRTOS 在 <code>vTaskEnterCritical</code> 中实现了关键部分,它们禁用调度程序并调用 <code>portDISABLE_INTERRUPTS</code>.这可以防止在关键部分中进行上下文切换和ISR服务.因此,关键部分被用作防止 vanilla FreeRTOS 同时访问的有效保护方法.</p><p>另一方面, ESP32 没有内核的硬件方法来禁用彼此的中断.调用 <code>portDISABLE_INTERRUPTS()</code> 对其他内核的中断没有影响.因此,禁用中断不是防止同时访问共享数据的有效保护方法,因为即使当前内核已禁用其自身的中断,它也会使其他内核可以自由访问数据.</p><p>因此, ESP-IDF FreeRTOS 使用互斥锁实现关键部分,进入或退出关键部分的调用必须提供与需要访问保护的共享资源相关联的互斥锁.当进入 ESP-IDF FreeRTOS 中的关键部分时,调用内核将禁用其调度程序和中断,类似于 vanilla FreeRTOS 实现.但是,调用核也将使用互斥锁,而另一个核在关键部分不受影响.如果另一个核尝试使用相同的互斥锁,它将旋转直到释放互斥锁.因此,关键部分的 ESP-IDF FreeRTOS 实现允许核具有对共享资源的受保护访问,而不会禁用其他核.另一个核只有在尝试同时访问同一资源时才会受到影响.</p><p>ESP-IDF FreeRTOS 关键部分功能已经修改如下……</p><ul><li><code>taskENTER_CRITICAL(mux)</code>,<code>taskENTER_CRITICAL_ISR(mux)</code>,<code>portENTER_CRITICAL(mux)</code>,<code>portENTER_CRITICAL_ISR(mux)</code> 都是宏定义来调用 <code>vTaskEnterCritical()</code></li><li><code>taskEXIT_CRITICAL(mux)</code>,<code>taskEXIT_CRITICAL_ISR(mux)</code>,<code>portEXIT_CRITICAL(mux)</code>,<code>portEXIT_CRITICAL_ISR(mux)</code> 都是宏定义来调用 <code>vTaskExitCritical()</code></li></ul><p>有关更多详细信息,请参阅 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/freertos/include/freertos/portmacro.h" target="_blank" rel="noopener">freertos/include/freertos/portmacro.h</a> 和 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/freertos/task.c" target="_blank" rel="noopener">freertos/task.c</a></p><p>应该注意的是,当修改 vanilla FreeRTOS 代码与 ESP-IDF FreeRTOS 兼容时,修改关键部分的类型是微不足道的,因为它们都被定义为调用相同的函数.只要在进入和退出时提供相同的互斥锁,呼叫类型就无关紧要了.</p><h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><p>ESP32 通过连接到每个内核的浮点单元 (FPU,也称为协处理器)支持单精度浮点运算 (<code>float</code>) 的硬件加速.使用 FPU 对 ESP-IDF FreeRTOS 施加了一些行为限制.</p><p>ESP-IDF FreeRTOS 为 FPU 实现了延迟上下文切换.换句话说,当发生上下文切换时,不会立即保存核心 FPU 寄存器的状态.因此,利用 <code>float</code> 的任务必须在创建时固定到特定的核心.如果没有, ESP-IDF FreeRTOS 会自动将有问题的任务固定到任务首次使用 <code>float</code> 任务的任何核心上.同样由于惰性上下文切换,中断服务例程也必须不使用 <code>float</code>.</p><p>ESP32 不支持双精度浮点运算 (<code>double</code>) 的硬件加速.相反, <code>double</code> 是通过软件实现的,因此关于 <code>float</code> 的行为限制不适用于 <code>double</code>.请注意,由于缺少硬件加速,与 <code>float</code> 相比,双重操作可能会消耗更多的 CPU 时间.</p><h2 id="任务删除"><a href="#任务删除" class="headerlink" title="任务删除"></a>任务删除</h2><p>在 v9.0.0 之前删除 FreeRTOS 任务将任务内存的释放完全委托给空闲任务. 目前,如果正在删除的任务当前没有运行或没有固定到另一个核心(相对于核心 <code>vTaskDelete()</code> 被调用),任务内存的释放将立即发生(在 <code>vTaskDelete()</code> 内). 如果满足相同的条件,TLSP删除回调也将立即运行.</p><p>但是,调用 <code>vTaskDelete()</code> 来删除当前正在运行或固定到另一个核心的任务仍将导致释放被委派给空闲任务的内存.</p><h2 id="线程本地存储指针和删除回调"><a href="#线程本地存储指针和删除回调" class="headerlink" title="线程本地存储指针和删除回调"></a>线程本地存储指针和删除回调</h2><p>线程本地存储指针 (TLSP) 是直接存储在 TCB 中的指针. TLSP 允许每个任务拥有自己唯一的数据结构指针集.但是, vanilla FreeRTOS 中的任务删除行为不会自动释放 TLSP 指向的内存.因此,如果在删除任务之前用户未明确释放 TLSP 指向的内存,则会发生内存泄漏.</p><p>ESP-IDF FreeRTOS 提供了 Deletion Callbacks 的附加功能.删除任务删除期间自动调用回调以释放 TLSP 指向的内存.每个 TLSP 都可以拥有自己的 Deletion Callback.请注意,由于 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/freertos-smp.html#task-deletion" target="_blank" rel="noopener">Task Deletion</a> 行为,可能存在在空闲任务的上下文中调用 Deletion Callbacks 的实例.因此,删除回调不应该试图阻止,并且关键部分应该尽可能短,以最小化优先级倒置.</p><p>删除回调的类型为 <code>void(* TlsDeleteCallbackFunction_t)(int,void *)</code>,其中第一个参数是关联 TLSP 的索引号,第二个参数是 TLSP 本身.</p><p>通过调用 <code>vTaskSetThreadLocalStoragePointerAndDelCallback()</code> 将删除回调与 TLSP 一起设置.调用 vanilla FreeRTOS 函数 <code>vTaskSetThreadLocalStoragePointer()</code> 只会将 TLSP 关联的 Deletion Callback 设置为 NULL,这意味着在删除任务期间不会为该 TLSP 调用回调.如果删除回调为 NULL,则用户应在删除任务之前手动释放相关 TLSP 指向的内存,以避免内存泄漏.</p><p>menuconfig 中的 <code>CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS</code> 可用于配置TCB将具有的 TLSP 和删除回调数.</p><p>有关更多详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/freertos.html" target="_blank" rel="noopener">FreeRTOS API 参考</a>.</p><h2 id="配置-ESP-IDF-FreeRTOS"><a href="#配置-ESP-IDF-FreeRTOS" class="headerlink" title="配置 ESP-IDF FreeRTOS"></a>配置 ESP-IDF FreeRTOS</h2><p>可以使用 <code>Component_Config/FreeRTOS</code> 下的 <code>make menuconfig</code> 配置 ESP-IDF FreeRTOS. 以下部分重点介绍了一些 ESP-IDF FreeRTOS 配置选项.有关 ESP-IDF FreeRTOS 配置的完整列表,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/kconfig.html" target="_blank" rel="noopener">FreeRTOS</a></p><p><code>CONFIG_FREERTOS_UNICORE</code> 将仅在 <strong>PRO_CPU</strong> 上运行 ESP-IDF FreeRTOS.请注意,这不等于运行 vanilla FreeRTOS.将修改 ESP-IDF 中多个组件的行为,例如 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/esp32/cpu_start.c" target="_blank" rel="noopener">esp32/cpu_start.c</a>.有关在单核上运行 ESP-IDF FreeRTOS 的效果的更多详细信息,请在 ESP-IDF 组件中搜索 <code>CONFIG_FREERTOS_UNICORE</code> 的出现.</p><p><code>CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS</code> 将定义每个任务在 ESP-IDF FreeRTOS 中将具有的线程本地存储指针的数量.</p><p><code>CONFIG_SUPPORT_STATIC_ALLOCATION</code> 将在 ESP-IDF FreeRTOS 中启用 <code>xTaskCreateStaticPinnedToCore()</code> 的反向移植功能</p><p><code>CONFIG_FREERTOS_ASSERT_ON_UNTESTED_FUNCTION</code> 将触发 ESP-IDF FreeRTOS 中特定功能的暂停,这些功能尚未在 SMP 上下文中进行全面测试.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/freertos-smp.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP-IDF-FreeRTOS-SMP-Changes&quot;&gt;&lt;a href=&quot;#ESP-IDF-FreeRTOS-SMP-Changes&quot; class=&quot;headerlink&quot; title=&quot;ESP-IDF FreeRTOS SMP Changes&quot;&gt;&lt;/a&gt;ESP-IDF FreeRTOS SMP Changes&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;vanilla FreeRTOS 是设计运行在单核上. 但 ESP32 是双核的,包含 Protocol CPU (称为 &lt;strong&gt;CPU 0&lt;/strong&gt; 或&lt;strong&gt;PRO_CPU&lt;/strong&gt;)和 Application CPU (称为 &lt;strong&gt;CPU 1&lt;/strong&gt; 或 &lt;strong&gt;APP_CPU&lt;/strong&gt;). 这两个核实际上是相同的,并且共享相同的内存. 这允许任务在两个核之间交替运行.&lt;/p&gt;
&lt;p&gt;ESP-IDF FreeRTOS 是 vanilla FreeRTOS 的修改版本,支持对称多处理 (SMP). ESP-IDF FreeRTOS 基于 FreeRTOS v8.2.0 的 Xtensa 端口. 本指南概述了 vanilla FreeRTOS 和 ESP-IDF FreeRTOS 之间的主要区别. 可以通过 &lt;a href=&quot;http://www.freertos.org/a00106.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.freertos.org/a00106.html&lt;/a&gt; 找到 vanilla FreeRTOS 的 API 参考.&lt;/p&gt;
&lt;p&gt;有关 ESP-IDF FreeRTOS 独有功能的信息,请参阅 &lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/freertos_additions.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP-IDF FreeRTOS 附加功能&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7&quot;&gt;反向移植特性&lt;/a&gt;:虽然 ESP-IDF FreeRTOS 基于 FreeRTOS v8.2.0 的 Xtensa 端口,但许多 FreeRTOS v9.0.0 功能已被移植到 ESP-IDF.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA&quot;&gt;任务和任务创建&lt;/a&gt;:使用 &lt;code&gt;xTaskCreatePinnedToCore()&lt;/code&gt; 或 &lt;code&gt;xTaskCreateStaticPinnedToCore()&lt;/code&gt; 在 ESP-IDF FreeRTOS 中创建任务.这两个函数的最后一个参数是 xCoreID.此参数指定任务运行在那个核上.  &lt;strong&gt;PRO_CPU&lt;/strong&gt; 为 0, &lt;strong&gt;APP_CPU&lt;/strong&gt; 为 1,或者 tskNO_AFFINITY 允许任务在两者上运行.&lt;/p&gt;
&lt;p&gt;循环调度:ESP-IDF FreeRTOS 调度器将在 Ready 状态下具有相同优先级的多个任务之间实施循环调度时跳过任务.要避免此行为,请确保这些任务进入阻塞状态,或者分布在更广泛的优先级中.&lt;/p&gt;
&lt;p&gt;挂起调度器:在 ESP-IDF 中挂起调度器 FreeRTOS 只会影响调用核上的调度器.换句话说,在 &lt;strong&gt;PRO_CPU&lt;/strong&gt; 上调用 &lt;code&gt;vTaskSuspendAll()&lt;/code&gt; 不会阻止 &lt;strong&gt;APP_CPU&lt;/strong&gt; 进行调度,反之亦然.使用临界区或信号量代替同时访问保护.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#%E6%BB%B4%E7%AD%94%E4%B8%AD%E6%96%AD%E5%90%8C%E6%AD%A5&quot;&gt;滴答中断同步&lt;/a&gt;:&lt;strong&gt;PRO_CPU&lt;/strong&gt; 和 &lt;strong&gt;APP_CPU&lt;/strong&gt; 的滴答中断不同步. 不要期望使用 &lt;code&gt;vTaskDelay()&lt;/code&gt; 或 &lt;code&gt;vTaskDelayUntil()&lt;/code&gt; 作为在两个核之间同步任务执行的准确方法. 使用计数信号量,因为它们的上下文切换不会因抢占而与滴答中断相关联.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E7%A6%81%E7%94%A8%E4%B8%AD%E6%96%AD&quot;&gt;临界区和禁用中断&lt;/a&gt;:在 ESP-IDF FreeRTOS 中,临界区是使用互斥锁实现的.进入临界区涉及获取互斥锁,然后禁用调度器和调用核的中断.然而,另一个核不受影响.如果另一个核尝试使用相同的互斥锁,它将自旋直到调用核通过退出临界区释放互斥锁.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97&quot;&gt;浮点运算&lt;/a&gt;:ESP32 支持单精度浮点运算 (&lt;code&gt;float&lt;/code&gt;) 的硬件加速.然而,硬件加速的使用导致 ESP-IDF FreeRTOS 中的一些行为限制.因此,如果没有这样做,使用 float 的任务将自动固定到核.此外, float 不能用于中断服务程序.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#%E4%BB%BB%E5%8A%A1%E5%88%A0%E9%99%A4&quot;&gt;任务删除&lt;/a&gt;:任务删除行为已从 FreeRTOS v9.0.0 反向移植并修改为 SMP 兼容.调用 &lt;code&gt;vTaskDelete()&lt;/code&gt; 时,将立即释放任务内存,以删除当前未运行且未固定到其他核的任务.否则,释放任务存储器仍将被委托给空闲任务.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%8C%87%E9%92%88%E5%92%8C%E5%88%A0%E9%99%A4%E5%9B%9E%E8%B0%83&quot;&gt;线程本地存储指针和删除回调&lt;/a&gt;:ESP-IDF FreeRTOS 已经反向移植了线程本地存储指针 (TLSP) 功能.但是,添加了删除回调的额外功能.在删除任务期间会自动调用删除回调,并用于释放 TLSP 指向的内存.调用 &lt;code&gt;vTaskSetThreadLocalStoragePointerAndDelCallback()&lt;/code&gt; 来设置 TLSP 和删除回调.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;%E9%85%8D%E7%BD%AE-esp-idf-freertos&quot;&gt;配置 ESP-IDF FreeRTOS&lt;/a&gt;:可以使用 &lt;code&gt;make meunconfig&lt;/code&gt; 配置 ESP-IDF FreeRTOS 的几个方面,例如在 Unicore 模式下运行 ESP-IDF,或配置每个任务将具有的线程本地存储指针的数量.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（八）Flash 加密</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%AB%EF%BC%89Flash%20%E5%8A%A0%E5%AF%86/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%AB%EF%BC%89Flash%20%E5%8A%A0%E5%AF%86/</id>
    <published>2018-09-02T00:13:51.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flash-加密"><a href="#Flash-加密" class="headerlink" title="Flash 加密"></a>Flash 加密</h1><p>Flash 加密功能用于加密 ESP32 连接的 SPI  Flash 的内容。启用 Flash 加密后，通过物理方式读取 SPI Flash 的内容不足以恢复大多数 Flash 内容。</p><p>Flash 加密与安全启动功能是分离的，您可以使用 Flash 加密而无需启用<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html" target="_blank" rel="noopener">安全启动</a>。但是，我们建议将这两种功能一起用于安全的环境。在没有安全启动的情况下，需要执行其他配置以确保 Flash 加密的有效性。有关更多详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-without-secure-boot" target="_blank" rel="noopener">使用无安全启动的 Flash 加密</a>.</p><blockquote><p>启用闪存加密会限制您进一步更新 ESP32 的选项。请务必阅读本文档(包括 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-limitations" target="_blank" rel="noopener">Flash 加密限制</a>)并了解启用闪存加密的含义。</p></blockquote><a id="more"></a><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><ul><li><p>使用带有 256 位密钥的 AES 加密闪存的内容。闪存加密密钥存储在芯片内部的 efuse 中，并且(默认情况下)受软件访问保护。</p></li><li><p>通过 ESP32 的闪存缓存映射功能，Flash 访问是透明的 - 映射到地址空间的任何闪存区域在读取时都将被透明地解密。</p></li><li><p>通过使用明文数据烧录 ESP32 来应用加密，并且(如果启用了加密)引导加载程序会在首次启动时对数据进行加密。</p></li><li><p>并非所有闪存都是加密的。以下类型的闪存数据已加密:</p><ul><li><p>引导程序</p></li><li><p>安全启动引导加载程序摘要(如果启用了安全启动)</p></li><li><p>分区表</p></li><li><p>所有 “app” 类型分区</p></li><li><p>分区表中标有 “encrypted” 标志的任何分区</p><p> 可能希望一些数据分区保持未加密以便于访问，或者使用对于数据被加密时无效的闪存友好更新算法。由于 NVS 库与闪存加密不直接兼容，因此无法加密用于非易失性存储的 NVS 分区。有关更多详细信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html#nvs-encryption" target="_blank" rel="noopener">NVS 加密</a>。</p></li></ul></li><li><p>闪存加密密钥存储在 ESP32 芯片内部的 efuse 密钥块 1 中。默认情况下，此密钥具有读写保护功能，因此软件无法访问或更改密钥。</p></li><li><p>默认情况下，Efuse Block 1 编码方案为 “None”，并且在该块中存储 256 位密钥。在某些 ESP32 上，编码方案设置为 3/4 编码 (CODING_SCHEME efuse 的值为 1)，并且必须在该块中存储 192 位密钥。有关详细信息，请参见 《ESP32 技术参考手册》第 20.3.1.3 节 “系统参数 coding_scheme”。在所有情况下，算法都在 256 位密钥上运行，通过重复一些位（<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-algorithm" target="_blank" rel="noopener">具体细节</a>）来扩展  192 位密钥。当 <code>esptool.py</code> 连接到芯片或 <code>espefuse.py summary</code> 输出时，编码方案显示在 Features 行中。</p></li><li><p>闪存加密算法是 AES-256，其中密钥是“调整”的，每个 32 字节闪存块的偏移地址。这意味着每个 32 字节块(两个连续的 16 字节 AES 块)使用从闪存加密密钥派生的唯一密钥进行加密。</p></li><li><p>虽然芯片上运行的软件可以透明地解密闪存内容，但默认情况下，当启用闪存加密时，UART 引导加载程序无法解密(或加密)数据。</p></li><li><p>如果可以启用闪存加密，则编写<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#using-encrypted-flash" target="_blank" rel="noopener">使用加密闪存</a>的代码时，编程人员必须采取一定的预防措施。</p></li></ul><h2 id="2-Flash-加密初始化"><a href="#2-Flash-加密初始化" class="headerlink" title="2 Flash 加密初始化"></a>2 Flash 加密初始化</h2><p>这是默认(推荐) Flash 加密初始化过程。可以为开发或其他目的自定义此过程，有关详细信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-advanced-features" target="_blank" rel="noopener">Flash 加密高级功能</a>。</p><blockquote><p>在首次启动时启用闪存加密后，硬件通过串行重新闪存最多允许3次后续闪存烧录。必须遵循特殊过程(在<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#updating-encrypted-flash-serial" target="_blank" rel="noopener">串口烧录</a>中记录)才能执行这些更新。</p></blockquote><ul><li>如果启用了安全启动，则使用纯文本数据进行物理重新刷新需要“可重新映射”的安全启动摘要(请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-and-secure-boot" target="_blank" rel="noopener">Flash 加密和安全启动</a>)。</li><li>OTA 更新可用于更新 Flash 内容，而不计入此限制。</li><li>在开发中启用闪存加密时，请使用预生成的闪存加密密钥，以允许使用预加密数据进行无限次重新闪存。</li></ul><p>启用闪存加密的过程:</p><ul><li>必须在启用闪存加密支持的情况下编译引导加载程序。在 <code>make menuconfig</code> 中，导航到“安全功能”，然后选择“是”以“启动时启用闪存加密”。</li><li>如果同时启用安全启动，最好同时选择这些选项。首先阅读<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html" target="_blank" rel="noopener">安全启动</a>文档。</li><li>正常构建并刷新引导加载程序，分区表和工厂应用程序映像。这些分区最初写入未加密的闪存。</li></ul><blockquote><p>启用安全启动和闪存加密时，引导加载程序应用程序二进制 <code>bootloader.bin</code> 可能会变得太大。请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html#secure-boot-bootloader-size" target="_blank" rel="noopener">Bootloader 大小</a>。</p></blockquote><ul><li>首次启动时，引导加载程序会看到 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 设置为 0 (出厂默认值)，因此它使用硬件随机数生成器生成闪存加密密钥。该密钥存储在efuse中。密钥是读写保护，以防止进一步的软件访问。</li><li>然后，引导加载程序就地对所有加密分区进行加密。就地加密可能需要一些时间(对于大型分区，最多需要一分钟.)</li></ul><blockquote><p>第一次启动加密通道运行时，请勿中断ESP32的电源。如果电源中断，闪存内容将被破坏，并且需要再次使用未加密的数据烧录。像这样的重新烧录不会计入烧录限制。</p></blockquote><ul><li>烧录完成后。在 UART 引导加载程序运行时，激活(默认情况下)以禁用加密的闪存访问。有关高级详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#uart-bootloader-encryption" target="_blank" rel="noopener">启用 UART Bootloader 加密/解密</a>。</li><li><code>FLASH_CRYPT_CONFIG efuse</code> 也会被烧制到最大值(0xF)，以最大化闪存算法中调整的关键位数。有关高级详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#setting-flash-crypt-config" target="_blank" rel="noopener">设置 FLASH_CRYPT_CONFIG</a>。</li><li>最后，<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 以初始值 1 进行刻录。这个 efuse 激活透明闪存加密层，并限制后续重新刷新的次数。有关 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 的详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#updating-encrypted-flash" target="_blank" rel="noopener">更新加密的 Flash</a> 部分。</li><li>引导加载程序重置自身以重新加密的闪存重新引导。</li></ul><h2 id="3-使用加密的-Flash"><a href="#3-使用加密的-Flash" class="headerlink" title="3 使用加密的 Flash"></a>3 使用加密的 Flash</h2><p>ESP32 应用程序代码可以通过调用 <code>esp_flash_encryption_enabled()</code> 来检查当前是否启用了闪存加密。</p><p>启用闪存加密后，从代码访问闪存内容时需要注意一些事项。</p><h3 id="3-1-Flash-加密的范围"><a href="#3-1-Flash-加密的范围" class="headerlink" title="3.1 Flash 加密的范围"></a>3.1 Flash 加密的范围</h3><p>只要将 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 设置为设置了奇数位的值，就会透明地解密通过 MMU 的闪存缓存访问的所有闪存内容。这包括:</p><ul><li>Flash 中的可执行应用程序代码 (IROM)。</li><li>存储在闪存 (DROM) 中的所有只读数据。</li><li>通过 <code>esp_spi_flash_mmap()</code> 访问的任何数据。</li><li>ROM 引导加载程序读取软件引导加载程序映像。</li></ul><blockquote><p>MMU Flash 缓存无条件地解密所有数据。在闪存中未加密存储的数据将通过闪存缓存“透明地解密”，并且看起来像随机垃圾这样的软件。</p></blockquote><h3 id="3-2-读取加密的-Flash"><a href="#3-2-读取加密的-Flash" class="headerlink" title="3.2 读取加密的 Flash"></a>3.2 读取加密的 Flash</h3><p>要在不使用闪存缓存 MMU 映射的情况下读取数据，我们建议使用分区读取函数 <code>esp_partition_read()</code>。使用此功能时，只有从加密分区读取数据时才会解密数据。其他分区将以未加密方式读取。通过这种方式，软件可以以相同的方式访问加密和非加密的闪存。</p><p>通过其他 SPI 读取 APIs 读取的数据不会被解密:</p><ul><li>通过 <code>esp_spi_flash_read()</code> 读取的数据不会被解密</li><li>通过 ROM 函数 <code>SPIRead()</code> 读取的数据不会被解密 (esp-idf 应用程序不支持此功能)</li><li>使用非易失性存储 (NVS) API 存储的数据始终存储并读取解密。</li></ul><h3 id="3-3-写加密的-Flash"><a href="#3-3-写加密的-Flash" class="headerlink" title="3.3 写加密的 Flash"></a>3.3 写加密的 Flash</h3><p>在可能的情况下，我们建议使用分区写入函数 <code>esp_partition_write</code>。使用此功能时，只有在写入加密分区时才会加密数据。数据将被写入未加密的其他分区。通过这种方式，软件可以以相同的方式访问加密和非加密的闪存.</p><p>当 <code>write_encrypted</code> 参数设置为 true 时，<code>esp_spi_flash_write</code> 函数将写入数据。否则，数据将以未加密的方式写入.</p><p>ROM 函数 <code>esp_rom_spiflash_write_encrypted</code> 将加密数据写入闪存，ROM 函数 <code>SPIWrite</code> 将未加密写入闪存。(esp-idf 应用程序不支持这些功能).</p><p>未加密数据的最小写入大小为 4 个字节(对齐为 4 个字节)。由于数据是以块为单位加密的，因此加密数据的最小写入大小为 16 字节(对齐为16字节).</p><h2 id="4-更像加密的-Flash"><a href="#4-更像加密的-Flash" class="headerlink" title="4 更像加密的 Flash"></a>4 更像加密的 Flash</h2><h3 id="4-1-OTA-更新"><a href="#4-1-OTA-更新" class="headerlink" title="4.1 OTA 更新"></a>4.1 OTA 更新</h3><p>只要使用 <code>esp_partition_write</code> 函数，对加密分区的 OTA 更新将自动加密写入.</p><h3 id="4-2-串口烧录"><a href="#4-2-串口烧录" class="headerlink" title="4.2 串口烧录"></a>4.2 串口烧录</h3><p><code>FLASH_CRYPT_CNT efuse</code> 允许通过串口烧录(或其他物理方法)使用新的明文数据更新闪存，最多 3 次.</p><p>该过程涉及烧录明文数据，然后碰撞 <code>FLASH_CRYPT_CNT efuse</code> 的值，这会导致引导加载程序重新加密此数据.</p><h4 id="4-2-1-限制更新"><a href="#4-2-1-限制更新" class="headerlink" title="4.2.1 限制更新"></a>4.2.1 限制更新</h4><p>这种类型只有 4 个明文串行更新周期，包括初始加密闪存.</p><p>禁用第四次加密后，<code>FLASH_CRYPT_CNT efuse</code> 的最大值为 0xFF，永久禁用加密.</p><p>通过预生成的 Flash 加密密钥使用 OTA 更新或重新刷新可以超过此限制.</p><h4 id="4-2-2-串口烧录的注意事项"><a href="#4-2-2-串口烧录的注意事项" class="headerlink" title="4.2.2 串口烧录的注意事项"></a>4.2.2 串口烧录的注意事项</h4><ul><li>通过串口重新烧录时，重新刷新最初用明文数据写入的每个分区(包括 bootloader)。可以跳过不是“当前选择的” OTA 分区的应用程序分区(除非在那里找到明文应用程序映像，否则不会重新加密这些分区.)但是，标有“加密”标志的任何分区都将无条件地重新分区。加密，意味着任何已加密的数据将被加密两次并被破坏.<ul><li>使用 <code>make flash</code> 应烧录所有需要闪存的分区.</li></ul></li><li>如果启用了安全启动，则除非您使用“可重新启动”选项进行安全启动，否则无法通过串口重新刷新纯文本数据。请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-and-secure-boot" target="_blank" rel="noopener">Flash加密和安全启动</a>.</li></ul><h3 id="4-3-串口重新烧录程序"><a href="#4-3-串口重新烧录程序" class="headerlink" title="4.3 串口重新烧录程序"></a>4.3 串口重新烧录程序</h3><ul><li>正常的构建应用程序.</li><li>正常的使用明文数据刷新设备 (make flash 或 esptool.py 命令.)闪存所有先前加密的分区，包括引导加载程序(参见上一节).</li><li>此时，设备将无法启动(消息为 flash read err，1000)，因为它希望看到加密的引导加载程序，但引导加载程序是纯文本.</li><li>通过运行命令 <code>espefuse.py burn_efuse FLASH_CRYPT_CNT</code> 来刻录 <code>FLASH_CRYPT_CNT efuse</code>。 <code>espefuse.py</code> 会自动将位数递增 1，从而禁用加密.</li><li>重置设备，它将重新加密明文分区，然后再次刻录 <code>FLASH_CRYPT_CNT efuse</code> 以重新启用加密.</li></ul><h4 id="4-3-1-禁用串口更新"><a href="#4-3-1-禁用串口更新" class="headerlink" title="4.3.1 禁用串口更新"></a>4.3.1 禁用串口更新</h4><p>要防止通过串口进行进一步的明文更新，请在启用闪存加密后(即首次启动完成后)使用 <code>espefuse.py</code> 写保护 <code>FLASH_CRYPT_CNT efuse</code> :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espefuse.py --port PORT write_protect_efuse FLASH_CRYPT_CNT</span><br></pre></td></tr></table></figure><p>这可以防止进一步修改以禁用或重新启用闪存加密.</p><h3 id="4-4-通过预生成的-Flash-加密密钥重新烧录"><a href="#4-4-通过预生成的-Flash-加密密钥重新烧录" class="headerlink" title="4.4 通过预生成的 Flash 加密密钥重新烧录"></a>4.4 通过预生成的 Flash 加密密钥重新烧录</h3><p>可以在主机上预生成闪存加密密钥，并将其刻录到 ESP32 的 efuse 密钥块中。这允许数据在主机上预加密并烧录到 ESP32，而无需明文闪存更新.</p><p>这对于开发很有用，因为它消除了 4 次刷新限制。它还允许在启用安全启动的情况下重新刷新应用程序，因为每次都不需要重新启动引导加载程序.</p><blockquote><p>此方法仅用于协助开发，而不用于生产设备。如果为生产预生成闪存加密，请确保密钥是从高质量的随机数源生成的，并且不要跨多个设备共享相同的闪存加密密钥.</p></blockquote><h4 id="4-4-1-预生成-Flash-加密密钥"><a href="#4-4-1-预生成-Flash-加密密钥" class="headerlink" title="4.4.1 预生成 Flash 加密密钥"></a>4.4.1 预生成 Flash 加密密钥</h4><p>Flash 加密密钥是 32 字节的随机数据。您可以使用 <code>espsecure.py</code> 生成随机密钥:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure><p>(这些数据的随机性仅与操作系统一样好，而且是Python安装的随机数据源.)</p><p>或者，如果您使用安全启动并具有安全启动签名密钥，则可以生成安全启动专用签名密钥的确定性SHA-256摘要，并将其用作闪存加密密钥:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espsecure.py digest_private_key --keyfile secure_boot_signing_key.pem my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure><p>(如果为安全启动启用可重新映射模式，则使用相同的 32 个字节作为安全启动摘要键.)</p><p>以这种方式从安全启动签名密钥生成闪存加密密钥意味着您只需要存储一个密钥文件。然而，该方法根本不适用于生产设备.</p><h4 id="4-4-2-刻录-Flash-加密密钥"><a href="#4-4-2-刻录-Flash-加密密钥" class="headerlink" title="4.4.2 刻录 Flash 加密密钥"></a>4.4.2 刻录 Flash 加密密钥</h4><p>生成闪存加密密钥后，需要将其刻录到 ESP32 的 efuse 密钥块。这必须在首次加密启动之前完成，否则 ESP32 将生成软件无法访问或修改的随机密钥.</p><p>要将密钥刻录到设备(仅限一次):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espefuse.py --port PORT burn_key flash_encryption my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure><h4 id="4-4-3-带有预生成密钥的第一次烧录"><a href="#4-4-3-带有预生成密钥的第一次烧录" class="headerlink" title="4.4.3 带有预生成密钥的第一次烧录"></a>4.4.3 带有预生成密钥的第一次烧录</h4><p>烧录密钥后，按照与默认 Flash 加密初始化相同的步骤操作，并为第一次启动时刷新纯文本图像。引导加载程序将使用预先烧制的密钥启用闪存加密并加密所有分区.</p><h4 id="4-4-4-使用预生成密钥重新烧录"><a href="#4-4-4-使用预生成密钥重新烧录" class="headerlink" title="4.4.4 使用预生成密钥重新烧录"></a>4.4.4 使用预生成密钥重新烧录</h4><p>在首次启动时启用加密后，重新烧录加密镜像需要额外的手动步骤。这是我们预先加密我们希望在闪存中更新的数据的地方.</p><p>假设这是用于刷新明文数据的常规命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --port &#x2F;dev&#x2F;ttyUSB0 --baud 115200 write_flash 0x10000 build&#x2F;my-app.bin</span><br></pre></td></tr></table></figure><p>二进制应用程序映像 build/my-app.bin 写入偏移量 0x10000。此文件名和偏移量需要用于加密数据，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espsecure.py encrypt_flash_data --keyfile my_flash_encryption_key.bin --address 0x10000 -o build&#x2F;my-app-encrypted.bin build&#x2F;my-app.bin</span><br></pre></td></tr></table></figure><p>此示例命令将使用提供的密钥加密 my-app.bin，并生成加密文件 my-app-encrypted.bin。确保 address 参数与计划闪存二进制文件的地址匹配.</p><p>然后，使用esptool.py刷新加密的二进制文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --port &#x2F;dev&#x2F;ttyUSB0 --baud 115200 write_flash 0x10000 build&#x2F;my-app-encrypted.bin</span><br></pre></td></tr></table></figure><p>不需要进一步的步骤或 efuse 操作，因为我们闪存时数据已经加密.</p><h2 id="5-禁用-Flash-加密"><a href="#5-禁用-Flash-加密" class="headerlink" title="5 禁用 Flash 加密"></a>5 禁用 Flash 加密</h2><p>如果由于某种原因意外启用了闪存加密，则下一次明文数据闪存将使ESP32软化(设备将连续重启，打印错误闪存读错误， 1000).</p><p>您可以通过编写 <code>FLASH_CRYPT_CNT efuse</code> 再次禁用闪存加密:</p><ul><li>首先，运行 <code>make menuconfig</code> 并取消选中“安全功能”下的“启用闪存加密启动”.</li><li>退出 <code>menuconfig</code> 并保存新配置.</li><li>再次运行 <code>make menuconfig</code> 并仔细检查你是否真的禁用了这个选项！ 如果启用此选项，则引导加载程序将在引导时立即重新启用加密.</li><li>运行 <code>make flash</code> 以构建并刷新新的引导加载程序和应用程序，而不启用闪存加密.</li><li>运行 <code>espefuse.py</code> (在 components/esptool_py/esptool 中)以禁用 <code>FLASH_CRYPT_CNT efuse</code>)::</li></ul><p>重置 ESP32 并禁用闪存加密，引导加载程序将正常启动.</p><h2 id="6-Flash-加密的局限性"><a href="#6-Flash-加密的局限性" class="headerlink" title="6 Flash 加密的局限性"></a>6 Flash 加密的局限性</h2><p>Flash 加密可防止加密闪存的明文读出，从而保护固件免受未经授权的读取和修改.了解闪存加密系统的局限性非常重要:</p><ul><li>Flash 加密仅与密钥一样强大.因此，我们建议在首次启动时在设备上生成密钥(默认行为).如果在设备外生成密钥(请参阅通过预生成的 Flash 加密密钥重新刷新)，请确保遵循正确的步骤.</li><li>并非所有数据都是加密存储的.如果在闪存上存储数据，请检查您使用的方法(库，API 等)是否支持闪存加密.</li><li>Flash 加密不会阻止攻击者理解闪存的高级布局.这是因为相同的 AES 密钥用于每对相邻的 16 字节 AES 块.当这些相邻的 16 字节块包含相同的内容(例如空或填充区域)时，这些块将加密以产生匹配的加密块对.这可能允许攻击者在加密设备之间进行高级别比较(即判断两个设备是否可能运行相同的固件版本).</li><li>出于同样的原因，攻击者总能知道一对相邻的 16 字节块 (32 字节对齐)何时包含相同的内容.如果将敏感数据存储在闪存中，请记住这一点，设计闪存存储器，以免发生这种情况(使用计数器字节或每 16 字节一些其他不相同的值就足够了).</li></ul><h2 id="7-Flash-加密和安全启动"><a href="#7-Flash-加密和安全启动" class="headerlink" title="7 Flash 加密和安全启动"></a>7 Flash 加密和安全启动</h2><p>建议一起使用闪存加密和安全启动。但是，如果启用了安全启动，则重新刷新设备会有其他限制:</p><ul><li>OTA 更新不受限制(前提是新应用程序使用安全启动签名密钥正确签名).</li><li>只有选择了 Reflashable Secure Boot 模式并且预先生成安全启动密钥并将其刻录到 ESP32 (参见安全启动文档)，才能进行明文串口烧录更新。在此配置中， make bootloader 将生成预先消化的引导加载程序和安全引导摘要文件，以便在偏移量 0x0 处烧录。当遵循明文串行重新刷新步骤时，必须在烧录其他明文数据之前重新刷新该文件.</li><li>如果未重新启动引导加载程序，仍可以通过预生成的 Flash 加密密钥重新刷新。重新刷新引导加载程序需要在安全引导配置中启用相同的 Reflashable 选项.</li></ul><h2 id="8-使用没有安全启动的-Flash-加密"><a href="#8-使用没有安全启动的-Flash-加密" class="headerlink" title="8 使用没有安全启动的 Flash 加密"></a>8 使用没有安全启动的 Flash 加密</h2><p>如果在没有安全启动的情况下使用闪存加密，则可以使用串行重新烧录加载未经授权的代码。有关详细信息，请参阅串行烧录 然后，这个未授权的代码可以读取所有加密的分区(以解密的形式)，使闪存加密无效。这可以通过写保护 <code>FLASH_CRYPT_CNT efuse</code> 来避免，从而禁止串口重新烧录。FLASH_CRYPT_CNT可以使用命令对efuse进行写保护:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espefuse.py --port PORT write_protect_efuse FLASH_CRYPT_CNT</span><br></pre></td></tr></table></figure><p>或者，应用程序可以在其启动过程中调用 <code>esp_flash_write_protect_crypt_cnt()</code>.</p><h2 id="9-Flash-加密高级功能"><a href="#9-Flash-加密高级功能" class="headerlink" title="9 Flash 加密高级功能"></a>9 Flash 加密高级功能</h2><p>以下信息对于高级使用闪存加密非常有用:</p><h3 id="9-1-加密分区标志"><a href="#9-1-加密分区标志" class="headerlink" title="9.1 加密分区标志"></a>9.1 加密分区标志</h3><p>某些分区默认是加密的。否则，可以将任何分区标记为需要加密:</p><p>在分区表描述 CSV 文件中，有一个标志字段.</p><p>通常留空，如果在此字段中写入 “encrypted” ，则分区将在分区表中标记为已加密，此处写入的数据将被视为已加密(与应用程序分区相同):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000</span><br><span class="line">factory,  app,  factory, 0x10000, 1M</span><br><span class="line">secret_data, 0x40, 0x01, 0x20000, 256K, encrypted</span><br></pre></td></tr></table></figure><ul><li>默认分区表都不包含任何加密数据分区.</li><li>没有必要将 “app” 分区标记为已加密，它们始终被视为已加密.</li><li>如果未启用闪存加密，则“加密”标志不执行任何操作.</li><li>如果您希望保护此数据不受物理访问读取或修改的影响，则可以将 phy_init 数据标记为可选的phy分区.</li><li>无法将 nvs 分区标记为已加密.</li></ul><h3 id="9-2-启用-UART-Bootloader-加密-解密"><a href="#9-2-启用-UART-Bootloader-加密-解密" class="headerlink" title="9.2 启用 UART Bootloader 加密/解密"></a>9.2 启用 UART Bootloader 加密/解密</h3><p>默认情况下，首次启动时，闪存加密过程将刻录 <code>DISABLE_DL_ENCRYPT</code> ， <code>DISABLE_DL_DECRYPT</code> 和 <code>DISABLE_DL_CACHE</code> :</p><p>在 UART 引导加载程序引导模式下运行时， <code>DISABLE_DL_ENCRYPT</code> 禁用闪存加密操作.<br> <code>DISABLE_DL_DECRYPT</code> 在 UART 引导加载程序模式下运行时禁用透明闪存解密，即使 <code>FLASH_CRYPT_CNT efuse</code> 设置为在正常操作中启用它也是如此.<br>在 UART 引导加载程序模式下运行时， <code>DISABLE_DL_CACHE</code> 禁用整个 MMU 闪存缓存.<br>可以仅刻录其中一些 efuses，并在第一次引导之前对其余部分进行写保护(使用未设置值 0)，以便保留它们。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">espefuse.py --port PORT burn_efuse DISABLE_DL_DECRYPT</span><br><span class="line">espefuse.py --port PORT write_protect_efuse DISABLE_DL_ENCRYPT</span><br></pre></td></tr></table></figure><p>(注意，这些 efuse 中的所有 3 个都是通过一个写保护位禁用的，因此写保护将保护所有这些保护位.因此，在写保护之前必须设置任何位.)</p><blockquote><p>由于 esptool.py 不支持写入或读取加密闪存，因此写保护这些 efuse 以保持它们不被设置目前不是非常有用.</p></blockquote><blockquote><p>如果未设置 <code>DISABLE_DL_DECRYPT(0)</code>， 这有效地使闪存加密无效，因为具有物理访问权限的攻击者可以使用UART引导加载程序模式(使用自定义存根代码)来读取闪存内容.</p></blockquote><h3 id="9-3-设置-FLASH-CRYPT-CONFIG"><a href="#9-3-设置-FLASH-CRYPT-CONFIG" class="headerlink" title="9.3 设置 FLASH_CRYPT_CONFIG"></a>9.3 设置 <code>FLASH_CRYPT_CONFIG</code></h3><p><code>FLASH_CRYPT_CONFIG efuse</code> 确定闪存加密密钥中用块偏移“调整”的位数。有关详细信息，请参阅 Flash 加密算法.</p><p>引导加载程序的首次引导始终将此值设置为最大 0xF.</p><p>可以手动编写这些 efuse， 并在首次启动之前写保护，以便选择不同的调整值。不建议这样做.</p><p>强烈建议在值为零时永远不要写保护 <code>FLASH_CRYPT_CONFIG</code>。如果此 efuse 设置为零，则不会调整闪存加密密钥中的任何位，并且闪存加密算法等同于 AES ECB 模式.</p><h2 id="10-技术细节"><a href="#10-技术细节" class="headerlink" title="10 技术细节"></a>10 技术细节</h2><p>以下部分提供有关闪存加密操作的一些参考信息.</p><h3 id="10-1-FLASH-CRYPT-CNT-efuse"><a href="#10-1-FLASH-CRYPT-CNT-efuse" class="headerlink" title="10.1 FLASH_CRYPT_CNT efuse"></a>10.1 <code>FLASH_CRYPT_CNT efuse</code></h3><p><code>FLASH_CRYPT_CNT</code> 是一个 8 位 efuse 字段，用于控制闪存加密。Flash 加密根据此 efuse 中设置为 “1” 的位数启用或禁用:</p><ul><li>设置偶数位 (0,2,4,6,8) 时:禁用闪存加密，无法解密任何加密数据.<ul><li>如果引导加载程序是使用“启动时启用闪存加密”构建的，那么它将看到这种情况并立即重新加密闪存，无论它何时找到未加密的数据.完成后，它会将 efuse 中的另一位设置为 “1”，这意味着现在设置了奇数个位.<ul><li>在第一次纯文本引导时，位计数具有全新值 0，并且引导加载程序在加密后将其更改为位计数 1 (值 0x01).</li><li>在下一次明文闪存更新后，将位计数手动更新为 2 (值 0x03).重新加密引导加载程序后，将 efuse 位计数更改为 3 (值 0x07).</li><li>在下一个明文闪存之后，将位计数手动更新为 4 (值 0x0F).重新加密引导加载程序后，将 efuse 位计数更改为 5 (值 0x1F).</li><li>在最后的明文闪存之后，位计数被手动更新为 6 (值 0x3F).重新加密引导加载程序后，将 efuse 位计数更改为7 (值 0x7F).</li></ul></li></ul></li><li>设置奇数位 (1,3,5,7) 时:启用透明读取加密闪存.</li><li>设置完所有 8 位后(efuse 值 0xFF):禁用透明读取加密闪存，永久无法访问任何加密数据。Bootloader 通常会检测到这种情况并停止.为避免使用此状态加载未经授权的代码，必须使用安全引导或 <code>FLASH_CRYPT_CNT efuse</code> 必须写保护.</li></ul><h3 id="10-2-Flash-加密算法"><a href="#10-2-Flash-加密算法" class="headerlink" title="10.2 Flash 加密算法"></a>10.2 Flash 加密算法</h3><ul><li><p>AES-256 以 16 字节数据块运行.闪存加密引擎以 32 字节块，两个串联的 AES 块加密和解密数据.</p></li><li><p>AES 算法在闪存加密中反转使用，因此闪存加密“加密”操作是 AES 解密，“解密”操作是AES加密.这是出于性能原因，并未改变算法的有效性.</p></li><li><p>主闪存加密密钥存储在 efuse(BLOCK1) 中，默认情况下不受进一步写入或软件读取的影响.</p></li><li><p>每个 32 字节块(两个相邻的 16 字节 AES 块)使用唯一密钥加密.密钥源自efuse中的主闪存加密密钥，与闪存中该块的偏移量进行异或(“键调整”).</p></li><li><p>具体的调整取决于 <code>FLASH_CRYPT_CONFIG efuse</code> 的设置.这是一个 4 位 efuse， 其中每个位都能对特定范围的关键位进行异或运算:</p><ul><li>位 1， 该值的 0-66 位被异或.</li><li>位 2， 该值的 67-131 位被异或.</li><li>位 3， 该值的 132-194 被异或.</li><li>位 4， 该值的 195-256 位被异或.<br>建议始终保留 <code>FLASH_CRYPT_CONFIG</code> 以设置默认值 0xF，以便所有关键位与块偏移进行异或.有关详细信息，请参阅设置 <code>FLASH_CRYPT_CONFIG</code>.</li></ul></li><li><p>块偏移的高 19 位(第 5 位到第 23 位)与主闪存加密密钥进行异或.选择此范围有两个原因:最大闪存大小为 16MB(24 位)，每个块为 32 字节，因此最低有效 5 位 始终为零.</p></li><li><p>从 19 个块偏移位中的每一个到闪存加密密钥的 256 位存在特定映射，以确定哪个位与哪个位进行异或.请参阅 espsecure.py 源代码中的变量 <code>_FLASH_ENCRYPTION_TWEAK_PATTERN</code> 以获取完整的映射.</p></li><li><p>要查看 Python 中实现的完整闪存加密算法，请参阅 espsecure.py 源代码中的 <code>_flash_encryption_operation()</code> 函数.</p></li></ul><h2 id="11-参考资料"><a href="#11-参考资料" class="headerlink" title="11 参考资料"></a>11 参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Flash-加密&quot;&gt;&lt;a href=&quot;#Flash-加密&quot; class=&quot;headerlink&quot; title=&quot;Flash 加密&quot;&gt;&lt;/a&gt;Flash 加密&lt;/h1&gt;&lt;p&gt;Flash 加密功能用于加密 ESP32 连接的 SPI  Flash 的内容。启用 Flash 加密后，通过物理方式读取 SPI Flash 的内容不足以恢复大多数 Flash 内容。&lt;/p&gt;
&lt;p&gt;Flash 加密与安全启动功能是分离的，您可以使用 Flash 加密而无需启用&lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全启动&lt;/a&gt;。但是，我们建议将这两种功能一起用于安全的环境。在没有安全启动的情况下，需要执行其他配置以确保 Flash 加密的有效性。有关更多详细信息，请参阅&lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-without-secure-boot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用无安全启动的 Flash 加密&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;启用闪存加密会限制您进一步更新 ESP32 的选项。请务必阅读本文档(包括 &lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-limitations&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flash 加密限制&lt;/a&gt;)并了解启用闪存加密的含义。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（七）ESP32 Core Dump</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%83%EF%BC%89ESP32%20Core%20Dump/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2018/09/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%83%EF%BC%89ESP32%20Core%20Dump/</id>
    <published>2018-09-01T21:55:33.000Z</published>
    <updated>2020-07-23T08:03:09.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP32-Core-Dump"><a href="#ESP32-Core-Dump" class="headerlink" title="ESP32 Core Dump"></a>ESP32 Core Dump</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-IDF 支持在不可恢复的软件错误上生成 Core Dump。这个技术可以对软件发生故障时的软件状态进行事后分析。在系统崩溃进入 Panic 状态时，根据配置打印一些信息并停止或重新启动。用户可以选择生成 Core Dump，以便稍后在 PC 上分析故障原因。Core Dump 包含软件发生故障时系统中所有任务的快照。快照包括任务控制块(TCB)和堆栈。因此。有可能找出什么任务，在什么指令(代码行)和该任务的什么调用堆栈导致崩溃。ESP-IDF 提供特殊脚本 <code>espcoredump.py</code>，以帮助用户检索和分析 Core Dump。此工具提供两个用于 Core Dump 分析的命令:</p><ul><li><code>info_corefile</code> - 打印崩溃的任务的寄存器，调用堆栈，系统中可用任务的列表，内存区域和存储在 Core Dump (TCB 和堆栈)中的内存内容。</li><li><code>dbg_corefile</code> - 创建 Core Dump ELF 文件并使用此文件运行 GDB 调试会话。用户可以手动检查内存，变量和任务状态。请注意，由于并非所有内存都保存在 Core Dump 中，因此只有堆栈上分配的变量值才有意义。</li></ul><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>有许多与 Core Dump 相关的配置选项，用户可以在应用程序的配置菜单中选择 (<code>make menuconfig</code>)。</p><ol><li>Core Dump 数据目标(Components -&gt; ESP32-specific config -&gt; Core dump destination):<ul><li>禁用 Core Dump 生成</li><li>将 Core Dump 保存到 Flash</li><li>将 Core Dump 打印到 UART</li></ul></li><li>核心转储中的最大任务快照数(Components -&gt; ESP32-specific config -&gt; Core dump -&gt; Maximum number of tasks)。</li><li>Core Dump 打印到 UART 之前的延迟时间(Components -&gt; ESP32-specific config -&gt; Core dump print to UART delay).。值以 ms 为单位。</li></ol><h2 id="将-Core-Dump-保存到-Flash"><a href="#将-Core-Dump-保存到-Flash" class="headerlink" title="将 Core Dump 保存到 Flash"></a>将 Core Dump 保存到 Flash</h2><p>选择此选项后，Core Dump 将保存到 Flash 上的特殊分区。当使用随 ESP-IDF 提供的默认分区表文件时，它会自动在 Flash 上分配必要的空间，但如果用户想要将自己的布局文件与 Core Dump 功能一起使用，则应为 Core Dump 定义单独的分区，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size</span><br><span class="line"># Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000</span><br><span class="line">factory,  app,  factory, 0x10000, 1M</span><br><span class="line">coredump, data, coredump,,        64K</span><br></pre></td></tr></table></figure><p>分区名称没有特殊要求。可以根据用户应用需求选择，但分区类型应为“数据”，子类型应为“coredump”。此外，在选择分区大小时请注意，Core Dump 数据结构会引入 20 字节的常量开销和 12 字节的每任务开销。此开销不包括每个任务的 TCB 和堆栈的大小，因此，partirion 大小应至少为 20 + max task stack number x(12 + TCB size + max task stack size) 字节。</p><p>从 Flash 分析 Core Dump 的通用命令示例是:<br><code>espcoredump.py -p &lt;/path/to/serial/port&gt; info_corefile &lt;/path/to/program/elf/file&gt;</code><br>或<br> <code>espcoredump.py -p &lt;/path/to/serial/port&gt; dbg_corefile &lt;/path/to/program/elf/file&gt;</code></p><h2 id="将-Core-Dump-打印到UART"><a href="#将-Core-Dump-打印到UART" class="headerlink" title="将 Core Dump 打印到UART"></a>将 Core Dump 打印到UART</h2><p>选择此选项时，在系统崩溃进入 Panic 状态时，将在 UART 上打印 <strong>base64 编码的 Core Dump</strong>。在这种情况下，用户应手动将 Core Dump 文本正文保存到某个文件，然后运行以下命令:<br><code>espcoredump.py info_corefile -t b64 -c &lt;/path/to/saved/base64/text&gt; &lt;/path/to/program/elf/file&gt;</code><br>或<br> <code>espcoredump.py dbg_corefile -t b64 -c &lt;/path/to/saved/base64/text&gt; &lt;/path/to/program/elf/file&gt;</code></p><p>Base64 编码的 Core Dump 体将位于以下页眉和页脚之间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; CORE DUMP START &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&lt;body of base64-encoded core dump, save it to file on disk&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; CORE DUMP END &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>CORE DUMP START 和 CORE DUMP END 行不得包含在 Core Dump 文本文件中。</p><h2 id="Backtraces-中的-ROM-函数"><a href="#Backtraces-中的-ROM-函数" class="headerlink" title="Backtraces 中的 ROM 函数"></a>Backtraces 中的 ROM 函数</h2><p>可能的情况是，在崩溃时，一些任务或/和崩溃的任务本身在其调用堆栈中具有一个或多个 ROM 功能。由于 ROM 不是程序 ELF 的一部分，GDB 不可能解析这样的调用堆栈，因为它试图分析函数的序言来实现它。在这种情况下，调用堆栈打印将在第一个 ROM 函数中被错误消息打破。要解决此问题，您可以使用 Espressif 提供的 <a href="https://dl.espressif.com/dl/esp32_rom.elf" target="_blank" rel="noopener">ROM ELF</a> 并将其传递给 ‘espcoredump.py’。</p><h2 id="运行-‘espcoredump-py’"><a href="#运行-‘espcoredump-py’" class="headerlink" title="运行 ‘espcoredump.py’"></a>运行 ‘espcoredump.py’</h2><p>通用命令语法:</p><p><code>espcoredump.py [options] command [args]</code></p><p><code>Script Options:</code>    </p><ul><li>–chip,-c {auto,esp32}. Target chip type. Supported values are auto and esp32.</li><li>–port,-p PORT. Serial port device.</li><li>–baud,-b BAUD. Serial port baud rate used when flashing/reading.</li></ul><p><code>Commands:</code>    </p><ul><li>info_corefile. Retrieve core dump and print useful info.</li><li>dbg_corefile. Retrieve core dump and start GDB session with it.</li></ul><p><code>Command Arguments:</code></p><ul><li>–gdb,-g GDB. Path to gdb to use for data retrieval.</li><li>–core,-c CORE. Path to core dump file to use (if skipped core dump will be read from flash).</li><li>–core-format,-t CORE_FORMAT. Specifies that file passed with “-c” is an ELF (“elf”), dumped raw binary (“raw”) or base64-encoded (“b64”) format.</li><li>–off,-o OFF. Ofsset of coredump partition in flash (type “make partition_table” to see it).</li><li>–save-core,-s SAVE_CORE. Save core to file. Othwerwise temporary core file will be deleted. Ignored with “-c”.</li><li>–rom-elf,-r ROM_ELF. Path to ROM ELF file to use (if skipped “esp32_rom.elf” is used).</li><li>–print-mem,-m Print memory dump. Used only with “info_corefile”.</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/core_dump.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP32-Core-Dump&quot;&gt;&lt;a href=&quot;#ESP32-Core-Dump&quot; class=&quot;headerlink&quot; title=&quot;ESP32 Core Dump&quot;&gt;&lt;/a&gt;ESP32 Core Dump&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ESP-IDF 支持在不可恢复的软件错误上生成 Core Dump。这个技术可以对软件发生故障时的软件状态进行事后分析。在系统崩溃进入 Panic 状态时，根据配置打印一些信息并停止或重新启动。用户可以选择生成 Core Dump，以便稍后在 PC 上分析故障原因。Core Dump 包含软件发生故障时系统中所有任务的快照。快照包括任务控制块(TCB)和堆栈。因此。有可能找出什么任务，在什么指令(代码行)和该任务的什么调用堆栈导致崩溃。ESP-IDF 提供特殊脚本 &lt;code&gt;espcoredump.py&lt;/code&gt;，以帮助用户检索和分析 Core Dump。此工具提供两个用于 Core Dump 分析的命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;info_corefile&lt;/code&gt; - 打印崩溃的任务的寄存器，调用堆栈，系统中可用任务的列表，内存区域和存储在 Core Dump (TCB 和堆栈)中的内存内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dbg_corefile&lt;/code&gt; - 创建 Core Dump ELF 文件并使用此文件运行 GDB 调试会话。用户可以手动检查内存，变量和任务状态。请注意，由于并非所有内存都保存在 Core Dump 中，因此只有堆栈上分配的变量值才有意义。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
</feed>
