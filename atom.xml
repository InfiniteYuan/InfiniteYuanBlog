<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>InfiniteYuan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.infiniteyuan.com/"/>
  <updated>2020-08-02T06:36:34.031Z</updated>
  <id>https://blog.infiniteyuan.com/</id>
  
  <author>
    <name>InfiniteYuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ESP32 学习笔记（三十） ESP32 性能分析，与 Cortex-M4 性能比较</title>
    <link href="https://blog.infiniteyuan.com/2020/07/04/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%20ESP32%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%8E%20Cortex-M4%20%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"/>
    <id>https://blog.infiniteyuan.com/2020/07/04/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%20ESP32%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%8E%20Cortex-M4%20%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/</id>
    <published>2020-07-04T13:25:59.000Z</published>
    <updated>2020-08-02T06:36:34.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-EEMBC"><a href="#关于-EEMBC" class="headerlink" title="关于 EEMBC"></a>关于 EEMBC</h1><p><a href="https://www.eembc.org/about/" target="_blank" rel="noopener">About EEMBC</a></p><p>EEMBC 为自动驾驶，移动成像，物联网，移动设备和许多其他应用程序中使用的硬件和软件制定性能基准。</p><p>EEMBC 基准测试得分的主要受众是创建依赖嵌入式微控制器和微处理器的系统的公司：从智能手机到太阳能电池板的所有产品。尽管此类制造商通常具有自己的专有基准，但是 EEMBC 提供了一种有吸引力的替代方案，可替代购买硬件，进行设置，然后在候选处理器组上进行所有测量的所有复杂性。 EEMBC 基准套件通过提供统一，严格定义的测量标准，使制造商可以轻松地比较替代解决方案，从而使制造商避免了此繁琐的过程。这不仅使大型制造商受益，而且使开发人员，集成商，</p><a id="more"></a><h2 id="ESP32-8266-与-Cortex-M3-M4-性能比较"><a href="#ESP32-8266-与-Cortex-M3-M4-性能比较" class="headerlink" title="ESP32/8266 与 Cortex-M3/M4 性能比较"></a>ESP32/8266 与 Cortex-M3/M4 性能比较</h2><p><a href="https://www.eembc.org/coremark/view.php?benchmark_seq=13244,13243,1139,1506" target="_blank" rel="noopener">ESP32/8266 与 Cortex-M3/M4 性能比较</a><br><img src="https://img-blog.csdnimg.cn/20200704114043419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于-EEMBC&quot;&gt;&lt;a href=&quot;#关于-EEMBC&quot; class=&quot;headerlink&quot; title=&quot;关于 EEMBC&quot;&gt;&lt;/a&gt;关于 EEMBC&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.eembc.org/about/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;About EEMBC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;EEMBC 为自动驾驶，移动成像，物联网，移动设备和许多其他应用程序中使用的硬件和软件制定性能基准。&lt;/p&gt;
&lt;p&gt;EEMBC 基准测试得分的主要受众是创建依赖嵌入式微控制器和微处理器的系统的公司：从智能手机到太阳能电池板的所有产品。尽管此类制造商通常具有自己的专有基准，但是 EEMBC 提供了一种有吸引力的替代方案，可替代购买硬件，进行设置，然后在候选处理器组上进行所有测量的所有复杂性。 EEMBC 基准套件通过提供统一，严格定义的测量标准，使制造商可以轻松地比较替代解决方案，从而使制造商避免了此繁琐的过程。这不仅使大型制造商受益，而且使开发人员，集成商，&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二十九） ESP32 低功耗模式</title>
    <link href="https://blog.infiniteyuan.com/2020/05/31/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%20ESP32%20%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.infiniteyuan.com/2020/05/31/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%20ESP32%20%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-05-31T09:59:38.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP32-低功耗模式"><a href="#ESP32-低功耗模式" class="headerlink" title="ESP32 低功耗模式"></a>ESP32 低功耗模式</h1><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1 概要"></a>1 概要</h2><p>ESP32 系列芯片提供三种可配置的睡眠模式，针对这些睡眠模式,我们提供了了多种低功耗解决方案，用户可以结合具体需求选择睡眠模式并进行配置。三种睡眠模式如下:</p><ul><li>Modem-sleep 模式：CPU 可运行，时钟可被配置。Wi-Fi/蓝牙基带和射频关闭。</li><li>Light-sleep 模式：CPU 暂停运行，Wi-Fi/蓝牙基带和射频关闭。<strong>RTC 存储器和外设以及 ULP 协处理器运行</strong>。任何唤醒事件(MAC、主机、RTC 定时器或外部中断)都会唤醒芯片。</li><li>Deep-sleep 模式：CPU 和大部分外设都会掉电，Wi-Fi/蓝牙基带和射频关闭，只有 <strong>RTC 存储器和 RTC 外设以及 ULP 协处理器</strong>可以工作。Wi-Fi 和蓝牙连接数据存储在 RTC 中。</li></ul><p>三种模式的区别如下：</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/2020061714483194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70#pic_center" alt="三种模式的区别"></p><hr><h2 id="2-Modem-sleep-模式"><a href="#2-Modem-sleep-模式" class="headerlink" title="2 Modem-sleep 模式"></a>2 Modem-sleep 模式</h2><p>目前 ESP32 的 Modem-sleep 仅工作在 Station 模式下,连接路由器后生效。Station 会周期性在工作状态和睡眠状态两者之间切换。<br>ESP32 通过 Wi-Fi 的 DTIM Beacon 机制与路由器保持连接。在 Modem-sleep 模式下，系统可以自动被唤醒，无需配置唤醒源。</p><blockquote><p>一般路由器的 DTIM Beacon 间隔为 100 ms ~ 1,000 ms。</p></blockquote><blockquote><p>DTIM (Delivery Traffic Indication Message): 使用无线路由器时无线发送数据包的频率。</p></blockquote><p>在 Modem-sleep 模式下，ESP32 会在两次 DTIM Beacon 间隔时间内，关闭 Wi-Fi 模块电路，达到省电效果，在下次 Beacon 到来前自动唤醒。睡眠时间由路由器的 DTIM Beacon 时间决定。Modem-sleep 模式可以保持与路由器的 Wi-Fi 连接，并通过路由器接收来自手机或者服务器的交互信息。</p><h3 id="2-1-API-说明"><a href="#2-1-API-说明" class="headerlink" title="2.1 API 说明"></a>2.1 API 说明</h3><p>通过以下接口配置 Modem-sleep 模式，<code>type</code> 可选参数：</p><ul><li><code>WIFI_PS_NONE</code>: 不使用 Modem-sleep 模式</li><li><code>WIFI_PS_MIN_MODEM</code>: ESP32 接收 Beacon 的间隔与路由器的 DTIM 间隔相同，即 1 个路由器间隔</li><li><code>WIFI_PS_MAX_MODEM</code>: ESP32 接收 Beacon 的间隔可由程序进行配置，间隔周期 <code>wifi_sta_config_t</code> 结构体中 <code>listen_interval</code> 值决定，单位为 路由器的 Beacon 间隔，默认值为 3（即 3 个路由器 Beacon 间隔）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    WIFI_PS_NONE,        <span class="comment">/**&lt; No power save */</span></span><br><span class="line">    WIFI_PS_MIN_MODEM,   <span class="comment">/**&lt; Minimum modem power saving. In this mode, station wakes up to receive beacon every DTIM period */</span></span><br><span class="line">    WIFI_PS_MAX_MODEM,   <span class="comment">/**&lt; Maximum modem power saving. In this mode, interval to receive beacons is determined by the listen_interval parameter in wifi_sta_config_t */</span></span><br><span class="line">&#125; <span class="keyword">wifi_ps_type_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_wifi_set_ps</span><span class="params">(<span class="keyword">wifi_ps_type_t</span> type)</span></span>;</span><br></pre></td></tr></table></figure><ol><li><code>type</code> 参数为 <code>WIFI_PS_MAX_MODEM</code> ，ESP32 接收 Beacon 的间隔 <code>listen_interval</code> 配置方法：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTEN_INTERVAL 3</span></span><br><span class="line"><span class="keyword">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">    .sta = &#123;</span><br><span class="line">        .ssid = <span class="string">"SSID"</span>,</span><br><span class="line">        .password = <span class="string">"Password"</span>,</span><br><span class="line">        .listen_interval = LISTEN_INTERVAL,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &amp;wifi_config));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_start());</span><br></pre></td></tr></table></figure><h3 id="2-2-应用"><a href="#2-2-应用" class="headerlink" title="2.2 应用"></a>2.2 应用</h3><p>Modem-sleep 一般用于 CPU 持续处于工作状态并需要保持 Wi-Fi 连接的应用场景，例如，使用 ESP32 本地语音唤醒功能，CPU 需要持续采集和处理音频数据。</p><hr><h2 id="3-Light-sleep-模式"><a href="#3-Light-sleep-模式" class="headerlink" title="3 Light-sleep 模式"></a>3 Light-sleep 模式</h2><p>Light-sleep 的工作模式与 Modem-sleep 相似，不同的是，除了关闭 Wi-Fi 模块电路以外，在 Light-sleep 模式下，还会关闭时钟并暂停内部 CPU，比 Modem-sleep 功耗更低。有两种方式使 CPU 进入 Light-sleep 模式：</p><ul><li>强制 Light-sleep： 通过调用 API 强制 CPU 进入 Light-sleep 模式，强制进入 Light-sleep 模式后，<strong>不能通过路由器接收</strong>来自手机或者服务器的交互信息</li><li>自动 Light-sleep： 配置为自动休眠方式后，会在 CPU 处于空闲的状态下自动进入 Light-sleep 模式，<strong>能通过路由器接收</strong>来自手机或者服务器的交互信息</li></ul><h3 id="3-1-强制-Light-sleep"><a href="#3-1-强制-Light-sleep" class="headerlink" title="3.1 强制 Light-sleep"></a>3.1 强制 Light-sleep</h3><p>参考示例: <a href="https://github.com/espressif/esp-idf/tree/release/v3.2/examples/system/light_sleep" target="_blank" rel="noopener">light_sleep</a></p><p>开发者可以使系统强制进入 Light-sleep 模式，即调用强制 Light-sleep 接口，强制关闭 Wi-Fi 模块电路并暂停内部 CPU。强制休眠后，能通过定时器、 GPIO（RTC IO 和 Digital IO）和 UART 唤醒。从 Light-sleep 唤醒后，会从进入休眠的位置继续执行程序。强制进入 Light-sleep 模式后，可以保持与路由器的 Wi-Fi 连接，但不能通过路由器接收来自手机或者服务器的交互信息。</p><blockquote><p>注意：</p></blockquote><blockquote><ol><li>强制 Light-sleep 接口调用后，并不会立即休眠，而是等到系统空闲后才进入休眠，</li></ol></blockquote><blockquote><ol start="2"><li>强制进入 Light-sleep 模式后，不能接收 IP 网络发送的网络数据。</li></ol></blockquote><h4 id="3-1-1-API-说明"><a href="#3-1-1-API-说明" class="headerlink" title="3.1.1 API 说明"></a>3.1.1 API 说明</h4><ol><li>配置唤醒源后，可使用 <code>esp_light_sleep_start()</code>  函数进入 Light-sleep 模式。在没有配置唤醒源的情况下也可以进入轻度睡眠状态，在这种情况下，芯片将无限期地处于 Light-sleep 模式，直到外部复位。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enter sleep mode */</span></span><br><span class="line">esp_light_sleep_start();</span><br><span class="line"><span class="comment">/* Execution continues here after wakeup */</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-应用"><a href="#3-1-2-应用" class="headerlink" title="3.1.2 应用"></a>3.1.2 应用</h4><p>强制 Light-sleep 模式可用于需要保持与路由器的连接，不需要实时响应路由器发来的数据的场景。</p><h3 id="3-2-自动-Light-sleep"><a href="#3-2-自动-Light-sleep" class="headerlink" title="3.2 自动 Light-sleep"></a>3.2 自动 Light-sleep</h3><p>参考示例: <a href="https://github.com/espressif/esp-idf/tree/release/v3.2/examples/wifi/power_save" target="_blank" rel="noopener">power_save</a></p><p>开发者可配置系统在空闲时自动进入 Light-sleep 模式，并能在需要 CPU 工作时自动唤醒，无需配置唤醒源。在配置为自动 Light-sleep 后，可以保持与路由器的 Wi-Fi 连接，并通过路由器接收来自手机或者服务器的交互信息，对用户体验没有影响。<br>通常自动 Light-sleep 会与 Modem-sleep 模式 以及电源管理功能共同使用，电源管理功能允许系统根据 CPU 负载动态调节 CPU 频率以降低功耗。</p><blockquote><p>若系统应用中有小于 DTIM Beacon 间隔时间的循环定时,系统将不能进入 Light-sleep 模式。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200617144640674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70#pic_center" alt="此处输入图片的描述"></p><h4 id="3-2-1-API-说明"><a href="#3-2-1-API-说明" class="headerlink" title="3.2.1 API 说明"></a>3.2.1 API 说明</h4><ol><li>通过 <code>esp_err_t esp_pm_configure(const void* vconfig)</code> 接口配置电源管理功能，参数 <code>light_sleep_enable</code> 为 true 时使能自动休眠功能。</li></ol><blockquote><p>使能 自动 Light-sleep 功能，需要使能 <a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/kconfig.html#config-freertos-use-tickless-idle" target="_blank" rel="noopener">CONFIG_FREERTOS_USE_TICKLESS_IDLE</a> 和 <a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/kconfig.html#config-pm-enable" target="_blank" rel="noopener">CONFIG_PM_ENABLE</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_PM_ENABLE</span></span><br><span class="line">    <span class="comment">// Configure dynamic frequency scaling:</span></span><br><span class="line">    <span class="comment">// maximum and minimum frequencies are set in sdkconfig,</span></span><br><span class="line">    <span class="comment">// automatic light sleep is enabled if tickless idle support is enabled.</span></span><br><span class="line">    <span class="keyword">esp_pm_config_esp32_t</span> pm_config = &#123;</span><br><span class="line">            .max_freq_mhz = CONFIG_EXAMPLE_MAX_CPU_FREQ_MHZ,</span><br><span class="line">            .min_freq_mhz = CONFIG_EXAMPLE_MIN_CPU_FREQ_MHZ,</span><br><span class="line">#<span class="keyword">if</span> CONFIG_FREERTOS_USE_TICKLESS_IDLE</span><br><span class="line">            .light_sleep_enable = <span class="literal">true</span></span><br><span class="line">#endif</span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_ERROR_CHECK( esp_pm_configure(&amp;pm_config) );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CONFIG_PM_ENABLE</span></span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-应用"><a href="#3-2-2-应用" class="headerlink" title="3.2.2 应用"></a>3.2.2 应用</h4><p>自动 Light-sleep 模式可用于需要保持与路由器的连接，可以实时响应路由器发来的数据的场景。并且在未接收到命令时，CPU 可以处于空闲状态。比如 Wi-Fi 开关的应用，大部分时间 CPU 都是空闲的，直到收到控制命令，CPU 才需要进行 GPIO 的操作。</p><hr><h2 id="3-3-Deep-sleep-模式"><a href="#3-3-Deep-sleep-模式" class="headerlink" title="3.3 Deep-sleep 模式"></a>3.3 Deep-sleep 模式</h2><p>参考示例: <a href="https://github.com/espressif/esp-idf/tree/release/v3.2/examples/system/deep_sleep" target="_blank" rel="noopener">deep_sleep</a></p><p>相对于其他两种模式，系统无法自动进入 Deep-sleep，需要由用户调用接口函数 <code>esp_deep_sleep_start()</code> 进入 Deep-sleep 模式。在该模式下，芯片会断开所有 Wi-Fi 连接与数据连接，进入 Deep-sleep 模式，只有 <strong>RTC 存储器和 RTC 外设以及 ULP 协处理器</strong>可以工作。从 Deep-sleep 唤醒后，CPU 将软件复位重启。</p><h3 id="3-3-1-API-说明"><a href="#3-3-1-API-说明" class="headerlink" title="3.3.1 API 说明"></a>3.3.1 API 说明</h3><ol><li>配置唤醒源后，可使用 <code>esp_deep_sleep_start()</code> 函数进入 Deep-sleep 模式。在没有配置唤醒源的情况下也可以进入 Deep-sleep 状态，在这种情况下，芯片将无限期地处于 Deep-sleep 模式，直到外部复位。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enter deep sleep */</span></span><br><span class="line">esp_deep_sleep_start();</span><br></pre></td></tr></table></figure><h3 id="3-3-2-应用"><a href="#3-3-2-应用" class="headerlink" title="3.3.2 应用"></a>3.3.2 应用</h3><p>Deep-sleep 可以用于低功耗的传感器应用,或者大部分时间都不需要进行数据传输的情况。设备可以每隔一段时间从 Deep-sleep 状态醒来测量数据并上传,之后继续进入 Deep-sleep。也可以将多个数据存储于 RTC memory(RTC memory 在 Deep-sleep 模式下仍然可以保存数据),然后一次发送出去。</p><hr><h2 id="4-唤醒方式"><a href="#4-唤醒方式" class="headerlink" title="4 唤醒方式"></a>4 唤醒方式</h2><p>针对 <strong>强制 Lighe-sleep</strong> 和 <strong>Deep-sleep</strong> 需要配置唤醒源的情况，有以下唤醒方式可以选择：</p><blockquote><p>部分唤醒方式仅支持 Light-sleep</p></blockquote><h3 id="4-1-GPIO"><a href="#4-1-GPIO" class="headerlink" title="4.1 GPIO"></a>4.1 GPIO</h3><ol><li><p>External wakeup (ext0)</p><p>RTC IO 模块包含当其中 <strong>一个 RTC IO</strong> 的电平为唤醒电平（可配置为逻辑高或低）触发唤醒的逻辑。</p><p>RTC IO 是 RTC 外设电源域的一部分，因此如果使能该唤醒源，RTC 外设将在睡眠期间保持上电状态。在 ESP32 的修订版 0 和 1 中，此唤醒源与 ULP 和触摸唤醒源不兼容。</p><p>由于在此模式下启用了 RTC IO 模块，因此也可以使用内部上拉或下拉电阻。</p><p><code>esp_sleep_enable_ext0_wakeup()</code> 函数可用于启用此唤醒源。</p></li><li><p>External wakeup (ext1)</p><p>RTC 控制器包含使用 <strong>多个 RTC IO</strong> 触发唤醒的逻辑。两个逻辑功能之一可用于触发唤醒：</p><ul><li>如果任何一个所选 IO 为高电平，则唤醒（<code>ESP_EXT1_WAKEUP_ANY_HIGH</code>）</li><li>如果所有选定的 IO 都为低电平，则唤醒（<code>ESP_EXT1_WAKEUP_ALL_LOW</code>）</li></ul><p>该唤醒源由 RTC 控制器实现。因此，RTC 外设和 RTC 存储器可以在此模式下断电。</p><p>但是，如果 RTC 外设断电，内部上拉和下拉电阻将被禁用。要使用内部上拉或下拉电阻，请在睡眠期间请求 RTC 外设电源域保持上电。</p><p><code>esp_sleep_enable_ext1_wakeup()</code> 函数可用于启用此唤醒源。</p></li><li><p>Touch pad wakeup</p><p>RTC IO 模块包含触摸传感器中断时触发唤醒的逻辑。您需要在芯片开始睡眠之前配置触摸传感器中断。</p><p>当 RTC 外设未被强制上电时，ESP32 的修订版 0 和 1 仅支持此唤醒模式。</p><p><code>esp_sleep_enable_touchpad_wakeup()</code> 函数可用于启用此唤醒源。</p></li><li><p>GPIO wakeup <strong>(light sleep only)</strong></p><p>除了上面描述的 EXT0 和 EXT1 唤醒源之外，在 Light-sleep 模式下还有一种从外部输入唤醒的方法。通过该唤醒源，每个引脚可以使用 <code>gpio_wakeup_enable()</code> 函数单独配置为高电平或低电平唤醒。与 EXT0 和 EXT1 唤醒源（只能与 RTC IO 一起使用）不同，此唤醒源可用于任何 IO（RTC 或数字）。</p><p><code>esp_sleep_enable_gpio_wakeup()</code> 函数可用于启用此唤醒源。</p></li></ol><h3 id="4-2-ULP-协处理器唤醒"><a href="#4-2-ULP-协处理器唤醒" class="headerlink" title="4.2 ULP 协处理器唤醒"></a>4.2 ULP 协处理器唤醒</h3><p>参考示例: <a href="https://github.com/espressif/esp-idf/tree/release/v3.2/examples/system/ulp" target="_blank" rel="noopener">system/ulp</a></p><p>ULP 协处理器可以在芯片处于睡眠模式时运行，并且可以用于轮询传感器，监视 ADC 或触摸传感器值，并在检测到特定事件时唤醒芯片。ULP 协处理器是 RTC 外设电源域的一部分，它运行存储在 RTC 慢速存储器中的程序。如果请求此唤醒模式，RTC 慢速存储器将在睡眠期间启动。在 ULP 协处理器开始运行程序之前，RTC 外设将自动上电; 程序停止运行后，RTC 外设将再次自动关闭。</p><p>当 RTC 外设未被强制上电时，ESP32 的修订版 0 和 1 仅支持此唤醒模式。</p><p><code>esp_sleep_enable_ulp_wakeup()</code> 函数可用于启用此唤醒源。</p><h3 id="4-3-Timer"><a href="#4-3-Timer" class="headerlink" title="4.3 Timer"></a>4.3 Timer</h3><p>RTC 控制器具有内置定时器，可用于在预定义的时间后唤醒芯片。时间以微秒精度指定，但实际分辨率取决于为 RTC SLOW_CLK 选择的时钟源。</p><p>此唤醒模式不需要在睡眠期间打开 RTC 外设或 RTC 存储器。</p><p><code>esp_sleep_enable_timer_wakeup()</code> 函数可用于启用此唤醒源。</p><h3 id="4-4-UART-wakeup-light-sleep-only"><a href="#4-4-UART-wakeup-light-sleep-only" class="headerlink" title="4.4 UART wakeup (light sleep only)"></a>4.4 UART wakeup (light sleep only)</h3><p>仅支持  Light-sleep 模式。当 ESP32 从外部设备接收 UART 输入时，通常需要在输入数据可用时唤醒芯片。UART 外设包含一项功能，当看到 RX 引脚上的一定数量的上升沿时，可以将芯片从 Light-sleep 状态唤醒。可以使用 <code>uart_set_wakeup_threshold()</code> 函数设置此上升沿数。请注意，唤醒后 UART 不会接收触发唤醒的字符（及其前面的任何字符）。这意味着外部设备通常需要在发送数据之前向 ESP32 发送额外字符以触发唤醒。</p><p><code>esp_sleep_enable_uart_wakeup()</code> 函数可用于启用此唤醒源。</p><h2 id="5-GPIO-Hold-功能"><a href="#5-GPIO-Hold-功能" class="headerlink" title="5 GPIO Hold 功能"></a>5 GPIO Hold 功能</h2><p>每个 IO pad(包括 RTC pad)都有单独的 hold 功能，由 RTC 寄存器控制。pad 的 hold 功能被置上后，pad 在置上 hold 那一刻的状态被强制保持，无论内部信号如何变化，修改 IO_MUX 配置或者 GPIO 配置，都不会改变 pad 的状态。应用如果希望在看门狗超时触发内核复位和系统复位时或者 Deep-sleep 时 pad 的状态不被改变，就需要提前把 hold 置上。</p><blockquote><p>在 Deep-sleep 模式下使用 Hold 功能，可能会增加功耗。并且如果使用内部上拉或下拉电阻，需要在睡眠期间使 RTC 外设电源域保持上电。</p></blockquote><blockquote><p>在睡眠模式下，部分引脚的电源域可能关掉了，所以无法 Hold 功能无法生效，这时需要确认能否打开电源域。例如：GPIO16、17 会在 light sleep 下关闭电源域 VDD_SDIO，所以无法 Hold，这时需要在 esp_light_sleep_start() 中修改代码打开电源域。</p></blockquote><p>针对 RTC IO，可对<strong>单个 RTC Pad 使能 Hold 功能</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rtc_gpio_init(<span class="number">27</span>);</span><br><span class="line">rtc_gpio_set_direction(<span class="number">27</span>, RTC_GPIO_MODE_OUTPUT_ONLY);</span><br><span class="line">rtc_gpio_set_level(<span class="number">27</span>, <span class="number">1</span>);</span><br><span class="line">rtc_gpio_pullup_en(<span class="number">27</span>);</span><br><span class="line">rtc_gpio_hold_en(<span class="number">27</span>);</span><br></pre></td></tr></table></figure><p>针对 数字 IO，会对<strong>所有 数字 IO 使能 Hold 功能</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gpio_pad_select_gpio(<span class="number">26</span>);</span><br><span class="line">gpio_set_direction(<span class="number">26</span>, GPIO_MODE_OUTPUT);</span><br><span class="line">gpio_set_level(<span class="number">26</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">gpio_hold_en(<span class="number">26</span>);</span><br><span class="line"><span class="comment">/*When the chip is in Deep-sleep mode, all digital gpio will hold the state before sleep, and when the chip is woken up, the status of digital gpio will not be held.*/</span></span><br><span class="line">gpio_deep_sleep_hold_en();</span><br></pre></td></tr></table></figure><h2 id="6-常见问题"><a href="#6-常见问题" class="headerlink" title="6 常见问题"></a>6 常见问题</h2><ol><li><p>进入 Deep-sleep 后，功耗较高</p><p> 有这些原因可能会导致功耗较高：</p><ul><li><code>esp_sleep_enable_ext0_wakeup()</code> 需要打开 RTC 外设，产生额外的 100mA 左右的电流消耗，调用 <code>esp_sleep_enable_ext1_wakeup()</code> 则不需要打开 RTC 外设，即不会产生额外的电流。</li><li>在 IDF 3.1.1 前的版本可能存在使用 wifi 并关闭后进入睡眠模式，功耗比未使用 wifi 后进入睡眠模式高 1mA 左右。这种情况下，需要在进入睡眠模式前调用 <code>adc_power_off()</code> 关闭 ADC 以解决这个问题。</li><li>使用 Hold 功能保持一个固定电平，可能会增加功耗 1mA 左右，这种情况也是由于打开 RTC 外设导致。</li><li>某些 GPIO 漏电，一些 ESP32 IO 具有内部上拉或下拉，默认情况下启用。如果外部电路在 Deep-sleep 模式下驱动此引脚，则由于流过这些上拉和下拉的电流，电流消耗可能会增加。要隔离引脚，防止额外的电流消耗，请调用 <code>rtc_gpio_isolate()</code> 函数。例如：ESP32-WROVER 模组上，外部上拉 GPIO12。GPIO12 在 ESP32 芯片中也有内部下拉。这意味着在 Deep-sleep 中，一些电流将流过这些外部和内部电阻，从而增加电流消耗。</li><li>某些 IO 芯片内外电压不匹配，可能会增加电流消耗。如果存在电压不匹配的情况，需要在进入睡眠模式前配置 IO 为 Disable 模式，并使能 Hold 功能。</li></ul></li><li><p>使能 自动 Light-sleep 后，功耗较高</p><ul><li>存在任务持续运行占用 CPU 资源，导致 CPU 负载过大无法休眠。若是这种情况，请检测是否存在 任务 持续运行，并优化当前应用程序流程使 CPU 能周期性空闲进入 Light-sleep 模式。</li><li>若系统应用中有小于 DTIM Beacon 间隔时间的循环定时，系统将不能进入 Light-sleep 模式。</li><li>若未使用最新 IDF 3.2 版本，可能会因为某些外设使用（例如：I2C、I2S），导致无法自动进入 Light-sleep 模式。若是这个问题，请更新到最新的 IDF 3.2 版本。</li><li>若系统不需要 FreeRTOS 时钟配置为 1000 Hz，可将 FreeRTOS 时钟降低为 100 Hz，可显著降低功耗。</li></ul></li><li><p>自动 Light-sleep 调试方法</p><ul><li>在 menuconfig 中使能 <a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/kconfig.html#config-pm-profiling" target="_blank" rel="noopener">CONFIG_PM_PROFILING</a> ，如果使能，<code>esp_pm_*</code> 函数将跟踪每个电源管理锁的保留时间，<code>esp_pm_dump_locks</code> 函数将打印此信息。 此功能可用于分析哪些锁阻止芯片进入低功耗状态，并查看芯片在每种省电模式下花费的时间，并应在应用程序中保持禁用状态。</li><li>在 menuconfig 中使能 <a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/kconfig.html#config-pm-trace" target="_blank" rel="noopener">CONFIG_PM_TRACE</a>，如果使能，某些 GPIO 将用于发出 RTOS 滴答，频率切换，进入/退出空闲状态等事件的信号。有关 GPIO 列表，请参阅 <code>pm_trace.c</code> 文件。 此功能旨在用于分析/调试电源管理实现的行为时使用，并应在应用程序中保持禁用状态。</li></ul></li></ol><h2 id="7-不同功耗模式下的功耗"><a href="#7-不同功耗模式下的功耗" class="headerlink" title="7 不同功耗模式下的功耗"></a>7 不同功耗模式下的功耗</h2><p><img src="https://img-blog.csdnimg.cn/20200617144756531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70#pic_center" alt="不同功耗模式下的功耗"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP32-低功耗模式&quot;&gt;&lt;a href=&quot;#ESP32-低功耗模式&quot; class=&quot;headerlink&quot; title=&quot;ESP32 低功耗模式&quot;&gt;&lt;/a&gt;ESP32 低功耗模式&lt;/h1&gt;&lt;h2 id=&quot;1-概要&quot;&gt;&lt;a href=&quot;#1-概要&quot; class=&quot;headerlink&quot; title=&quot;1 概要&quot;&gt;&lt;/a&gt;1 概要&lt;/h2&gt;&lt;p&gt;ESP32 系列芯片提供三种可配置的睡眠模式，针对这些睡眠模式,我们提供了了多种低功耗解决方案，用户可以结合具体需求选择睡眠模式并进行配置。三种睡眠模式如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Modem-sleep 模式：CPU 可运行，时钟可被配置。Wi-Fi/蓝牙基带和射频关闭。&lt;/li&gt;
&lt;li&gt;Light-sleep 模式：CPU 暂停运行，Wi-Fi/蓝牙基带和射频关闭。&lt;strong&gt;RTC 存储器和外设以及 ULP 协处理器运行&lt;/strong&gt;。任何唤醒事件(MAC、主机、RTC 定时器或外部中断)都会唤醒芯片。&lt;/li&gt;
&lt;li&gt;Deep-sleep 模式：CPU 和大部分外设都会掉电，Wi-Fi/蓝牙基带和射频关闭，只有 &lt;strong&gt;RTC 存储器和 RTC 外设以及 ULP 协处理器&lt;/strong&gt;可以工作。Wi-Fi 和蓝牙连接数据存储在 RTC 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种模式的区别如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十五）使用 LittlevGL 实现 2048 小游戏</title>
    <link href="https://blog.infiniteyuan.com/2020/05/17/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E4%BD%BF%E7%94%A8%20LittlevGL%20%E5%AE%9E%E7%8E%B0%202048%20%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <id>https://blog.infiniteyuan.com/2020/05/17/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E4%BD%BF%E7%94%A8%20LittlevGL%20%E5%AE%9E%E7%8E%B0%202048%20%E5%B0%8F%E6%B8%B8%E6%88%8F/</id>
    <published>2020-05-17T14:43:38.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-LittlevGL-实现-2048-小游戏"><a href="#使用-LittlevGL-实现-2048-小游戏" class="headerlink" title="使用 LittlevGL 实现 2048 小游戏"></a>使用 LittlevGL 实现 2048 小游戏</h1><p>2048 这款益智小游戏，游戏的规则十分简单，简单易上手的数字小游戏，但又十分虐心。曾经也是风靡一时。</p><p>现在我们在 ESP32 上自己动手实现 2048 这款小游戏吧。</p><a id="more"></a><h2 id="1-使用-LittlevGL"><a href="#1-使用-LittlevGL" class="headerlink" title="1 使用 LittlevGL"></a>1 使用 LittlevGL</h2><p>esp32-lvgl-gui 仓库已经适配了 LittlevGL V5.3，并适配了几款屏幕(ILI9341、ST7789、SSD1306、NT35510) 和 触摸驱动(FT5X06、XPT2046)。</p><p>使用时，在 <code>menuconfig</code> 中选择你所使用的 屏幕 和 触摸驱动。</p><p>编译代码：</p><ol><li>添加头文件：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lvgl includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iot_lvgl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* game include */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"game.h"</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>初始化 LittlevGL：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Initialize LittlevGL */</span></span><br><span class="line">    lv_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tick interface， Initialize a Timer for 1 ms period and in its interrupt call*/</span></span><br><span class="line">    <span class="comment">// esp_register_freertos_tick_hook(lv_tick_task_callback);</span></span><br><span class="line">    lvgl_tick_timer = xTimerCreate(</span><br><span class="line">        <span class="string">"lv_tickinc_task"</span>,</span><br><span class="line">        <span class="number">1</span> / portTICK_PERIOD_MS,            <span class="comment">//period time</span></span><br><span class="line">        pdTRUE,                            <span class="comment">//auto load</span></span><br><span class="line">        (<span class="keyword">void</span> *)<span class="literal">NULL</span>,                      <span class="comment">//timer parameter</span></span><br><span class="line">        lv_tick_task_callback);            <span class="comment">//timer callback</span></span><br><span class="line">    xTimerStart(lvgl_tick_timer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Display interface */</span></span><br><span class="line">    lvgl_lcd_display_init();           <span class="comment">/*Initialize your display*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Input device interface */</span></span><br><span class="line">    input_device = lvgl_indev_init();                     <span class="comment">/*Initialize your indev*/</span></span><br><span class="line"></span><br><span class="line">    lvgl_timer = xTimerCreate(</span><br><span class="line">        <span class="string">"lv_task"</span>,</span><br><span class="line">        <span class="number">10</span> / portTICK_PERIOD_MS,           <span class="comment">//period time</span></span><br><span class="line">        pdTRUE,                            <span class="comment">//auto load</span></span><br><span class="line">        (<span class="keyword">void</span> *)<span class="literal">NULL</span>,                      <span class="comment">//timer parameter</span></span><br><span class="line">        lvgl_task_time_callback);          <span class="comment">//timer callback</span></span><br><span class="line">    xTimerStart(lvgl_timer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2048 game init</span></span><br><span class="line">    game_init(<span class="number">480</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// game logic handle task</span></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        user_task,   <span class="comment">//Task Function</span></span><br><span class="line">        <span class="string">"user_task"</span>, <span class="comment">//Task Name</span></span><br><span class="line">        <span class="number">1024</span>*<span class="number">4</span>,      <span class="comment">//Stack Depth</span></span><br><span class="line">        <span class="literal">NULL</span>,        <span class="comment">//Parameters</span></span><br><span class="line">        <span class="number">1</span>,           <span class="comment">//Priority</span></span><br><span class="line">        <span class="literal">NULL</span>);       <span class="comment">//Task Handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2048-游戏逻辑"><a href="#2-2048-游戏逻辑" class="headerlink" title="2 2048 游戏逻辑"></a>2 2048 游戏逻辑</h2><h3 id="2-1-界面初始化"><a href="#2-1-界面初始化" class="headerlink" title="2.1 界面初始化"></a>2.1 界面初始化</h3><p>将游戏相关界面初始化分为以下几步：</p><ol><li>Step 1: 画游戏背景</li><li>Step 2: 画游戏分数显示框</li><li>Step 3: 画游戏网格</li><li>Step 4: 画游戏网格中每个单元格的内容</li></ol><h3 id="2-2-滑动处理"><a href="#2-2-滑动处理" class="headerlink" title="2.2 滑动处理"></a>2.2 滑动处理</h3><h4 id="2-2-1-判断滑动方向"><a href="#2-2-1-判断滑动方向" class="headerlink" title="2.2.1 判断滑动方向"></a>2.2.1 判断滑动方向</h4><p>通过调用 LittlevGL 的 API 读取触摸状态(抬起/按下、坐标点)，计算水平/竖直方向滑动的差值，判断为哪个方向上的滑动(上/下/左/右)，执行相应的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">lv_indev_drv_t</span> input_device;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">user_task</span><span class="params">(<span class="keyword">void</span> *pvParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> pressing = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">lv_indev_data_t</span> touchpad_data;</span><br><span class="line">    <span class="keyword">lv_point_t</span> last_data;</span><br><span class="line">    <span class="keyword">int16_t</span> x_diff, y_diff;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(<span class="number">50</span> / portTICK_PERIOD_MS);</span><br><span class="line">        input_device.<span class="built_in">read</span>(&amp;touchpad_data); <span class="comment">// 读取触摸驱动的值</span></span><br><span class="line">        <span class="keyword">if</span> (touchpad_data.state == LV_INDEV_STATE_REL) &#123; <span class="comment">// 当前为 `抬起` 状态</span></span><br><span class="line">            pressing = <span class="literal">false</span>; <span class="comment">// 计算坐标偏移量</span></span><br><span class="line">            x_diff = touchpad_data.<span class="built_in">point</span>.x - last_data.x;</span><br><span class="line">            y_diff = touchpad_data.<span class="built_in">point</span>.y - last_data.y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(x_diff) &gt; SENSITIVE || <span class="built_in">fabs</span>(y_diff) &gt; SENSITIVE) &#123; <span class="comment">// 判断滑动距离是否超过判断阈值</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(x_diff) &gt; <span class="built_in">fabs</span>(y_diff)) &#123; <span class="comment">// 判断是否为水平滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (x_diff &gt; <span class="number">0</span>) &#123; <span class="comment">// 判单是否为向右滑动</span></span><br><span class="line">                        move_right();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向左滑动</span></span><br><span class="line">                        move_left();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 竖直方向滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (y_diff &gt; <span class="number">0</span>) &#123; <span class="comment">// 判单是否为向下滑动</span></span><br><span class="line">                        move_down();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向上滑动</span></span><br><span class="line">                        move_up();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last_data.x = touchpad_data.<span class="built_in">point</span>.x;</span><br><span class="line">            last_data.y = touchpad_data.<span class="built_in">point</span>.y;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (touchpad_data.state == LV_INDEV_STATE_PR) &#123; <span class="comment">// 当前为 `按下` 状态</span></span><br><span class="line">            <span class="keyword">if</span> (!pressing) &#123; <span class="comment">// 按下状态，记录初次按下的坐标点</span></span><br><span class="line">                last_data.x = touchpad_data.<span class="built_in">point</span>.x;</span><br><span class="line">                last_data.y = touchpad_data.<span class="built_in">point</span>.y;</span><br><span class="line">                pressing = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-滑动逻辑处理"><a href="#2-2-2-滑动逻辑处理" class="headerlink" title="2.2.2 滑动逻辑处理"></a>2.2.2 滑动逻辑处理</h4><ol><li>判断同一行/列滑动方向上是否存在相等的数值</li><li>相同的单元格，数值相加为相邻单元格中的后一个(滑动方向上)的数值</li><li>画出总的得分</li><li>判断游戏是否结束</li><li>刷新界面上的单元格</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> num_matrix[<span class="number">5</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 保存所有的单元格中的数值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> score_num = <span class="number">0</span>; <span class="comment">// 总得分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_up</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t, nx = <span class="number">-1</span>, ny = <span class="number">0</span>, nn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i)</span><br><span class="line">        tmp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num_matrix[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[++k] = num_matrix[i][j];</span><br><span class="line">                num_matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &lt;= k - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[t] == tmp[t + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t] *= <span class="number">2</span>;</span><br><span class="line">                tmp[t + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                score_num += tmp[t];</span><br><span class="line">                <span class="keyword">if</span> (nx == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nx = t;</span><br><span class="line">                    ny = j;</span><br><span class="line">                    nn = tmp[t];</span><br><span class="line">                &#125;</span><br><span class="line">                t += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t++;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            <span class="keyword">if</span> (tmp[i])</span><br><span class="line">                num_matrix[t++][j] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画总分</span></span><br><span class="line">    draw_score_num(score_num);</span><br><span class="line">    <span class="comment">// 刷新网格中单元格的内容</span></span><br><span class="line">    gen_num();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>GitHub 源码：<a href="https://github.com/InfiniteYuan/esp32-lvgl-gui/tree/master/lvgl_2048" target="_blank" rel="noopener">esp32-lvgl-gui</a></li><li>Twitter 视频：<a href="https://twitter.com/InfiniteYuan/status/1048106496649641985?s=20" target="_blank" rel="noopener">Twitter</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-LittlevGL-实现-2048-小游戏&quot;&gt;&lt;a href=&quot;#使用-LittlevGL-实现-2048-小游戏&quot; class=&quot;headerlink&quot; title=&quot;使用 LittlevGL 实现 2048 小游戏&quot;&gt;&lt;/a&gt;使用 LittlevGL 实现 2048 小游戏&lt;/h1&gt;&lt;p&gt;2048 这款益智小游戏，游戏的规则十分简单，简单易上手的数字小游戏，但又十分虐心。曾经也是风靡一时。&lt;/p&gt;
&lt;p&gt;现在我们在 ESP32 上自己动手实现 2048 这款小游戏吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二十八） ESP32 串口下载过程(使用 esptool) [转]</title>
    <link href="https://blog.infiniteyuan.com/2020/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%20ESP32%20%E4%B8%B2%E5%8F%A3%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B(%E4%BD%BF%E7%94%A8%20esptool)%20[%E8%BD%AC]/"/>
    <id>https://blog.infiniteyuan.com/2020/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%20ESP32%20%E4%B8%B2%E5%8F%A3%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B(%E4%BD%BF%E7%94%A8%20esptool)%20[%E8%BD%AC]/</id>
    <published>2020-03-12T15:38:11.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP32-串口下载过程-使用-esptool"><a href="#ESP32-串口下载过程-使用-esptool" class="headerlink" title="ESP32 串口下载过程(使用 esptool)"></a>ESP32 串口下载过程(使用 esptool)</h1><p>原文链接：<a href="https://www.esp32.com/viewtopic.php?f=25&amp;t=8161&amp;p=34283#p34283" target="_blank" rel="noopener">https://www.esp32.com/viewtopic.php?f=25&amp;t=8161&amp;p=34283#p34283</a></p><p>通常，我们会通过 python 脚本，从 PC 端，通过串口给 esp32 芯片或者模块下载固件程序。<br>通过 esptool (<a href="https://github.com/espressif/esptool" target="_blank" rel="noopener">https://github.com/espressif/esptool</a>) 脚本，我们可以很方便的实现。</p><p>但有时，我们也希望能通过其他单片机的串口，给 esp32/esp8266 进行固件更新。（前提是外部单片机能够控制esp32 进入串口下载模式)。<br>完整的串口通信协议可以参考这里(<a href="https://github.com/espressif/esptool/w" target="_blank" rel="noopener">https://github.com/espressif/esptool/w</a> … -Protocol)<br>为了方便调试，我们可以通过运行 esptool，来查看上位机与esp32之间的通信过程。</p><a id="more"></a><p>首先，esp32 的串口通信协议基于 SLIP (Serial Line Internet Protocol)。任何一个数据包以0xC0开始，以0xC0结尾。数据包内容中的0xC0替换为0xDB 0xDC。数据包内容中的0xDB替换为0xDB 0xDD.</p><p>在运行esptool的同时，在命令中添加 –trace 参数，即可查看通信过程中的串口数据。</p><p>以读取 flash id 的过程为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python esptool.py -b <span class="number">115200</span> -p /dev/cu.SLAB_USBtoUART --trace --no-stub flash_id</span><br></pre></td></tr></table></figure><p>从输出的 log 中，我们可以看到串口通信的具体内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TRACE +<span class="number">0.000</span> command op=<span class="number">0x09</span> data len=<span class="number">16</span> wait_response=<span class="number">1</span> timeout=<span class="number">3.000</span> data=<span class="number">1</span>c20006040000080ffffffff00000000</span><br><span class="line">TRACE +<span class="number">0.000</span> Write <span class="number">26</span> bytes: </span><br><span class="line">    c000091000000000 <span class="number">001</span>c200060400000 | .......... .`@..</span><br><span class="line">    <span class="number">80f</span>fffffff000000 <span class="number">00</span>c0             | ..........</span><br><span class="line">TRACE +<span class="number">0.004</span> Read <span class="number">1</span> bytes: c0</span><br><span class="line">TRACE +<span class="number">0.000</span> Read <span class="number">13</span> bytes: <span class="number">01090400</span>c840160000000000c0</span><br><span class="line">TRACE +<span class="number">0.000</span> Received full packet: <span class="number">01090400</span>c840160000000000</span><br></pre></td></tr></table></figure><p>上面的 log 中，串口向 esp32 发送 26 字节十六进制序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c000091000000000001c20006040000080ffffffff00000000c0</span><br></pre></td></tr></table></figure><p>esp32 向串口返回13字节十六进制序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c001090400c840160000000000c0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP32-串口下载过程-使用-esptool&quot;&gt;&lt;a href=&quot;#ESP32-串口下载过程-使用-esptool&quot; class=&quot;headerlink&quot; title=&quot;ESP32 串口下载过程(使用 esptool)&quot;&gt;&lt;/a&gt;ESP32 串口下载过程(使用 esptool)&lt;/h1&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://www.esp32.com/viewtopic.php?f=25&amp;amp;t=8161&amp;amp;p=34283#p34283&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.esp32.com/viewtopic.php?f=25&amp;amp;t=8161&amp;amp;p=34283#p34283&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通常，我们会通过 python 脚本，从 PC 端，通过串口给 esp32 芯片或者模块下载固件程序。&lt;br&gt;通过 esptool (&lt;a href=&quot;https://github.com/espressif/esptool&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/espressif/esptool&lt;/a&gt;) 脚本，我们可以很方便的实现。&lt;/p&gt;
&lt;p&gt;但有时，我们也希望能通过其他单片机的串口，给 esp32/esp8266 进行固件更新。（前提是外部单片机能够控制esp32 进入串口下载模式)。&lt;br&gt;完整的串口通信协议可以参考这里(&lt;a href=&quot;https://github.com/espressif/esptool/w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/espressif/esptool/w&lt;/a&gt; … -Protocol)&lt;br&gt;为了方便调试，我们可以通过运行 esptool，来查看上位机与esp32之间的通信过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二十七） ESP32 的启动过程 [转]</title>
    <link href="https://blog.infiniteyuan.com/2020/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%20ESP32%20%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%20[%E8%BD%AC]/"/>
    <id>https://blog.infiniteyuan.com/2020/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%20ESP32%20%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%20[%E8%BD%AC]/</id>
    <published>2020-03-12T15:22:04.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP32-的启动过程"><a href="#ESP32-的启动过程" class="headerlink" title="ESP32 的启动过程"></a>ESP32 的启动过程</h1><p>原文来自：<a href="https://www.esp32.com/viewtopic.php?f=25&amp;t=8030&amp;p=33812#p33812" target="_blank" rel="noopener">https://www.esp32.com/viewtopic.php?f=25&amp;t=8030&amp;p=33812#p33812</a></p><h2 id="关于-ROM"><a href="#关于-ROM" class="headerlink" title="[关于 ROM]"></a>[关于 ROM]</h2><p>在 esp32 上电运行后，芯片运行的第一个程序。这段程序是芯片设计与生产的时候，固化在硬件电路中的。所以它是不可修改的(Read Only Memory)。<br>esp32 的 ROM 负责检测芯片的strapping配置，来决定芯片应该处于什么状态。比如，esp32 上电后，ROM 程序会检查 [GPIO0, GPIO2, GPIO4, MTDO, GPIO5]的状态。<br>如果 GPIO0 / GPIO2 同时为低电平，则会进入下载模式，等待串口通信信息。<br>如果GPIO0为高电平，则会进入Flash 运行模式，启动SPI 驱动，并加载Flash中的程序段。</p><a id="more"></a><p>BOOT_MODE[5:0]:<br>(pull-up, pull-down, pull-down, pull-up, pull-up, SW4 /5/4/3/2/1/ )<br>[GPIO0, GPIO2, GPIO4, MTDO, GPIO5]<br>1 x x x x –&gt; SPI Boot<br>0 0 x x x –&gt; Download Boot (Jonit-Detection of UART0+UART1+SDIO_Slave)</p><p>下载模式的串口输出如下(115200), ROM默认会输出当前所处的模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rst:<span class="number">0x1</span> (POWERON_RESET),boot:<span class="number">0x3</span> (DOWNLOAD_BOOT(UART0/UART1/SDIO_REI_REO_V2))</span><br><span class="line">waiting <span class="keyword">for</span> download</span><br></pre></td></tr></table></figure><p>其中，boot:0x3 表示的是芯片strapping pin脚的状态，<br>0x03对应 [GPIO0, GPIO2, GPIO4, MTDO, GPIO5] 的值为 [ 0, 0, 0, 1, 1]<br>所以处于 Download Boot 模式。</p><h2 id="关于下载模式"><a href="#关于下载模式" class="headerlink" title="[关于下载模式]"></a>[关于下载模式]</h2><p>当 esp32 处于下载模式时，会等待串口通信同步，并按照通信协议等待接收指令(协议可参考该文档：<a href="https://github.com/espressif/esptool/wiki/Serial-Protocol" target="_blank" rel="noopener">Serial-Protocol</a><br>通过esptool脚本，可以进行寄存器的读写，固件下载，程序运行等操作。</p><h2 id="关于STUB"><a href="#关于STUB" class="headerlink" title="[关于STUB]"></a>[关于STUB]</h2><p>在 ROM 模式，由于芯片处于低频工作的状态，通信速率受限。<br>在 esptool 中，会将一段小程序加载到 esp32 的 RAM 中，并跳转执行 RAM 中的小程序。这段小程序包含了 ROM 中相同的串口通信协议，并对其进行了扩充。感兴趣的开发者，(可以参考这里 <a href="https://github.com/espressif/esptool/tree/master/flasher_stub" target="_blank" rel="noopener">flasher_stub</a>)</p><h2 id="关于-Flash-Boot-模式"><a href="#关于-Flash-Boot-模式" class="headerlink" title="[关于 Flash Boot 模式]"></a>[关于 Flash Boot 模式]</h2><p>如果芯片启动时，GPIO0 为高电平，芯片会进入 Flash 运行模式。 此时，启动 SPI 驱动，并加载 Flash 中的程序段。ROM 会读取外置 Flash 的 0x1000 地址，加载并运行二级 bootloader。</p><h2 id="关于-Bootloader"><a href="#关于-Bootloader" class="headerlink" title="[关于 Bootloader]"></a>[关于 Bootloader]</h2><p>bootloader 可以认为是一个独立的小程序，bootloader 会对芯片频率进行初始化，并且读取系统 SPI 的配置信息，对 Flash 运行模式以及频率进行配置，然后根据分区表的定义，从对应的地址加载应用程序，并且运行应用程序固件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP32-的启动过程&quot;&gt;&lt;a href=&quot;#ESP32-的启动过程&quot; class=&quot;headerlink&quot; title=&quot;ESP32 的启动过程&quot;&gt;&lt;/a&gt;ESP32 的启动过程&lt;/h1&gt;&lt;p&gt;原文来自：&lt;a href=&quot;https://www.esp32.com/viewtopic.php?f=25&amp;amp;t=8030&amp;amp;p=33812#p33812&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.esp32.com/viewtopic.php?f=25&amp;amp;t=8030&amp;amp;p=33812#p33812&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于-ROM&quot;&gt;&lt;a href=&quot;#关于-ROM&quot; class=&quot;headerlink&quot; title=&quot;[关于 ROM]&quot;&gt;&lt;/a&gt;[关于 ROM]&lt;/h2&gt;&lt;p&gt;在 esp32 上电运行后，芯片运行的第一个程序。这段程序是芯片设计与生产的时候，固化在硬件电路中的。所以它是不可修改的(Read Only Memory)。&lt;br&gt;esp32 的 ROM 负责检测芯片的strapping配置，来决定芯片应该处于什么状态。比如，esp32 上电后，ROM 程序会检查 [GPIO0, GPIO2, GPIO4, MTDO, GPIO5]的状态。&lt;br&gt;如果 GPIO0 / GPIO2 同时为低电平，则会进入下载模式，等待串口通信信息。&lt;br&gt;如果GPIO0为高电平，则会进入Flash 运行模式，启动SPI 驱动，并加载Flash中的程序段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十四）ESP32 I2C Slave 实现</title>
    <link href="https://blog.infiniteyuan.com/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89ESP32%20I2C%20Slave%20%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.infiniteyuan.com/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89ESP32%20I2C%20Slave%20%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-11-22T01:24:44.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文章将介绍使用 ESP32 作为 I2C 实现 Random Read/Write 和  Sequential Read/Write 时序。</p><p>首先通过下面的图了解下 Random Read 时序，I2C Master 通过这个时序读取任意数据地址开始的数据。<br><img src="https://img-blog.csdnimg.cn/20191123145556881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="Random Read"></p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">___________________________________________________________________________________________________________________________________________________</span><br><span class="line">| start | slave_addr + write_bit + ack | data address |start | slave_addr + read_bit + ack |  <span class="built_in">read</span> n<span class="number">-1</span> bytes + ack | <span class="built_in">read</span> <span class="number">1</span> <span class="keyword">byte</span> + nack | <span class="built_in">stop</span> |</span><br></pre></td></tr></table></figure><blockquote><p><strong>RANDOM READ</strong>: A random read requires a “dummy” byte write sequence to load in the data word address. Once the device address word and data word address are clocked in and acknowledged by the EEPROM, the microcontroller must generate another start condition.<br>The microcontroller now initiates a current address read by sending a device address with the read/write select bit high. The EEPROM acknowledges the device address and serially clocks out the data word. The microcontroller does not respond with a zero but does generate a following stop condition </p></blockquote><ul><li>现有的 I2C Slave 无法实现类似 Random Read 时序<ul><li>原因分析：esp-idf 提供的 <code>i2c_slave_write_buffer</code> <code>i2c_slave_read_buffer</code> API 都是操作 RingBuffer 实现，而 Random Read 需要 Slave 在 接收到 <code>slave_addr + read_bit + data address</code> 前将数据放入 I2C 的硬件 FIFO 中。若是通过 API 进行判断当前 Master 想要操作的 数据地址，会因为这个 API 都是操作 RingBuffer 而有所延迟，导致 Master 接收到错误的数据（因为此时硬件 FIFO 还没有数据）。</li><li>解决办法：<ul><li>在接收到 <code>slave_addr + write_bit + data address</code> 时将可能需要发送到主机的数据放入 TX FIFO 中，当主机继续发送 <code>slave_addr + read_bit + data address</code> 并 提供读数据时钟 时，I2C Slave 硬件会将 TX FIFO 中的数据发送到 Master。若主机不再发送 <code>slave_addr + read_bit + data address</code>，就将 FIFO 清空避免在之后的操作中造成错误。</li><li>通过自定义中断处理程序，在相应的中断中进行处理</li></ul></li></ul></li></ul><h1 id="I2C-中断介绍"><a href="#I2C-中断介绍" class="headerlink" title="I2C 中断介绍"></a>I2C 中断介绍</h1><ol><li>想要针对某个 I2C 或者 某种模式，使用自定义的中断处理程序，需要修改 <code>esp-idf/components/driver/i2c.c</code> 中的代码，这里仅仅针对 master 使用驱动中提供的中断处理程序，当模式为 Slave 时，使用自定义的中断处理程序。</li></ol><blockquote><p>在 release/3.2 中，无法直接使用 <code>i2c_isr_register</code> 覆盖之前的中断处理程序。通过简单修改驱动源文件，并在应用程序中调用 <code>i2c_isr_register</code> 实现使用自定义的中断处理程序。</p></blockquote><p>修改 <code>esp-idf/components/driver/i2c.c</code> 文件中 <code>i2c_driver_install</code>  函数中的这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == I2C_MODE_MASTER) &#123;</span><br><span class="line">    <span class="comment">//hook isr handler</span></span><br><span class="line">    i2c_isr_register(i2c_num, i2c_isr_handler_default, p_i2c_obj[i2c_num], intr_alloc_flags, &amp;p_i2c_obj[i2c_num]-&gt;intr_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用程序中使用自定义的中断处理程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> IRAM_ATTR <span class="title">i2c_slave_isr_handler_default</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief i2c slave initialization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">i2c_slave_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i2c_slave_port = I2C_SLAVE_NUM;</span><br><span class="line">    <span class="keyword">i2c_config_t</span> conf_slave;</span><br><span class="line">    conf_slave.sda_io_num = I2C_SLAVE_SDA_IO;</span><br><span class="line">    conf_slave.sda_pullup_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf_slave.scl_io_num = I2C_SLAVE_SCL_IO;</span><br><span class="line">    conf_slave.scl_pullup_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf_slave.mode = I2C_MODE_SLAVE;</span><br><span class="line">    conf_slave.slave.addr_10bit_en = <span class="number">0</span>;</span><br><span class="line">    conf_slave.slave.slave_addr = ESP_SLAVE_ADDR;</span><br><span class="line">    i2c_param_config(i2c_slave_port, &amp;conf_slave);</span><br><span class="line">    i2c_driver_install(i2c_slave_port, conf_slave.mode, I2C_SLAVE_RX_BUF_LEN, I2C_SLAVE_TX_BUF_LEN, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i2c_isr_register(I2C_SLAVE_NUM, i2c_slave_isr_handler_default, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>) != ESP_OK) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"i2c_isr_register error"</span>);</span><br><span class="line">        <span class="keyword">return</span> ESP_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Slave-中断处理程序"><a href="#Slave-中断处理程序" class="headerlink" title="Slave 中断处理程序"></a>Slave 中断处理程序</h1><p>需要使用的几个中断：</p><ul><li><strong>I2C_SLAVE_TRAN_COMP_INT</strong>：从机收到设备地址和数据地址时将触发（device address + W/R bit + data address），在这里需要判断 Write/Read。若是 Write，需要清空 TX FIFO，并提前将需要操作的数据放入 TX FIFO 中（根据数据地址），尽可能放满 TX FIFO</li><li><strong>I2C_TRANS_COMPLETE_INT</strong>：从机检测到 STOP 时将触发，这个中断中需要将 RX FIFO 中的数据取到数据缓冲区中</li><li><strong>I2C_TXFIFO_EMPTY_INT</strong>：硬件 TX FIFO 为空时将触发，（PS：实际测试触发时，FIFO 大小为 27 byte），将可能操作的数据继续放入 TX FIFO 中</li><li><strong>I2C_RXFIFO_FULL_INT</strong>：硬件 RX FIFO 满时将触发，将 RX FIFO 中的数据取到数据缓冲区中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> IRAM_ATTR <span class="title">i2c_slave_isr_handler_default</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i2c_num = I2C_SLAVE_NUM;</span><br><span class="line">    <span class="keyword">uint32_t</span> status = I2C_INSTANCE[i2c_num]-&gt;int_status.val;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    portBASE_TYPE HPTaskAwoken = pdFALSE;</span><br><span class="line">    <span class="keyword">while</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        status = I2C_INSTANCE[i2c_num]-&gt;int_status.val;</span><br><span class="line">        <span class="keyword">if</span> (status &amp; I2C_ACK_ERR_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"ae\n"</span>);</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_ena.ack_err = <span class="number">0</span>;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.ack_err = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_TRANS_COMPLETE_INT_ST_M) &#123; <span class="comment">// receive data after receive device address + W/R bit and data address</span></span><br><span class="line">            <span class="comment">// ets_printf("tc, ");</span></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.trans_complete = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> rx_fifo_cnt = I2C_INSTANCE[i2c_num]-&gt;status_reg.rx_fifo_cnt;</span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                <span class="comment">// ets_printf("R\n");</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                <span class="comment">// ets_printf("W ");</span></span><br><span class="line">                ets_printf(<span class="string">"Slave Recv"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; rx_fifo_cnt; idx++) &#123;</span><br><span class="line">                    slave_data[w_r_index++] = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">                &#125;</span><br><span class="line">                ets_printf(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_full = <span class="number">1</span>;</span><br><span class="line">            slave_event = SLAVE_IDLE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_SLAVE_TRAN_COMP_INT_ST_M) &#123; <span class="comment">// slave receive device address + W/R bit + data address</span></span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                ets_printf(<span class="string">"sc, Slave Send\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                <span class="comment">// ets_printf("sc W\n");</span></span><br><span class="line">                w_r_index = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">                <span class="keyword">switch</span> (slave_event) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SLAVE_IDLE:</span><br><span class="line">                        ets_printf(<span class="string">"sc, I2W\n"</span>);</span><br><span class="line">                        <span class="comment">// reset tx fifo to avoid send last byte when master send read command next.</span></span><br><span class="line">                        i2c_reset_tx_fifo(i2c_num);</span><br><span class="line"></span><br><span class="line">                        slave_event = SLAVE_WRITE;</span><br><span class="line">                        slave_send_index = w_r_index;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> tx_fifo_rem = I2C_FIFO_LEN - I2C_INSTANCE[i2c_num]-&gt;status_reg.tx_fifo_cnt;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tx_fifo_rem; i++) &#123;</span><br><span class="line">                            WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), slave_data[slave_send_index++]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        I2C_INSTANCE[i2c_num]-&gt;int_ena.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                        I2C_INSTANCE[i2c_num]-&gt;int_clr.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.slave_tran_comp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_TXFIFO_EMPTY_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"tfe, "</span>);</span><br><span class="line">            <span class="keyword">int</span> tx_fifo_rem = I2C_FIFO_LEN - I2C_INSTANCE[i2c_num]-&gt;status_reg.tx_fifo_cnt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                ets_printf(<span class="string">"R\r\n"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tx_fifo_rem; i++) &#123;</span><br><span class="line">                    WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), slave_data[slave_send_index++]);</span><br><span class="line">                &#125;</span><br><span class="line">                I2C_INSTANCE[i2c_num]-&gt;int_ena.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                I2C_INSTANCE[i2c_num]-&gt;int_clr.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                ets_printf(<span class="string">"W\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_RXFIFO_OVF_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"rfo\n"</span>);</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_ovf = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_RXFIFO_FULL_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"rff\n"</span>);</span><br><span class="line">            <span class="keyword">int</span> rx_fifo_cnt = I2C_INSTANCE[i2c_num]-&gt;status_reg.rx_fifo_cnt;</span><br><span class="line">            <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; rx_fifo_cnt; idx++) &#123;</span><br><span class="line">                slave_data[w_r_index++] = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">            &#125;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_full = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ets_printf("%x\n", status);</span></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.val = status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//We only need to check here if there is a high-priority task needs to be switched.</span></span><br><span class="line">    <span class="keyword">if</span>(HPTaskAwoken == pdTRUE) &#123;</span><br><span class="line">        portYIELD_FROM_ISR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h1><ul><li><a href="https://github.com/InfiniteYuan/ESP32-I2C-Slave/tree/master" target="_blank" rel="noopener">ESP32-I2C-Slave</a></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf" target="_blank" rel="noopener">I2C Specification</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这篇文章将介绍使用 ESP32 作为 I2C 实现 Random Read/Write 和  Sequential Read/Write 时序。&lt;/p&gt;
&lt;p&gt;首先通过下面的图了解下 Random Read 时序，I2C Master 通过这个时序读取任意数据地址开始的数据。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191123145556881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70&quot; alt=&quot;Random Read&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十三）ESP32 ping 功能</title>
    <link href="https://blog.infiniteyuan.com/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89ESP32%20ping%20%E5%8A%9F%E8%83%BD/"/>
    <id>https://blog.infiniteyuan.com/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89ESP32%20ping%20%E5%8A%9F%E8%83%BD/</id>
    <published>2019-11-22T01:23:18.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">pingResults</span><span class="params">(<span class="keyword">ping_target_id_t</span> msgType, esp_ping_found * pf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"AvgTime:%.1fmS Sent:%d Rec:%d min(mS):%d max(mS):%d Resp(mS):%d Timeouts:%d Total Time:%d\n"</span>, (<span class="keyword">float</span>)pf-&gt;total_time/pf-&gt;recv_count, pf-&gt;send_count, pf-&gt;recv_count,  pf-&gt;min_time, pf-&gt;max_time ,pf-&gt;resp_time, pf-&gt;timeout_count, pf-&gt;total_time);</span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start_Ping_ESP32</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">uint32_t</span> ip_pinG = ipaddr_addr(<span class="string">"163.177.151.109"</span>);<span class="comment">//百度IP地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_count = <span class="number">2000</span>;<span class="comment">//ping的次数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_timeout = <span class="number">1000</span>; <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_delay = <span class="number">2000</span>; <span class="comment">//ping 的间隔</span></span><br><span class="line">    ping_deinit();</span><br><span class="line">    esp_ping_set_target(PING_TARGET_IP_ADDRESS_COUNT, &amp;ping_count, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_RCV_TIMEO, &amp;ping_timeout, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_DELAY_TIME, &amp;ping_delay, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_IP_ADDRESS, &amp;ip_pinG, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_RES_FN, &amp;pingResults, <span class="keyword">sizeof</span>(pingResults));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span> res = <span class="number">0</span>;</span><br><span class="line">    res = ping_init();</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"PING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error:%d\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ping&quot;&gt;&lt;a href=&quot;#ping&quot; class=&quot;headerlink&quot; title=&quot;ping&quot;&gt;&lt;/a&gt;ping&lt;/h1&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十二）LittlevGL 添加自定义字体和物理按键</title>
    <link href="https://blog.infiniteyuan.com/2019/05/12/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89LittlevGL%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E7%89%A9%E7%90%86%E6%8C%89%E9%94%AE/"/>
    <id>https://blog.infiniteyuan.com/2019/05/12/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89LittlevGL%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E7%89%A9%E7%90%86%E6%8C%89%E9%94%AE/</id>
    <published>2019-05-12T20:05:34.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LittlevGL-添加自定义字体"><a href="#LittlevGL-添加自定义字体" class="headerlink" title="LittlevGL 添加自定义字体"></a>LittlevGL 添加自定义字体</h1><ol><li>获取字库 <code>ttf</code> 文件<br>可以从一些网站上获取字库文件，比如<blockquote><p>请注意字体许可证</p></blockquote></li><li>生成源文件<br>使用 LittlevGL 提供的字库文件<a href="https://littlevgl.com/ttf-font-to-c-array" target="_blank" rel="noopener">转换工具</a>，将 <code>ttf</code> 字库文件转换为源文件。</li></ol><a id="more"></a><ol start="3"><li>将生成的源文件添加到 LittlevGL 工程中，添加以下代码声明字体：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern lv_font_t my_font_name;</span><br></pre></td></tr></table></figure>或者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LV_FONT_DECLARE(my_font_name);</span><br></pre></td></tr></table></figure>源代码中使用这个字体可以：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style.text.font &#x3D; &amp;my_font_name;</span><br></pre></td></tr></table></figure>或者将这个字体添加到当前使用的字体中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_font_add(&amp;my_font_name, &amp;current_use);</span><br></pre></td></tr></table></figure></li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LV_FONT_DECLARE(my_font_name);</span><br><span class="line"></span><br><span class="line">void lv_chinese_fonts1(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*Concatenate the fonts into one*&#x2F;</span><br><span class="line">&#x2F;&#x2F;    lv_font_add(&amp;arial_cyrillic_20, &amp;arial_ascii_20); 相同高度才可以添加到一起</span><br><span class="line">&#x2F;&#x2F;    lv_font_add(&amp;arial_math_20, &amp;arial_ascii_20);</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 创建一个新的样式，并且修改新样式的文本字体 *&#x2F;</span><br><span class="line">    static lv_style_t style1; </span><br><span class="line">    lv_style_copy(&amp;style1, &amp;lv_style_plain);</span><br><span class="line">    style1.text.font &#x3D; &amp;my_font_name; &#x2F;* 设置自定义字体 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;*Create a label and set new text*&#x2F;</span><br><span class="line">    lv_obj_t * label &#x3D; lv_label_create(lv_scr_act(), NULL); &#x2F;* 创建标签 *&#x2F;</span><br><span class="line">    lv_obj_set_pos(label, 10, 10);       &#x2F;* 设置相对位置 *&#x2F;</span><br><span class="line">    lv_label_set_style(label, &amp;style1);  &#x2F;* 设置样式 *&#x2F;</span><br><span class="line">    lv_label_set_text(label, &quot;Hello World!\n 世界你好,我是littleVGL!&quot;);      &#x2F;* 显示汉字 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LittlevGL-添加自定义符号"><a href="#LittlevGL-添加自定义符号" class="headerlink" title="LittlevGL 添加自定义符号"></a>LittlevGL 添加自定义符号</h1><p>流程：</p><ul><li>寻找合适的 <code>ttf</code> 文件（包含目标符号，可在 linux 下通过 FontForge 软件打开 <code>ttf</code> 文件，查看包含那些字符）</li><li>使用 LittlevGL 提供的字库文件<a href="https://littlevgl.com/ttf-font-to-c-array" target="_blank" rel="noopener">转换工具</a>，将选中的符号转换为 <code>c</code> 源文件。在转换的页面 <code>Range</code> 中输入目标符号的 Unicode 编码，怎么查询可以通过百度</li><li>将源文件添加到工程中，和上面添加字体类似，首先声明字体，然后添加到字体中或者直接使用。</li><li>定义一个宏指向这个目标符号，宏的内容需要为 <code>UTF-8编码</code>，通过 <a href="https://www.qqxiuzi.cn/bianma/Unicode-UTF.php" target="_blank" rel="noopener">Unicode和UTF编码转换</a> 可以进行转换</li></ul><p>例如：<br><img src="https://img-blog.csdnimg.cn/20190515163138800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="摄氏度符号"></p><p>这样就需要在程序中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* MACROS *&#x2F;</span><br><span class="line">#define SYMBOL_TEMP &quot;\xE2\x84\x83&quot; &#x2F;&#x2F; E28483</span><br><span class="line"></span><br><span class="line">&#x2F;* STATIC VARIABLES *&#x2F;</span><br><span class="line">LV_FONT_DECLARE(tempreture_symbol_40);</span><br><span class="line"></span><br><span class="line">&#x2F;* Add font to current font *&#x2F;</span><br><span class="line">lv_font_add(&amp;tempreture_symbol_40, &amp;lv_font_dejavu_40);</span><br><span class="line"></span><br><span class="line">&#x2F;* Use this symbol *&#x2F;</span><br><span class="line">lv_label_set_text(temp_l, &quot;21.5 &quot;SYMBOL_TEMP);</span><br></pre></td></tr></table></figure><h1 id="LittlevGL-添加物理按键"><a href="#LittlevGL-添加物理按键" class="headerlink" title="LittlevGL 添加物理按键"></a>LittlevGL 添加物理按键</h1><p>注册物理按键驱动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">uint8_t my_btn_read()</span><br><span class="line">&#123;</span><br><span class="line">    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool my_input_read(lv_indev_data_t *data)</span><br><span class="line">&#123;</span><br><span class="line">    static int8_t last_btn &#x3D; 0;    &#x2F;* Store the last pressed button *&#x2F;</span><br><span class="line">    int8_t btn_pr &#x3D; my_btn_read(); &#x2F;* Get the ID (0,1,2...) of the pressed button *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (btn_pr &gt; 0)</span><br><span class="line">    &#123;                                    &#x2F;* Is there a button press? *&#x2F;</span><br><span class="line">        last_btn &#x3D; btn_pr;               &#x2F;* Save the ID of the pressed button *&#x2F;</span><br><span class="line">        data-&gt;state &#x3D; LV_INDEV_STATE_PR; &#x2F;* Set the pressed state *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        data-&gt;state &#x3D; LV_INDEV_STATE_REL; &#x2F;* Set the released state *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data-&gt;btn &#x3D; last_btn; &#x2F;* Set the last button *&#x2F;</span><br><span class="line"></span><br><span class="line">    return false; &#x2F;* No buffering so no more data read *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">void my_button_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static lv_indev_t *indev;</span><br><span class="line">    lv_indev_drv_t indev_drv;</span><br><span class="line"></span><br><span class="line">    lv_indev_drv_init(&amp;indev_drv);</span><br><span class="line"></span><br><span class="line">    indev_drv.read &#x3D; my_input_read;</span><br><span class="line">    indev_drv.type &#x3D; LV_INDEV_TYPE_BUTTON;</span><br><span class="line">    indev &#x3D; lv_indev_drv_register(&amp;indev_drv);</span><br><span class="line"></span><br><span class="line">    &#x2F;*points_array: these points will be assigned to the buttons to press a specific point on the screen.*&#x2F;</span><br><span class="line">    static lv_point_t points_array[] &#x3D; &#123;&#123;20, 20&#125;&#125;;</span><br><span class="line">    lv_indev_set_button_points(indev, points_array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个按键，保证上面的点在按钮的区域内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static lv_obj_t *btn &#x3D; lv_btn_create(lv_scr_act(), NULL);  </span><br><span class="line">lv_obj_set_size(btn, 40, 40);</span><br><span class="line">lv_obj_set_pos(btn, 0, 0);</span><br><span class="line">lv_btn_set_action(btn, LV_BTN_ACTION_CLICK, btn_click_action);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LittlevGL-添加自定义字体&quot;&gt;&lt;a href=&quot;#LittlevGL-添加自定义字体&quot; class=&quot;headerlink&quot; title=&quot;LittlevGL 添加自定义字体&quot;&gt;&lt;/a&gt;LittlevGL 添加自定义字体&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;获取字库 &lt;code&gt;ttf&lt;/code&gt; 文件&lt;br&gt;可以从一些网站上获取字库文件，比如&lt;blockquote&gt;
&lt;p&gt;请注意字体许可证&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;生成源文件&lt;br&gt;使用 LittlevGL 提供的字库文件&lt;a href=&quot;https://littlevgl.com/ttf-font-to-c-array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转换工具&lt;/a&gt;，将 &lt;code&gt;ttf&lt;/code&gt; 字库文件转换为源文件。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十一）使用 ESP32 做为 WebServer</title>
    <link href="https://blog.infiniteyuan.com/2019/04/28/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32%20%E5%81%9A%E4%B8%BA%20WebServer/"/>
    <id>https://blog.infiniteyuan.com/2019/04/28/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32%20%E5%81%9A%E4%B8%BA%20WebServer/</id>
    <published>2019-04-28T19:34:34.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-ESP32-做为-WebServer"><a href="#使用-ESP32-做为-WebServer" class="headerlink" title="使用 ESP32 做为 WebServer"></a>使用 ESP32 做为 WebServer</h1><p>在某些场景，我们可能需要在手机上或者其他移动终端访问 ESP32 的数据，这个时候我们需要在手机上展示 ESP32 设备的相关信息，这个时候可以用 APP 在手机上展示数据，或者在手机浏览器中打开存储在 ESP32 上的网页。或者其他的方式。</p><p>这篇文章我们将介绍第二种方式。在 ESP32 上存储网页文件，将 ESP32 做为一个简单的 WebServer。</p><p>工作流程：(第一种方式)</p><ol><li>首先通过 gzip 将 HTML 文件压缩为 <code>.gz</code> 文件</li><li>使用 filetoarray 工具将 <code>.gz</code> 文件转为头文件</li><li>在 ESP32 程序中将头文件中的数组发送出去</li></ol><p>工作流程：(第二种方式)</p><ol><li>首先通过 gzip 将 HTML 文件压缩为 <code>.gz</code> 文件</li><li>使用 ESP32 构建系统中的<a href="https://blog.csdn.net/qq_27114397/article/details/81152448#_449" target="_blank" rel="noopener">嵌入二进制数据</a>的方式，将其添加到 Flash 中的 <code>.rodata</code> 部分</li><li>在 ESP32 程序中将 Flash 中的数组发送出去</li></ol><a id="more"></a><h2 id="filetoarray-工具"><a href="#filetoarray-工具" class="headerlink" title="filetoarray 工具"></a>filetoarray 工具</h2><p>使用这个工具将 <code>.gz</code> 文件转换为包含十六进制数组和其长度的头文件。</p><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span>;</span><br><span class="line">    <span class="keyword">long</span> flen;</span><br><span class="line">    <span class="keyword">char</span> *fname;</span><br><span class="line">    <span class="keyword">char</span> pname[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( argc == <span class="number">2</span> ) &#123;</span><br><span class="line">        fname = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(pname, fname);</span><br><span class="line">        <span class="keyword">char</span> *dot = <span class="built_in">strchr</span>(pname, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">while</span> (dot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *dot = <span class="string">'_'</span>;</span><br><span class="line">            dot = <span class="built_in">strchr</span>(pname, <span class="string">'.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Filename not supplied\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(fname, <span class="string">"rb"</span>);</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    flen = ftell(fp);</span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buffer</span> = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((flen + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    fread(<span class="built_in">buffer</span>, flen, <span class="number">1</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n//File: %s, Size: %lu\n"</span>, fname, flen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"#define %s_len %lu\n"</span>, pname, flen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const uint8_t %s[] PROGMEM = &#123;\n"</span>, pname);</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; flen; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 0x%02X"</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="built_in">buffer</span>[i]));</span><br><span class="line">        <span class="keyword">if</span> (i &lt; (flen - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">16</span>) == <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n&#125;;\n\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">buffer</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTML-文件到头文件"><a href="#HTML-文件到头文件" class="headerlink" title="HTML 文件到头文件"></a>HTML 文件到头文件</h2><p>使用方式：</p><ol><li>使用 gzip 将 HTML 文件转换为 <code>.gz</code> 文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip index.html</span><br></pre></td></tr></table></figure><ol start="2"><li>编译 <code>filetoarray.c</code> 源文件，生成可执行文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc filetoarray.c -o filetoarray</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 filetoarray 将  <code>.gz</code> 文件转为头文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filetoarray index.html.gz &gt; index.h</span><br></pre></td></tr></table></figure><h2 id="HTML-文件到-Flash"><a href="#HTML-文件到-Flash" class="headerlink" title="HTML 文件到 Flash"></a>HTML 文件到 Flash</h2><p>使用方式：</p><ol><li>使用 gzip 将 HTML 文件转换为 <code>.gz</code> 文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip index.html</span><br></pre></td></tr></table></figure><ol start="2"><li>在工程 <code>main</code> 目录下的 <code>component.mk</code> 中添加</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_EMBED_FILES := www/index.html.gz</span><br></pre></td></tr></table></figure><ol start="3"><li>在工程源码中这样使用</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_start[] <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_start"</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_end[]   <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_end"</span>);</span><br><span class="line"><span class="keyword">size_t</span> index_html_gz_len = index_html_gz_end - index_html_gz_start;</span><br><span class="line"></span><br><span class="line">httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz_start, index_html_gz_len);</span><br></pre></td></tr></table></figure><h2 id="在-ESP32-中启动-HTTP-Server"><a href="#在-ESP32-中启动-HTTP-Server" class="headerlink" title="在 ESP32 中启动 HTTP Server"></a>在 ESP32 中启动 HTTP Server</h2><p>第一种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"index.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">index_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span>&#123;</span><br><span class="line">    httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">    httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    <span class="keyword">return</span> httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz, index_html_gz_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">index_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_start[] <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_start"</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_end[]   <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_end"</span>);</span><br><span class="line"><span class="keyword">size_t</span> index_html_gz_len = index_html_gz_end - index_html_gz_start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">    httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    <span class="keyword">return</span> httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz_start, index_html_gz_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"app_httpd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"esp_http_server.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_httpd_main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">httpd_handle_t</span> camera_httpd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">httpd_config_t</span> <span class="built_in">config</span> = HTTPD_DEFAULT_CONFIG();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">httpd_uri_t</span> index_uri = &#123;</span><br><span class="line">        .uri       = <span class="string">"/"</span>,</span><br><span class="line">        .method    = HTTP_GET,</span><br><span class="line">        .handler   = index_handler,</span><br><span class="line">        .user_ctx  = <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Starting web server on port: '%d'"</span>, <span class="built_in">config</span>.server_port);</span><br><span class="line">    <span class="keyword">if</span> (httpd_start(&amp;camera_httpd, &amp;<span class="built_in">config</span>) == ESP_OK) &#123;</span><br><span class="line">        httpd_register_uri_handler(camera_httpd, &amp;index_uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ul><li><a href="https://github.com/espressif/esp-who/blob/master/examples/single_chip/camera_web_server/main/app_httpd.c" target="_blank" rel="noopener">web server</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-ESP32-做为-WebServer&quot;&gt;&lt;a href=&quot;#使用-ESP32-做为-WebServer&quot; class=&quot;headerlink&quot; title=&quot;使用 ESP32 做为 WebServer&quot;&gt;&lt;/a&gt;使用 ESP32 做为 WebServer&lt;/h1&gt;&lt;p&gt;在某些场景，我们可能需要在手机上或者其他移动终端访问 ESP32 的数据，这个时候我们需要在手机上展示 ESP32 设备的相关信息，这个时候可以用 APP 在手机上展示数据，或者在手机浏览器中打开存储在 ESP32 上的网页。或者其他的方式。&lt;/p&gt;
&lt;p&gt;这篇文章我们将介绍第二种方式。在 ESP32 上存储网页文件，将 ESP32 做为一个简单的 WebServer。&lt;/p&gt;
&lt;p&gt;工作流程：(第一种方式)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先通过 gzip 将 HTML 文件压缩为 &lt;code&gt;.gz&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;使用 filetoarray 工具将 &lt;code&gt;.gz&lt;/code&gt; 文件转为头文件&lt;/li&gt;
&lt;li&gt;在 ESP32 程序中将头文件中的数组发送出去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;工作流程：(第二种方式)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先通过 gzip 将 HTML 文件压缩为 &lt;code&gt;.gz&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;使用 ESP32 构建系统中的&lt;a href=&quot;https://blog.csdn.net/qq_27114397/article/details/81152448#_449&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;嵌入二进制数据&lt;/a&gt;的方式，将其添加到 Flash 中的 &lt;code&gt;.rodata&lt;/code&gt; 部分&lt;/li&gt;
&lt;li&gt;在 ESP32 程序中将 Flash 中的数组发送出去&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二十六）NVS</title>
    <link href="https://blog.infiniteyuan.com/2019/04/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89NVS/"/>
    <id>https://blog.infiniteyuan.com/2019/04/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89NVS/</id>
    <published>2019-04-12T20:33:16.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NVS-Non-volatile-storage"><a href="#NVS-Non-volatile-storage" class="headerlink" title="NVS - Non-volatile storage"></a>NVS - Non-volatile storage</h1><p>非易失性存储（NVS）库主要用于在闪存中存储键值对。本节介绍 NVS 使用的一些概念。</p><h2 id="底层存储"><a href="#底层存储" class="headerlink" title="底层存储"></a>底层存储</h2><p>目前，NVS 通过 <code>spi_flash_{read|write|erase}</code>  API 使用主闪存的一部分。该库使用具有 data 类型和 nvs 子类型的所有分区。应用程序可以通过 <code>nvs_open</code> API 选择使用带有标签 nvs 的分区或通过 <code>nvs_open_from_part</code> API 使用指定名称的任意分区。</p><blockquote><p>如果 NVS 分区被截断（例如，更改分区表布局时），则应擦除其内容。ESP-IDF 构建系统提供 <code>make erase_flash</code> 以擦除闪存芯片的所有内容。</p></blockquote><blockquote><p>NVS 最适合存储许多小值，而不是 “string” 和 “blob” 类型的大值。如果需要存储大的 blob 或字符串，请考虑使用在损耗均衡库之上的 FAT 文件系统提供的功能。</p></blockquote><a id="more"></a><h2 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h2><p>NVS 在键值对上操作。键是 ASCII 字符串，最大键长度当前为 15 个字符。值可以具有以下类型之一：</p><ul><li>整形: uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t</li><li>以0结尾的字符串</li><li>可变长的二进制数据(blob)</li></ul><blockquote><p>字符串值目前限制为 4000 字节。这包括空终止符。Blob 值限制为 508000 字节或（分区大小的 97.6％- 4000）字节，以较低者为准。</p></blockquote><p>键必须是唯一的。为已存在的键写入值的行为如下：</p><ul><li>如果新值相同，则更新值</li><li>如果新值与旧值的数据类型不同，则返回错误</li></ul><p>读取值时也会执行数据类型检查。如果读取操作的数据类型与值的数据类型不匹配，则返回错误。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>为了缓解不同组件之间键名称中的潜在冲突，NVS 将每个键值对分配给一个命名空间。命名空间名称遵循与键名相同的规则，即最多15个字符的长度。命名空间名称在 <code>nvs_open</code> 或 <code>nvs_open_from_part</code> 调用中指定。此调用返回一个不透明句柄，该句柄用于后续调用 <code>nvs_read_ *</code>，<code>nvs_write_ *</code> 和 <code>nvs_commit</code> 函数。这样，handle 与命名空间相关联，并且键名不会与其他命名空间中的相同名称冲突。 请注意，不同 NVS 分区中具有相同名称的命名空间被视为单独的命名空间。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>NVS 与 ESP32 闪存加密系统不直接兼容。然而，如果 NVS 加密与 ESP32 闪存加密一起使用，数据仍可以加密形式存储。</p><h2 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h2><h3 id="键值对的日志"><a href="#键值对的日志" class="headerlink" title="键值对的日志"></a>键值对的日志</h3><p>NVS 按顺序存储键值对，新的键值对添加在最后。当必须更新任何给定密钥的值时，在日志的末尾添加新的键值对，并将旧的键值对标记为已擦除。</p><h3 id="页面和条目"><a href="#页面和条目" class="headerlink" title="页面和条目"></a>页面和条目</h3><p>NVS 库在其操作中使用两个主要实体：页面和条目。Page 是一个逻辑结构，用于存储整个日志的一部分。逻辑页面对应于闪存的一个物理扇区。正在使用的页面具有与之关联的序列号。序列号在页面上强制排序。较高的序列号对应于稍后创建的页面。</p><h3 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h3><p>页面由三部分组成：标题，条目状态位图和条目本身。要与 ESP32 闪存加密兼容，条目大小为 32 个字节。对于整数类型，条目包含一个键值对。对于字符串和 blob，条目包含键值对的一部分。</p><h3 id="条目状态位图和条目"><a href="#条目状态位图和条目" class="headerlink" title="条目状态位图和条目"></a>条目状态位图和条目</h3><p>每个条目可以处于以下三种状态之一。每个状态在入口状态位图中用两位表示。位图中的最后四位（256-2 * 126）未使用。</p><ul><li>空（2’b11）</li><li>被写（2’b10）</li><li>删除（2’b00）</li></ul><h3 id="条目结构"><a href="#条目结构" class="headerlink" title="条目结构"></a>条目结构</h3><p>对于基本类型的值（当前长度为 1 到 8 个字节的整数），条目包含一个键值对。对于字符串和 blob 类型，条目包含整个键值对的一部分。对于字符串，如果键值对跨越多个条目，则所有条目都存储在同一页面中。通过将 Blob 划分为更小的块，允许Blob跨越多个页面。为了跟踪这些块，存储称为“blob 索引”条目的附加固定长度元数据条目。早期格式的 blob 仍然受支持（可以读取和修改）。但是，一旦修改了blob，就会使用新格式存储它们。</p><p>可变长度值（字符串和 blob）写入后续条目，每个条目 32 个字节。第一个条目的 Span 字段表示使用了多少条目。</p><h3 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a>命名空间</h3><p>如上所述，每个键值对属于一个名称空间。命名空间标识符（字符串）存储为名称空间中键值对的键，索引为0。与这些键对应的值是这些命名空间的索引。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/storage/nvs_flash.html" target="_blank" rel="noopener">Non-volatile storage library</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NVS-Non-volatile-storage&quot;&gt;&lt;a href=&quot;#NVS-Non-volatile-storage&quot; class=&quot;headerlink&quot; title=&quot;NVS - Non-volatile storage&quot;&gt;&lt;/a&gt;NVS - Non-volatile storage&lt;/h1&gt;&lt;p&gt;非易失性存储（NVS）库主要用于在闪存中存储键值对。本节介绍 NVS 使用的一些概念。&lt;/p&gt;
&lt;h2 id=&quot;底层存储&quot;&gt;&lt;a href=&quot;#底层存储&quot; class=&quot;headerlink&quot; title=&quot;底层存储&quot;&gt;&lt;/a&gt;底层存储&lt;/h2&gt;&lt;p&gt;目前，NVS 通过 &lt;code&gt;spi_flash_{read|write|erase}&lt;/code&gt;  API 使用主闪存的一部分。该库使用具有 data 类型和 nvs 子类型的所有分区。应用程序可以通过 &lt;code&gt;nvs_open&lt;/code&gt; API 选择使用带有标签 nvs 的分区或通过 &lt;code&gt;nvs_open_from_part&lt;/code&gt; API 使用指定名称的任意分区。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 NVS 分区被截断（例如，更改分区表布局时），则应擦除其内容。ESP-IDF 构建系统提供 &lt;code&gt;make erase_flash&lt;/code&gt; 以擦除闪存芯片的所有内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;NVS 最适合存储许多小值，而不是 “string” 和 “blob” 类型的大值。如果需要存储大的 blob 或字符串，请考虑使用在损耗均衡库之上的 FAT 文件系统提供的功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二十五）脉冲计数器</title>
    <link href="https://blog.infiniteyuan.com/2019/03/26/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>https://blog.infiniteyuan.com/2019/03/26/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%99%A8/</id>
    <published>2019-03-26T10:40:00.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="脉冲计数器"><a href="#脉冲计数器" class="headerlink" title="脉冲计数器"></a>脉冲计数器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PCNT（脉冲计数器）模块用于计算输入信号的上升沿和/或下降沿的数量。每个脉冲计数器单元都有一个 16 位有符号计数器寄存器和两个通道，可配置为递增或递减计数器。每个通道都有一个接收待检测信号边沿的信号输入，以及一个可用于启用或禁用信号输入的控制输入。输入具有可选滤波器，可用于丢弃信号中不需要的毛刺。</p><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>此 API 的功能描述分为四个部分：</p><ul><li>配置 - 描述计数器的配置参数以及如何设置计数器。</li><li>操作计数器 - 提供有关暂停，测量和清除计数器的控制功能相关信息。</li><li>滤波脉冲 - 介绍滤波脉冲和计数器控制信号的可选项。</li><li>使用中断 - 介绍如何在计数器的特定状态上触发中断。</li></ul><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>PCNT 模块有 8 个独立的计数“单元”，编号从 0 到 7. 在 API 中，它们使用 <code>pcnt_unit_t</code> 引用。每个单元有两个独立的通道，编号为 0 和 1，并用 <code>pcnt_channel_t</code> 指定。</p><p>使用 <code>pcnt_config_t</code> 为每个单元的通道单独提供配置，并涵盖：</p><ul><li>此配置所指的单元和通道编号。</li><li>脉冲输入和脉冲门输入的GPIO编号。</li><li>两对参数：<code>pcnt_ctrl_mode_t</code> 和 <code>pcnt_count_mode_t</code>，用于定义计数器如何响应，具体取决于控制信号的状态以及如何计算脉冲的正/负边沿。</li><li>当脉冲计数满足特定限制时，用于建立观察点和触发中断的两个极限值（最小值/最大值）。</li></ul><p>然后通过调用上面的 <code>pcnt_config_t</code> 作为输入参数的函数 <code>pcnt_unit_config()</code> 来完成特定通道的设置。</p><p>要在配置中禁用脉冲或控制输入引脚，请提供 <code>PCNT_PIN_NOT_USED</code> 而不是 GPIO 编号。</p><h2 id="操作计数器"><a href="#操作计数器" class="headerlink" title="操作计数器"></a>操作计数器</h2><p>使用 <code>pcnt_unit_config()</code> 进行设置后，计数器立即开始运行。可以通过调用 <code>pcnt_get_counter_value()</code> 获取累积的脉冲计数。</p><p>有几个函数可以控制计数器的操作：<code>pcnt_counter_pause()</code>，<code>pcnt_counter_resume()</code> 和 <code>pcnt_counter_clear()</code></p><p>也可以通过调用 <code>pcnt_set_mode()</code> 使用 <code>pcnt_unit_config()</code> 动态更改计数器模式。</p><p>如果需要，可以使用 <code>pcnt_set_pin()</code> “动态”更改脉冲输入引脚和控制输入引脚。要禁用特定输入，请提供功能参数 <code>PCNT_PIN_NOT_USED</code> 而不是 GPIO 编号。</p><blockquote><p>为了使计数器不会错过任何脉冲，脉冲持续时间应该长于一个 APB_CLK 周期（12.5 ns）。脉冲在 APB_CLK 时钟的边沿上采样，如果在边缘之间落下，则可能会丢失。这适用于对带或不带过滤器的操作。</p></blockquote><h2 id="滤波脉冲"><a href="#滤波脉冲" class="headerlink" title="滤波脉冲"></a>滤波脉冲</h2><p>PCNT 单元在每个脉冲和控制输入上都有滤波器，增加了忽略信号中短暂毛刺的选项。</p><p>通过调用 <code>pcnt_set_filter_value()</code> 在 APB_CLK 时钟周期中提供忽略脉冲的长度。可以使用 <code>pcnt_get_filter_value()</code> 检查当前过滤器设置。APB_CLK 时钟以 80 MHz运行。</p><p>通过调用 <code>pcnt_filter_enable()</code>/<code>pcnt_filter_disable()</code> 将过滤器投入运行/暂停。</p><h2 id="使用中断"><a href="#使用中断" class="headerlink" title="使用中断"></a>使用中断</h2><p>在 <code>pcnt_evt_type_t</code> 中定义的五个计数器状态监视事件能够触发中断。事件发生在脉冲计数器达到特定值：</p><ul><li>最小或最大计数值：在配置中讨论的 <code>pcnt_config_t</code> 中提供的 <code>counter_l_lim</code> 或 <code>counter_h_lim</code></li><li>使用函数 <code>pcnt_set_event_value()</code> 设置阈值 0 或阈值 1 值。</li><li>脉冲计数=0</li></ul><p>要注册，启用或禁用中断以服务上述事件，请调用 <code>pcnt_isr_register()</code>，<code>pcnt_intr_enable()</code> 和 <code>pcnt_intr_disable()</code>。要在达到阈值时启用或禁用事件，还需要调用函数 <code>pcnt_event_enable()</code> 和 <code>pcnt_event_disable()</code>。</p><p>要检查当前设置的阈值，请使用函数 <code>pcnt_get_event_value()</code>。</p><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>带控制信号和事件中断的脉冲计数器示例：<a href="https://github.com/espressif/esp-idf/tree/106dc0590/examples/peripherals/pcnt" target="_blank" rel="noopener">peripherals/pcnt</a>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/pcnt.html" target="_blank" rel="noopener">Pulse Counter</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;脉冲计数器&quot;&gt;&lt;a href=&quot;#脉冲计数器&quot; class=&quot;headerlink&quot; title=&quot;脉冲计数器&quot;&gt;&lt;/a&gt;脉冲计数器&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;PCNT（脉冲计数器）模块用于计算输入信号的上升沿和/或下降沿的数量。每个脉冲计数器单元都有一个 16 位有符号计数器寄存器和两个通道，可配置为递增或递减计数器。每个通道都有一个接收待检测信号边沿的信号输入，以及一个可用于启用或禁用信号输入的控制输入。输入具有可选滤波器，可用于丢弃信号中不需要的毛刺。&lt;/p&gt;
&lt;h2 id=&quot;功能概述&quot;&gt;&lt;a href=&quot;#功能概述&quot; class=&quot;headerlink&quot; title=&quot;功能概述&quot;&gt;&lt;/a&gt;功能概述&lt;/h2&gt;&lt;p&gt;此 API 的功能描述分为四个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置 - 描述计数器的配置参数以及如何设置计数器。&lt;/li&gt;
&lt;li&gt;操作计数器 - 提供有关暂停，测量和清除计数器的控制功能相关信息。&lt;/li&gt;
&lt;li&gt;滤波脉冲 - 介绍滤波脉冲和计数器控制信号的可选项。&lt;/li&gt;
&lt;li&gt;使用中断 - 介绍如何在计数器的特定状态上触发中断。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二十四）SPIFFS 文件系统</title>
    <link href="https://blog.infiniteyuan.com/2019/03/23/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89SPIFFS%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://blog.infiniteyuan.com/2019/03/23/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89SPIFFS%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2019-03-23T20:21:27.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SPIFFS-文件系统"><a href="#SPIFFS-文件系统" class="headerlink" title="SPIFFS 文件系统"></a>SPIFFS 文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SPIFFS 是一个文件系统，用于嵌入式目标上的 SPI NOR 闪存设备。它支持磨损均衡，文件系统一致性检查等。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>目前，spiffs 不支持目录。它产生扁平结构。如果 SPIFFS 安装在 /spiffs 下创建一个带有路径 /spiffs/tmp/myfile.txt 的文件，则会在 SPIFFS 中创建一个名为 /tmp/myfile.txt 的文件，而不是在目录 /spiffs/tmp 下创建一个名为的 myfile.txt。</li><li>它不是实时堆栈。一次写入操作可能持续时间比另一次更长。</li><li>目前，它没法检测或处理块被损坏的情况。</li></ul><a id="more"></a><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>主机端工具用于创建 SPIFS 分区镜像文件(.bin)，其中一个工具是 <a href="https://github.com/igrr/mkspiffs" target="_blank" rel="noopener">mkspiffs</a>。您可以使用它从给定文件夹创建镜像文件，然后使用 <code>esptool.py</code> 下载该镜像文件到设备中</p><p>为此，您需要获取一些参数：</p><ul><li>块大小：4096（SPI Flash的标准）</li><li>页面大小：256（SPI Flash标准）</li><li>图像大小：分区大小（以字节为单位）（可以从分区表中获取）</li><li>分区偏移：分区的起始地址（可以从分区表中获取）</li></ul><p>例如：<br>将目标文件夹打包为 1 兆字节镜像文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkspiffs -c [src_folder] -b 4096 -p 256 -s 0x100000 spiffs.bin</span><br></pre></td></tr></table></figure><p>要在偏移量 0x110000 处将镜像文件烧录到 ESP32：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python esptool.py --chip esp32 --port [port] --baud [baud] write_flash -z 0x110000 spiffs.bin</span><br></pre></td></tr></table></figure><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ol><li>无法从 SPIFFS 中读取到文件内容</li></ol><p>这种情况是由于通过工具制作的文件系统格式与程序中的文件系统格式不同导致，可通过运行 <code>./mkspiffs --version</code> 在你的 mkspiffs 目录和 <code>grep SPIFFS sdkconfig</code> 在你的工程目录，之后对比两者配置的不同之处。</p><p>例如：</p><p>运行 <code>./mkspiffs --version</code> 在 mkspiffs 目录中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkspiffs ver. <span class="number">0.2</span><span class="number">.3</span><span class="number">-6</span>-g983970e</span><br><span class="line">Build configuration name: generic</span><br><span class="line">SPIFFS ver. <span class="number">0.3</span><span class="number">.7</span><span class="number">-5</span>-gf5e26c4</span><br><span class="line">Extra build flags: (none)</span><br><span class="line">SPIFFS configuration:</span><br><span class="line">  SPIFFS_OBJ_NAME_LEN: <span class="number">32</span></span><br><span class="line">  SPIFFS_OBJ_META_LEN: <span class="number">0</span></span><br><span class="line">  SPIFFS_USE_MAGIC: <span class="number">1</span></span><br><span class="line">  SPIFFS_USE_MAGIC_LENGTH: <span class="number">1</span></span><br><span class="line">  SPIFFS_ALIGNED_OBJECT_INDEX_TABLES: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>运行 <code>grep SPIFFS sdkconfig</code> 在工程目录中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># SPIFFS Configuration</span><br><span class="line">CONFIG_SPIFFS_MAX_PARTITIONS=<span class="number">3</span></span><br><span class="line"># SPIFFS Cache Configuration</span><br><span class="line">CONFIG_SPIFFS_CACHE=y</span><br><span class="line">CONFIG_SPIFFS_CACHE_WR=y</span><br><span class="line">CONFIG_SPIFFS_CACHE_STATS=</span><br><span class="line">CONFIG_SPIFFS_PAGE_CHECK=y</span><br><span class="line">CONFIG_SPIFFS_GC_MAX_RUNS=<span class="number">10</span></span><br><span class="line">CONFIG_SPIFFS_GC_STATS=</span><br><span class="line">CONFIG_SPIFFS_PAGE_SIZE=<span class="number">256</span></span><br><span class="line">CONFIG_SPIFFS_OBJ_NAME_LEN=<span class="number">32</span></span><br><span class="line">CONFIG_SPIFFS_USE_MAGIC=y</span><br><span class="line">CONFIG_SPIFFS_USE_MAGIC_LENGTH=y</span><br><span class="line">CONFIG_SPIFFS_META_LENGTH=<span class="number">4</span></span><br><span class="line">CONFIG_SPIFFS_USE_MTIME=y</span><br><span class="line">CONFIG_SPIFFS_DBG=</span><br><span class="line">CONFIG_SPIFFS_API_DBG=</span><br><span class="line">CONFIG_SPIFFS_GC_DBG=</span><br><span class="line">CONFIG_SPIFFS_CACHE_DBG=</span><br><span class="line">CONFIG_SPIFFS_CHECK_DBG=</span><br><span class="line">CONFIG_SPIFFS_TEST_VISUALISATION=</span><br></pre></td></tr></table></figure><p>对比之后我们发现有 <code>SPIFFS_OBJ_META_LEN:0</code>（mkspiffs）和 <code>CONFIG_SPIFFS_META_LENGTH=4</code>（sdkconfig） 不同，这个可能就是导致无法从文件系统中读取的原因。那我们重新构建一下 <code>mkspiffs</code>，通过在 mkspiffs 目录中运行以下命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make dist BUILD_CONFIG_NAME=<span class="string">"-esp-idf"</span> CPPFLAGS=<span class="string">"-DSPIFFS_OBJ_META_LEN=4"</span></span><br></pre></td></tr></table></figure><p>这时，我们重新比较下两者的差别:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkspiffs ver. <span class="number">0.2</span><span class="number">.3</span><span class="number">-6</span>-g983970e</span><br><span class="line">Build configuration name: esp-idf</span><br><span class="line">SPIFFS ver. <span class="number">0.3</span><span class="number">.7</span><span class="number">-5</span>-gf5e26c4</span><br><span class="line">Extra build flags: -DSPIFFS_OBJ_META_LEN=<span class="number">4</span></span><br><span class="line">SPIFFS configuration:</span><br><span class="line">  SPIFFS_OBJ_NAME_LEN: <span class="number">32</span></span><br><span class="line">  SPIFFS_OBJ_META_LEN: <span class="number">4</span><span class="comment">// 这里已经改变为和工程中的 SPIFFS 格式配置相同</span></span><br><span class="line">  SPIFFS_USE_MAGIC: <span class="number">1</span></span><br><span class="line">  SPIFFS_USE_MAGIC_LENGTH: <span class="number">1</span></span><br><span class="line">  SPIFFS_ALIGNED_OBJECT_INDEX_TABLES: <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># SPIFFS Configuration</span><br><span class="line">CONFIG_SPIFFS_MAX_PARTITIONS=<span class="number">3</span></span><br><span class="line"># SPIFFS Cache Configuration</span><br><span class="line">CONFIG_SPIFFS_CACHE=y</span><br><span class="line">CONFIG_SPIFFS_CACHE_WR=y</span><br><span class="line">CONFIG_SPIFFS_CACHE_STATS=</span><br><span class="line">CONFIG_SPIFFS_PAGE_CHECK=y</span><br><span class="line">CONFIG_SPIFFS_GC_MAX_RUNS=<span class="number">10</span></span><br><span class="line">CONFIG_SPIFFS_GC_STATS=</span><br><span class="line">CONFIG_SPIFFS_PAGE_SIZE=<span class="number">256</span></span><br><span class="line">CONFIG_SPIFFS_OBJ_NAME_LEN=<span class="number">32</span></span><br><span class="line">CONFIG_SPIFFS_USE_MAGIC=y</span><br><span class="line">CONFIG_SPIFFS_USE_MAGIC_LENGTH=y</span><br><span class="line">CONFIG_SPIFFS_META_LENGTH=<span class="number">4</span></span><br><span class="line">CONFIG_SPIFFS_USE_MTIME=y</span><br><span class="line">CONFIG_SPIFFS_DBG=</span><br><span class="line">CONFIG_SPIFFS_API_DBG=</span><br><span class="line">CONFIG_SPIFFS_GC_DBG=</span><br><span class="line">CONFIG_SPIFFS_CACHE_DBG=</span><br><span class="line">CONFIG_SPIFFS_CHECK_DBG=</span><br><span class="line">CONFIG_SPIFFS_TEST_VISUALISATION=</span><br></pre></td></tr></table></figure><p>这样应该就可以解决不能从文件系统中读取文件内容了。</p><h2 id="mkspiffs-工具构建"><a href="#mkspiffs-工具构建" class="headerlink" title="mkspiffs 工具构建"></a>mkspiffs 工具构建</h2><p>构建 mkspiffs 的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/igrr/mkspiffs.git</span></span><br><span class="line">git submodule update --init</span><br><span class="line">make dist</span><br><span class="line"><span class="meta"># make dist CPPFLAGS=<span class="meta-string">"-DSPIFFS_OBJ_META_LEN=4"</span> BUILD_CONFIG_NAME=-custom <span class="comment">//可选</span></span></span><br></pre></td></tr></table></figure><h3 id="SPIFFS-配置"><a href="#SPIFFS-配置" class="headerlink" title="SPIFFS 配置"></a>SPIFFS 配置</h3><p>在 mkspiffs 构建时设置的某些 SPIFFS 选项会影响生成的文件系统映像的格式。在构建 mkspiffs 和构建使用 SPIFFS 的应用程序时，请确保将此类选项设置为相同的值。</p><p>这些选项包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SPIFFS_OBJ_NAME_LEN</span><br><span class="line">SPIFFS_OBJ_META_LEN</span><br><span class="line">SPIFFS_USE_MAGIC</span><br><span class="line">SPIFFS_USE_MAGIC_LENGTH</span><br><span class="line">SPIFFS_ALIGNED_OBJECT_INDEX_TABLES</span><br></pre></td></tr></table></figure><p>可能是其他人要查看这些选项的默认值，请检查此存储库中的 <code>include/spiffs_config.h</code> 文件。</p><p>要在构建时覆盖某些选项，请传递额外的 CPPFLAGS。您还可以设置 BUILD_CONFIG_NAME 变量以区分构建的二进制文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make dist CPPFLAGS=<span class="string">"-DSPIFFS_OBJ_META_LEN=4"</span> BUILD_CONFIG_NAME=-custom</span><br></pre></td></tr></table></figure><p>要检查构建mkspiff时设置的选项，请使用 <code>--version</code> 命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ mkspiffs --version</span><br><span class="line">mkspiffs ver. <span class="number">0.2</span><span class="number">.2</span></span><br><span class="line">Build configuration name: custom</span><br><span class="line">SPIFFS ver. <span class="number">0.3</span><span class="number">.7</span><span class="number">-5</span>-gf5e26c4</span><br><span class="line">Extra build flags: -DSPIFFS_OBJ_META_LEN=<span class="number">4</span></span><br><span class="line">SPIFFS configuration:</span><br><span class="line">  SPIFFS_OBJ_NAME_LEN: <span class="number">32</span></span><br><span class="line">  SPIFFS_OBJ_META_LEN: <span class="number">4</span></span><br><span class="line">  SPIFFS_USE_MAGIC: <span class="number">1</span></span><br><span class="line">  SPIFFS_USE_MAGIC_LENGTH: <span class="number">1</span></span><br><span class="line">  SPIFFS_ALIGNED_OBJECT_INDEX_TABLES: <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/storage/spiffs.html" target="_blank" rel="noopener">SPIFFS Filesystem</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SPIFFS-文件系统&quot;&gt;&lt;a href=&quot;#SPIFFS-文件系统&quot; class=&quot;headerlink&quot; title=&quot;SPIFFS 文件系统&quot;&gt;&lt;/a&gt;SPIFFS 文件系统&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SPIFFS 是一个文件系统，用于嵌入式目标上的 SPI NOR 闪存设备。它支持磨损均衡，文件系统一致性检查等。&lt;/p&gt;
&lt;h2 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;目前，spiffs 不支持目录。它产生扁平结构。如果 SPIFFS 安装在 /spiffs 下创建一个带有路径 /spiffs/tmp/myfile.txt 的文件，则会在 SPIFFS 中创建一个名为 /tmp/myfile.txt 的文件，而不是在目录 /spiffs/tmp 下创建一个名为的 myfile.txt。&lt;/li&gt;
&lt;li&gt;它不是实时堆栈。一次写入操作可能持续时间比另一次更长。&lt;/li&gt;
&lt;li&gt;目前，它没法检测或处理块被损坏的情况。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 开发笔记（十）使用 ESP32+Camera 二维码识别</title>
    <link href="https://blog.infiniteyuan.com/2019/03/14/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32+Camera%20%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    <id>https://blog.infiniteyuan.com/2019/03/14/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32+Camera%20%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%AF%86%E5%88%AB/</id>
    <published>2019-03-14T15:16:37.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-ESP32-Camera-进行二维码识别"><a href="#使用-ESP32-Camera-进行二维码识别" class="headerlink" title="使用 ESP32 Camera 进行二维码识别"></a>使用 ESP32 Camera 进行二维码识别</h1><ul><li>GitHub: <a href="https://github.com/InfiniteYuan/esp32-camera-qr-recoginize/tree/master/examples/single_chip/qrcode_recoginize" target="_blank" rel="noopener">esp32-camera-qr-recoginize</a></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li><a href="https://github.com/espressif/esp-who" target="_blank" rel="noopener">ESP-WHO</a></li><li><a href="https://github.com/espressif/esp-idf" target="_blank" rel="noopener">ESP-IDF</a></li></ul><a id="more"></a><h2 id="使用-quirc-二维码识别库"><a href="#使用-quirc-二维码识别库" class="headerlink" title="使用 quirc 二维码识别库"></a>使用 quirc 二维码识别库</h2><ul><li><a href="https://github.com/dlbeer/quirc" target="_blank" rel="noopener">quirc</a></li></ul><h2 id="摄像头初始化"><a href="#摄像头初始化" class="headerlink" title="摄像头初始化"></a>摄像头初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_PIXEL_FORM PIXFORMAT_GRAYSCALE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_FRAME_SIZE FRAMESIZE_VGA</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_CAMERA_MODEL_CUSTOM</span></span><br><span class="line">    <span class="comment">/* IO13, IO14 is designed for JTAG by default,</span></span><br><span class="line"><span class="comment">     * to use it as generalized input,</span></span><br><span class="line"><span class="comment">     * firstly declair it as pullup input */</span></span><br><span class="line">    <span class="keyword">gpio_config_t</span> conf;</span><br><span class="line">    conf.mode = GPIO_MODE_INPUT;</span><br><span class="line">    conf.pull_up_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf.pull_down_en = GPIO_PULLDOWN_DISABLE;</span><br><span class="line">    conf.intr_type = GPIO_INTR_DISABLE;</span><br><span class="line">    conf.pin_bit_mask = <span class="number">1L</span>L &lt;&lt; <span class="number">13</span>;</span><br><span class="line">    gpio_config(&amp;conf);</span><br><span class="line">    conf.pin_bit_mask = <span class="number">1L</span>L &lt;&lt; <span class="number">14</span>;</span><br><span class="line">    gpio_config(&amp;conf);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">config</span>.ledc_channel = LEDC_CHANNEL_0;</span><br><span class="line">    <span class="built_in">config</span>.ledc_timer = LEDC_TIMER_0;</span><br><span class="line">    <span class="built_in">config</span>.pin_d0 = Y2_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d1 = Y3_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d2 = Y4_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d3 = Y5_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d4 = Y6_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d5 = Y7_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d6 = Y8_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d7 = Y9_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_xclk = XCLK_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_pclk = PCLK_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_vsync = VSYNC_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_href = HREF_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_sscb_sda = SIOD_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_sscb_scl = SIOC_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_pwdn = PWDN_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_reset = RESET_GPIO_NUM;</span><br><span class="line">    <span class="comment">// Only support 10 MHz current. Camera will output bad image when XCLK is 20 MHz.</span></span><br><span class="line">    <span class="built_in">config</span>.xclk_freq_hz = <span class="number">10000000</span>;</span><br><span class="line">    <span class="built_in">config</span>.pixel_format = CAMERA_PIXEL_FORM;</span><br><span class="line">    <span class="built_in">config</span>.frame_size = CAMERA_FRAME_SIZE;</span><br><span class="line">    <span class="built_in">config</span>.jpeg_quality = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">config</span>.fb_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera init</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_camera_init(&amp;<span class="built_in">config</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Camera init failed with error 0x%x"</span>, err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create QR-code recognize task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    app_qr_recognize(&amp;<span class="built_in">config</span>);</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Free heap: %u"</span>, xPortGetFreeHeapSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a>二维码识别</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr_recoginze</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">camera_config_t</span> *camera_config = (<span class="keyword">camera_config_t</span> *)parameter;</span><br><span class="line">    <span class="comment">// Use VGA Size currently, but quirc can support other frame size.(eg: FRAMESIZE_SVGA,FRAMESIZE_VGA，</span></span><br><span class="line">    <span class="comment">// FRAMESIZE_CIF,FRAMESIZE_QVGA,FRAMESIZE_HQVGA,FRAMESIZE_QCIF,FRAMESIZE_QQVGA2,FRAMESIZE_QQVGA,etc)</span></span><br><span class="line">    <span class="keyword">if</span> (camera_config-&gt;frame_size &gt; FRAMESIZE_VGA) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Camera Frame Size err %d"</span>, (camera_config-&gt;frame_size));</span><br><span class="line">        vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save image width and height, avoid allocate memory repeatly.</span></span><br><span class="line">    <span class="keyword">uint16_t</span> old_width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> old_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct a new QR-code recognizer.</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Construct a new QR-code recognizer(quirc)."</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quirc</span> *<span class="title">qr_recognizer</span> = <span class="title">quirc_new</span>();</span></span><br><span class="line">    <span class="keyword">if</span> (!qr_recognizer) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Can't create quirc object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">camera_fb_t</span> *fb = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> *<span class="built_in">image</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> id_count = <span class="number">0</span>;</span><br><span class="line">    UBaseType_t uxHighWaterMark;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入口处检测一次 */</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"uxHighWaterMark = %d"</span>, uxTaskGetStackHighWaterMark( <span class="literal">NULL</span> ));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">"uxHighWaterMark = %d"</span>, uxTaskGetStackHighWaterMark( <span class="literal">NULL</span> ));</span><br><span class="line">        <span class="comment">// Capture a frame</span></span><br><span class="line">        fb = esp_camera_fb_get();</span><br><span class="line">        <span class="keyword">if</span> (!fb) &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">"Camera capture failed"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old_width != fb-&gt;<span class="built_in">width</span> || old_height != fb-&gt;<span class="built_in">height</span>) &#123;</span><br><span class="line">            ESP_LOGD(TAG, <span class="string">"Recognizer size change w h len: %d, %d, %d"</span>, fb-&gt;<span class="built_in">width</span>, fb-&gt;<span class="built_in">height</span>, fb-&gt;len);</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">"Resize the QR-code recognizer."</span>);</span><br><span class="line">            <span class="comment">// Resize the QR-code recognizer.</span></span><br><span class="line">            <span class="keyword">if</span> (quirc_resize(qr_recognizer, fb-&gt;<span class="built_in">width</span>, fb-&gt;<span class="built_in">height</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">"Resize the QR-code recognizer err."</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                old_width = fb-&gt;<span class="built_in">width</span>;</span><br><span class="line">                old_height = fb-&gt;<span class="built_in">height</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** These functions are used to process images for QR-code recognition.</span></span><br><span class="line"><span class="comment">         * quirc_begin() must first be called to obtain access to a buffer into</span></span><br><span class="line"><span class="comment">         * which the input image should be placed. Optionally, the current</span></span><br><span class="line"><span class="comment">         * width and height may be returned.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * After filling the buffer, quirc_end() should be called to process</span></span><br><span class="line"><span class="comment">         * the image for QR-code recognition. The locations and content of each</span></span><br><span class="line"><span class="comment">         * code may be obtained using accessor functions described below.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">image</span> = quirc_begin(qr_recognizer, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">image</span>, fb-&gt;buf, fb-&gt;len);</span><br><span class="line">        quirc_end(qr_recognizer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the number of QR-codes identified in the last processed image.</span></span><br><span class="line">        id_count = quirc_count(qr_recognizer);</span><br><span class="line">        <span class="keyword">if</span> (id_count == <span class="number">0</span>) &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">"Error: not a valid qrcode"</span>);</span><br><span class="line">            esp_camera_fb_return(fb);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print information of QR-code</span></span><br><span class="line">        dump_info(qr_recognizer, id_count);</span><br><span class="line">        esp_camera_fb_return(fb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Destroy QR-Code recognizer (quirc)</span></span><br><span class="line">    quirc_destroy(qr_recognizer);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Deconstruct QR-Code recognizer(quirc)"</span>);</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例结果"><a href="#示例结果" class="headerlink" title="示例结果"></a>示例结果</h2><p><img src="https://img-blog.csdnimg.cn/20190315190639946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="示例结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-ESP32-Camera-进行二维码识别&quot;&gt;&lt;a href=&quot;#使用-ESP32-Camera-进行二维码识别&quot; class=&quot;headerlink&quot; title=&quot;使用 ESP32 Camera 进行二维码识别&quot;&gt;&lt;/a&gt;使用 ESP32 Camera 进行二维码识别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;GitHub: &lt;a href=&quot;https://github.com/InfiniteYuan/esp32-camera-qr-recoginize/tree/master/examples/single_chip/qrcode_recoginize&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;esp32-camera-qr-recoginize&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/espressif/esp-who&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP-WHO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/espressif/esp-idf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP-IDF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ESP32 开发笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二十三）看门狗</title>
    <link href="https://blog.infiniteyuan.com/2019/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <id>https://blog.infiniteyuan.com/2019/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89%E7%9C%8B%E9%97%A8%E7%8B%97/</id>
    <published>2019-03-12T10:52:35.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗"></a>看门狗</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-IDF 支持两种类型的看门狗：中断看门狗定时器和任务看门狗定时器（TWDT）。中断看门狗定时器和 TWDT 都可以使用 make menuconfig 启用，但 TWDT 也可以在运行时启用。中断看门狗负责检测 FreeRTOS 任务切换长时间被阻止的情况。TWDT 负责检测运行的任务在长时间没有让出 CPU 的情况。</p><h2 id="中断看门狗"><a href="#中断看门狗" class="headerlink" title="中断看门狗"></a>中断看门狗</h2><p>中断看门狗可确保 FreeRTOS 任务切换中断长时间不被阻止。这种情况很不好，因为没有其他任务能获得 CPU 运行时间，包括可能重要的任务，如 WiFi 任务和空闲任务。阻塞的任务切换中断可能发生当一个程序运行到无限循环并且中断被禁用或挂起中断。</p><p>中断监视程序的默认操作是调用 panic 处理程序。将会把寄存器转储以便于使用 OpenOCD 或 gdbstub找到，在禁用中断的情况下会阻塞哪些代码。根据 panic 处理程序的配置，它还可以盲目地重置 CPU，这在生产环境中可能是首选。</p><p>中断看门狗是围绕定时器组 1 中的硬件看门狗构建的。如果由于某种原因这个看门狗无法执行调用 panic 处理程序的 NMI 处理程序（例如，因为 IRAM 被垃圾覆盖），它将硬重置 SOC。</p><a id="more"></a><h2 id="任务看门狗定时器"><a href="#任务看门狗定时器" class="headerlink" title="任务看门狗定时器"></a>任务看门狗定时器</h2><p>负责检测运行的任务在长时间没有让出 CPU 的情况。这是 CPU “饥饿”的症状，通常是由一个高优先级任务不让出 CPU 资源的循环引起，从而使较低优先级任务无法获得 CPU 资源。这可能是外围设备上的代码写得不好，也可能是陷入无限循环的任务。</p><p>默认情况下，TWDT 将监视每个 CPU 的空闲任务，但任何任务都可以选择由 TWDT 监视。每个观察任务必须定期“重置” TWDT 以指示它们已被分配 CPU 时间。如果任务未在 TWDT 超时期限内重置，则将打印一条警告，其中包含有关哪些任务未能及时重置 TWDT 以及哪些任务当前正在 ESP32 CPU 上运行的信息。并且还有可能在用户代码中重新定义函数 <code>esp_task_wdt_isr_user_handler</code> 以接收此事件。</p><p>TWDT 围绕定时器组 0 中的硬件看门狗定时器构建。可以通过调用 <code>esp_task_wdt_init（）</code> 来初始化 TWDT，这将配置硬件定时器。然后，任务可以使用 <code>esp_task_wdt_add（）</code> 订阅 TWDT 监视。每个订阅的任务必须定期调用 <code>esp_task_wdt_reset（）</code> 来重置 TWDT。任何订阅任务无法定期调用 <code>esp_task_wdt_reset（）</code> 表示一个或多个任务已经缺乏 CPU 资源或者陷入某个循环。</p><p>可以使用 <code>esp_task_wdt_delete（）</code> 从 TWDT 取消订阅监视的任务。已取消订阅的任务不应再调用 <code>esp_task_wdt_reset（）</code>。一旦所有任务都从 TWDT 取消订阅，可以通过调用 <code>esp_task_wdt_deinit（）</code> 来取消初始化 TWDT。</p><p>默认情况下，make menuconfig 中的 CONFIG_TASK_WDT 将被启用，导致 TWDT 在启动期间自动初始化。同样，CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0 和 CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU1 也会默认启用，导致两个空闲任务在启动期间订阅 TWDT。</p><h2 id="JTAG-和-看门狗"><a href="#JTAG-和-看门狗" class="headerlink" title="JTAG 和 看门狗"></a>JTAG 和 看门狗</h2><p>在使用 OpenOCD 进行调试时，每次到达断点时都会暂停 CPU。但是，如果看门狗定时器在遇到断点时继续运行，它们最终会触发复位，从而很难调试代码。 因此，OpenOCD 将在每个断点处禁用中断和任务看门狗的硬件定时器。 此外，OpenOCD 在离开断点时不会重新启用它们。 这意味着中断看门狗和任务看门狗功能将基本上被禁用。 当 ESP32 通过 JTAG 连接到 OpenOCD 时，不会产生任何看门狗警告或 panic。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/system/wdts.html" target="_blank" rel="noopener">Watchdogs</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;看门狗&quot;&gt;&lt;a href=&quot;#看门狗&quot; class=&quot;headerlink&quot; title=&quot;看门狗&quot;&gt;&lt;/a&gt;看门狗&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ESP-IDF 支持两种类型的看门狗：中断看门狗定时器和任务看门狗定时器（TWDT）。中断看门狗定时器和 TWDT 都可以使用 make menuconfig 启用，但 TWDT 也可以在运行时启用。中断看门狗负责检测 FreeRTOS 任务切换长时间被阻止的情况。TWDT 负责检测运行的任务在长时间没有让出 CPU 的情况。&lt;/p&gt;
&lt;h2 id=&quot;中断看门狗&quot;&gt;&lt;a href=&quot;#中断看门狗&quot; class=&quot;headerlink&quot; title=&quot;中断看门狗&quot;&gt;&lt;/a&gt;中断看门狗&lt;/h2&gt;&lt;p&gt;中断看门狗可确保 FreeRTOS 任务切换中断长时间不被阻止。这种情况很不好，因为没有其他任务能获得 CPU 运行时间，包括可能重要的任务，如 WiFi 任务和空闲任务。阻塞的任务切换中断可能发生当一个程序运行到无限循环并且中断被禁用或挂起中断。&lt;/p&gt;
&lt;p&gt;中断监视程序的默认操作是调用 panic 处理程序。将会把寄存器转储以便于使用 OpenOCD 或 gdbstub找到，在禁用中断的情况下会阻塞哪些代码。根据 panic 处理程序的配置，它还可以盲目地重置 CPU，这在生产环境中可能是首选。&lt;/p&gt;
&lt;p&gt;中断看门狗是围绕定时器组 1 中的硬件看门狗构建的。如果由于某种原因这个看门狗无法执行调用 panic 处理程序的 NMI 处理程序（例如，因为 IRAM 被垃圾覆盖），它将硬重置 SOC。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二十二）睡眠模式</title>
    <link href="https://blog.infiniteyuan.com/2019/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%E7%9D%A1%E7%9C%A0%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.infiniteyuan.com/2019/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%E7%9D%A1%E7%9C%A0%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-03-12T00:28:34.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="睡眠模式"><a href="#睡眠模式" class="headerlink" title="睡眠模式"></a>睡眠模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 有轻度睡眠(light sleep)和深度睡眠(deep sleep)两种省电模式。</p><p>在轻度睡眠模式下，数字外设，大多数 RAM 和 CPU 都是时钟门控的，电源电压会降低。从轻度睡眠退出后，外围设备和 CPU 恢复运行，其内部状态将得以保留。</p><p>在深度睡眠模式下，CPU，大多数 RAM 以及从 APB_CLK 提供时钟的所有数字外设都将断电。芯片中仍然可以通电的唯一部分是：RTC 控制器，RTC 外设（包括 ULP 协处理器）和 RTC 存储器（慢速和快速）。</p><p>可以使用多种唤醒源从深度和轻度睡眠模式唤醒。可以组合这些唤醒源，在这种情况下，当触发任何一个源时芯片将被唤醒。可以使用 <code>esp_sleep_enable_X_wakeup</code> API 启用唤醒源，并可以使用 <code>esp_sleep_disable_wakeup_source()</code> API 禁用唤醒源。下一节将详细介绍这些 API。在进入浅色或深度睡眠模式之前，可以随时配置唤醒源。</p><p>此外，应用程序可以使用 <code>esp_sleep_pd_config()</code> API 强制 RTC 外设和 RTC 存储器的特定掉电模式。</p><p>配置唤醒源后，应用程序可以使用 <code>esp_light_sleep_start()</code> 或 <code>esp_deep_sleep_start()</code> API 进入睡眠模式。此时，将根据请求的唤醒源配置硬件，RTC 控制器将关闭 CPU 或数字外设的电源或关闭电源。</p><a id="more"></a><h2 id="WiFi-BT-和睡眠模式"><a href="#WiFi-BT-和睡眠模式" class="headerlink" title="WiFi/BT 和睡眠模式"></a>WiFi/BT 和睡眠模式</h2><p>在深度睡眠和轻度睡眠模式下，无线外围设备断电。 在进入深度睡眠或轻度睡眠模式之前，应用程序必须调用适当的函数（<code>esp_bluedroid_disable()</code>，<code>esp_bt_controller_disable()</code>，<code>esp_wifi_stop()</code>）禁用 WiFi 和 BT。 即使不调用这些功能，也不会在深度睡眠或轻度睡眠中保持 WiFi 和 BT 连接。</p><p>如果需要维护 WiFi 连接，请启用 WiFi 调制解调器睡眠(modem sleep)，并启用自动轻度睡眠功能（请参阅<a href="https://blog.csdn.net/qq_27114397/article/details/88411347" target="_blank" rel="noopener">电源管理 API</a>）。这将允许系统在需要 WiFi 驱动程序时自动从睡眠中唤醒，从而保持与 AP 的连接。</p><h2 id="唤醒源"><a href="#唤醒源" class="headerlink" title="唤醒源"></a>唤醒源</h2><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>RTC 控制器具有内置定时器，可用于在预定义的时间后唤醒芯片。时间以微秒精度指定，但实际分辨率取决于为 RTC SLOW_CLK 选择的时钟源。有关 RTC 时钟选项的详细信息，请参见“ESP32 技术参考手册”的“复位和时钟”一章。</p><p>此唤醒模式不需要在睡眠期间打开 RTC 外围设备或 RTC 存储器。</p><p><code>esp_sleep_enable_timer_wakeup()</code> 函数可用于使用定时器启用深度睡眠唤醒。</p><h3 id="Touch-pad"><a href="#Touch-pad" class="headerlink" title="Touch pad"></a>Touch pad</h3><p>RTC IO 模块包含触摸传感器中断时触发唤醒的逻辑。您需要在芯片开始深度睡眠之前配置触摸传感器。</p><p>当 RTC 外设未被强制上电时（即 <code>ESP_PD_DOMAIN_RTC_PERIPH</code> 应设置为 <code>ESP_PD_OPTION_AUTO</code>），ESP32 的修订版 0 和 1 仅支持此唤醒模式。</p><p><code>esp_sleep_enable_touchpad_wakeup()</code> 函数可用于启用此唤醒源。</p><h3 id="External-唤醒-ext0"><a href="#External-唤醒-ext0" class="headerlink" title="External 唤醒(ext0)"></a>External 唤醒(ext0)</h3><p>RTC IO 模块包含当其中 <strong>一个 RTC GPIO</strong> 的电平为预定义的逻辑电平时触发唤醒的逻辑。RTC IO 是 RTC 外设电源域的一部分，因此如果请求唤醒源，RTC 外设将在深度睡眠期间保持通电状态。</p><p>由于在此模式下启用了 RTC IO 模块，因此也可以使用内部上拉或下拉电阻。在调用 <code>esp_sleep_start()</code> 之前，需要使用 <code>rtc_gpio_pullup_en()</code> 和 <code>rtc_gpio_pulldown_en()</code> 函数由应用程序配置它们。</p><p>在 ESP32 的修订版 0 和 1 中，此唤醒源与 ULP 和触摸唤醒源不兼容。</p><p><code>esp_sleep_enable_ext0_wakeup()</code> 函数可用于启用此唤醒源。</p><blockquote><p>从睡眠状态唤醒后，用于唤醒的 IO pad 将被配置为 RTC IO。在将此 pad 用作数字 GPIO 之前，请使用 <code>rtc_gpio_deinit(gpio_num)</code> 函数重新配置它。</p></blockquote><h3 id="External-唤醒-ext1"><a href="#External-唤醒-ext1" class="headerlink" title="External 唤醒(ext1)"></a>External 唤醒(ext1)</h3><p>RTC 控制器包含使用 <strong>多个 RTC GPIO</strong> 触发唤醒的逻辑。两个逻辑功能之一可用于触发唤醒：</p><ul><li>如果任何所选引脚为高电平，则唤醒（<code>ESP_EXT1_WAKEUP_ANY_HIGH</code>）</li><li>如果所有选定的引脚都为低电平，则唤醒（<code>ESP_EXT1_WAKEUP_ALL_LOW</code>）</li></ul><p>该唤醒源由 RTC 控制器实现。因此，RTC 外设和 RTC 存储器可以在此模式下断电。但是，如果 RTC 外设断电，内部上拉和下拉电阻将被禁用。要使用内部上拉或下拉电阻，请在睡眠期间请求 RTC 外设电源域保持开启，并在进入睡眠模式之前使用 rtc_gpio_ 函数配置上拉/下拉电阻：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);</span><br><span class="line">gpio_pullup_dis(gpio_num);</span><br><span class="line">gpio_pulldown_en(gpio_num);</span><br></pre></td></tr></table></figure><p><code>esp_sleep_enable_ext1_wakeup()</code>  函数可用于启用此唤醒源。</p><blockquote><p>从睡眠状态唤醒后，用于唤醒的 IO pad 将被配置为 RTC IO。在将此 pad 用作数字 GPIO 之前，请使用 <code>rtc_gpio_deinit(gpio_num)</code> 函数重新配置它。</p></blockquote><h3 id="ULP-协处理器唤醒"><a href="#ULP-协处理器唤醒" class="headerlink" title="ULP 协处理器唤醒"></a>ULP 协处理器唤醒</h3><p>ULP 协处理器可以在芯片处于睡眠模式时运行，并且可以用于轮询传感器，监视 ADC 或触摸传感器值，并在检测到特定事件时唤醒芯片。ULP 协处理器是 RTC 外设电源域的一部分，它运行存储在 RTC 慢速存储器中的程序。如果请求此唤醒模式，RTC 慢速内存将在睡眠期间启动。在 ULP 协处理器开始运行程序之前，RTC 外设将自动上电; 程序停止运行后，RTC 外设将再次自动关闭。</p><p>当 RTC 外设未被强制上电时（即 <code>ESP_PD_DOMAIN_RTC_PERIPH</code> 应设置为 <code>ESP_PD_OPTION_AUTO</code>），ESP32 的修订版 0 和 1 仅支持此唤醒模式。</p><p><code>esp_sleep_enable_ulp_wakeup()</code>  函数可用于启用此唤醒源。</p><h3 id="GPIO-唤醒-仅-light-sleep"><a href="#GPIO-唤醒-仅-light-sleep" class="headerlink" title="GPIO 唤醒(仅 light sleep)"></a>GPIO 唤醒(仅 light sleep)</h3><p>除了上面描述的 EXT0 和 EXT1 唤醒源之外，在轻度睡眠模式下还有一种从外部输入唤醒的方法。通过该唤醒源，每个引脚可以单独使用 <code>gpio_wakeup_enable()</code> 函数配置为高电平或低电平唤醒。与 EXT0 和 EXT1 唤醒源（只能与 RTC IO 一起使用）不同，此唤醒源可用于任何 IO（RTC 或数字）。</p><p><code>esp_sleep_enable_gpio_wakeup()</code> 函数可用于启用此唤醒源。</p><h3 id="UART-唤醒-仅-light-sleep"><a href="#UART-唤醒-仅-light-sleep" class="headerlink" title="UART 唤醒(仅 light sleep)"></a>UART 唤醒(仅 light sleep)</h3><p>当 ESP32 从外部设备接收 UART 输入时，通常需要在输入数据可用时唤醒芯片。UART 外设包含一项功能，当看到 RX 引脚上的一定数量的上升沿时，可以将芯片从轻度睡眠状态唤醒。可以使用 <code>uart_set_wakeup_threshold()</code> 函数设置此上升沿数。请注意，唤醒后 UART 不会接收触发唤醒的字符（及其前面的任何字符）。 这意味着外部设备通常需要在发送数据之前向 ESP32 发送额外字符以触发唤醒。</p><p><code>esp_sleep_enable_uart_wakeup()</code> 函数可用于启用此唤醒源。</p><h2 id="RTC外设和存储器掉电"><a href="#RTC外设和存储器掉电" class="headerlink" title="RTC外设和存储器掉电"></a>RTC外设和存储器掉电</h2><p>默认情况下，<code>esp_deep_sleep_start()</code> 和 <code>esp_light_sleep_start()</code> 函数将关闭所有启用的唤醒源不再需要的 RTC 电源域。要覆盖此行为，请提供 <code>esp_sleep_pd_config()</code> 函数。</p><p>注意：在 ESP32 的版本 0 中，RTC 快速存储器将始终在深度睡眠中保持启用状态，以便深度睡眠存根可以在复位后运行。 如果应用程序在深度睡眠后不需要干净的重置行为，则可以覆盖此项。</p><p>如果程序中的某些变量放入RTC慢速存储器（例如，使用 <code>RTC_DATA_ATTR</code> 属性），RTC 慢速存储器将默认保持通电状态。 如果需要，可以使用 <code>esp_sleep_pd_config()</code> 函数覆盖它。</p><h2 id="进入轻度睡眠"><a href="#进入轻度睡眠" class="headerlink" title="进入轻度睡眠"></a>进入轻度睡眠</h2><p>配置唤醒源后，可使用 <code>esp_light_sleep_start()</code> 函数进入轻度睡眠模式。在没有配置唤醒源的情况下也可以进入轻度睡眠状态，在这种情况下，芯片将无限期地处于轻度睡眠模式，直到外部复位。</p><h2 id="进入深度睡眠"><a href="#进入深度睡眠" class="headerlink" title="进入深度睡眠"></a>进入深度睡眠</h2><p>配置唤醒源后，可使用 <code>esp_deep_sleep_start()</code> 函数进入深度睡眠模式。在没有配置唤醒源的情况下也可以进入深度睡眠状态，在这种情况下，芯片将无限期地处于深度睡眠模式，直到外部复位。</p><h2 id="IO-配置"><a href="#IO-配置" class="headerlink" title="IO 配置"></a>IO 配置</h2><p>一些 ESP32 IO 具有内部上拉或下拉，默认情况下启用。如果外部电路在深度睡眠模式下驱动此引脚，则由于流过这些上拉和下拉的电流，电流消耗可能会增加。</p><p>要隔离引脚，防止额外的电流消耗，请调用 <code>rtc_gpio_isolate()</code> 函数。</p><p>例如，在 ESP32-WROVER 模块上，外部上拉 GPIO12。GPIO12 在 ESP32 芯片中也有内部下拉。这意味着在深度睡眠中，一些电流将流过这些外部和内部电阻，从而将深度睡眠电流增加到最小可能值以上。在 <code>esp_deep_sleep_start()</code> 之前添加以下代码以删除此额外电流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtc_gpio_isolate(GPIO_NUM_12);</span><br></pre></td></tr></table></figure><h2 id="UART-输出处理"><a href="#UART-输出处理" class="headerlink" title="UART 输出处理"></a>UART 输出处理</h2><p>在进入睡眠模式之前，<code>esp_deep_sleep_start()</code> 将刷新 UART FIFO 的内容。</p><p>使用 <code>esp_light_sleep_start()</code> 进入轻度睡眠模式时，UART FIFO 不会被刷新。相反，UART 输出将被暂停，FIFO 中的剩余字符将在从轻度睡眠唤醒后发送出去。</p><h2 id="检查睡眠唤醒原因"><a href="#检查睡眠唤醒原因" class="headerlink" title="检查睡眠唤醒原因"></a>检查睡眠唤醒原因</h2><p><code>esp_sleep_get_wakeup_cause()</code> 函数可用于检查哪个唤醒源触发了从睡眠模式中唤醒。</p><p>对于 TouchPad 和 ext1 唤醒源，可以使用 <code>esp_sleep_get_touchpad_wakeup_status()</code> 和 <code>esp_sleep_get_ext1_wakeup_status()</code> 函数识别引起唤醒的引脚或 TouchPad。</p><h2 id="禁用睡眠唤醒源"><a href="#禁用睡眠唤醒源" class="headerlink" title="禁用睡眠唤醒源"></a>禁用睡眠唤醒源</h2><p>先前配置的唤醒源可以在之后使用 <code>esp_sleep_disable_wakeup_source()</code> API 禁用。此功能将停用触发对给定唤醒源。此外，如果参数为 ESP_SLEEP_WAKEUP_ALL，它可以禁用所有触发器。</p><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>深度睡眠的基本功能的实现在 protocols/sntp 示例中给出，其中 ESP 模块被周期性地唤醒以从 NTP 服务器检索时间。</p><p>system/deep_sleep 示例中更广泛的说明了各种深度睡眠唤醒触发器和 ULP 协处理器编程的使用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/system/sleep_modes.html" target="_blank" rel="noopener">Sleep Modes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;睡眠模式&quot;&gt;&lt;a href=&quot;#睡眠模式&quot; class=&quot;headerlink&quot; title=&quot;睡眠模式&quot;&gt;&lt;/a&gt;睡眠模式&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ESP32 有轻度睡眠(light sleep)和深度睡眠(deep sleep)两种省电模式。&lt;/p&gt;
&lt;p&gt;在轻度睡眠模式下，数字外设，大多数 RAM 和 CPU 都是时钟门控的，电源电压会降低。从轻度睡眠退出后，外围设备和 CPU 恢复运行，其内部状态将得以保留。&lt;/p&gt;
&lt;p&gt;在深度睡眠模式下，CPU，大多数 RAM 以及从 APB_CLK 提供时钟的所有数字外设都将断电。芯片中仍然可以通电的唯一部分是：RTC 控制器，RTC 外设（包括 ULP 协处理器）和 RTC 存储器（慢速和快速）。&lt;/p&gt;
&lt;p&gt;可以使用多种唤醒源从深度和轻度睡眠模式唤醒。可以组合这些唤醒源，在这种情况下，当触发任何一个源时芯片将被唤醒。可以使用 &lt;code&gt;esp_sleep_enable_X_wakeup&lt;/code&gt; API 启用唤醒源，并可以使用 &lt;code&gt;esp_sleep_disable_wakeup_source()&lt;/code&gt; API 禁用唤醒源。下一节将详细介绍这些 API。在进入浅色或深度睡眠模式之前，可以随时配置唤醒源。&lt;/p&gt;
&lt;p&gt;此外，应用程序可以使用 &lt;code&gt;esp_sleep_pd_config()&lt;/code&gt; API 强制 RTC 外设和 RTC 存储器的特定掉电模式。&lt;/p&gt;
&lt;p&gt;配置唤醒源后，应用程序可以使用 &lt;code&gt;esp_light_sleep_start()&lt;/code&gt; 或 &lt;code&gt;esp_deep_sleep_start()&lt;/code&gt; API 进入睡眠模式。此时，将根据请求的唤醒源配置硬件，RTC 控制器将关闭 CPU 或数字外设的电源或关闭电源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二十一）电源管理</title>
    <link href="https://blog.infiniteyuan.com/2019/03/11/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://blog.infiniteyuan.com/2019/03/11/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/</id>
    <published>2019-03-11T22:20:34.000Z</published>
    <updated>2020-08-02T06:36:34.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-IDF 中包含的电源管理算法可以根据应用组件的要求调整 APB 频率，CPU 频率，并使芯片进入 light sleep 模式，以尽可能低的功耗运行应用程序。</p><p>应用程序组件可以通过创建和获取电源管理锁来表达其要求。</p><p>例如，由 APB 提供时钟的外围设备的驱动器可以在使用外围设备的时间内请求将 APB 频率设置为80MHz。另一个例子是，当有任务准备好运行时，RTOS 将请求 CPU 以最高配置频率运行。又一个例子是需要启用中断的外围驱动器。这样的驱动程序可以请求禁用 light sleep。</p><p>当然，要求更高的 APB 或 CPU 频率或禁用 light sleep 会导致更高的电流消耗。组件应尽可能在最短的时间内限制电源管理锁的使用。</p><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>可以使用 <code>CONFIG_PM_ENABLE</code> 选项在编译时启用电源管理。</p><p>启用电源管理功能的代价是增加了中断延迟。额外延迟取决于许多因素，其中包括 CPU 频率，单/双核模式，是否需要执行频率切换。最小额外延迟为 0.2us（当 CPU 频率为 240MHz，并且未启用频率调整时），最大额外延迟为 40us（启用频率调整时，在中断输入时执行从 40MHz 到 80MHz 的切换）。</p><p>通过调用 <code>esp_pm_configure()</code> 函数，可以在应用程序中启用动态频率调整（DFS）和自动光睡眠。它的参数是定义频率缩放设置的结构，<code>esp_pm_config_esp32_t</code>。在此结构中，需要初始化 3 个字段：</p><ul><li><code>max_freq_mhz</code>  - 最大 CPU 频率，以 MHZ 为单位（即采用 <code>ESP_PM_CPU_FREQ_MAX</code> 时使用的频率）。 这通常设置为 <code>CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ</code>。</li><li><code>min_freq_mhz</code>  - 最小 CPU 频率，以 MHz 为单位（即仅采用 <code>ESP_PM_APB_FREQ_MAX</code> 锁定时使用的频率）。 这可以设置为 XTAL 频率，或 XTAL 频率除以整数。 请注意，10MHz 是可以生成 1MHz 的默认 REF_TICK 时钟的最低频率。</li><li><code>light_sleep_enable</code>  - 当没有锁定时，系统是否应自动进入 light sleep 状态（true/false）。</li></ul><blockquote><p>自动 light sleep 模式基于 FreeRTOS Tickless Idle 功能。如果在 menuconfig 中未启用 <code>CONFIG_FREERTOS_USE_TICKLESS_IDLE</code>选项，则 <code>esp_pm_configure()</code> 将返回 <code>ESP_ERR_NOT_SUPPORTED</code> 错误，但请求自动 light sleep。</p></blockquote><blockquote><p>在 light sleep 模式下，外设是时钟门控的，不会产生中断（来自 GPIO 和内部外设）。睡眠模式文档中描述的唤醒源可用于从 light sleep 状态唤醒。例如，EXT0 和 EXT1 唤醒源可用于从 GPIO 唤醒。</p></blockquote><p>或者，可以在 menuconfig 中启用 <code>CONFIG_PM_DFS_INIT_AUTO</code> 选项。如果启用，最大 CPU 频率由 <code>CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ</code> 设置决定，最小 CPU 频率设置为 XTAL 频率。</p><h2 id="电源管理锁"><a href="#电源管理锁" class="headerlink" title="电源管理锁"></a>电源管理锁</h2><p>如概述中所述，应用程序可以获取/释放锁以控制电源管理算法。当应用程序锁定时，对于每个锁定，电源管理算法操作以下面描述的方式受到限制。释放锁定时，将删除此类限制。</p><p>应用程序的不同部分可以采用相同的锁定。 在这种情况下，锁定必须被释放的次数与获取的次数相同，以便恢复功率管理算法。</p><p>在 ESP32 中，支持三种类型的锁：</p><ul><li><code>ESP_PM_CPU_FREQ_MAX</code><br>请求 CPU 频率为 <code>esp_pm_configure()</code> 设置的最大值。对于 ESP32，此值可以设置为 80,160 或 240MHz。</li><li><code>ESP_PM_APB_FREQ_MAX</code><br>请求 APB 频率处于最大支持值。对于 ESP32，这是 80MHz。</li><li><code>ESP_PM_NO_LIGHT_SLEEP</code><br>防止使用自动 light sleep 模式。</li></ul><h2 id="ESP32-的电源管理算法"><a href="#ESP32-的电源管理算法" class="headerlink" title="ESP32 的电源管理算法"></a>ESP32 的电源管理算法</h2><p>启用动态频率调整后，CPU 频率将按如下方式切换：</p><ul><li><p>如果最大 CPU 频率（使用 <code>esp_pm_configure()</code> 或 <code>CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ</code> 设置）为 240 MHz：</p><ol><li>获取 <code>ESP_PM_CPU_FREQ_MAX</code> 或 <code>ESP_PM_APB_FREQ_MAX</code> 时，CPU 频率为 240 MHz，APB 频率为 80 MHz。</li><li>否则，频率将切换到使用 <code>esp_pm_configure()</code>设置的最小值。</li></ol></li><li><p>如果最大 CPU 频率为 160 MHz：</p><ol><li>获取 <code>ESP_PM_CPU_FREQ_MAX</code> 时，CPU 频率设置为 160 MHz，APB 频率设置为 80 MHz。</li><li>当未获取 <code>ESP_PM_CPU_FREQ_MAX</code> 但 <code>ESP_PM_APB_FREQ_MAX</code> 为时，CPU 和 APB 频率设置为 80 MHz。</li><li>否则，频率将切换到使用 <code>esp_pm_configure()</code> 设置的最小值。</li></ol></li><li><p>如果最大 CPU 频率为 80 MHz：</p><ol><li>获取 <code>ESP_PM_CPU_FREQ_MAX</code> 或 <code>ESP_PM_APB_FREQ_MAX</code> 锁时，CPU 和 APB 频率将为 80 MHz。</li><li>否则，频率将切换到使用 <code>esp_pm_configure()</code> 设置的最小值。</li></ol></li><li><p>如果未获取任何锁定，并且在调用 <code>esp_pm_configure()</code> 时启用了轻度睡眠，则系统将进入轻度睡眠模式(light sleep)。轻度睡眠的持续时间将由以下因素确定：</p><ul><li>FreeRTOS 任务因有限超时而被阻止<ul><li>定时器使用高分辨率计时器 API 注册</li></ul></li></ul></li></ul><p>轻度睡眠持续时间将被选择为在最近的事件之前唤醒（任务被解锁或计时器过去）。</p><h2 id="动态频率调整和外设驱动程序"><a href="#动态频率调整和外设驱动程序" class="headerlink" title="动态频率调整和外设驱动程序"></a>动态频率调整和外设驱动程序</h2><p>启用 DFS 后，APB 频率可在单个 RTOS 滴答内多次更改。即使 APB 频率发生变化，一些外围设备也能正常工作; 有些不能。</p><p>即使 APB 频率发生变化，以下外设也能正常工作：</p><ul><li>UART：如果 REF_TICK 用作时钟源（请参阅 uart_config_t 的 use_ref_tick 成员）。</li><li>LEDC：如果 REF_TICK 用作时钟源（参见 <code>ledc_timer_config()</code> 函数）。</li><li>RMT：如果 REF_TICK 用作时钟源。 目前，驱动程序不支持 REF_TICK，但可以通过清除相应通道的 <code>RMT_REF_ALWAYS_ON_CHx</code> 位来启用它。</li></ul><p>目前，以下外围驱动程序知道 DFS，并将在事务持续时间内使用 <code>ESP_PM_APB_FREQ_MAX</code> 锁定：</p><ul><li>SPI master</li><li>SDMMC</li></ul><p>启用驱动程序时，以下驱动程序将保持 <code>ESP_PM_APB_FREQ_MAX</code> 锁定：</p><ul><li>SPI slave  - 在调用 <code>spi_slave_initialize()</code> 和 <code>spi_slave_free()</code> 之间。</li><li>以太网 - 在调用 <code>esp_eth_enable()</code> 和 <code>esp_eth_disable()</code> 之间。</li><li>WiFi  - 在调用 <code>esp_wifi_start()</code> 和 <code>esp_wifi_stop()</code> 之间。 如果启用了调制解调器睡眠(modem sleep)，则在禁用无线电时的一段时间内将释放锁定。</li><li>蓝牙 - 在调用 <code>esp_bt_controller_enable()</code> 和 <code>esp_bt_controller_disable()</code> 之间。</li><li>CAN  - 调用 <code>can_driver_install()</code> 和 <code>can_driver_uninstall()</code> 之间</li></ul><p>以下外围驱动程序尚未处理 DFS。应用程序需要在必要时获取/释放锁定：</p><ul><li>I2C</li><li>I2S</li><li>MCPWM</li><li>PCNT</li><li>Sigma-delta</li><li>Timer group</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/system/power_management.html" target="_blank" rel="noopener">Power Management</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;电源管理&quot;&gt;&lt;a href=&quot;#电源管理&quot; class=&quot;headerlink&quot; title=&quot;电源管理&quot;&gt;&lt;/a&gt;电源管理&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ESP-IDF 中包含的电源管理算法可以根据应用组件的要求调整 APB 频率，CPU 频率，并使芯片进入 light sleep 模式，以尽可能低的功耗运行应用程序。&lt;/p&gt;
&lt;p&gt;应用程序组件可以通过创建和获取电源管理锁来表达其要求。&lt;/p&gt;
&lt;p&gt;例如，由 APB 提供时钟的外围设备的驱动器可以在使用外围设备的时间内请求将 APB 频率设置为80MHz。另一个例子是，当有任务准备好运行时，RTOS 将请求 CPU 以最高配置频率运行。又一个例子是需要启用中断的外围驱动器。这样的驱动程序可以请求禁用 light sleep。&lt;/p&gt;
&lt;p&gt;当然，要求更高的 APB 或 CPU 频率或禁用 light sleep 会导致更高的电流消耗。组件应尽可能在最短的时间内限制电源管理锁的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（二十）RTC 和低功耗管理</title>
    <link href="https://blog.infiniteyuan.com/2019/03/04/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89RTC%20%E5%92%8C%E4%BD%8E%E5%8A%9F%E8%80%97%E7%AE%A1%E7%90%86/"/>
    <id>https://blog.infiniteyuan.com/2019/03/04/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89RTC%20%E5%92%8C%E4%BD%8E%E5%8A%9F%E8%80%97%E7%AE%A1%E7%90%86/</id>
    <published>2019-03-04T10:10:42.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RTC-和低功耗管理"><a href="#RTC-和低功耗管理" class="headerlink" title="RTC 和低功耗管理"></a>RTC 和低功耗管理</h1><p>ESP32 采用了先进的电源管理技术，可以在不同的功耗模式之间切换。</p><h2 id="1-功耗模式"><a href="#1-功耗模式" class="headerlink" title="1 功耗模式"></a>1 功耗模式</h2><ul><li>Active 模式:芯片射频处于工作状态。芯片可以接收、发射和侦听信号。</li><li>Modem-sleep 模式:CPU 可运行，时钟可被配置。Wi-Fi/蓝牙基带和射频关闭。</li><li>Light-sleep 模式:CPU 暂停运行。RTC 存储器和外设以及 ULP 协处理器运行。任何唤醒事件(MAC、主机、RTC 定时器或外部中断)都会唤醒芯片。</li><li>Deep-sleep 模式:CPU 和大部分外设都会掉电，只有 RTC 存储器和 RTC 外设处于工作状态。Wi-Fi 和蓝牙连接数据存储在 RTC 中。ULP 协处理器可以工作。</li><li>Hibernation 模式:内置的 8 MHz 振荡器和 ULP 协处理器均被禁用。RTC 内存恢复电源被切断。只有1 个位于低速时钟上的 RTC 时钟定时器和某些 RTC GPIO 在工作。RTC 时钟定时器或 RTC GPIO 可以将芯片从 Hibernation 模式中唤醒。</li></ul><a id="more"></a><h2 id="2-低功耗模式功耗"><a href="#2-低功耗模式功耗" class="headerlink" title="2 低功耗模式功耗"></a>2 低功耗模式功耗</h2><p>设备在不同的功耗模式下有不同的电流消耗，详情请见下表。</p><p><img src="https://img-blog.csdnimg.cn/20190304100817958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="不同功耗模式下的功耗">)<img src="https://img-blog.csdnimg.cn/201903041011254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="射频功耗参数"></p><h2 id="3-说明"><a href="#3-说明" class="headerlink" title="3 说明"></a>3 说明</h2><ul><li>ESP32 系列芯片中，ESP32-D0WDQ6 与 ESP32-D0WD 的 CPU 最大频率为 240 MHz;ESP32-D2WD 与 ESP32-S0WD 的 CPU 最大频率为 160 MHz。</li><li>在 Wi-Fi 开启的场景中，芯片会在 Active 和 Modem-sleep 模式之间切换，功耗也会在两种模式间变化。</li><li>Modem-sleep 模式下，CPU 频率自动变化，频率取决于 CPU 负载和使用的外设。</li><li>Deep-sleep 模式下，仅 ULP 协处理器处于工作状态时，可以操作 GPIO 及低功耗 I2C。</li><li>当系统处于超低功耗传感器监测模式时，ULP 协处理器和传感器周期性工作,ADC 以 1% 占空比工作，系统功耗典型值为 100 μA。</li></ul><h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h2><ul><li><a href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf" target="_blank" rel="noopener">ESP32 技术参考手册</a></li><li><a href="https://infiniteyuan.blog.csdn.net/article/details/106451678" target="_blank" rel="noopener">ESP32 学习笔记（二十九） ESP32 低功耗模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RTC-和低功耗管理&quot;&gt;&lt;a href=&quot;#RTC-和低功耗管理&quot; class=&quot;headerlink&quot; title=&quot;RTC 和低功耗管理&quot;&gt;&lt;/a&gt;RTC 和低功耗管理&lt;/h1&gt;&lt;p&gt;ESP32 采用了先进的电源管理技术，可以在不同的功耗模式之间切换。&lt;/p&gt;
&lt;h2 id=&quot;1-功耗模式&quot;&gt;&lt;a href=&quot;#1-功耗模式&quot; class=&quot;headerlink&quot; title=&quot;1 功耗模式&quot;&gt;&lt;/a&gt;1 功耗模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Active 模式:芯片射频处于工作状态。芯片可以接收、发射和侦听信号。&lt;/li&gt;
&lt;li&gt;Modem-sleep 模式:CPU 可运行，时钟可被配置。Wi-Fi/蓝牙基带和射频关闭。&lt;/li&gt;
&lt;li&gt;Light-sleep 模式:CPU 暂停运行。RTC 存储器和外设以及 ULP 协处理器运行。任何唤醒事件(MAC、主机、RTC 定时器或外部中断)都会唤醒芯片。&lt;/li&gt;
&lt;li&gt;Deep-sleep 模式:CPU 和大部分外设都会掉电，只有 RTC 存储器和 RTC 外设处于工作状态。Wi-Fi 和蓝牙连接数据存储在 RTC 中。ULP 协处理器可以工作。&lt;/li&gt;
&lt;li&gt;Hibernation 模式:内置的 8 MHz 振荡器和 ULP 协处理器均被禁用。RTC 内存恢复电源被切断。只有1 个位于低速时钟上的 RTC 时钟定时器和某些 RTC GPIO 在工作。RTC 时钟定时器或 RTC GPIO 可以将芯片从 Hibernation 模式中唤醒。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（十六）ESP-MESH 编程指南</title>
    <link href="https://blog.infiniteyuan.com/2019/03/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89ESP-MESH%20%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>https://blog.infiniteyuan.com/2019/03/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89ESP-MESH%20%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</id>
    <published>2019-03-02T19:03:45.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP-MESH-编程指南"><a href="#ESP-MESH-编程指南" class="headerlink" title="ESP-MESH 编程指南"></a>ESP-MESH 编程指南</h1><p>这是 ESP-MESH 的编程指南，包括 API 参考和编码示例。本指南分为以下几部分：</p><ul><li>ESP-MESH 编程模型</li><li>编写 ESP-MESH 应用程序</li><li>自组织网络</li><li>应用实例</li><li>API 参考</li></ul><p>有关 ESP-MESH 协议的文档，请参阅 <a href="https://mp.csdn.net/postedit/86743079" target="_blank" rel="noopener">ESP-MESH API 指南</a>。</p><a id="more"></a><h2 id="ESP-MESH-编程模型"><a href="#ESP-MESH-编程模型" class="headerlink" title="ESP-MESH 编程模型"></a>ESP-MESH 编程模型</h2><h3 id="软件栈"><a href="#软件栈" class="headerlink" title="软件栈"></a>软件栈</h3><p>ESP-MESH 软件栈构建在 Wi-Fi 驱动/FreeRTOS 之上，并且在某些情况下可以使用 LwIP 栈（即根节点）。下图说明了 ESP-MESH 软件栈。<br><img src="https://img-blog.csdnimg.cn/2019030215595528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 软件栈"></p><h3 id="系统事件"><a href="#系统事件" class="headerlink" title="系统事件"></a>系统事件</h3><p>应用程序通过 ESP-MESH 事件与 ESP-MESH 交互。由于 ESP-MESH 构建在 Wi-Fi 栈的顶部，因此应用程序也可以通过 Wi-Fi 事件任务与 Wi-Fi 驱动交互。下图说明了 ESP-MESH 应用程序中各种系统事件的接口。<br><img src="https://img-blog.csdnimg.cn/20190302162721734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 系统事件"><br><code>mesh_event_id_t</code> 定义所有可能的  ESP-MESH 系统事件，并且可以指示诸如父/子的连接/断开之类的事件。在可以使用 ESP-MESH 系统事件之前，应用程序必须通过 <code>esp_mesh_set_config()</code> 注册 Mesh 事件回调。 回调用于从 ESP-MESH 栈以及 LwIP 栈接收事件，并且应包含与应用程序相关的每个事件的处理程序。</p><p>系统事件的典型用例包括使用诸如 <code>MESH_EVENT_PARENT_CONNECTED</code> 和 <code>MESH_EVENT_CHILD_CONNECTED</code> 之类的事件来指示节点何时可以分别开始上游和下游传输数据。 同样，<code>MESH_EVENT_ROOT_GOT_IP</code> 和 <code>MESH_EVENT_ROOT_LOST_IP</code> 可用于指示根节点何时能够和不能将数据传输到外部 IP 网络。</p><blockquote><p>在自组织模式下使用 ESP-MESH 时，用户必须确保不会调用 Wi-Fi API。这是因为自组织模式将在内部进行 Wi-Fi API 调用以连接/断开/扫描等。来自应用程序的任何 Wi-Fi 调用（包括来自回调函数和 Wi-Fi 事件处理程序的调用）可能干扰 ESP-MESH 的自组织行为。因此，在调用 <code>esp_mesh_start()</code> 之后，并且在调用 <code>esp_mesh_stop()</code> 之前，用户不应该调用 Wi-Fi API。</p></blockquote><h3 id="LwIP-amp-ESP-MESH"><a href="#LwIP-amp-ESP-MESH" class="headerlink" title="LwIP &amp; ESP-MESH"></a>LwIP &amp; ESP-MESH</h3><p><strong>应用程序可以直接访问 ESP-MESH 栈，而无需通过 LwIP 栈。仅根节点需要 LwIP 栈向/从外部 IP 网络发送/接收数据。</strong> 但是，由于每个节点都可能成为根节点（由于自动根节点选择），每个节点仍必须初始化 LwIP 栈。</p><p><strong>每个节点都需要通过调用 <code>tcpip_adapter_init()</code> 来初始化 LwIP 栈。为了防止非根节点访问 LwIP 栈，应用程序应在 LwIP 栈初始化后停止以下服务</strong>：</p><ul><li>SoftAP 接口上的 DHCP 服务器服务。</li><li>Station 接口上的 DHCP 客户端服务。</li></ul><p>以下代码段演示了如何为 ESP-MESH 应用程序初始化 LwIP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*  tcpip initialization *&#x2F;</span><br><span class="line">tcpip_adapter_init();</span><br><span class="line">&#x2F;*</span><br><span class="line"> * for mesh</span><br><span class="line"> * stop DHCP server on softAP interface by default</span><br><span class="line"> * stop DHCP client on station interface by default</span><br><span class="line"> *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA));</span><br><span class="line">&#x2F;* do not specify system event callback, use NULL instead. *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_event_loop_init(NULL, NULL));</span><br></pre></td></tr></table></figure><blockquote><p>ESP-MESH 要求根节点与路由器连接。因此，如果节点成为根节点，则相应的处理程序必须启动 DHCP 客户端服务并立即获取 IP 地址。这样做将允许其他节点开始向/从外部 IP 网络发送/接收分组。但是，如果使用静态 IP 设置，则不需要此步骤。</p></blockquote><h2 id="编写-ESP-MESH-应用程序"><a href="#编写-ESP-MESH-应用程序" class="headerlink" title="编写 ESP-MESH 应用程序"></a>编写 ESP-MESH 应用程序</h2><p><strong>启动 ESP-MESH 的先决条件是初始化 LwIP 和 Wi-Fi。</strong> 以下代码片段演示了初始化 ESP-MESH 之前必要的先决条件步骤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tcpip_adapter_init();</span><br><span class="line">&#x2F;*</span><br><span class="line"> * for mesh</span><br><span class="line"> * stop DHCP server on softAP interface by default</span><br><span class="line"> * stop DHCP client on station interface by default</span><br><span class="line"> *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA));</span><br><span class="line">&#x2F;* do not specify system event callback, use NULL instead. *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_event_loop_init(NULL, NULL));</span><br><span class="line"></span><br><span class="line">&#x2F;*  Wi-Fi initialization *&#x2F;</span><br><span class="line">wifi_init_config_t config &#x3D; WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_init(&amp;config));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_start());</span><br></pre></td></tr></table></figure><p>初始化 LwIP 和 Wi-Fi 后，启动和运行 ESP-MESH 网络的过程可归纳为以下三个步骤：</p><ul><li>初始化 Mesh</li><li>配置 ESP-MESH 网络</li><li>启动 Mesh</li></ul><h3 id="初始化-Mesh"><a href="#初始化-Mesh" class="headerlink" title="初始化 Mesh"></a>初始化 Mesh</h3><p>以下代码段演示了如何初始化 ESP-MESH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*  mesh initialization *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_init());</span><br></pre></td></tr></table></figure><h3 id="配置-ESP-MESH-网络"><a href="#配置-ESP-MESH-网络" class="headerlink" title="配置 ESP-MESH 网络"></a>配置 ESP-MESH 网络</h3><p><strong>ESP-MESH 通过 <code>esp_mesh_set_config()</code> 配置，它使用 <code>mesh_cfg_t</code> 结构接收其参数。</strong> 该结构包含用于配置 ESP-MESH 的以下参数：</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Channel</td><td>Range from 1 to 14</td></tr><tr><td>Event Callback</td><td>Callback for Mesh Events, see mesh_event_cb_t</td></tr><tr><td>Mesh ID</td><td>ID of ESP-MESH Network, see mesh_addr_t</td></tr><tr><td>Router</td><td>Router Configuration, see mesh_router_t</td></tr><tr><td>Mesh AP</td><td>Mesh AP Configuration, see mesh_ap_cfg_t</td></tr><tr><td>Crypto Functions</td><td>Crypto Functions for Mesh IE, see mesh_crypto_funcs_t</td></tr></tbody></table><p>以下代码段演示了如何配置 ESP-MESH。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Enable the Mesh IE encryption by default *&#x2F;</span><br><span class="line">mesh_cfg_t cfg &#x3D; MESH_INIT_CONFIG_DEFAULT();</span><br><span class="line">&#x2F;* mesh ID *&#x2F;</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.mesh_id, MESH_ID, 6);</span><br><span class="line">&#x2F;* mesh event callback *&#x2F;</span><br><span class="line">cfg.event_cb &#x3D; &amp;mesh_event_handler;</span><br><span class="line">&#x2F;* channel (must match the router&#39;s channel) *&#x2F;</span><br><span class="line">cfg.channel &#x3D; CONFIG_MESH_CHANNEL;</span><br><span class="line">&#x2F;* router *&#x2F;</span><br><span class="line">cfg.router.ssid_len &#x3D; strlen(CONFIG_MESH_ROUTER_SSID);</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len);</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.router.password, CONFIG_MESH_ROUTER_PASSWD,</span><br><span class="line">       strlen(CONFIG_MESH_ROUTER_PASSWD));</span><br><span class="line">&#x2F;* mesh softAP *&#x2F;</span><br><span class="line">cfg.mesh_ap.max_connection &#x3D; CONFIG_MESH_AP_CONNECTIONS;</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD,</span><br><span class="line">       strlen(CONFIG_MESH_AP_PASSWD));</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_set_config(&amp;cfg));</span><br></pre></td></tr></table></figure><h3 id="启动-Mesh"><a href="#启动-Mesh" class="headerlink" title="启动 Mesh"></a>启动 Mesh</h3><p>以下代码段演示了如何启动 ESP-MESH。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* mesh start *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_start());</span><br></pre></td></tr></table></figure><p><strong>启动 ESP-MESH 后，应用程序应检查 ESP-MESH 事件以确定它何时连接到网络。连接后，应用程序可以使用 <code>esp_mesh_send()</code> 和 <code>esp_mesh_recv()</code> 通过 ESP-MESH 网络开始发送和接收数据包。</strong></p><h2 id="自组织网络"><a href="#自组织网络" class="headerlink" title="自组织网络"></a>自组织网络</h2><p>自组织网络是 ESP-MESH 的一项功能，节点可以自动扫描/选择/连接/重新连接到其他节点和路由器。此功能允许 ESP-MESH 网络通过使网络对动态网络拓扑和条件具有鲁棒性来实现高度自治。启用自组织网络后，ESP-MESH 网络中的节点无需自主执行以下操作：</p><ul><li>选择或选择根节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-building-a-network" target="_blank" rel="noopener">构建网络</a>中的自动根节点选择）</li><li>选择首选父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-building-a-network" target="_blank" rel="noopener">构建网络</a>中的父节点选择）</li><li>检测到断开连接时自动重新连接（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-managing-a-network" target="_blank" rel="noopener">管理网络</a>中的中间父节点故障）</li></ul><p>启用自组织网络后，ESP-MESH 栈将在内部调用 Wi-Fi 驱动程序 API。因此，应用层不应对 Wi-Fi 驱动程序 API 进行任何调用，同时启用自组织网络，否则可能会干扰 ESP-MESH。</p><h3 id="切换自组织网络"><a href="#切换自组织网络" class="headerlink" title="切换自组织网络"></a>切换自组织网络</h3><p>应用程序在运行时通过调用 <code>esp_mesh_set_self_organized()</code> 函数可以启用或禁用自组织网络。该函数具有以下两个参数：</p><ul><li><code>bool enable</code> 指定是启用还是禁用自组织网络。</li><li><code>bool select_parent</code> 指定在启用自组织网络时是否应选择新的父节点。根据节点类型和节点的当前状态，选择新父级具有不同的效果。禁用自组织网络时，此参数未使用。</li></ul><h3 id="禁用自组织网络"><a href="#禁用自组织网络" class="headerlink" title="禁用自组织网络"></a>禁用自组织网络</h3><p>以下代码段演示了如何禁用自组织网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Disable self organized networking</span><br><span class="line">esp_mesh_set_self_organized(false, false);</span><br></pre></td></tr></table></figure><p>当禁用自组织网络时，ESP-MESH 将尝试维持节点当前的 Wi-Fi 状态。</p><ul><li>如果节点先前已连接到其他节点，则它将保持连接状态。</li><li>如果节点先前已断开连接并且正在扫描父节点或路由器，则它将停止扫描。</li><li>如果节点先前尝试重新连接到父节点或路由器，它将停止重新连接。</li></ul><h3 id="启用自组织网络"><a href="#启用自组织网络" class="headerlink" title="启用自组织网络"></a>启用自组织网络</h3><p>在启用自组织网络时，ESP-MESH 将尝试维持节点当前的 Wi-Fi 状态。但是，根据节点类型以及是否选择了新父节点，节点的 Wi-Fi 状态可能会发生变化。下表显示了启用自组织网络的效果。</p><p><img src="https://img-blog.csdnimg.cn/20190302173636709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以下代码演示了如何启用自组织网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Enable self organized networking and select a new parent</span><br><span class="line">esp_mesh_set_self_organized(true, true);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Enable self organized networking and manually reconnect</span><br><span class="line">esp_mesh_set_self_organized(true, false);</span><br><span class="line">esp_mesh_connect();</span><br></pre></td></tr></table></figure><h3 id="调用-Wi-Fi-驱动程序-API"><a href="#调用-Wi-Fi-驱动程序-API" class="headerlink" title="调用 Wi-Fi 驱动程序 API"></a>调用 Wi-Fi 驱动程序 API</h3><p>应用程序可能希望在使用 ESP-MESH 时直接调用 Wi-Fi 驱动程序 API 的情况。例如，应用程序可能想要手动扫描相邻的 AP。但是，<strong>在应用程序调用任何 Wi-Fi 驱动程序 API 之前，必须禁用自组织网络。</strong> 这将阻止 ESP-MESH 栈尝试调用任何 Wi-Fi 驱动程序 API ，ESP-MESH 栈的这些调用可能干扰应用程序的调用。</p><p>因此，<strong>应该在调用 <code>esp_mesh_set_self_organized()</code> 进行禁用和启用自组织网络之间放置对 Wi-Fi 驱动程序 API 的调用。</strong> 以下代码段演示了应用程序在使用 ESP-MESH 时如何安全地调用 <code>esp_wifi_scan_start()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Disable self organized networking</span><br><span class="line">esp_mesh_set_self_organized(0, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Stop any scans already in progress</span><br><span class="line">esp_wifi_scan_stop();</span><br><span class="line">&#x2F;&#x2F;Manually start scan. Will automatically stop when run to completion</span><br><span class="line">esp_wifi_scan_start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Process scan results</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if still connected</span><br><span class="line">esp_mesh_set_self_organized(1, 0);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if non-root and disconnected</span><br><span class="line">esp_mesh_set_self_organized(1, 1);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if root and disconnected</span><br><span class="line">esp_mesh_set_self_organized(1, 0);  &#x2F;&#x2F;Don&#39;t select new parent</span><br><span class="line">esp_mesh_connect();                 &#x2F;&#x2F;Manually reconnect to router</span><br></pre></td></tr></table></figure><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>ESP-IDF 包含这些 ESP-MESH 示例项目：</p><p><a href="https://github.com/espressif/esp-idf/tree/ebdcbe8c6/examples/mesh/internal_communication" target="_blank" rel="noopener">内部通信示例</a>演示了如何设置 ESP-MESH 网络并让根节点向网络中的每个节点发送数据包。</p><p><a href="https://github.com/espressif/esp-idf/tree/ebdcbe8c6/examples/mesh/manual_networking" target="_blank" rel="noopener">手动网络示例</a>演示了如何在没有自组织功能的情况下使用 ESP-MESH。此示例显示如何对节点进行编程以手动扫描潜在父节点列表，并根据自定义条件选择父节点。</p><h2 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul><li>esp32/include/esp_mesh.h</li></ul><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ul><li>esp_err_tesp_mesh_init(void)</li><li>esp_err_tesp_mesh_deinit(void)</li><li>esp_err_tesp_mesh_start(void)</li><li>esp_err_tesp_mesh_stop(void)</li><li>esp_err_tesp_mesh_send(constmesh_addr_t *to, constmesh_data_t *data, int flag, constmesh_opt_topt[], int opt_count)</li><li>esp_err_tesp_mesh_recv(mesh_addr_t *from, mesh_data_t *data, int timeout_ms, int *flag, mesh_opt_topt[], int opt_count)</li><li>esp_err_tesp_mesh_recv_toDS(mesh_addr_t *from, mesh_addr_t *to, mesh_data_t *data, int timeout_ms, int *flag, mesh_opt_topt[], int opt_count)</li><li>esp_err_tesp_mesh_set_config(constmesh_cfg_t *config)</li><li>esp_err_tesp_mesh_get_config(mesh_cfg_t *config)</li><li>esp_err_tesp_mesh_set_router(constmesh_router_t *router)</li><li>esp_err_tesp_mesh_get_router(mesh_router_t *router)</li><li>esp_err_tesp_mesh_set_id(constmesh_addr_t *id)</li><li>esp_err_tesp_mesh_get_id(mesh_addr_t *id)</li><li>esp_err_tesp_mesh_set_type(mesh_type_ttype)</li><li>mesh_type_tesp_mesh_get_type(void)</li><li>esp_err_tesp_mesh_set_max_layer(int max_layer)</li><li>int esp_mesh_get_max_layer(void)</li><li>esp_err_tesp_mesh_set_ap_password(const uint8_t *pwd, int len)</li><li>esp_err_tesp_mesh_set_ap_authmode(wifi_auth_mode_tauthmode)</li><li>wifi_auth_mode_tesp_mesh_get_ap_authmode(void)</li><li>esp_err_tesp_mesh_set_ap_connections(int connections)</li><li>int esp_mesh_get_ap_connections(void)</li><li>int esp_mesh_get_layer(void)</li><li>esp_err_tesp_mesh_get_parent_bssid(mesh_addr_t *bssid)</li><li>bool esp_mesh_is_root(void)</li><li>esp_err_tesp_mesh_set_self_organized(bool enable, bool select_parent)</li><li>bool esp_mesh_get_self_organized(void)</li><li>esp_err_tesp_mesh_waive_root(constmesh_vote_t *vote, int reason)</li><li>esp_err_tesp_mesh_set_vote_percentage(float percentage)</li><li>float esp_mesh_get_vote_percentage(void)</li><li>esp_err_tesp_mesh_set_ap_assoc_expire(int seconds)</li><li>int esp_mesh_get_ap_assoc_expire(void)</li><li>int esp_mesh_get_total_node_num(void)</li><li>int esp_mesh_get_routing_table_size(void)</li><li>esp_err_tesp_mesh_get_routing_table(mesh_addr_t *mac, int len, int *size)</li><li>esp_err_tesp_mesh_post_toDS_state(bool reachable)</li><li>esp_err_tesp_mesh_get_tx_pending(mesh_tx_pending_t *pending)</li><li>esp_err_tesp_mesh_get_rx_pending(mesh_rx_pending_t *pending)</li><li>int esp_mesh_available_txupQ_num(constmesh_addr_t *addr, uint32_t *xseqno_in)</li><li>esp_err_tesp_mesh_set_xon_qsize(int qsize)</li><li>int esp_mesh_get_xon_qsize(void)</li><li>esp_err_tesp_mesh_allow_root_conflicts(bool allowed)</li><li>bool esp_mesh_is_root_conflicts_allowed(void)</li><li>esp_err_tesp_mesh_set_group_id(constmesh_addr_t *addr, int num)</li><li>esp_err_tesp_mesh_delete_group_id(constmesh_addr_t *addr, int num)</li><li>int esp_mesh_get_group_num(void)</li><li>esp_err_tesp_mesh_get_group_list(mesh_addr_t *addr, int num)</li><li>bool esp_mesh_is_my_group(constmesh_addr_t *addr)</li><li>esp_err_tesp_mesh_set_capacity_num(int num)</li><li>int esp_mesh_get_capacity_num(void)</li><li>esp_err_tesp_mesh_set_ie_crypto_funcs(const mesh_crypto_funcs_t *crypto_funcs)</li><li>esp_err_tesp_mesh_set_ie_crypto_key(const char *key, int len)</li><li>esp_err_tesp_mesh_get_ie_crypto_key(char *key, int len)</li><li>esp_err_tesp_mesh_set_root_healing_delay(int delay_ms)</li><li>int esp_mesh_get_root_healing_delay(void)</li><li>esp_err_tesp_mesh_set_event_cb(constmesh_event_cb_tevent_cb)</li><li>esp_err_tesp_mesh_fix_root(bool enable)</li><li>bool esp_mesh_is_root_fixed(void)</li><li>esp_err_tesp_mesh_set_parent(constwifi_config_t *parent, constmesh_addr_t *parent_mesh_id, mesh_type_tmy_type, int my_layer)</li><li>esp_err_tesp_mesh_scan_get_ap_ie_len(int *len)</li><li>esp_err_tesp_mesh_scan_get_ap_record(wifi_ap_record_t *ap_record, void *buffer)</li><li>esp_err_tesp_mesh_flush_upstream_packets(void)</li><li>esp_err_tesp_mesh_get_subnet_nodes_num(constmesh_addr_t *child_mac, int *nodes_num)</li><li>esp_err_tesp_mesh_get_subnet_nodes_list(constmesh_addr_t *child_mac, mesh_addr_t *nodes, int nodes_num)</li><li>esp_err_tesp_mesh_disconnect(void)</li><li>esp_err_tesp_mesh_connect(void)</li><li>esp_err_tesp_mesh_flush_scan_result(void)</li><li>esp_err_tesp_mesh_switch_channel(const uint8_t *new_bssid, int csa_newchan, int csa_count)</li><li>esp_err_tesp_mesh_get_router_bssid(uint8_t *router_bssid)</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/network/esp_mesh.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP-MESH-编程指南&quot;&gt;&lt;a href=&quot;#ESP-MESH-编程指南&quot; class=&quot;headerlink&quot; title=&quot;ESP-MESH 编程指南&quot;&gt;&lt;/a&gt;ESP-MESH 编程指南&lt;/h1&gt;&lt;p&gt;这是 ESP-MESH 的编程指南，包括 API 参考和编码示例。本指南分为以下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ESP-MESH 编程模型&lt;/li&gt;
&lt;li&gt;编写 ESP-MESH 应用程序&lt;/li&gt;
&lt;li&gt;自组织网络&lt;/li&gt;
&lt;li&gt;应用实例&lt;/li&gt;
&lt;li&gt;API 参考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关 ESP-MESH 协议的文档，请参阅 &lt;a href=&quot;https://mp.csdn.net/postedit/86743079&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP-MESH API 指南&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（十五）ESP-MESH</title>
    <link href="https://blog.infiniteyuan.com/2019/02/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89ESP-MESH/"/>
    <id>https://blog.infiniteyuan.com/2019/02/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89ESP-MESH/</id>
    <published>2019-02-01T17:17:30.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP-MESH"><a href="#ESP-MESH" class="headerlink" title="ESP-MESH"></a>ESP-MESH</h1><p>本指南提供有关 ESP-MESH 协议的信息。有关 API 使用的更多信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/network/esp_mesh.html" target="_blank" rel="noopener">MESH API 参考</a>。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-MESH 是一种基于 Wi-Fi 协议构建的网络协议。ESP-MESH 允许在大的物理区域（室内和室外）上分布的多个设备（以下称为节点）在单个 WLAN（无线局域网）下互连。ESP-MESH 具有自组织和自我修复功能，意味着网络可以自主构建和维护。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://img-blog.csdnimg.cn/20190201111240103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="传统的 Wi-Fi 网络架构"><br>传统的 Wi-Fi 网络是一点对多点网络，其中称为接入点（AP）的单个中心节点直接连接到所有其他节点（station）。AP 负责仲裁和转发节点之间的传输。一些 AP 还通过路由器中继与外部 IP 网络的传输。传统的 Wi-Fi 网络由于要求每个站必须在一定范围内以直接与 AP 连接而具有有限覆盖区域的缺点。此外，传统的 Wi-Fi 网络易于过载，因为网络中允许的最大站数受到 AP 容量的限制。</p><p><img src="https://img-blog.csdnimg.cn/20190201113539338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>ESP-MESH 与传统的 Wi-Fi 网络的不同之处在于节点不需要连接到中心节点。相反，允许节点与相邻节点连接。节点相互负责传递彼此的传输。这允许 ESP-MESH 网络具有更大的覆盖区域，因为节点仍然可以实现互连而无需在中心节点的范围内。同样，ESP-MESH 也不易受到过载的影响，因为网络上允许的节点数量不再受单个中心节点的限制。</p><a id="more"></a><h2 id="ESP-MESH概念"><a href="#ESP-MESH概念" class="headerlink" title="ESP-MESH概念"></a>ESP-MESH概念</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td>节点</td><td>任何属于或可以属于 ESP-MESH 网络的设备</td></tr><tr><td>根节点</td><td>网络中的顶级节点</td></tr><tr><td>子节点</td><td>当节点 X 连接到另一节点 Y 时，节点 X 是子节点，其中连接使节点 X 比根节点更远离节点 Y（就连接数而言）。</td></tr><tr><td>父节点</td><td>子节点的相反概念</td></tr><tr><td>子孙节点</td><td>通过从父节点到子节点重复进行都可以访问的任何节点（例：父-&gt;子-&gt;子孙）</td></tr><tr><td>同级节点</td><td>共享同一父节点的节点</td></tr><tr><td>连接</td><td>AP 与站之间的传统 Wi-Fi 关联。ESP-MESH 中的节点将使用其工作站接口与另一个节点的 SoftAP 接口关联，从而形成连接。连接过程包括 Wi-Fi 中的认证和关联过程。</td></tr><tr><td>上游连接</td><td>从节点到其父节点的连接</td></tr><tr><td>下游连接</td><td>从节点到其子节点之一的连接</td></tr><tr><td>无线跳数</td><td>源节点和目标节点之间的路径部分，对应于单个无线连接。遍历单个连接的数据包称为单跳，而遍历多个连接称为多跳。</td></tr><tr><td>子网</td><td>一个子网是 ESP-MESH 网络的细分，它由一个节点及其所有后代节点组成。因此，根节点的子网由 ESP-MESH 网络中的所有节点组成。</td></tr><tr><td>MAC 地址</td><td>媒体访问控制地址，用于唯一标识 ESP-MESH 网络中的每个节点或路由器。</td></tr><tr><td>DS</td><td>分配系统（外部 IP 网络）</td></tr></tbody></table><h3 id="树状网络拓扑结构"><a href="#树状网络拓扑结构" class="headerlink" title="树状网络拓扑结构"></a>树状网络拓扑结构</h3><p>ESP-MESH 基于 Wi-Fi 协议构建，可以被视为将许多单独的 Wi-Fi 网络组合到单个 WLAN 中的网络协议。在 Wi-Fi 中，Station 在任何时候都限于与 AP（上游连接）的单个连接，而 AP 可以同时连接到多个 Station（下游连接）。然而，ESP-MESH 允许节点同时充当 Station 和 AP。因此，ESP-MESH 中的节点可以使用其 SoftAP 接口具有多个下游连接，同时使用其 Station 接口具有单个上游连接。这就是具有由多个层组成的父子层次结构的树状网络拓扑结构。</p><p><img src="https://img-blog.csdnimg.cn/20190201114600123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 树状网络拓扑结构"><br>ESP-MESH 是多跳网络，意味着节点可以通过一个或多个无线“跳跃”将数据包发送到网络中的其他节点。因此，ESP-MESH 中的节点不仅传输自己的数据包，还同时用作其他节点的中继。如果物理层上的任何两个节点之间存在路径（通过一个或多个无线跳），则 ESP-MESH 网络内的 <strong>任何两个节点（节点对）</strong> 都可以进行通信。</p><blockquote><p>ESP-MESH 网络中的大小（节点总数）取决于网络中允许的最大层数，以及每个节点可以拥有的最大下游连接数。可以通过配置这两个变量限制网络的大小。</p></blockquote><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p><img src="https://img-blog.csdnimg.cn/20190201115649174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 节点类型"><br><strong>根节点：</strong> 根节点是网络中的顶级节点，并且是 ESP-MESH 网络和外部 IP 网络之间的唯一接口。 根节点连接到传统的 Wi-Fi 路由器，并将数据包中继到外部 IP 网络或从中继到 ESP-MESH 网络内的节点。 ESP-MESH 网络中只能有一个根节点，根节点的上游连接只可能与路由器连接。参考上图，节点 A 是网络的根节点。</p><p><strong>叶节点：</strong> 叶节点是不允许具有任何子节点（没有下游连接）的节点。因此，叶子节点只能发送或接收自己的数据包，但不能转发其他节点的数据包。如果节点位于网络的最大允许层上，则将其指定为叶节点。这可以防止节点形成任何下游连接，从而确保网络不会添加额外的层。由于需要为任何下游连接提供 SoftAP 接口，因此一些没有 SoftAP 接口（仅限 Station）的节点也将被指定为叶节点。参考上图，节点 L/M/N 位于网络最大允许层上，因此已被指定为叶节点。</p><p><strong>中间父节点：</strong> 既不是根节点也不是叶节点的连接节点是中间父节点。中间父节点必须具有单个上游连接（单个父节点），但可以具有零到多个下游连接（零到多个子节点）。因此，中间父节点可以发送和接收数据包，但也可以转发从其上游和下游连接发送的数据包。参考上图，节点 B 到 J 是中间父节点。没有下游连接的中间父节点（例如节点 E/F/G/I/J）不等同于叶节点，因为它们在将来仍然允许形成下游连接。</p><p><strong>空闲节点：</strong> 尚未加入网络的节点被指定为空闲节点。空闲节点将尝试与中间父节点形成上游连接，或尝试在正确的情况下成为根节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>）。参考上图，节点 K 和 O 是空闲节点。</p><h3 id="信标帧-Beacon-帧-和-RSSI-阈值"><a href="#信标帧-Beacon-帧-和-RSSI-阈值" class="headerlink" title="信标帧(Beacon 帧)和 RSSI 阈值"></a>信标帧(Beacon 帧)和 RSSI 阈值</h3><p>ESP-MESH 中能够形成下游连接（即具有 SoftAP 接口）的每个节点将<strong>周期性地发送 Wi-Fi 信标帧</strong>。节点使用信标帧来允许其他节点检测其存在并知道其状态。空闲节点将监听信标帧以生成潜在父节点的列表，空闲节点将与其中一个形成上游连接。<strong>ESP-MESH 使用信标帧中的供应商信息（Vendor IE）元素来存储（传输）元数据</strong>，例如：</p><ul><li>节点类型（根节点，中间父节点，叶节点，空闲节点）</li><li>当前节点层</li><li>网络中允许的最大层数</li><li>当前子节点数</li><li>要接受的最大下游连接数</li></ul><p>潜在上游连接的信号强度由潜在父节点的信标帧的 RSSI（接收信号强度指示）表示。为了防止节点形成弱上游连接，ESP-MESH 为信标帧实现了 RSSI 阈值机制。如果节点检测到 RSSI 低于预先配置的阈值的信标帧，则在形成上游连接时将忽略发送该信标帧的节点。</p><p><img src="https://img-blog.csdnimg.cn/20190201120120285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="RSSI 阈值的影响"><br>上图中的面板 A 展示了 RSSI 阈值如何影响空闲节点具有的候选父节点的数量。</p><p>上图中的面板 B 展示了 RF 屏蔽对象如何降低潜在父节点的 RSSI。由于 RF 屏蔽对象，节点 X 的 RSSI 高于阈值的区域显着减小。这导致空闲节点忽略节点 X，即使节点 X 在物理上相邻。由于更强的 RSSI，空闲节点将改为与物理上远的节点Y形成上游连接。</p><blockquote><p>节点在技术上仍然接收 MAC 层上的所有信标帧。RSSI 阈值是 ESP-MESH 功能，它只是过滤掉所有接收到的低于预先配置阈值的信号帧。</p></blockquote><h3 id="首选父节点"><a href="#首选父节点" class="headerlink" title="首选父节点"></a>首选父节点</h3><p>当空闲节点具有多个候选父节点（潜在父节点）时，空闲节点将与首选父节点形成上游连接。<strong>首选父节点基于以下标准确定</strong>：</p><ul><li>候选父节点位于哪个层</li><li>候选父节点当前具有的下游连接（子节点）的数量</li></ul><p>首选父节点的选择将始终优先考虑网络最浅层（包括根节点）上的候选父节点。这有助于在形成上游连接时最小化ESP-MESH网络中的层总数。例如，给定第二层节点和第三层节点，第二层节点将始终是首选的。</p><p>如果在同一层内存在多个候选父节点，则具有最少子节点的候选父节点将是首选的。该标准具有平衡同一层的节点之间的下游连接数的效果。</p><p><img src="https://img-blog.csdnimg.cn/20190201140919219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="首选父节点"><br>上图中的面板 A 展示了在给定五个候选父节点 B/C/D/E/F 的情况下空闲节点 G 如何选择首选父节点的示例。最浅层上的节点是首选的，因此节点 B/C 优先选择做为父节点，因为它们是第二层节点，而节点 D/E/F 在第三层上。选择节点 C 作为首选父节点，因为与节点 B 相比，它具有更少的下游连接（更少的子节点）。</p><p>上图中的面板 B 展示了根节点在空闲节点 G 的范围内的情况。换句话说，当节点 G 接收时，根节点的信标帧高于 RSSI 阈值。根节点始终是最浅节点，因此，在 ESP-MESH网络中，给定多个候选父节点时，根节点总是首选的父节点。</p><blockquote><p>用户还可以定义自己的算法以选择首选父节点，或强制节点仅与特定父节点连接（请参阅<a href="https://github.com/espressif/esp-idf/tree/2790d4a/examples/mesh/manual_networking" target="_blank" rel="noopener">手动 MESH 网络示例</a>）。</p></blockquote><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>ESP-MESH 网络中的每个节点将单独维护自己的路由表，用于将 ESP-MESH 数据包（请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#esp-mesh-packet" target="_blank" rel="noopener">ESP-MESH 数据包</a>）正确路由到正确目标节点。特定节点的路由表将包括特定节点的子网内所有节点的 MAC 地址（包括特定节点本身的 MAC 地址）。每个路由表在内部划分为多个子表，每个子表对应于每个子节点的子网。</p><p><img src="https://img-blog.csdnimg.cn/20190201142029243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH路由表示例"><br>使用上面的图作为示例，节点 B 的路由表将包括节点 B 到 I 的 MAC 地址（即，等同于节点 B 的子网）。节点 B 的路由表在内部划分为两个子表，包含节点 C 到 F 和节点 G 到 I（即分别等同于节点 C 和 G 的子网）。</p><p><strong>ESP-MESH 利用路由表来确定是否应根据以下规则向上游或下游转发 ESP-MESH 数据包。</strong></p><ol><li>如果数据包的目标 MAC 地址在当前节点的路由表中并且不是当前节点，请选择包含目标 MAC 地址的子表，并将数据包下游转发到与子表对应的子节点。</li><li>如果目标 MAC 地址不在当前节点的路由表中，则将数据包上游转发到当前节点的父节点。重复执行此操作将导致数据包到达根节点，其中路由表应包含网络中的所有节点。</li></ol><blockquote><p>用户可以调用 <code>esp_mesh_get_routing_table()</code> 来获取节点的路由表，或者调用 <code>esp_mesh_get_routing_table_size()</code> 来获取节点的路由表的大小。<br><code>esp_mesh_get_subnet_nodes_list()</code> 可用于获取特定子节点的相应子表。同样，<code>esp_mesh_get_subnet_nodes_num()</code> 可用于获取子表的大小。</p></blockquote><h2 id="构建-ESP-MESH-网络"><a href="#构建-ESP-MESH-网络" class="headerlink" title="构建 ESP-MESH 网络"></a>构建 ESP-MESH 网络</h2><h3 id="一般过程"><a href="#一般过程" class="headerlink" title="一般过程"></a>一般过程</h3><blockquote><p>在 ESP-MESH 网络构建过程开始之前，配置的某些部分必须在网络中的每个节点上保持一致（请参阅 <code>mesh_cfg_t</code>）。每个节点必须配置相同的 Mesh 网络 ID，路由器配置和 SoftAP 配置。</p></blockquote><p>ESP-MESH 网络构建过程涉及根节点选择，然后逐层形成下游连接，直到所有节点都加入网络。网络的确切布局可以取决于诸如根节点选择，父节点选择和异步上电复位等因素。但是，ESP-MESH 网络构建过程可以概括为以下步骤：</p><p><img src="https://img-blog.csdnimg.cn/2019020114281399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 网络构建过程"></p><ol><li><p>根节点选择</p><p><strong>根节点可以在配置期间指定</strong>（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#user-designated-root-node" target="_blank" rel="noopener">用户指定的根节点部分</a>），或者<strong>根据每个节点和路由器之间的信号强度动态选择</strong>（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>）。选择后，根节点将与路由器连接并开始允许形成下游连接。参考上图，节点 A 被选择为根节点，因此节点 A 与路由器形成上游连接。</p></li><li><p>第二层形成</p><p>一旦根节点连接到路由器，根节点范围内的空闲节点将开始与根节点连接，从而形成网络的第二层。连接后，第二层节点成为中间父节点（假设允许的最大层数 &gt; 2），因此形成下一层。参考上图，节点 B 到 D 在根节点的范围内。因此，节点 B 到 D 与根节点形成上游连接，并成为中间父节点。</p></li><li><p>形成剩余层</p><p>剩余的空闲节点将与范围内的中间父节点连接，从而在网络中形成新层。连接后，空闲节点将成为中间父节点或叶节点，具体取决于网络允许的最大层数。重复该步骤，直到网络中不再有空闲节点或者直到达到网络的最大允许层为止。参考上图，节点 E/F/G 分别与节点 B/C/D 连接，并成为中间父节点本身。</p></li><li><p>限制树深度</p><p>为防止网络超出允许的最大层数，最大层上的节点一旦连接就会自动成为叶子节点。这防止任何其他空闲节点与叶节点连接，从而防止形成新的层形式。但是，如果空闲节点没有其他可能的父节点，它将无限期地保持空闲状态。参考上图，网络的最大允许层数设置为 4。因此，当节点 H 连接时，它成为叶节点以防止形成任何下游连接。</p></li></ol><h3 id="自动根节点选择"><a href="#自动根节点选择" class="headerlink" title="自动根节点选择"></a>自动根节点选择</h3><p><strong>根节点的自动选择涉及所有空闲节点之间基于其与路由器的信号强度的选举过程。每个空闲节点将通过 Wi-Fi 信标帧发送其 MAC 地址和路由器 RSSI 值</strong>。MAC 地址用于唯一地标识网络中的每个节点，而路由器 RSSI 用于指示节点参考路由器的信号强度。</p><p>然后，<strong>每个节点将同时扫描来自其他空闲节点的信标帧</strong>。<strong>如果节点检测到具有更强路由器 RSSI 的信标帧，则该节点将开始发送该信标帧的内容</strong>（即，对具有更强路由器 RSSI 的节点进行投票）。<strong>传输和扫描的过程将重复预先配置的最小迭代次数</strong>（默认为 10 次迭代），<strong>这将导致具有最强路由器 RSSI 的信标帧在整个网络中传播</strong>。</p><p>在所有迭代之后，每个节点将单独检查其投票百分比（投票数/参与选举的节点数）以确定它是否应该成为根节点。<strong>如果节点的投票百分比大于预配置的阈值（默认为 90％），则该节点将成为根节点</strong>。</p><p>下图演示了在自动选择根节点时如何构建 ESP-MESH 网络。</p><p><img src="https://img-blog.csdnimg.cn/20190201144333598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="根节点选择示例"></p><ol><li>在上电复位时，每个节点开始发送由其自己的 MAC 地址和路由器 RSSI 组成的信标帧。</li><li>在多次传输和扫描迭代中，具有最强路由器 RSSI 的信标帧在整个网络中传播。节点 C 具有最强的路由器RSSI（-10db），因此其信标帧在整个网络中传播。参与选举的所有节点都对节点 C 进行投票，从而给节点 C 一个 100％ 的投票百分比。因此，节点 C 成为根节点并与路由器连接。</li><li>一旦节点 C 与路由器连接，节点 A/B/D/E 就与节点 C 连接，因为它是首选的父节点（即最浅节点）。节点 A/B/D/E 构成网络的第二层。</li><li>节点 F 和 G 分别与节点 D 和 E 连接，网络构建过程完成。</li></ol><blockquote><p>可以使用 <code>esp_mesh_set_attempts（）</code> 配置选举过程的最小迭代次数。用户应该基于网络内的节点数量来调整迭代次数（即，网络越大，所需的扫描迭代次数越多）。</p></blockquote><blockquote><p>也可以使用 <code>esp_mesh_set_vote_percentage()</code> 配置投票百分比阈值。设置低投票百分比阈值可导致两个或更多节点成为同一 ESP-MESH 网络内的根节点，从而导致建立多个网络。如果是这种情况，ESP-MESH 具有自主解决根节点冲突的内部机制。多个根节点的网络将组合成具有单个根节点的单个网络。但是，根节点冲突，其中两个或多个根节点具有相同的路由器 SSID 但不处理不同的路由器 BSSID。</p></blockquote><h3 id="用户指定根节点"><a href="#用户指定根节点" class="headerlink" title="用户指定根节点"></a>用户指定根节点</h3><p><strong>根节点也可以由用户指定，这将使指定的根节点直接与路由器连接并放弃选举过程。当指定根节点时，网络中的所有其他节点也必须放弃选举过程以防止发生根节点冲突。</strong> 下图演示了当用户指定根节点时如何构建 ESP-MESH 网络。</p><p><img src="https://img-blog.csdnimg.cn/20190201145101139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="指定根节点示例（根节点= A，最大层数= 4）"></p><ol><li>节点 A 被用户指定为根节点，因此直接与路由器连接。所有其他节点放弃选举过程。</li><li>节点 C/D 连接节点 A 作为其首选父节点。两个节点构成网络的第二层。</li><li>同样，节点 B/E 与节点 C 连接，节点 F 与节点 D 连接。节点 B/E/F 构成网络的第三层。</li><li>节点 G 与节点 E 连接，形成网络的第四层。但是，此网络中允许的最大层数配置为 4，因此节点 G 成为叶节点以防止形成任何新层。</li></ol><blockquote><p>在指定根节点时，根节点应调用 <code>esp_mesh_set_parent()</code> 以直接与路由器连接。同样，所有其他节点应调用 <code>esp_mesh_fix_root()</code> 以放弃选举过程。</p></blockquote><h3 id="父节点选择"><a href="#父节点选择" class="headerlink" title="父节点选择"></a>父节点选择</h3><p>默认情况下，ESP-MESH 是自组织的，这意味着每个节点将自动选择与哪个潜在父节点形成上游连接。自主选择的父节点称为首选父节点。用于选择首选父节点的标准旨在减少 ESP-MESH 网络中的层数，并平衡潜在父节点之间的下游连接数（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#preferred-parent-node" target="_blank" rel="noopener">首选父节点</a>）。</p><p>但是，ESP-MESH 还允许用户禁用自组织行为，这将允许用户定义自己的父节点选择标准，或配置节点以具有指定的父节点（请参阅<a href="https://github.com/espressif/esp-idf/tree/2790d4a/examples/mesh/manual_networking" target="_blank" rel="noopener">手动 MESH 网络示例</a>）。</p><h3 id="异步上电复位"><a href="#异步上电复位" class="headerlink" title="异步上电复位"></a>异步上电复位</h3><p>ESP-MESH 网络建设可能受节点上电顺序的影响。如果网络中的某些节点异步上电（即相隔几分钟），则网络的最终结构可能与所有节点同步通电的理想情况不同。上电延迟的节点将遵循以下规则：</p><p>规则1：如果网络中已存在根节点，则延迟节点将不会尝试选择新的根节点，即使它与路由器具有更强的 RSSI。通过连接首选父节点，延迟节点将像任何其他空闲节点一样加入网络。如果延迟节点是指定的根节点，则网络中的所有其他节点将保持空闲，直到延迟节点通电。</p><p>规则2：如果延迟节点形成上游连接并成为中间父节点，则它也可以成为其他节点的新首选父节点（即，是较浅的节点）。这将导致其他节点切换其上游连接以与延迟节点连接（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#parent-node-switching" target="_blank" rel="noopener">父节点切换</a>）。</p><p>规则3：如果空闲节点具有在通电时被延迟的指定父节点，则空闲节点将不会在没有其指定的父节点的情况下尝试形成任何上游连接。空闲节点将无限期地保持空闲，直到其指定的父节点上电为止。</p><p>以下示例演示了异步上电对网络构建的影响。</p><p><img src="https://img-blog.csdnimg.cn/20190201150942611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="基于异步电源的网络构建示例"></p><ol><li>节点 A/C/D/F/G/H 同步上电，通过广播其 MAC 地址和路由器 RSSI 开始根节点选举过程。节点 A 被选为根节点，因为它具有最强的 RSSI。</li><li>一旦节点 A 成为根节点，其余节点就开始逐层形成具有其首选选父节点的上游连接。结果是一个有五层的网络。</li><li>节点 B/E 在上电时被延迟但是没有尝试成为根节点，即使它们具有比节点 A 更强的路由器 RSSI（-20db 和 -10db）。相反，两个延迟节点形成与其首选父节点的上游连接。节点 A 和 C 分别。连接后，两个节点 B/E 都成为中间父节点。</li><li>节点 D/G 切换它们的上游连接，因为节点 B 是新的首选父节点，因为它位于较浅的层（第二层节点）上。由于切换，所得到的网络具有三层而不是原始的五层。</li></ol><p>同步上电：如果所有节点同步上电，节点 E 将成为根节点，因为它具有最强的路由器 RSSI（-10db）。与在异步通电条件下形成的网络相比，这将导致显着不同的网络布局。但是，如果用户手动切换根节点，仍然可以达到同步开机网络布局（请参阅 <code>esp_mesh_waive_root()</code> ）。</p><blockquote><p>由异步上电引起的父节点选择的差异在 ESP-MESH 中在某种程度上被自动校正（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#parent-node-switching" target="_blank" rel="noopener">父节点切换</a>）</p></blockquote><h3 id="环路避免，检测和处理"><a href="#环路避免，检测和处理" class="headerlink" title="环路避免，检测和处理"></a>环路避免，检测和处理</h3><p>环路是特定节点与其后代节点之一（特定节点的子网内的节点）形成上游连接的情况。这导致圆形连接路径，从而破坏树状网络拓扑结构。ESP-MESH 通过排除在选择节点的路由表中已存在的节点（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#routing-tables" target="_blank" rel="noopener">路由表</a>）来防止在父节点选择期间产生环路，从而防止特定节点尝试连接到其子网内的任何节点。</p><p>在发生环路的情况下，ESP-MESH利用路径验证机制和能量传输机制来检测环路发生。导致环路的上游连接的父节点将通知子节点环路并启动断开连接。</p><h2 id="管理网络"><a href="#管理网络" class="headerlink" title="管理网络"></a>管理网络</h2><p>ESP-MESH 是一个自我修复网络，意味着它可以检测并纠正网络路由中的故障。当具有一个或多个子节点的父节点发生故障或父节点与其子节点之间的连接变得不稳定时，会发生故障。ESP-MESH 中的子节点将自动选择新的父节点并与其形成上游连接以维持网络互连。ESP-MESH 可以处理根节点故障和中间父节点故障。</p><h3 id="根节点故障"><a href="#根节点故障" class="headerlink" title="根节点故障"></a>根节点故障</h3><p><strong>如果根节点发生故障，与其连接的节点（第二层节点）将立即检测到根节点的故障。第二层节点最初将尝试与根节点重新连接。但是，在多次尝试失败后，第二层节点将初始化新一轮的根节点选举。具有最强路由器 RSSI 的第二层节点将被选为新的根节点，而剩余的第二层节点将与新的根节点（或相邻的父节点，如果不在范围内）形成上游连接。</strong></p><p>如果根节点和多个下游层同时发生故障（例如，根节点，第二层和第三层），仍然起作用的最浅层将初始化根节点选举。以下示例说明了从根节点分解的自我修复示例。</p><p><img src="https://img-blog.csdnimg.cn/20190201153541569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="从根节点故障中自我修复"></p><ol><li>节点 C 是网络的根节点。节点 A/B/D/E 是连接到节点 C 的第二层节点。</li><li>节点 C 发生故障。在多次尝试重新连接失败后，第二层节点通过广播其路由器 RSSI 开始选举过程。节点 B 具有最强的路由器 RSSI。</li><li>节点 B 被选为根节点并开始接受下游连接。剩余的第二层节点 A/D/E 形成与节点 B 的上游连接，因此网络被修复并且可以继续正常操作。</li></ol><blockquote><p>如果指定的根节点发生故障，则其余节点将不会自主地尝试选择新的根节点，因为在使用指定的根节点时将永远不会尝试选举过程。</p></blockquote><h3 id="中间父节点故障"><a href="#中间父节点故障" class="headerlink" title="中间父节点故障"></a>中间父节点故障</h3><p><strong>如果中间父节点发生故障，则断开连接的子节点将首先尝试与父节点重新连接。在多次尝试重新连接失败后，每个子节点将开始扫描潜在的父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#beacon-frames-rssi-thresholding" target="_blank" rel="noopener">信标帧和 RSSI 阈值</a>）。</strong></p><p>如果其他可能的父节点可用，则每个子节点将单独选择新的首选父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#preferred-parent-node" target="_blank" rel="noopener">首选父节点</a>）并与其形成上游连接。如果特定子节点没有其他潜在父节点，则它将无限期保持空闲状态。</p><p>下图说明了从中间父节点分解的自我修复的示例。</p><p><img src="https://img-blog.csdnimg.cn/20190201153956675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="从中间父节点故障中自我修复"></p><ol><li>网络的以下分支由节点 A 到 G 组成。</li><li>节点 C 发生故障。 节点 F/G 检测到故障并尝试与节点 C 重新连接。多次尝试重新连接失败后，节点 F/G 开始选择新的首选父节点。</li><li>节点 G 超出任何其他父节点的范围，因此暂时保持空闲。节点 F 在节点 B/E 的范围内，但是节点 B 被选择，因为它是较浅的节点。节点 F 在与节点 B 连接之后成为中间父节点，因此节点 G 可以与节点 F 连接。网络被修复，但是网络路由已经受到影响并且添加了额外的层。</li></ol><blockquote><p>如果子节点具有指定的父节点，则子节点将不会尝试连接新的父节点。子节点将无限期保持空闲状态。</p></blockquote><h3 id="根节点切换"><a href="#根节点切换" class="headerlink" title="根节点切换"></a>根节点切换</h3><p><strong>除非根节点发生故障，否则 ESP-MESH 不会自动切换根节点。即使根节点的路由器 RSSI 降级到断开点，根节点也将保持不变</strong>。根节点切换是明确开始新选举的行为，使得具有更强路由器 RSSI 的节点将被选为新的根节点。这可以是适应降低根节点性能的有用方法。</p><p><strong>要触发根节点切换，当前根节点必须显式调用 <code>esp_mesh_waive_root()</code> 以触发新选举</strong>。当前根节点将发信号通知网络内的所有节点开始发送和扫描信标帧（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>），同时保持连接到网络（即，不空闲）。如果另一个节点收到的选票多于当前根节点，则将启动根节点切换。否则，根节点将保持不变。</p><p>新选择的根节点向当前根节点发送切换请求，该当前根节点将以确认响应，表示两个节点都准备切换。一旦收到确认，新选出的根节点将与其父节点断开连接，并迅速与路由器形成上游连接，从而成为网络的新根节点。先前的根节点将断开与路由器的连接，同时保持其所有下游连接并进入空闲状态。然后，先前的根节点将开始扫描潜在的父节点并选择首选父节点。</p><p>下图说明了根节点切换的示例。</p><p><img src="https://img-blog.csdnimg.cn/20190201160040642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="根节点切换示例"></p><ol><li>节点 C 是当前的根节点，但路由器的信号强度降低（-85db）。节点 C 触发新的选举，并且所有节点在仍然连接的同时开始发送和扫描信标帧。</li><li>经过多轮传输和扫描后，节点 B 被选为新的根节点。节点 B 向节点 C 发送切换请求，节点 C 以确认响应。</li><li>节点 B 与其父节点断开连接，并与路由器连接，成为网络新的根节点。节点 C 与路由器断开连接，进入空闲状态，并开始扫描并选择新的首选父节点。节点 C 在整个过程中维护其所有下游连接。</li><li>节点 C 选择节点 B 作为其首选父节点，形成上游连接，并成为第二层节点。交换根节点后网络布局类似，因为节点 C 仍保持相同的子网。但是，由于交换根节点，节点 C 的子网中的每个节点都被放置了一层。如果任何节点由于根节点切换而具有新的优选父节点，则父节点切换可以随后调整网络布局。</li></ol><blockquote><p>根节点切换必须要求选举，因此仅在使用自组织 ESP-MESH 网络时才支持。换句话说，如果使用指定的根节点，则不能发生根节点切换。</p></blockquote><h3 id="父节点切换"><a href="#父节点切换" class="headerlink" title="父节点切换"></a>父节点切换</h3><p><strong>父节点切换需要子节点将其上游连接切换到较浅层的另一个父节点。父节点切换自动发生，这意味着如果较浅层的潜在父节点变得可用（即，由于<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#asynchronous-power-on-reset" target="_blank" rel="noopener">异步上电复位</a>），子节点将自动改变其上游连接。</strong></p><p>所有潜在的父节点周期性地发送信标帧（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#beacon-frames-rssi-thresholding" target="_blank" rel="noopener">信标帧和 RSSI 阈值</a>），允许子节点扫描较浅的父节点的可用性。由于父节点切换，自组织的 ESP-MESH 网络可以动态调整其网络布局，以确保每个连接具有良好的 RSSI 并且网络中的层数最小化。</p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="ESP-MESH数据包"><a href="#ESP-MESH数据包" class="headerlink" title="ESP-MESH数据包"></a>ESP-MESH数据包</h3><p>ESP-MESH 网络数据传输使用 ESP-MESH 数据包。ESP-MESH 数据包完全包含在 Wi-Fi 数据帧的帧体内。ESP-MESH 网络中的多跳数据传输将涉及通过不同的 Wi-Fi 数据帧在每个无线跳上承载的单个 ESP-MESH 数据包。</p><p>下图显示了 ESP-MESH 数据包的结构及其与 Wi-Fi 数据帧的关系。</p><p><img src="https://img-blog.csdnimg.cn/20190201162512352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 数据包"><br>ESP-MESH 数据包的包头包含源节点和目标节点的 MAC 地址。选项字段包含与特殊类型的 ESP-MESH 数据包有关的信息，例如组传输或源自外部 IP 网络的数据包（请参阅 <code>MESH_OPT_SEND_GROUP</code> 和 <code>MESH_OPT_RECV_DS_ADDR</code>）。</p><p>ESP-MESH 数据包的有效负载包含实际的应用程序数据。此数据可以是原始二进制数据，也可以在应用程序层协议（如 HTTP，MQTT 和 JSON）下编码（请参阅 <code>mesh_proto_t</code>）。</p><blockquote><p>将 ESP-MESH 数据包发送到外部 IP 网络时，包头的目标地址字段将包含目标服务器的 IP 地址和端口，而不是节点的 MAC 地址（请参阅 <code>mesh_addr_t</code>）。此外，根节点将处理输出 TCP/IP 数据包的形成。</p></blockquote><h3 id="组控制和多播"><a href="#组控制和多播" class="headerlink" title="组控制和多播"></a>组控制和多播</h3><p>多播是一种允许将单个 ESP-MESH 数据包同时传输到网络中的多个节点的功能。ESP-MESH 中的多播可以通过指定目标节点列表或指定预先配置的节点组来实现。两种多播方法都是通过 <code>esp_mesh_send()</code> 调用的。</p><p>要通过指定目标节点列表进行多播，用户必须首先将 ESP-MESH 数据包的目标地址设置为多播组地址（01:00:5E:xx:xx:xx）。这表示 ESP-MESH 数据包是具有一组地址的多播数据包，并且该地址应从头选项中获取。然后，用户必须将目标节点的 MAC 地址列为选项（请参阅 <code>mesh_opt_t</code> 和 <code>MESH_OPT_SEND_GROUP</code>）。这种多播方法不需要事先设置，但可能产生大量开销数据，因为每个目标节点的 MAC 地址必须列在数据包包头的选项字段中。</p><p>按组进行多播允许将 ESP-MESH 数据包传输到预先配置的节点组。每个组由唯一 ID 标识，并且可以通过 <code>esp_mesh_set_group_id()</code> 将节点放入组中。对组进行组播涉及将 ESP-MESH 数据包中的目的地址设置为目标组 ID。此外，必须设置 <code>MESH_DATA_GROUP</code> 标志。使用组进行多播会产生较少的开销，但需要先前将节点添加到组中。</p><blockquote><p>在多播期间，网络中的所有节点仍然在 MAC 层上接收 ESP-MESH 数据包。但是，未包含在 MAC 地址列表或目标组中的节点将简单地过滤掉该数据包。</p></blockquote><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播是一种允许单个 ESP-MESH 数据包同时传输到网络中所有节点的功能。每个节点基本上将广播包转发到其所有上游和下游连接，使得广播包尽可能快地在整个网络中传播。但是，ESP-MESH 利用以下方法避免在广播期间浪费带宽。</p><ol><li>当中间父节点从其父节点接收广播包时，它将广播包转发到其每个子节点，同时为其自身存储广播包的副本。</li><li>当中间父节点是广播的源节点时，它将向上游发送广播包到父节点并且向下游发送广播包到每个子节点。</li><li>当中间父节点从其子节点之一接收广播包时，它将广播包转发到其父节点及其剩余的每个子节点，同时为其自身存储广播包的副本。</li><li>当叶节点是广播的源节点时，它将直接将数据包传输到其父节点。</li><li>当根节点是广播的源节点时，根节点将数据包传输到其所有子节点。</li><li>当根节点从其子节点之一接收广播包时，它将广播包转发到其剩余的每个子节点，同时为其自身存储广播包的副本。</li><li>当节点接收到源地址与其自己的 MAC 地址匹配的广播包时，该节点将丢弃该广播包。</li><li>当中间父节点从其父节点接收到最初从其子节点之一发送的广播包时，它将丢弃广播包。</li></ol><h3 id="上游流量控制"><a href="#上游流量控制" class="headerlink" title="上游流量控制"></a>上游流量控制</h3><p>ESP-MESH 依靠父节点来控制其直接子节点的上游数据流。为了防止父节点的消息缓冲区由于上游传输的过载而溢出，父节点将为其每个子节点分配用于上游传输的配额，称为接收窗口。<strong>每个子节点必须在允许向上游传输之前申请接收窗口。</strong> 可以动态调整接收窗口的大小。从子节点到父节点的上游传输包括以下步骤：</p><ol><li>在每次传输之前，子节点向其父节点发送窗口请求。窗口请求由序列号组成，该序列号对应于待传输的子节点的数据包。</li><li>父节点接收窗口请求，并将序列号与子节点发送的先前数据包的序列号进行比较。该比较用于计算发送回子节点的接收窗口的大小。</li><li>子节点根据父节点指定的窗口大小发送数据包。如果子节点耗尽其接收窗口，则必须通过在允许继续发送之前发送请求来获得另一个接收窗口。</li></ol><blockquote><p>ESP-MESH 不支持任何下游流量控制。</p></blockquote><blockquote><p>由于父节点切换，在上游传输期间可能发生数据包丢失。</p></blockquote><p>由于根节点充当外部 IP 网络的唯一接口，因此下游节点了解根节点与外部 IP 网络的连接状态至关重要。如果不这样做，可能会导致节点在与 IP 网络断开连接时尝试将数据上行传递到根节点。这导致不必要的传输和数据包丢失。ESP-MESH 通过提供一种机制来解决此问题，该机制基于根节点和外部 IP 网络之间的连接状态来稳定传出数据的吞吐量。根节点可以通过调用 <code>esp_mesh_post_toDS_state()</code> 将其外部 IP 网络连接状态广播到所有其他节点。</p><h3 id="双向数据流"><a href="#双向数据流" class="headerlink" title="双向数据流"></a>双向数据流</h3><p>下图说明了 ESP-MESH 双向数据流中涉及的各种网络层。</p><p><img src="https://img-blog.csdnimg.cn/20190201165440991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 双向数据流"><br>由于使用了<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#routing-tables" target="_blank" rel="noopener">路由表</a>，ESP-MESH 能够完全在网状层上处理包转发。仅当根节点向/从外部 IP 网络发送/接收数据包时，才需要 TCP/IP 层。</p><h2 id="信道切换"><a href="#信道切换" class="headerlink" title="信道切换"></a>信道切换</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在传统的 Wi-Fi 网络中，信道是预定的频率范围。在基本服务集（BSS）中，服务 AP 及其连接的 Station 必须在相同信道（1 至 14）上发送信标。在同一信道上运行的物理上相邻的 BSS（基本服务集）可能会导致干扰并降低性能。</p><p>为了使 BSS 适应不断变化的物理层条件并保持性能，Wi-Fi 包含用于网络信道切换的机制。网络信道切换是尝试将 BSS 移动到新的操作信道，同时在此过程中最小化对 BSS 的干扰。然而，应该认识到，在将所有 Station 移动到新的操作信道时，信道切换可能是不成功的。</p><p>在 Wi-Fi 网络中，AP 触发网络信道切换，目的是使 AP 和所有连接的 Station 同步切换到新信道。通过在 AP 的周期性发送的信标帧内嵌入信道切换公告（CSA）元素来实现网络信道切换。CSA 元素用于向所有连接的站点通告关于即将到来的网络信道切换，并且将被包括在多个信标帧中直到切换发生。</p><p>CSA 元素包含关于新信道号和信道切换计数的信息，其指示在网络信道切换发生之前剩余的信标帧间隔（TBTT）的数量。因此，每个信标帧递减信道切换计数，并允许连接的 Station 将其信道切换与 AP 同步。</p><h3 id="ESP-MESH-网络信道切换"><a href="#ESP-MESH-网络信道切换" class="headerlink" title="ESP-MESH 网络信道切换"></a>ESP-MESH 网络信道切换</h3><p>ESP-MESH 网络信道切换还利用包含 CSA 元素的信标帧。然而，作为多跳网络使得 ESP-MESH 中的切换过程更复杂，因为信标帧可能无法到达网络内的所有节点（即，在单跳中）。因此，ESP-MESH 网络依靠节点转发 CSA 元素，以便它在整个网络中传播。</p><p>当具有一个或多个子节点的中间父节点接收到包含 CSA 的信标帧时，该节点将通过将该元素包括在其下一个发送的信标帧中（即，具有相同的新信道号和信道切换计数）来转发 CSA 元素。鉴于 ESP-MESH 网络内的所有节点都接收相同的 CSA，节点可以使用信道切换计数来同步其信道切换，尽管由于 CSA 元素转发而导致短的延迟。</p><p>ESP-MESH 网络信道切换可以由路由器或根节点触发。</p><h3 id="根节点触发"><a href="#根节点触发" class="headerlink" title="根节点触发"></a>根节点触发</h3><p>只有当 ESP-MESH 网络未连接到路由器时，才会发生根节点触发的信道切换。通过调用 <code>esp_mesh_switch_channel()</code>，根节点将设置初始信道切换计数值并开始在其信标帧中包含 CSA 元素。然后，每个 CSA 元素由第二层节点接收，并在它们自己的信标帧中向下游转发。</p><h3 id="路由器触发"><a href="#路由器触发" class="headerlink" title="路由器触发"></a>路由器触发</h3><p>当 ESP-MESH 网络连接到路由器时，整个网络必须使用与路由器相同的信道。因此，当根节点连接到路由器时，将不允许根节点触发通道切换。</p><p>当根节点从路由器接收包含 CSA 元素的信标帧时，根节点将 CSA 元素中的信道切换计数值设置为自定义值，然后通过信标帧向下游转发。它还将相对于自定义值递减后续 CSA 元素的通道切换计数。此自定义值可以基于诸如网络层数，当前节点数等因素。</p><p>将信道切换计数值设置为自定义值是由于 ESP-MESH 网络及其路由器可能具有不同且变化的信标间隔。因此，路由器提供的信道切换计数值与 ESP-MESH 网络无关。通过使用自定义值，ESP-MESH 网络中的节点能够相对于 ESP-MESH 网络的信标间隔同步切换信道。但是，这也会导致 ESP-MESH 网络的信道切换与路由器及其连接站的信道切换不同步。</p><h3 id="网络信道切换的影响"><a href="#网络信道切换的影响" class="headerlink" title="网络信道切换的影响"></a>网络信道切换的影响</h3><ul><li>由于 ESP-MESH 网络信道切换与路由器的信道切换不同步，ESP-MESH 网络和路由器之间将存在临时信道差异。<ul><li>ESP-MESH 网络的信道切换时间取决于 ESP-MESH 网络的信标间隔和根节点的自定义信道切换计数值。</li><li>通道差异可防止在 ESP-MESH 网络切换期间根节点与路由器之间的任何数据交换。</li><li>在 ESP-MESH 网络中，根节点和中间父节点将请求其连接的子节点停止传输，直到通过将 CSA 元素中的信道切换模式字段设置为 1 来进行信道切换。</li><li>频繁路由器触发的网络信道切换会降低 ESP-MESH 网络的性能。请注意，这可能是由 ESP-MESH 网络本身引起的（例如，由于与 ESP-MESH 网络的无线媒体争用）。如果是这种情况，用户应禁用路由器上的自动信道切换，并使用指定的信道。</li></ul></li><li>当存在临时信道差异时，根节点在技术上保持与路由器的连接。<ul><li>在根节点未能通过固定数量的路由器信标间隔从路由器接收任何信标帧或探测响应之后发生断开连接。</li><li>断开连接后，根节点将自动重新扫描所有通道以查找是否存在路由器。</li></ul></li><li>如果根节点无法接收任何路由器的 CSA 信标帧（例如，由于路由器给出的切换时间短），路由器将在没有 ESP-MESH 网络知识的情况下切换信道。<ul><li>路由器切换通道后，根节点将无法再接收路由器的信标帧和探测响应，并在固定数量的信标间隔后导致断开连接。</li><li>断开连接后，根节点将重新扫描路由器的所有通道。</li><li>根节点将在整个过程中维护下游连接。</li></ul></li></ul><blockquote><p>尽管 ESP-MESH 网络信道切换旨在将网络内的所有节点移动到新的操作信道，但应该认识到信道切换可能不能成功地移动所有节点（例如，由于诸如节点故障的原因）。</p></blockquote><h3 id="通道和路由器切换配置"><a href="#通道和路由器切换配置" class="headerlink" title="通道和路由器切换配置"></a>通道和路由器切换配置</h3><p>ESP-MESH 允许通过配置启用/禁用自主通道切换。同样，也可以通过配置启用/禁用自主路由器切换（即，当根节点自主连接到另一个路由器时）。自主信道切换和路由器切换取决于以下配置参数和运行时条件。</p><p><strong>允许通道切换：</strong> 此参数通过 <code>mesh_cfg_t</code> 结构的 <code>allow_channel_switch</code> 字段设置，并允许 ESP-MESH 网络在设置时动态切换通道。</p><p><strong>预设信道：</strong> 通过将 <code>mesh_cfg_t</code> 结构的信道字段设置为所需的信道号，ESP-MESH 网络可以拥有预设信道。如果未设置此字段，则会覆盖 <code>allow_channel_switch</code> 参数，以便始终允许通道切换。</p><p><strong>允许路由器切换：</strong> 此参数通过 <code>mesh_router_t</code> 的 <code>allow_router_switch</code> 字段设置，并允许 ESP-MESH 在设置时动态切换到其他路由器。</p><p><strong>预设路由器BSSID：</strong> ESP-MESH 网络可以通过将 <code>mesh_router_t</code> 结构的 <code>bssid</code> 字段设置为所需路由器的 BSSID 来具有预设路由器。如果未设置此字段，则会覆盖 <code>allow_router_switch</code> 参数，以便始终允许路由器切换。</p><p><strong>根节点存在：</strong> 根节点的存在还会影响是允许还是允许通道或路由器切换。</p><p>下表说明了参数/条件的不同组合如何影响是否允许信道切换和/或路由器切换。请注意，X 表示参数的“不关心”。</p><p><img src="https://img-blog.csdnimg.cn/20190201171947753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>可以基于多个指标评估 ESP-MESH 网络的性能，例如：</p><p><strong>网络构建时间：</strong> 从头开始构建 ESP-MESH 网络所需的时间。</p><p><strong>恢复时间：</strong> 网络检测节点故障所需的时间，并执行适当的操作来修复网络（例如生成新的根节点或形成新的连接）。</p><p><strong>每跳延迟：</strong> 通过一个无线跳数据传输的延迟。换句话说，将数据包从父节点传输到子节点所花费的时间，反之亦然。</p><p><strong>网络节点容量：</strong> ESP-MESH 网络可以同时支持的节点总数。<strong>此数字由节点可接受的最大下游连接数和网络中允许的最大层数确定。</strong></p><p>下表列出了 ESP-MESH 网络的常见性能数据。但是，用户应注意，基于网络配置和操作环境的安装之间的性能数字可能会有很大差异。</p><blockquote><p>使用以下测试条件产生上述性能数据。</p><ul><li>测试设备数量：100</li><li>要接受的最大下游连接数：6</li><li>最大允许层数：6</li></ul></blockquote><blockquote><p>吞吐量取决于数据包错误率和跳数。</p></blockquote><blockquote><p>根节点访问外部IP网络的吞吐量直接受 ESP-MESH 网络中节点数量和路由器带宽的影响。</p></blockquote><h2 id="进一步说明"><a href="#进一步说明" class="headerlink" title="进一步说明"></a>进一步说明</h2><ul><li>数据传输使用 Wi-Fi WPA2-PSK 加密</li><li>网状网络 IE 使用 AES 加密</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ESP-MESH&quot;&gt;&lt;a href=&quot;#ESP-MESH&quot; class=&quot;headerlink&quot; title=&quot;ESP-MESH&quot;&gt;&lt;/a&gt;ESP-MESH&lt;/h1&gt;&lt;p&gt;本指南提供有关 ESP-MESH 协议的信息。有关 API 使用的更多信息，请参阅 &lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/network/esp_mesh.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MESH API 参考&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ESP-MESH 是一种基于 Wi-Fi 协议构建的网络协议。ESP-MESH 允许在大的物理区域（室内和室外）上分布的多个设备（以下称为节点）在单个 WLAN（无线局域网）下互连。ESP-MESH 具有自组织和自我修复功能，意味着网络可以自主构建和维护。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190201111240103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70&quot; alt=&quot;传统的 Wi-Fi 网络架构&quot;&gt;&lt;br&gt;传统的 Wi-Fi 网络是一点对多点网络，其中称为接入点（AP）的单个中心节点直接连接到所有其他节点（station）。AP 负责仲裁和转发节点之间的传输。一些 AP 还通过路由器中继与外部 IP 网络的传输。传统的 Wi-Fi 网络由于要求每个站必须在一定范围内以直接与 AP 连接而具有有限覆盖区域的缺点。此外，传统的 Wi-Fi 网络易于过载，因为网络中允许的最大站数受到 AP 容量的限制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190201113539338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;ESP-MESH 与传统的 Wi-Fi 网络的不同之处在于节点不需要连接到中心节点。相反，允许节点与相邻节点连接。节点相互负责传递彼此的传输。这允许 ESP-MESH 网络具有更大的覆盖区域，因为节点仍然可以实现互连而无需在中心节点的范围内。同样，ESP-MESH 也不易受到过载的影响，因为网络上允许的节点数量不再受单个中心节点的限制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 学习笔记（十九）High Resolution Timer</title>
    <link href="https://blog.infiniteyuan.com/2018/12/24/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89High%20Resolution%20Timer/"/>
    <id>https://blog.infiniteyuan.com/2018/12/24/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89High%20Resolution%20Timer/</id>
    <published>2018-12-24T11:22:42.000Z</published>
    <updated>2020-08-02T06:36:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高分辨率定时器"><a href="#高分辨率定时器" class="headerlink" title="高分辨率定时器"></a>高分辨率定时器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虽然 FreeRTOS 提供软件定时器，但这些定时器有一些限制：</p><ul><li>最大分辨率等于 RTOS 滴答周期</li><li>低优先级任务调度定时器回调</li></ul><p>硬件定时器没有这两个限制，但通常使用起来不方便。例如，应用程序组件可能需要在将来的某些时间触发定时器事件，但硬件定时器仅包含一个用于中断生成的“比较”值。这意味着需要在硬件计时器之上构建一些设施来管理待处理事件列表，可以在发生相应的硬件中断时为这些事件调度回调。</p><p><code>esp_timer</code> API 集提供了这样的功能。在内部，<code>esp_timer</code> 使用 32 位硬件定时器（FRC1，“传统”定时器）。<code>esp_timer</code> 提供单次和周期定时器，微秒时间分辨率和 64 位范围。</p><p>从高优先级的 <code>esp_timer</code> 任务调度定时器回调。由于所有回调都是从同一任务调度的，因此建议仅从回调本身执行尽可能少的工作，而是使用队列将事件发布到优先级较低的任务。</p><p>如果优先级高于 <code>esp_timer</code> 的其他任务正在运行，则回调调度将延迟，直到 <code>esp_timer</code> 任务有机会运行。例如，如果正在进行 <code>SPI</code> 闪存操作，则会发生这种情况。</p><p>创建和启动计时器，并调度回调需要一些时间。因此，单触发 <code>esp_timer</code> 的超时值有一个下限。如果调用 <code>esp_timer_start_once()</code> 时超时值小于20us，则仅在大约 20us 后调度回调。</p><p>周期性 <code>esp_timer</code> 还对最小定时器周期施加 50us 限制。周期小于 50us 的定期软件定时器不实用，因为它们会占用大部分 CPU 时间。如果发现需要小周期的定时器，请考虑使用专用硬件外设或 DMA 功能。</p><a id="more"></a><h2 id="使用-esp-timer-API"><a href="#使用-esp-timer-API" class="headerlink" title="使用 esp_timer API"></a>使用 <code>esp_timer</code> API</h2><p>单个计时器由 <code>esp_timer_handle_t</code> 类型表示。定时器有与之关联的回调函数。每次计时器过去时，都会从 <code>esp_timer</code> 任务调用此回调函数。</p><ul><li>要创建计时器，请调用 <code>esp_timer_create()</code>。</li><li>要在不再需要时删除计时器，请调用 <code>esp_timer_delete()</code>。</li></ul><p>定时器可以以单次模式或定期模式启动。</p><ul><li>要以单次模式启动计时器，请调用 <code>esp_timer_start_once()</code>，传递应该调用回调的时间间隔。调用回调时，会认为计时器已停止。</li><li>要以周期模式启动定时器，请调用 <code>esp_timer_start_periodic()</code>，传递应调用回调的周期。计时器一直运行，直到调用 <code>esp_timer_stop()</code>。</li></ul><p>请注意，调用 <code>esp_timer_start_once()</code> 或 <code>esp_timer_start_periodic()</code> 时，计时器不能运行。要重新启动正在运行的计时器，请先调用 <code>esp_timer_stop()</code>，然后调用其中一个启动函数。</p><h2 id="获得当前时间"><a href="#获得当前时间" class="headerlink" title="获得当前时间"></a>获得当前时间</h2><p><code>esp_timer</code> 还提供了一个便捷函数来获取自启动以来经过的时间，精度为微秒：<code>esp_timer_get_time()</code>。此函数返回自 <code>esp_timer</code> 初始化以来的微秒数，这通常在调用 <code>app_main</code> 函数之前不久发生。</p><p>与 <code>gettimeofday</code> 函数不同，<code>esp_timer_get_time()</code> 返回的值：</p><ul><li>芯片从深度睡眠中唤醒后，从零开始</li><li>没有应用时区或 DST 调整</li></ul><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><ul><li><a href="https://github.com/espressif/esp-idf/tree/7b13308/examples/system/esp_timer" target="_blank" rel="noopener">system/esp_timer</a></li></ul><h2 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h2><ul><li><a href="https://github.com/espressif/esp-idf/blob/7b13308/components/esp32/include/esp_timer.h" target="_blank" rel="noopener">esp32/include/esp_timer.h</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/system/esp_timer.html" target="_blank" rel="noopener">High Resolution Timer</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高分辨率定时器&quot;&gt;&lt;a href=&quot;#高分辨率定时器&quot; class=&quot;headerlink&quot; title=&quot;高分辨率定时器&quot;&gt;&lt;/a&gt;高分辨率定时器&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;虽然 FreeRTOS 提供软件定时器，但这些定时器有一些限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大分辨率等于 RTOS 滴答周期&lt;/li&gt;
&lt;li&gt;低优先级任务调度定时器回调&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;硬件定时器没有这两个限制，但通常使用起来不方便。例如，应用程序组件可能需要在将来的某些时间触发定时器事件，但硬件定时器仅包含一个用于中断生成的“比较”值。这意味着需要在硬件计时器之上构建一些设施来管理待处理事件列表，可以在发生相应的硬件中断时为这些事件调度回调。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;esp_timer&lt;/code&gt; API 集提供了这样的功能。在内部，&lt;code&gt;esp_timer&lt;/code&gt; 使用 32 位硬件定时器（FRC1，“传统”定时器）。&lt;code&gt;esp_timer&lt;/code&gt; 提供单次和周期定时器，微秒时间分辨率和 64 位范围。&lt;/p&gt;
&lt;p&gt;从高优先级的 &lt;code&gt;esp_timer&lt;/code&gt; 任务调度定时器回调。由于所有回调都是从同一任务调度的，因此建议仅从回调本身执行尽可能少的工作，而是使用队列将事件发布到优先级较低的任务。&lt;/p&gt;
&lt;p&gt;如果优先级高于 &lt;code&gt;esp_timer&lt;/code&gt; 的其他任务正在运行，则回调调度将延迟，直到 &lt;code&gt;esp_timer&lt;/code&gt; 任务有机会运行。例如，如果正在进行 &lt;code&gt;SPI&lt;/code&gt; 闪存操作，则会发生这种情况。&lt;/p&gt;
&lt;p&gt;创建和启动计时器，并调度回调需要一些时间。因此，单触发 &lt;code&gt;esp_timer&lt;/code&gt; 的超时值有一个下限。如果调用 &lt;code&gt;esp_timer_start_once()&lt;/code&gt; 时超时值小于20us，则仅在大约 20us 后调度回调。&lt;/p&gt;
&lt;p&gt;周期性 &lt;code&gt;esp_timer&lt;/code&gt; 还对最小定时器周期施加 50us 限制。周期小于 50us 的定期软件定时器不实用，因为它们会占用大部分 CPU 时间。如果发现需要小周期的定时器，请考虑使用专用硬件外设或 DMA 功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 学习笔记" scheme="https://blog.infiniteyuan.com/categories/ESP32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ESP32" scheme="https://blog.infiniteyuan.com/tags/ESP32/"/>
    
  </entry>
  
</feed>
