<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>InfiniteYuan</title>
  
  
  <link href="/InfiniteYuanBlog/atom.xml" rel="self"/>
  
  <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/"/>
  <updated>2020-07-23T06:28:59.493Z</updated>
  <id>https://infiniteyuan.github.io/InfiniteYuanBlog/</id>
  
  <author>
    <name>InfiniteYuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo Blog</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/hexo_blog_log/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/hexo_blog_log/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:28:59.493Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（一）关于 ESP-IDF 编程的一些说明</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%B3%E4%BA%8E%20ESP-IDF%20%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%B3%E4%BA%8E%20ESP-IDF%20%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:28:59.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-ESP-IDF-编程的一些说明"><a href="#关于-ESP-IDF-编程的一些说明" class="headerlink" title="关于 ESP-IDF 编程的一些说明"></a>关于 ESP-IDF 编程的一些说明</h1><h2 id="应用启动流程"><a href="#应用启动流程" class="headerlink" title="应用启动流程"></a>应用启动流程</h2><p>本文档说明了在调用 ESP-IDF 应用程序的 <code>app_main</code> 函数之前发生的一些步骤.</p><p>启动过程如下：<br> <strong>1. 位于 ROM 中的第一阶段引导程序将第二阶段引导程序映像从 flash 0x1000 地址加载到 RAM( IRAM 和 DRAM ).<br> 2. 第二阶段引导程序从 flash 中加载分区表和主应用程序映像.主应用程序包含 RAM 段和通过 flash cache 映射的只读段.<br> 3. 主应用程序映像执行.此时,可以启动第二个 CPU 和 RTOS 调度器.</strong><br>以下各节将详细介绍此过程.</p><a id="more"></a><h2 id="第一阶段引导程序"><a href="#第一阶段引导程序" class="headerlink" title="第一阶段引导程序"></a>第一阶段引导程序</h2><p><strong>SoC 复位后,PRO CPU 会立即开始运行,执行复位向量代码,而 APP CPU 将保持复位状态.</strong> 在启动过程中, PRO CPU 会进行所有有关的初始化.APP CPU 复位状态在应用程序启动代码的 <code>call_start_cpu0</code> 函数中被取消.复位向量代码位于 ESP32 芯片掩模 ROM 中的 0x40000400 地址,并且无法修改.<br>复位向量调用的启动代码通过检查 <code>GPIO_STRAP_REG</code> 寄存器的引导引脚状态来确定引导模式.根据复位原因,有以下情况：</p><ol><li>从深度睡眠(<code>deep sleep</code>)模式复位：如果 <code>RTC_CNTL_STORE6_REG</code> 中的值非零,并且 <code>RTC_CNTL_STORE7_REG</code> 中的 RTC 存储器的 CRC 值有效,则使用 <code>RTC_CNTL_STORE6_REG</code> 作为入口地址并立即跳转到该地址.如果 <code>RTC_CNTL_STORE6_REG</code> 为零,或者 <code>RTC_CNTL_STORE7_REG</code> 包含无效的  CRC 值,或者通过 <code>RTC_CNTL_STORE6_REG</code> 调用的代码执行完毕,则继续启动,就像上电复位一样.注意：此时若要运行自定义的代码,需要提供深度睡眠存根机制.请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档.<ol start="2"><li>对于上电复位,软件 SOC 复位和看门狗 SOC 复位：检查 <code>GPIO_STRAP_REG</code> 寄存器,是否要求 UART 或 SDIO 下载模式.如果是这种情况,配置 UART 或 SDIO,并等待下载代码.否则,继续启动,就好像是由于软件 CPU 复位.</li><li>对于软件 CPU 复位和看门狗 CPU 复位：根据 EFUSE 值配置 SPI flash,并尝试从 flash 中加载代码.在下面的段落中会更详细地描述了该步骤.如果从 flash 中加载代码失败,解压 BASIC 解释器到 RAM 中并启动它.请注意,发生这种情况时 RTC 看门狗仍然是开启的,因此除非解释器接收到任何输入,否则看门狗将在几百毫秒内复位 SOC,重复整个过程.如果解释器收到来自 UART 的任何输入,它将禁用看门狗.</li></ol></li></ol><p><strong>应用程序二进制映像从 flash 的 0x1000 地址开始加载.</strong> 闪存的第一个 4kB 扇区用于存储安全引导IV和应用程序映像的签名.有关详细信息,请查看安全启动文档.</p><h2 id="第二阶段引导程序"><a href="#第二阶段引导程序" class="headerlink" title="第二阶段引导程序"></a>第二阶段引导程序</h2><p>在 ESP-IDF 中,位于 flash 0x1000 地址的二进制映像是第二阶段引导程序. 第二阶段引导程序源代码可在 ESP-IDF 的 <code>components/bootloader</code> 目录中找到.请注意,第二阶段引导程序这样的安排并不是 ESP32 芯片唯一可行的安排.可以编写一个功能齐全的应用程序,当 flash 偏移到 0x1000 地址时可以工作,但这超出了本文档的范围.ESP-IDF 中使用第二阶段引导程序来增加 flash 布局的灵活性(使用分区表),并允许与闪存加密,安全引导和无线更新(OTA)相关的操作执行.</p><p><strong>当第一阶段引导程序完成校验并加载第二阶段引导程序时,它会跳转到在二进制映像头中找到的第二阶段引导程序的入口地址.</strong></p><p><strong>第二阶段引导程序读取在 0x8000 地址的分区表.</strong> 更多有关信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">分区表</a>文档.<strong>引导程序找到 factory 和 OTA 分区,并根据 OTA 信息分区中的数据决定引导哪个分区.</strong></p><p>对于所选分区,第二阶段引导程序将映射到 IRAM 和 DRAM 的数据和代码段拷贝到其加载地址.对于在 DROM 和 IROM 区域中具有加载地址的节,flash MMU 将提供正确的映射.请注意,第二阶段引导程序为 PRO 和 APP CPU 配置了 flash MMU,但它仅为 PRO CPU 启用 flash MMU.原因是第二阶段引导程序代码被加载到 APP CPU 缓存所使用的内存区域.为 APP CPU 启用缓存的任务将交给应用程序.加载代码并配置 flash MMU 后,第二阶段引导程序将跳转到二进制映像头中的应用程序入口地址.</p><p>目前,无法将应用程序定义的挂钩添加到引导程序以自定义应用程序分区的选择逻辑.例如,这可能需要根据 GPIO 的状态加载不同的应用程序映像.此类自定义功能将在未来添加到 ESP-IDF 中.目前,可以通过将 bootloader 组件拷贝到应用程序目录并在那里进行必要的更改来自定义引导程序.在这种情况下,ESP-IDF 构建系统将编译应用程序目录中的组件而不是 ESP-IDF 自身目录中的组件.</p><h2 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h2><p>ESP-IDF 应用程序入口地址是在 <code>components/esp32/cpu_start.c</code>中的<code>call_start_cpu0</code>函数.这个函数的两个主要功能是启用堆分配器并使 APP CPU 跳转到其入口地址<code>call_start_cpu1</code>.PRO CPU 上的代码设置 APP CPU 的入口地址、取消 APP CPU 复位,并等待全局标志被 APP CPU 上运行的代码设置,以表示 APP CPU 已经启动.这个函数执行后,PRO CPU 跳转到<code>start_cpu0</code>函数,APP CPU 跳转到<code>start_cpu1</code>函数.</p><p><code>start_cpu0</code>和<code>start_cpu1</code>都是弱函数,这意味着如果需要对初始化序列进行一些特定于应用程序的更改,则可以在应用程序中覆盖它们.<code>start_cpu0</code>默认启用或初始化 <code>menuconfig</code> 中选择的组件.请参阅<code>components/esp32/cpu_start.c</code>中此函数的源代码,以获取最新的执行步骤.请注意,在此阶段将调用应用程序中存在的任何 C ++ 全局构造函数.初始化完所有必要组件后,将创建主任务并启动 FreeRTOS 调度器.</p><p>当 PRO CPU 在 <code>start_cpu0</code>函数中进行初始化时,APP CPU 将在<code>start_cpu1</code>函数中等待调度器在 PRO CPU 上启动.在 PRO CPU 上启动调器器后,APP CPU 上的代码也会开启调度器.</p><p>主任务是运行 <code>app_main</code>函数. 可以在 <code>menuconfig</code> 中配置主任务堆栈大小和优先级. 应用程序可以将此任务用于特定应用程序的初始化,例如启动其他任务. 应用程序还可以将主任务用于事件循环和其他通用活动. 如果 <code>app_main</code> 函数返回,主任务会被删除.</p><h2 id="应用内存布局"><a href="#应用内存布局" class="headerlink" title="应用内存布局"></a>应用内存布局</h2><p>ESP32 芯片具有灵活的内存映射功能.本节将介绍  ESP-IDF 在默认情况下是如何使用这些功能的.<br>ESP-IDF 中的应用程序代码可以放入以下内存区域之一.</p><h3 id="IRAM-指令RAM"><a href="#IRAM-指令RAM" class="headerlink" title="IRAM(指令RAM)"></a>IRAM(指令RAM)</h3><p>ESP-IDF 为指令 RAM 分配内部 SRAM0 区域的一部分(在技术参考手册中定义).除了第一个 64 kB 块用于 PRO 和 APP CPU 高速缓存之外,该存储器范围的其余部分(即从 <code>0x40080000</code> 到 <code>0x400A0000</code> )用于存储需要从 RAM 中运行的应用程序部分.</p><p>使用链接描述文件将 ESP-IDF 的一些组件和 WiFi 协议栈的一些部分放入该区域.</p><p>如果需要将一些应用程序代码放入 IRAM,可以使用 <code>IRAM_ATTR</code> 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;esp_attr.h&quot;</span><br><span class="line">void IRAM_ATTR gpio_isr_handler(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是部分应用可能或应该放在 IRAM 中的情况.</p><ul><li>如果在注册中断处理程序时使用<code>ESP_INTR_FLAG_IRAM</code>,则必须将中断处理程序放在 IRAM 中.在这种情况下,ISR 可能只调用放在 IRAM 中的函数或存在于 ROM 中的函数.注意：所有 FreeRTOS API 目前都放在 IRAM 中,因此可以安全地从中断处理程序中调用.如果将 ISR 放在 IRAM 中,则必须使用 <code>DRAM_ATTR</code> 将 ISR 使用的所有常量数据和从 ISR 调用的函数(包括但不限于 <code>const char</code> 数组)放在 DRAM 中.</li><li>可以将一些关键性的时序代码放在 IRAM 中以减少从闪存加载代码相关的损耗.ESP32 通过 32 kB 高速缓存从闪存中读取代码和数据.在某些情况下,将函数放入到 IRAM 中可以减少由高速缓存未命中引起的延迟.</li></ul><h3 id="IROM-从Flash执行的代码"><a href="#IROM-从Flash执行的代码" class="headerlink" title="IROM(从Flash执行的代码)"></a>IROM(从Flash执行的代码)</h3><p>如果函数未明确放入到 IRAM 或 RTC 内存中,则将其放置到闪存中.Flash 技术参考手册中介绍了 Flash MMU 用于允许代码从闪存执行的机制. ESP-IDF 从 0x400D0000 - 0x40400000 区域开始放置应该从闪存执行的代码.启动时,第二阶段引导加载程序初始化 Flash MMU 以将代码所在的 flash 中的位置映射到该区域的开头.使用 0x40070000 - 0x40080000 范围内的两个 32kB 块透明地缓存对该区域的访问.<br>请注意,使用 Window ABI CALLx 指令可能无法访问 0x40000000 - 0x40400000 区域外的代码,因此如果应用程序使用 0x40400000 - 0x40800000 或 0x40800000 - 0x40C00000 区域,需要特别小心. ESP-IDF 默认不使用这些区域.</p><h3 id="RTC-高速存储器"><a href="#RTC-高速存储器" class="headerlink" title="RTC 高速存储器"></a>RTC 高速存储器</h3><p>从深度睡眠模式唤醒后,将要运行的代码必须放入 RTC 存储器.请查看<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档中的详细说明.</p><h3 id="DRAM-数据-RAM"><a href="#DRAM-数据-RAM" class="headerlink" title="DRAM (数据 RAM)"></a>DRAM (数据 RAM)</h3><p>链接器将非常量静态数据和零初始化数据放入 256 kB 的 0x3FFB0000 - 0x3FFF0000 区域中.请注意,如果使用蓝牙堆栈,此区域将减少 64kB(通过将开始地址移至 0x3FFC0000).如果使用跟踪存储器,该区域的长度也会减少 16 kB 或 32kB.放置静态数据后,在此区域中的所有剩下的空间都将用于运行时堆.</p><p>常量数据也可以放入 DRAM 中,例如,如果它用在 ISR 中(参见上面 IRAM 部分的注释).为此,可以使用 DRAM_ATTR 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DRAM_ATTR const char[] format_string &#x3D; &quot;%p %x&quot;;</span><br><span class="line">char buffer[64];</span><br><span class="line">sprintf(buffer, format_string, ptr, val);</span><br></pre></td></tr></table></figure><p>不必说,不建议在 ISR 中使用 printf 和其他输出功能.为了进行调试,从中断服务程序打印log时使用 <code>ESP_EARLY_LOGx</code> 宏.在这种情况下,必须确保将 TAG 和格式字符串都放入到 DRAM 中.</p><p><code>__NOINIT_ATTR</code>宏可以用作将数据放入<code>.noinit</code>部分的属性.放入此部分的值不会在启动时初始化,并在软件重新启动后保留其值.<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__NOINIT_ATTR uint32_t noinit_data;</span><br></pre></td></tr></table></figure><h3 id="DROM-存储在-Flash-中的数据"><a href="#DROM-存储在-Flash-中的数据" class="headerlink" title="DROM(存储在 Flash 中的数据)"></a>DROM(存储在 Flash 中的数据)</h3><p>默认情况下,链接器将常量数据放入到一个 4 MB 的区域中(0x3F400000 - 0x3F800000),该区域被用于通过 Flash MMU 和缓存访问外部闪存.但是对于文字常量不同,它们由编译器嵌入到应用程序代码中.</p><h3 id="RTC-低速存储器"><a href="#RTC-低速存储器" class="headerlink" title="RTC 低速存储器"></a>RTC 低速存储器</h3><p>从 RTC 存储器中运行的代码使用的全局和静态变量(即深度睡眠存根代码)必须放入到 RTC 慢速存储器中. 请查看<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档中的详细说明.</p><p><code>RTC_NOINIT_ATTR</code>宏可用于将数据放入到这种类型的内存中.放在此部分中的数据,在从深度睡眠中醒来后也会保持其值.<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTC_NOINIT_ATTR uint32_t rtc_noinit_data;</span><br></pre></td></tr></table></figure><h3 id="DMA-能力要求"><a href="#DMA-能力要求" class="headerlink" title="DMA 能力要求"></a>DMA 能力要求</h3><p>大多数 DMA 控制器(例如 SPI,sdmmc 等)都要求发送/接收缓冲区应放在 DRAM 中并进行字对齐.我们建议将 DMA 缓冲区放在静态变量中而不是堆栈中.使用<code>DMA_ATTR</code>宏声明全局/本地静态变量,如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DMA_ATTR uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;</span><br><span class="line"></span><br><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    DMA_ATTR static uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在堆栈中放置DMA缓冲区仍然是允许的,但必须记住：</p><ol><li>如果堆栈在 pSRAM 中,切勿尝试这样做.如果任务的堆栈放在 pSRAM 中,则必须执行<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/external-ram.html" target="_blank" rel="noopener">支持外部 RAM </a>文档(至少在 menuconfig 中启用 <code>SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY</code> 选项)中所述的几个步骤.确保你的任务不在 pSRAM 中.</li><li>在将变量放在适当的位置之前的函数中使用 <code>WORD_ALIGNED_ATTR</code> 宏,如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t stuff;</span><br><span class="line">    WORD_ALIGNED_ATTR uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;   &#x2F;&#x2F;or the buffer will be placed right after stuff.</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><a href="https://esp-idf.readthedocs.io/en/latest/api-guides/general-notes.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于-ESP-IDF-编程的一些说明&quot;&gt;&lt;a href=&quot;#关于-ESP-IDF-编程的一些说明&quot; class=&quot;headerlink&quot; title=&quot;关于 ESP-IDF 编程的一些说明&quot;&gt;&lt;/a&gt;关于 ESP-IDF 编程的一些说明&lt;/h1&gt;&lt;h2 id=&quot;应用启动流程&quot;&gt;&lt;a href=&quot;#应用启动流程&quot; class=&quot;headerlink&quot; title=&quot;应用启动流程&quot;&gt;&lt;/a&gt;应用启动流程&lt;/h2&gt;&lt;p&gt;本文档说明了在调用 ESP-IDF 应用程序的 &lt;code&gt;app_main&lt;/code&gt; 函数之前发生的一些步骤.&lt;/p&gt;
&lt;p&gt;启动过程如下：&lt;br&gt; &lt;strong&gt;1. 位于 ROM 中的第一阶段引导程序将第二阶段引导程序映像从 flash 0x1000 地址加载到 RAM( IRAM 和 DRAM ).&lt;br&gt; 2. 第二阶段引导程序从 flash 中加载分区表和主应用程序映像.主应用程序包含 RAM 段和通过 flash cache 映射的只读段.&lt;br&gt; 3. 主应用程序映像执行.此时,可以启动第二个 CPU 和 RTOS 调度器.&lt;/strong&gt;&lt;br&gt;以下各节将详细介绍此过程.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（七）ESP32 Core Dump</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%83%EF%BC%89ESP32%20Core%20Dump/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%83%EF%BC%89ESP32%20Core%20Dump/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:28:59.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESP32-Core-Dump"><a href="#ESP32-Core-Dump" class="headerlink" title="ESP32 Core Dump"></a>ESP32 Core Dump</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-IDF 支持在不可恢复的软件错误上生成 Core Dump。这个技术可以对软件发生故障时的软件状态进行事后分析。在系统崩溃进入 Panic 状态时，根据配置打印一些信息并停止或重新启动。用户可以选择生成 Core Dump，以便稍后在 PC 上分析故障原因。Core Dump 包含软件发生故障时系统中所有任务的快照。快照包括任务控制块(TCB)和堆栈。因此。有可能找出什么任务，在什么指令(代码行)和该任务的什么调用堆栈导致崩溃。ESP-IDF 提供特殊脚本 <code>espcoredump.py</code>，以帮助用户检索和分析 Core Dump。此工具提供两个用于 Core Dump 分析的命令:</p><ul><li><code>info_corefile</code> - 打印崩溃的任务的寄存器，调用堆栈，系统中可用任务的列表，内存区域和存储在 Core Dump (TCB 和堆栈)中的内存内容。</li><li><code>dbg_corefile</code> - 创建 Core Dump ELF 文件并使用此文件运行 GDB 调试会话。用户可以手动检查内存，变量和任务状态。请注意，由于并非所有内存都保存在 Core Dump 中，因此只有堆栈上分配的变量值才有意义。</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>有许多与 Core Dump 相关的配置选项，用户可以在应用程序的配置菜单中选择 (<code>make menuconfig</code>)。</p><ol><li>Core Dump 数据目标(Components -&gt; ESP32-specific config -&gt; Core dump destination):<ul><li>禁用 Core Dump 生成</li><li>将 Core Dump 保存到 Flash</li><li>将 Core Dump 打印到 UART</li></ul></li><li>核心转储中的最大任务快照数(Components -&gt; ESP32-specific config -&gt; Core dump -&gt; Maximum number of tasks)。</li><li>Core Dump 打印到 UART 之前的延迟时间(Components -&gt; ESP32-specific config -&gt; Core dump print to UART delay).。值以 ms 为单位。</li></ol><h2 id="将-Core-Dump-保存到-Flash"><a href="#将-Core-Dump-保存到-Flash" class="headerlink" title="将 Core Dump 保存到 Flash"></a>将 Core Dump 保存到 Flash</h2><p>选择此选项后，Core Dump 将保存到 Flash 上的特殊分区。当使用随 ESP-IDF 提供的默认分区表文件时，它会自动在 Flash 上分配必要的空间，但如果用户想要将自己的布局文件与 Core Dump 功能一起使用，则应为 Core Dump 定义单独的分区，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size</span><br><span class="line"># Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000</span><br><span class="line">factory,  app,  factory, 0x10000, 1M</span><br><span class="line">coredump, data, coredump,,        64K</span><br></pre></td></tr></table></figure><p>分区名称没有特殊要求。可以根据用户应用需求选择，但分区类型应为“数据”，子类型应为“coredump”。此外，在选择分区大小时请注意，Core Dump 数据结构会引入 20 字节的常量开销和 12 字节的每任务开销。此开销不包括每个任务的 TCB 和堆栈的大小，因此，partirion 大小应至少为 20 + max task stack number x(12 + TCB size + max task stack size) 字节。</p><p>从 Flash 分析 Core Dump 的通用命令示例是:<br><code>espcoredump.py -p &lt;/path/to/serial/port&gt; info_corefile &lt;/path/to/program/elf/file&gt;</code><br>或<br> <code>espcoredump.py -p &lt;/path/to/serial/port&gt; dbg_corefile &lt;/path/to/program/elf/file&gt;</code></p><h2 id="将-Core-Dump-打印到UART"><a href="#将-Core-Dump-打印到UART" class="headerlink" title="将 Core Dump 打印到UART"></a>将 Core Dump 打印到UART</h2><p>选择此选项时，在系统崩溃进入 Panic 状态时，将在 UART 上打印 <strong>base64 编码的 Core Dump</strong>。在这种情况下，用户应手动将 Core Dump 文本正文保存到某个文件，然后运行以下命令:<br><code>espcoredump.py info_corefile -t b64 -c &lt;/path/to/saved/base64/text&gt; &lt;/path/to/program/elf/file&gt;</code><br>或<br> <code>espcoredump.py dbg_corefile -t b64 -c &lt;/path/to/saved/base64/text&gt; &lt;/path/to/program/elf/file&gt;</code></p><p>Base64 编码的 Core Dump 体将位于以下页眉和页脚之间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; CORE DUMP START &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&lt;body of base64-encoded core dump, save it to file on disk&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; CORE DUMP END &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>CORE DUMP START 和 CORE DUMP END 行不得包含在 Core Dump 文本文件中。</p><h2 id="Backtraces-中的-ROM-函数"><a href="#Backtraces-中的-ROM-函数" class="headerlink" title="Backtraces 中的 ROM 函数"></a>Backtraces 中的 ROM 函数</h2><p>可能的情况是，在崩溃时，一些任务或/和崩溃的任务本身在其调用堆栈中具有一个或多个 ROM 功能。由于 ROM 不是程序 ELF 的一部分，GDB 不可能解析这样的调用堆栈，因为它试图分析函数的序言来实现它。在这种情况下，调用堆栈打印将在第一个 ROM 函数中被错误消息打破。要解决此问题，您可以使用 Espressif 提供的 <a href="https://dl.espressif.com/dl/esp32_rom.elf" target="_blank" rel="noopener">ROM ELF</a> 并将其传递给 ‘espcoredump.py’。</p><h2 id="运行-‘espcoredump-py’"><a href="#运行-‘espcoredump-py’" class="headerlink" title="运行 ‘espcoredump.py’"></a>运行 ‘espcoredump.py’</h2><p>通用命令语法:</p><p><code>espcoredump.py [options] command [args]</code></p><p><code>Script Options:</code>    </p><ul><li>–chip,-c {auto,esp32}. Target chip type. Supported values are auto and esp32.</li><li>–port,-p PORT. Serial port device.</li><li>–baud,-b BAUD. Serial port baud rate used when flashing/reading.</li></ul><p><code>Commands:</code>    </p><ul><li>info_corefile. Retrieve core dump and print useful info.</li><li>dbg_corefile. Retrieve core dump and start GDB session with it.</li></ul><p><code>Command Arguments:</code></p><ul><li>–gdb,-g GDB. Path to gdb to use for data retrieval.</li><li>–core,-c CORE. Path to core dump file to use (if skipped core dump will be read from flash).</li><li>–core-format,-t CORE_FORMAT. Specifies that file passed with “-c” is an ELF (“elf”), dumped raw binary (“raw”) or base64-encoded (“b64”) format.</li><li>–off,-o OFF. Ofsset of coredump partition in flash (type “make partition_table” to see it).</li><li>–save-core,-s SAVE_CORE. Save core to file. Othwerwise temporary core file will be deleted. Ignored with “-c”.</li><li>–rom-elf,-r ROM_ELF. Path to ROM ELF file to use (if skipped “esp32_rom.elf” is used).</li><li>–print-mem,-m Print memory dump. Used only with “info_corefile”.</li></ul><p><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/core_dump.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ESP32-Core-Dump&quot;&gt;&lt;a href=&quot;#ESP32-Core-Dump&quot; class=&quot;headerlink&quot; title=&quot;ESP32 Core Dump&quot;&gt;&lt;/a&gt;ESP32 Core Dump&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（三）分区表</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%8C%BA%E8%A1%A8/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:28:59.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>单个 ESP32 的 flash 可以包含多个应用程序,以及许多不同类型的数据(校准数据,文件系统,参数存储等). 因此,分区表被下载到 flash 中的 0x8000 地址(默认偏移量).</p><p>分区表长度为 0xC00 字节(最多 95 个分区表条目). 在表数据之后附加 MD5 校验和. 如果分区表由于安全引导而签名,则签名将附加在分区表之后.</p><p>分区表中的每个条目都有一个 <code>name</code> (label),<code>type</code>(app,data 或其他),<code>subtype</code>以及加载分区的 flash 中的 <code>offset</code> (偏移量).</p><p>使用分区表的最简单方法是 <code>make menuconfig</code> 并选择一个简单的预定义分区表:</p><ul><li>“Single factory app, no OTA”</li><li>“Factory app, two OTA definitions”</li></ul><p>在这两种情况下,<code>factory</code> 应用程序下载到 0x10000 地址. 如果您 <code>make partition_table</code>,那么它将打印分区表的摘要.</p><a id="more"></a><h2 id="内置分区表"><a href="#内置分区表" class="headerlink" title="内置分区表"></a>内置分区表</h2><p>以下是 <code>Single factory app, no OTA</code> 的分区表配置信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Espressif ESP32 Partition Table</span><br><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  app,  factory, 0x10000, 1M,</span><br></pre></td></tr></table></figure><ul><li>flash 中的 0x10000(64KB) 偏移量被标记为 <code>factory</code> 应用程序. 默认情况下,引导加载程序将运行此应用程序.</li><li>在分区表中还定义了两个用于存储 NVS 库分区和 PHY 初始化数据的数据区域.</li></ul><p>以下是 <code>Factory app, two OTA definitions</code> 的分区表配置信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Espressif ESP32 Partition Table</span><br><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x4000,</span><br><span class="line">otadata,  data, ota,     0xd000,  0x2000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  0,    0,       0x10000, 1M,</span><br><span class="line">ota_0,    0,    ota_0,  0x110000, 1M,</span><br><span class="line">ota_1,    0,    ota_1,  0x210000, 1M,</span><br></pre></td></tr></table></figure><ul><li>现在有三个应用程序分区定义.</li><li>这三种 <code>Type</code> 都设置为 <code>app</code>,但在 0x10000 位置的 <code>factory</code> 应用程序和后面的两个 <code>OTA</code> 应用程序的子类型有所不同.</li><li>还有一个新的 <code>ota data</code> 区域,用于保存 OTA 更新的数据. 引导加载程序会查询此数据,以便了解要执行的应用程序. 如果 <code>ota data</code> 为空,它将执行 <code>factory</code> 应用程序.</li></ul><h2 id="创建自定义分区表"><a href="#创建自定义分区表" class="headerlink" title="创建自定义分区表"></a>创建自定义分区表</h2><p>如果在 menuconfig 中选择 “Custom partition table CSV”,还应该输入要用于分区表的 CSV 文件的名称(在项目目录中). CSV 文件中有将要用于分区表配置的任意数量的定义.</p><p>CSV 格式与上面摘要中打印的格式相同. 但是,CSV 中并非所有字段都是必需的. 例如,以下是 OTA 分区表的“输入” CSV:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Custom partition table</span><br><span class="line"># Name,   Type, SubType, Offset, Size, Flags</span><br><span class="line">nvs,      data, nvs,     ,       0x4000,</span><br><span class="line">otadata,  data, ota,     ,       0x2000,</span><br><span class="line">phy_init, data, phy,     ,       0x1000,</span><br><span class="line">factory,  app,  factory, ,       1M,</span><br><span class="line">ota_0,    app,  ota_0,   ,       1M,</span><br><span class="line">ota_1,    app,  ota_1,   ,       1M,</span><br></pre></td></tr></table></figure><ul><li>字段之间的空格被忽略,任何以＃(注释)开头的行也是如此.</li><li>CSV 文件中的每个非注释行都是分区定义.</li><li>每个分区的 “Offset” 字段为空. <code>gen_esp32part.py</code> 工具填充每个空白偏移量,从分区表开始并确保每个分区正确对齐.</li></ul><h3 id="名字字段"><a href="#名字字段" class="headerlink" title="名字字段"></a>名字字段</h3><p>名称字段可以是任何有意义的名称. 这对 ESP32 来说并不重要. 超过 16 个字符的名称将被截取.</p><h3 id="类型字段"><a href="#类型字段" class="headerlink" title="类型字段"></a>类型字段</h3><p>分区类型字段可以指定为 app(0) 或 data(1). 或者它可以是数字 0-254(或十六进制 0x00-0xFE). 类型 0x00-0x3F 保留用于 esp-idf 核心功能.</p><p>如果您的应用程序需要存储数据,请在 0x40-0xFE 范围内添加自定义分区类型.</p><p>引导加载程序忽略 app(0) 和 data(1) 以外的任何分区类型.</p><h3 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a>子类型</h3><p>8 位子类型字段特定于给定的分区类型.</p><p>esp-idf 当前仅指定 “app” 和 “data” 分区类型的子类型字段的含义.</p><h3 id="App-子类型"><a href="#App-子类型" class="headerlink" title="App 子类型"></a>App 子类型</h3><p>当 type 为 “app” 时,子类型字段可以指定为 factory(0),ota_0(0x10)… ota_15(0x1F) 或 test(0x20).</p><ul><li>factory(0) 是默认的应用程序分区. 引导加载程序将执行工厂应用程序,除非它看到类型为 data/ota 的分区,在这种情况下,它会读取此分区以确定要引导的 OTA 映像.<ul><li>OTA 永远不会更新 <code>factory</code> 分区.</li><li>如果要保留 OTA 项目中的闪存使用率,可以删除 <code>factory</code> 分区并改为使用 ota_0.</li></ul></li><li>ota_0(0x10)… ota_15(0x1F) 是 OTA app 区域. 有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html" target="_blank" rel="noopener">OTA文档</a>,然后使用 OTA 数据分区配置引导加载程序应引导的应用程序. 如果使用 OTA,则应用程序应至少具有两个 OTA 应用程序槽(<code>ota_0</code>＆<code>ota_1</code>). 有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html" target="_blank" rel="noopener">OTA文档</a>.</li><li>test(0x2) 是 <code>factory</code> 测试程序的保留子类型. esp-idf 引导程序当前不支持它.</li></ul><h3 id="数据子类型"><a href="#数据子类型" class="headerlink" title="数据子类型"></a>数据子类型</h3><p>当 type 为 “data” 时,子类型字段可以指定为 ota(0),phy(1),nvs(2).</p><ul><li>ota(0) 是<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html#ota-data-partition" target="_blank" rel="noopener">OTA数据分区</a>,它存储有关当前所选 OTA 应用程序的信息.此分区的大小应为 0x2000 字节.有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html#ota-data-partition" target="_blank" rel="noopener">OTA文档</a>.</li><li>phy(1) 用于存储 PHY 初始化数据.这允许 PHY 到每个设备被配置,而不是在固件.<ul><li>在默认配置中,不使用 phy 分区,并且 PHY 初始化数据被编译到 app 本身.因此,可以从分区表中删除此分区以节省空间.</li><li>要从此分区加载 PHY 数据,请运行 <code>make menuconfig</code> 并启用 <code>CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</code> 选项.您还需要使用 <code>phy init</code> 数据刷新(flash)设备,因为 esp-idf 构建系统不会自动执行此操作.</li></ul></li><li>nvs(2) 用于<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/storage/nvs_flash.html" target="_blank" rel="noopener">非易失性存储(NVS)API</a>.<ul><li>NVS 用于存储每个设备 PHY 校准数据(与初始化数据不同).</li><li>如果使用<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/wifi/esp_wifi.html" target="_blank" rel="noopener">esp_wifi_set_storage(WIFI_STORAGE_FLASH)</a>初始化功能,则 NVS 用于存储 WiFi 数据.</li><li>NVS API 还可用于其他应用程序数据.</li><li>强烈建议您在项目中包含至少 0x3000 字节的 NVS 分区.</li><li>如果使用 NVS API 存储大量数据,请将 NVS 分区默认的 0x6000 字节大小增加.</li></ul></li></ul><p>其他数据子类型保留用于将来的 esp-idf 用途.</p><h3 id="偏移量-amp-大小"><a href="#偏移量-amp-大小" class="headerlink" title="偏移量 &amp; 大小"></a>偏移量 &amp; 大小</h3><p>具有空白偏移的分区将在前一个分区之后开始,或者第一个分区是在分区表之后开始.</p><p>应用程序分区必须处于与 0x10000(64K) 对齐的偏移量. 如果将偏移字段留空,工具将自动对齐分区. 如果为应用程序分区指定未对齐的偏移量,该工具将返回错误.</p><p>大小和偏移量可以指定为十进制数,带前缀 0x 的十六进制数,或大小乘数 K 或 M(1024 和 1024 * 1024 字节).</p><p>如果希望分区表中的分区与表本身的任何起始偏移量(<code>CONFIG_PARTITION_TABLE_OFFSET</code>)一起使用,请将所有分区的偏移字段(在 CSV 文件中)留空. 类似地,如果更改分区表偏移,则要注意所有空白分区偏移可能会更改为匹配,并且任何固定偏移现在可能与分区表冲突(导致错误).</p><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>目前仅支持一个加密的标志. 如果此字段设置为加密,则在启用 Flash 加密时将对此分区进行加密.</p><p>(请注意,无论是否设置此标志,应用程序类型分区都将始终加密.)</p><h2 id="生成二进制分区表"><a href="#生成二进制分区表" class="headerlink" title="生成二进制分区表"></a>生成二进制分区表</h2><p>下载到 ESP32 的分区表是二进制格式,而不是 CSV 格式. 工具 <code>partition_table/gen_esp32part.py</code> 用于在 CSV 和二进制格式之间进行转换.</p><p>如果在 <code>make menuconfig</code> 中配置分区表 CSV 名称,然后生成 <code>partition_table</code>,则此转换将在构建过程中完成.</p><p>要手动将 CSV 转换为二进制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python gen_esp32part.py input_partitions.csv binary_partitions.bin</span><br></pre></td></tr></table></figure><p>要将二进制格式转换回 CSV:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python gen_esp32part.py binary_partitions.bin input_partitions.csv</span><br></pre></td></tr></table></figure><p>在 stdout 上显示二进制分区表的内容(这是生成 <code>make partition_table</code> 时显示的摘要的方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python gen_esp32part.py binary_partitions.bin</span><br></pre></td></tr></table></figure><h3 id="MD5-校验和"><a href="#MD5-校验和" class="headerlink" title="MD5 校验和"></a>MD5 校验和</h3><p>分区表的二进制格式包含基于分区表计算的 MD5 校验和. 此校验和用于在引导期间检查分区表的完整性.</p><p>可以通过 <code>gen_esp32part.py</code> 的 <code>--disable-md5sum</code> 选项或 <code>CONFIG_PARTITION_TABLE_MD5</code> 选项禁用 MD5 校验和生成. 例如,当使用传统引导加载程序无法处理 MD5 校验和且引导失败并且错误消息无效幻数 0xebeb 时,这很有用.</p><h2 id="烧录分区表"><a href="#烧录分区表" class="headerlink" title="烧录分区表"></a>烧录分区表</h2><ul><li><code>make partition_table-flash</code>:将使用 `esptool.py 下载分区表.</li><li><code>make flash</code>:会下载所有固件,包括分区表.</li></ul><p>手动下载命令也会打印在 <code>make partition_table</code> 中.</p><p>请注意,更新分区表不会擦除已根据旧分区表存储的数据. 您可以使用 <code>make erase_flash</code> (或 <code>esptool.py erase_flash</code>)来擦除整个闪存内容.</p><p><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分区表&quot;&gt;&lt;a href=&quot;#分区表&quot; class=&quot;headerlink&quot; title=&quot;分区表&quot;&gt;&lt;/a&gt;分区表&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;单个 ESP32 的 flash 可以包含多个应用程序,以及许多不同类型的数据(校准数据,文件系统,参数存储等). 因此,分区表被下载到 flash 中的 0x8000 地址(默认偏移量).&lt;/p&gt;
&lt;p&gt;分区表长度为 0xC00 字节(最多 95 个分区表条目). 在表数据之后附加 MD5 校验和. 如果分区表由于安全引导而签名,则签名将附加在分区表之后.&lt;/p&gt;
&lt;p&gt;分区表中的每个条目都有一个 &lt;code&gt;name&lt;/code&gt; (label),&lt;code&gt;type&lt;/code&gt;(app,data 或其他),&lt;code&gt;subtype&lt;/code&gt;以及加载分区的 flash 中的 &lt;code&gt;offset&lt;/code&gt; (偏移量).&lt;/p&gt;
&lt;p&gt;使用分区表的最简单方法是 &lt;code&gt;make menuconfig&lt;/code&gt; 并选择一个简单的预定义分区表:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“Single factory app, no OTA”&lt;/li&gt;
&lt;li&gt;“Factory app, two OTA definitions”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这两种情况下,&lt;code&gt;factory&lt;/code&gt; 应用程序下载到 0x10000 地址. 如果您 &lt;code&gt;make partition_table&lt;/code&gt;,那么它将打印分区表的摘要.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（二）构建系统</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:28:59.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h1><p>本文档解释了 Espressif 物联网开发框架构建系统和“组件”的概念.</p><p>如果您想知道如何组织新的 <code>ESP-IDF</code> 项目,请阅读本文档.</p><p>我们建议使用 <a href="https://github.com/espressif/esp-idf-template" target="_blank" rel="noopener">esp-idf-template</a> 项目作为项目的起点.</p><a id="more"></a><h2 id="使用构建系统"><a href="#使用构建系统" class="headerlink" title="使用构建系统"></a>使用构建系统</h2><p>esp-idf 中的 <code>README</code> 文件有如何使用构建系统构建项目的说明.</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>一个 <code>ESP-IDF</code> 项目可以看作是多个组件的组合.例如,对于显示当前湿度的网络服务器,可能有:</p><ul><li>ESP32 基础库( libc,rom bindings 等)</li><li>WiFi 驱动</li><li>TCP / IP 协议堆栈</li><li>FreeRTOS 操作系统</li><li>Web 服务器</li><li>湿度传感器驱动</li><li>主程序</li></ul><p><code>ESP-IDF</code> 使这些组件结构更清晰并具有可配置性.为此,在编译项目时,构建环境将查找 <code>ESP-IDF</code> 目录、项目目录和(可选)其他自定义组件目录中的所有组件.之后,它允许用户使用基于文本的菜单系统去自定义每个组件来配置 <code>ESP-IDF</code> 项目.在配置完项目中的组件之后,构建程序将编译项目.</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>“项目”是一个目录,其中包含构建单个 “app” (可执行文件)所需的文件和配置,以及其他附加文件,如:分区表,数据/文件系统分区和引导程序.</li><li>“项目配置”保存在项目根目录中的 <code>sdkconfig</code>  文件中.通过 <code>make menuconfig</code> 修改此文件以自定义项目配置.单个项目只包含一个项目配置.</li><li>“app” 是由 esp-idf 构建的可执行文件.单个项目通常会构建两个应用程序 - 一个“项目应用程序”(主要可执行文件,即您的自定义固件)和一个“引导程序”(启动项目应用程序的初始引导程序).</li><li>“组件”是独立代码的模块化部分,它们被编译成静态库(.a文件)并链接到应用程序.有些是由 esp-idf 本身提供的,有些则可能来自其他地方.</li></ul><p>有些东西不是项目的一部分:</p><ul><li>“ESP-IDF” 不是该项目的一部分.相反,它是独立的,并通过 <code>IDF_PATH</code> 环境变量链接到项目,该变量保存 <code>esp-idf</code> 目录的路径.这允许 IDF 框架与您的项目分离.</li><li>用于编译的工具链不是项目的一部分.工具链应安装在系统命令行 <code>PATH</code> 中,或者工具链的路径设置为项目配置中编译器前缀的一部分.</li></ul><h3 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h3><p>一个示例项目目录结构可能如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- myProject&#x2F;</span><br><span class="line">            - Makefile</span><br><span class="line">            - sdkconfig</span><br><span class="line">            - components&#x2F; - component1&#x2F; - component.mk</span><br><span class="line">                                        - Kconfig</span><br><span class="line">                                        - src1.c</span><br><span class="line">                          - component2&#x2F; - component.mk</span><br><span class="line">                                        - Kconfig</span><br><span class="line">                                        - src1.c</span><br><span class="line">                                        - include&#x2F; - component2.h</span><br><span class="line">            - main&#x2F;       - src1.c</span><br><span class="line">                          - src2.c</span><br><span class="line">                          - component.mk</span><br><span class="line"></span><br><span class="line">            - build&#x2F;</span><br></pre></td></tr></table></figure><p>“myProject” 示例包含以下元素:</p><ul><li>顶层项目 Makefile .此 Makefile 设置 <code>PROJECT_NAME</code> 变量,并(可选)定义项目范围的 make 变量.它包括核心的 <code>$(IDF_PATH)/make/project.mk</code> Makefile 文件,它实现了 <code>ESP-IDF</code> 构建系统的其余部分.</li><li>“sdkconfig” 项目配置文件.当 “make menuconfig” 运行时,将创建/更新此文件,并保存项目中所有组件的配置(包括 esp-idf 本身).“sdkconfig” 文件可能会也可能不会添加到项目的源代码管理系统中.</li><li>可选的 “components” 目录包含属于项目一部分的组件.项目不必包含此类自定义组件,但它可用于构造可重用代码或包括不属于 ESP-IDF 的第三方组件.</li><li>“main” 目录是一个特殊的“伪组件(pseudo-component)”,它包含项目本身的源代码.“main” 是默认名称,Makefile 变量<code>COMPONENT_DIRS</code>包含此组件,但您可以修改此变量(或设置 <code>EXTRA_COMPONENT_DIRS</code>)以查找其他位置的组件.</li><li>“build” 目录是项目编译时创建的,包含项目编译时产生的文件.运行 make 后,该目录被创建,并包含临时目标文件和库以及最终的二进制输出文件 <code>bin</code>.此目录通常不会添加到源代码管理中,也不会随项目源代码一起发布.</li></ul><p>组件目录包含一个组件 makefile 文件 - <code>component.mk</code>.这可能包含变量定义,以控制组件的构建过程,以及它与整个项目的集成.有关更多详细信息,请参阅[组件Makefile](#组件 Makefile).</p><p>每个组件还可以包括一个 <code>Kconfig</code> 文件,用于定义通过项目配置设置的组件配置选项.某些组件还可能包含 <code>Kconfig.projbuild</code> 和 <code>Makefile.projbuild</code> 文件,这些文件是用于覆盖项目部分的特殊文件.</p><h3 id="项目-Makefile"><a href="#项目-Makefile" class="headerlink" title="项目 Makefile"></a>项目 Makefile</h3><p>每个项目都有一个 Makefile,其中包含整个项目的构建配置.默认情况下,项目 Makefile 可以非常小.</p><h4 id="最小示例-Makefile"><a href="#最小示例-Makefile" class="headerlink" title="最小示例 Makefile"></a>最小示例 Makefile</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROJECT_NAME :&#x3D; myProject</span><br><span class="line"></span><br><span class="line">include $(IDF_PATH)&#x2F;make&#x2F;project.mk</span><br></pre></td></tr></table></figure><h4 id="强制项目变量"><a href="#强制项目变量" class="headerlink" title="强制项目变量"></a>强制项目变量</h4><ul><li>PROJECT_NAME:项目名称.二进制输出文件将使用此名称 - 即 myProject.bin, myProject.elf.</li></ul><h4 id="可选项目变量"><a href="#可选项目变量" class="headerlink" title="可选项目变量"></a>可选项目变量</h4><p>这些变量都有默认值,并可以被自定义操作覆盖.查看 <code>make/project.mk</code> 以获取所有实现细节.</p><ul><li><code>PROJECT_PATH</code>:顶级项目目录.默认为包含 Makefile 的目录.许多其他项目变量都基于此变量.项目路径不能包含空格.</li><li><code>BUILD_DIR_BASE</code>:所有 objects/libraries/binaries 文件的构建输出目录.默认为<code>$(PROJECT_PATH)/build</code>.</li><li><code>COMPONENT_DIRS</code>:搜索组件的目录.默认为<code>$(IDF_PATH)/components</code>( idf 组件),<code>$(PROJECT_PATH)/components</code>(项目组件),<code>$(PROJECT_PATH)/main</code> 和 <code>EXTRA_COMPONENT_DIRS</code> (其他组件).如果您不想在这些位置搜索组件,请覆盖此变量.</li><li><code>EXTRA_COMPONENT_DIRS</code>:用于搜索组件的其他目录的可选列表.</li><li><code>COMPONENTS</code>:要构建到项目中的组件名称列表.默认为<code>COMPONENT_DIRS</code>目录中的所有组件.</li><li><code>EXCLUDE_COMPONENTS</code>:在构建过程中要排除的组件名称的可选列表.请注意,这会减少构建时间,但不会减少二进制大小.</li><li><code>TEST_EXCLUDE_COMPONENTS</code>:在单元测试的构建过程中要排除的可选组件名称列表.</li></ul><p>这些 Makefile 变量中的任何路径都应该是绝对路径.您可以使用<code>$(PROJECT_PATH)/ xxx</code>,<code>$(IDF_PATH)/ xxx</code>转换相对路径,或使用 Make 函数<code>$(abspath xxx)</code>.</p><p>这些都变量应该在 Makefile 中的 <code>include $(IDF_PATH)/make/project.mk</code> 行之前设置.</p><h3 id="组件-Makefile"><a href="#组件-Makefile" class="headerlink" title="组件 Makefile"></a>组件 Makefile</h3><p>每个项目都包含一个或多个组件,这些组件可以是 esp-idf 的一部分,也可以从其他组件目录添加.</p><p>组件是包含 <code>component.mk</code> 文件的任何目录.</p><h3 id="搜索组件"><a href="#搜索组件" class="headerlink" title="搜索组件"></a>搜索组件</h3><p>在<code>COMPONENT_DIRS</code>中的目录列表中搜索项目的组件.此列表中的目录可以是组件本身(即它们包含 <code>component.mk</code> 文件),也可以是子目录为组件的顶级目录(包含组件的目录).</p><p>运行 <code>make list-components</code> 后,会输出这些变量,这可以帮助调试组件目录是否被找到.</p><h4 id="具有相同名称的多个组件"><a href="#具有相同名称的多个组件" class="headerlink" title="具有相同名称的多个组件"></a>具有相同名称的多个组件</h4><p>当 esp-idf 找到所有要编译的组件时,它将按照 <code>COMPONENT_DIRS</code> 指定的顺序执行此操作; 默认情况下,首先是 idf 组件,第二个是项目组件,最后是 <code>EXTRA_COMPONENT_DIRS</code> 中的组件.如果这些目录中的两个或多个包含具有相同名称的组件子目录,则使用搜索的最后一个位置中的组件.例如,这允许通过简单地将组件从 esp-idf 组件目录复制到项目组件树然后在那里修改它来覆盖具有修改版本的 esp-idf 组件.如果以这种方式使用,esp-idf 目录本身可以保持不变.</p><h4 id="最小组件-Makefile"><a href="#最小组件-Makefile" class="headerlink" title="最小组件 Makefile"></a>最小组件 Makefile</h4><p>最小的 <code>component.mk</code> 文件是一个空文件.如果文件为空,则设置默认组件行为:</p><ul><li>与 makefile 在相同的目录中的所有源文件(<code>*.c</code>,<code>*.cpp</code>,<code>*.cc</code>,<code>*.S</code>)将被编译到组件库中</li><li>子目录 “include” 将被添加到所有其他组件的全局 include 搜索路径中.</li><li>组件库将链接到项目应用程序中.</li></ul><p>有关更完整的示例组件 makefile,请参阅[示例组件 makefile](#示例组件 Makefile).</p><p>请注意,空的 <code>component.mk</code> 文件(调用默认组件构建行为)和没有 <code>component.mk</code> 文件(这意味着不会发生默认组件构建行为)之间存在差异.组件可能没有 <code>component.mk</code> 文件,如果它只包含影响项目配置或构建过程的其他文件.</p><h4 id="预设组件变量"><a href="#预设组件变量" class="headerlink" title="预设组件变量"></a>预设组件变量</h4><p>以下特定组件的变量可在<code>component.mk</code>中使用,但不应修改:</p><ul><li><code>COMPONENT_PATH</code>:组件目录.计算包含 <code>component.mk</code> 的目录的绝对路径.组件路径不能包含空格.</li><li><code>COMPONENT_NAME</code>:组件的名称.默认为组件目录的名称.</li><li><code>COMPONENT_BUILD_DIR</code>:组件构建目录.计算 <code>$(BUILD_DIR_BASE)</code> 中要构建此组件源文件的目录的绝对路径.每次构建组件时,这也是当前工作目录,因此 make 等目标中的相对路径都是相对于此目录.</li><li><code>COMPONENT_LIBRARY</code>:将为此组件构建的静态库文件的名称(相对于组件构建目录).默认为 <code>$(COMPONENT_NAME).a</code>.</li></ul><p>以下变量在项目级别设置,但会导出在组件构建中使用:</p><ul><li><code>PROJECT_NAME</code>:项目名称,在项目 Makefile 中设置</li><li><code>PROJECT_PATH</code>:包含项目 Makefile 的项目目录的绝对路径.</li><li><code>COMPONENTS</code>:此构建中包含的所有组件的名称.</li><li><code>CONFIG_ *</code>:项目配置中的每个值都有一个 make 中可用的对应变量.所有名称都以 <code>CONFIG_</code> 开头.</li><li><code>CC</code>,<code>LD</code>,<code>AR</code>,<code>OBJCOPY</code>:gcc xtensa 交叉工具链中每个工具的完整路径.</li><li><code>HOSTCC</code>,<code>HOSTLD</code>,<code>HOSTAR</code>:来自主机本机工具链的每个工具的全名.</li><li><code>IDF_VER</code>:ESP-IDF 版本,使用 git 命令 <code>git describe</code> 从 <code>$(IDF_PATH)/version.txt</code> 文件(如果存在)中检索.这里推荐的格式是单独的一行指定主要 IDF 发布版本,例如标记版本的 <code>v2.0</code> 或任意提交的 <code>v2.0-275-g0efaa4f</code>.应用程序可以通过调用 <code>esp_get_idf_version()</code> 来使用它.</li><li><code>PROJECT_VER</code>: 项目版本<ul><li>如果 <code>PROJECT_VER</code> 变量在项目 Makefile 文件中设置，则将使用其值。</li><li>否则，如果 <code>$PROJECT_PATH/version.txt</code> 存在，其内容将用作 <code>PROJECT_VER</code>。</li><li>否则，如果项目位于 Git 存储库中，则将使用git describe的输出。</li><li>否则，<code>PROJECT_VER</code> 将为“1”。</li></ul></li></ul><p>如果您修改 <code>component.mk</code> 中的任何这些变量,那么这不会阻止构建其他组件,但它可能使您的组件难以构建或者调试.</p><h4 id="可选项目范围的组件变量"><a href="#可选项目范围的组件变量" class="headerlink" title="可选项目范围的组件变量"></a>可选项目范围的组件变量</h4><p>可以在 <code>component.mk</code> 中设置以下变量来控制整个项目中的构建设置:</p><ul><li><code>COMPONENT_ADD_INCLUDEDIRS</code>:相对于组件目录的路径,将添加到项目中所有组件的 “include” 搜索路径.如果未被覆盖,则默认<code>include</code>.如果仅需要编译此特定组件的 “include” 目录,请将其添加到 <code>COMPONENT_PRIV_INCLUDEDIRS</code></li><li><code>COMPONENT_ADD_LDFLAGS</code>:为 LDFLAGS 添加链接器参数以用于应用程序可执行文件.默认为 <code>-l$(COMPONENT_NAME)</code>.如果将预编译库添加到此目录,请将它们添加为绝对路径 <code>-e$(COMPONENT_PATH)/libwhatever.a</code></li><li><code>COMPONENT_DEPENDS</code>:应在此组件之前编译的组件名称的可选列表.对于链接时依赖性,这不是必需的,因为所有组件”include”目录始终可用.如果一个组件生成一个”include”文件,然后您想要包含在另一个组件中,则这是必要的.大多数组件不需要设置此变量.</li><li><code>COMPONENT_ADD_LINKER_DEPS</code>:相对组件路径的文件的可选列表，如果它们发生更改，应触发 ELF 文件的重新链接。 通常用于链接描述文件和二进制库。大多数组件不需要设置此变量。</li></ul><p>以下变量仅适用于属于 esp-idf 本身的组件:</p><ul><li><code>COMPONENT_SUBMODULES</code>:组件使用的 git 子模块路径(相对于 COMPONENT_PATH)的可选列表.这些将由构建过程检查(并在必要时初始化).如果组件位于 IDF_PATH 目录之外,则忽略此变量.</li></ul><h4 id="可选特定的组件变量"><a href="#可选特定的组件变量" class="headerlink" title="可选特定的组件变量"></a>可选特定的组件变量</h4><p>可以在<code>component.mk</code>中设置以下变量来控制该组件的构建:</p><ul><li><code>COMPONENT_PRIV_INCLUDEDIRS</code>:目录路径,必须相对于组件目录,该组件目录将仅添加到此组件源文件的”include”搜索路径中.</li><li><code>COMPONENT_EXTRA_INCLUDES</code>:编译组件源文件时使用的任何额外包含路径.这些将以’-I’为前缀,并按原样传递给编译器.与<code>COMPONENT_PRIV_INCLUDEDIRS</code>变量类似,但这些路径不会相对于组件目录进行扩展.</li><li><code>COMPONENT_SRCDIRS</code>:目录路径,必须相对于组件目录,将用以搜索源文件(<code>* .cpp</code>,<code>* .c</code>,<code>* .S</code>).默认为’.’,即组件目录本身.覆盖它以指定包含源文件的不同目录列表.</li><li><code>COMPONENT_OBJS</code>:要编译的对象文件.默认值是<code>COMPONENT_SRCDIRS</code>中找到的每个源文件的 a.o 文件.覆盖此列表允许您排除<code>COMPONENT_SRCDIRS</code>中的源文件,否则将被编译.请参阅指定源文件</li><li><code>COMPONENT_EXTRA_CLEAN</code>:相对于组件构建目录的路径,使用<code>component.mk</code>文件中的自定义make规则生成的任何文件,以及作为make clean的一部分需要删除的文件.有关示例,请参阅<a href="#_428">源代码生成</a>.</li><li><code>COMPONENT_OWNBUILDTARGET</code>＆<code>COMPONENT_OWNCLEANTARGET</code>:这些目标允许您完全覆盖组件的默认构建行为.有关详细信息,请参阅[完全覆盖组件 Makefile](#完全覆盖组件 Makefile).</li><li><code>COMPONENT_CONFIG_ONLY</code>:如果设置,则此标志指示组件根本不生成任何内置输出(即未构建 <code>COMPONENT_LIBRARY</code>),并忽略大多数其他组件变量.此标志用于 IDF 内部组件,其中仅包含 KConfig.projbuild 和/或 Makefile.projbuild 文件以配置项目,但没有源文件.</li><li><code>CFLAGS</code>:传递给 C 编译器的标志.根据项目设置定义一组默认 <code>CFLAGS</code>.可以通过 <code>CFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li><li><code>CPPFLAGS</code>:传递给 C 预处理器的标志(用于. c , .cpp 和 .S 文件).根据项目设置定义一组默认的 <code>CPPFLAGS</code>.可以通过 <code>CPPFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li><li><code>CXXFLAGS</code>:传递给 C++ 编译器的标志.根据项目设置定义一组默认的 <code>CXXFLAGS</code>.可以通过 <code>CXXFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li></ul><p>要将编译标志应用于单个源文件,可以将变量覆盖添加为目标,即:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apps&#x2F;dhcpserver.o: CFLAGS +&#x3D; -Wno-unused-variable</span><br></pre></td></tr></table></figure><h3 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h3><p>每个组件还可以有一个 Kconfig 文件,与 <code>component.mk</code> 在同一目录下.Kconfig 中包含要添加到此组件的 “make menuconfig” 的配置设置.</p><p>运行 menuconfig 时,可在 “Component Settings” 菜单下找到这些设置.</p><p>要创建组件 KConfig 文件,最简单的方法是使用 esp-idf 中的 KConfig 文件做修改.</p><p>有关示例,请参阅<a href="#添加条件配置">添加条件配置</a>.</p><h3 id="示例：添加二进制库、组件配置文件-Kconfig"><a href="#示例：添加二进制库、组件配置文件-Kconfig" class="headerlink" title="示例：添加二进制库、组件配置文件 Kconfig"></a>示例：添加二进制库、组件配置文件 Kconfig</h3><p><img src="https://img-blog.csdnimg.cn/20190131111141734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># Component Makefile</span><br><span class="line">#</span><br><span class="line">ifdef CONFIG_BT_ENABLED</span><br><span class="line"></span><br><span class="line">COMPONENT_SRCDIRS :&#x3D; .</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_INCLUDEDIRS :&#x3D; include</span><br><span class="line"></span><br><span class="line"># add pre-compiled libraries</span><br><span class="line">LIBS :&#x3D; btdm_app</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_LDFLAGS     :&#x3D; -lbt -L $(COMPONENT_PATH)&#x2F;lib \</span><br><span class="line">                           $(addprefix -l,$(LIBS))</span><br><span class="line"></span><br><span class="line"># re-link program if BT binary libs change</span><br><span class="line">COMPONENT_ADD_LINKER_DEPS :&#x3D; $(patsubst %,$(COMPONENT_PATH)&#x2F;lib&#x2F;lib%.a,$(LIBS))</span><br><span class="line"></span><br><span class="line">COMPONENT_SUBMODULES +&#x3D; lib</span><br><span class="line"></span><br><span class="line">ifeq ($(GCC_NOT_5_2_0), 1)</span><br><span class="line"># TODO: annotate fallthroughs in Bluedroid code with comments</span><br><span class="line">CFLAGS +&#x3D; -Wno-implicit-fallthrough</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifdef CONFIG_BLUEDROID_ENABLED</span><br><span class="line"></span><br><span class="line">COMPONENT_PRIV_INCLUDEDIRS +&#x3D;   bluedroid&#x2F;bta&#x2F;include                   \</span><br><span class="line">                                bluedroid&#x2F;bta&#x2F;ar&#x2F;include</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_INCLUDEDIRS +&#x3D;    bluedroid&#x2F;api&#x2F;include&#x2F;api</span><br><span class="line"></span><br><span class="line">COMPONENT_SRCDIRS +&#x3D;    bluedroid&#x2F;bta&#x2F;dm                      \</span><br><span class="line">                        bluedroid&#x2F;bta&#x2F;gatt </span><br><span class="line"></span><br><span class="line">ifeq ($(GCC_NOT_5_2_0), 1)</span><br><span class="line">bluedroid&#x2F;bta&#x2F;sdp&#x2F;bta_sdp_act.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;btc&#x2F;core&#x2F;btc_config.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;stack&#x2F;btm&#x2F;btm_sec.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;stack&#x2F;smp&#x2F;smp_keys.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h3 id="预处理器定义"><a href="#预处理器定义" class="headerlink" title="预处理器定义"></a>预处理器定义</h3><p>ESP-IDF 构建系统在命令行上添加以下 C 预处理器定义:</p><ul><li><code>ESP_PLATFORM</code> - 可用于检测在 ESP-IDF 内发生的构建.</li><li><code>IDF_VER</code> - ESP-IDF 版本,有关详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/build-system.html#preset-component-variables" target="_blank" rel="noopener">预设组件变量</a>.</li><li><code>PROJECT_VER</code>：项目版本，有关详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/build-system.html#preset-component-variables" target="_blank" rel="noopener">预设组件变量</a>.</li><li><code>PROJECT_NAME</code>：项目名称，在项目 Makefile 中设置.</li></ul><h3 id="构建过程内部"><a href="#构建过程内部" class="headerlink" title="构建过程内部"></a>构建过程内部</h3><h4 id="顶级-Project-Makefile"><a href="#顶级-Project-Makefile" class="headerlink" title="顶级:Project Makefile"></a>顶级:Project Makefile</h4><ul><li>“make” 总是从项目目录和项目 makefile 运行,通常名为 Makefile.</li><li>项目 makefile 设置 <code>PROJECT_NAME</code>,并可选择自定义其他可选项目变量</li><li>项目 makefile 包含 <code>$(IDF_PATH)/make/project.mk</code>,其中包含项目级的 Make 逻辑.</li><li><code>project.mk</code> 填写默认的项目级 make 变量,并包含项目配置中的 make 变量.如果生成的包含项目配置的 makefile 已过期,则会重新生成(通过 <code>project_config.mk</code> 中的 targets),然后 make 进程从顶部重新开始.</li><li><code>project.mk</code> 根据默认组件目录或可选项目变量中设置的自定义组件列表构建需要要构建的组件列表.</li><li>每个组件都可以设置一些<a href="#可选项目范围的组件变量">可选项目范围的组件变量</a>.这些包含在 <code>component_project_vars.mk</code> 生成的 makefile 中 - 每个组件有一个.这些生成的 makefile 包含在 <code>project.mk</code>中.如果有任何缺失或过时,它们将被重新生成(通过对组件 makefile 的递归调用),然后 make 进程从顶部重新开始.</li><li>组件中的 Makefile.projbuild 文件包含在 make 进程中,以添加额外的目标或配置.</li><li>默认情况下,项目 makefile 还为每个组件生成顶级构建和清理目标,并设置 app 和 clean 目标以调用这些子目标.</li><li>为了编译每个组件,对组件 makefile 执行递归 make.</li></ul><p>为了更好地理解项目构建过程,请通读 <code>project.mk</code> 文件本身.</p><h4 id="第二级-组件Makefile"><a href="#第二级-组件Makefile" class="headerlink" title="第二级:组件Makefile"></a>第二级:组件Makefile</h4><ul><li>每次调用组件 makefile 都是通过 <code>$(IDF_PATH)/make/component_wrapper.mk</code> 包装器 makefile 进行的.</li><li>此组件包装器包含所有组件 <code>Makefile.componentbuild</code> 文件,使这些文件中的任何配方,变量等可用于每个组件.</li><li>调用<code>component_wrapper.mk</code>时将当前目录设置为组件构建目录,并将<code>COMPONENT_MAKEFILE</code>变量设置为<code>component.mk</code>的绝对路径.</li><li><code>component_wrapper.mk</code>为所有组件变量设置默认值,然后包括可以覆盖或修改这些变量的component.mk文件.</li><li>如果未定义 <code>COMPONENT_OWNBUILDTARGET</code> 和 <code>COMPONENT_OWNCLEANTARGET</code>,则会为组件的源文件和必备组件 <code>COMPONENT_LIBRARY</code> 静态库文件创建缺省构建和清除目标.</li><li><code>component_project_vars.mk</code> 文件在 <code>component_wrapper.mk</code> 中有自己的目标,如果由于组件 makefile 或项目配置的更改而需要重建此文件,则从 <code>project.mk</code> 进行评估.</li></ul><p>为了更好地理解组件制作过程,请通读 <code>component_wrapper.mk</code> 文件和 esp-idf 中包含的一些 <code>component.mk</code> 文件.</p><h3 id="以非交互方式运行"><a href="#以非交互方式运行" class="headerlink" title="以非交互方式运行"></a>以非交互方式运行</h3><p>在不希望交互式提示的情况下运行 <code>make</code> 时(例如:在 IDE 或自动构建系统中)将 <code>BATCH_BUILD = 1</code> 附加到 make 参数(或将其设置为环境变量).</p><p>设置 <code>BATCH_BUILD</code> 意味着以下内容:</p><ul><li>详细输出(与 <code>V = 1</code> 相同,见下文).如果您不想要详细输出,设置 <code>V = 0</code>.</li><li>如果项目配置缺少新配置项(来自新组件或 esp-idf 更新),则项目使用默认值,而不是提示用户输入每个项目.</li><li>如果构建系统需要调用<code>menuconfig</code>,则会打印错误并且构建失败.</li></ul><h3 id="高级-Make-用法"><a href="#高级-Make-用法" class="headerlink" title="高级 Make 用法"></a>高级 Make 用法</h3><ul><li><code>make app</code>，<code>make bootloader</code>，<code>make partition table</code> 可用于仅根据需要从项目中构建 <code>app</code>，<code>bootloader</code> 或 <code>partition table</code>。</li><li><code>make erase_flash</code> 和 <code>make erase_ota</code> 将分别使用 <code>esptool.py</code> 从 Flash 中擦除整个 Flash 和 OTA 分区选择配置。</li><li><code>make size</code> 打印有关应用程序的一些大小信息。<code>make size-components</code> 和 <code>make size-files</code> 是类似的目标，分别打印更详细的每个组件或每个源文件信息。</li></ul><h3 id="调试-Make-Process"><a href="#调试-Make-Process" class="headerlink" title="调试 Make Process"></a>调试 Make Process</h3><p>调试 esp-idf 构建系统的一些技巧:</p><ul><li>将 <code>V = 1</code> 附加到 make 参数(或将其设置为环境变量)将使 make 回显所有已执行的命令,以及为 sub-make 输入的每个目录.</li><li>运行 <code>make -w</code> 将导致 make 在为 sub-make 输入时回显每个目录 - 与 <code>V = 1</code> 相同但不回显所有命令.</li><li>运行 <code>make --trace</code> (可能除了上述参数之一)将打印出构建时的每个目标,以及导致它构建的依赖项.</li><li>运行 <code>make -p</code> 会打印每个 makefile 中每个生成的目标的(非常详细的)摘要.</li></ul><p>有关更多调试技巧和一般制作信息,请参阅 GNU制作手册.</p><h4 id="警告未定义的变量"><a href="#警告未定义的变量" class="headerlink" title="警告未定义的变量"></a>警告未定义的变量</h4><p>默认情况下,如果引用了未定义的变量(如<code>$(DOES_NOT_EXIST)</code>),构建过程将打印警告.这对于查找变量名称中的错误非常有用.</p><p>如果您不想要此行为,可以在 SDK 工具配置下的 menuconfig 顶级菜单中禁用它.</p><p>请注意,如果在 Makefile 中使用<code>ifdef</code>或<code>ifndef</code>,则此选项不会触发警告.</p><h3 id="覆盖项目的部分内容"><a href="#覆盖项目的部分内容" class="headerlink" title="覆盖项目的部分内容"></a>覆盖项目的部分内容</h3><h4 id="Makefile-projbuild"><a href="#Makefile-projbuild" class="headerlink" title="Makefile.projbuild"></a>Makefile.projbuild</h4><p>对于具有必须在顶级项目 make pass 中进行求值的构建要求的组件,可以在组件目录中创建名为 <code>Makefile.projbuild</code> 的文件.在计算 <code>project.mk</code> 时会包含此 makefile.</p><p>例如,如果您的组件需要为整个项目添加 CFLAGS (不仅仅是为了自己的源文件),那么您可以在 Makefile.projbuild 中设置 <code>CFLAGS +=</code>.</p><p><code>Makefile.projbuild</code> 文件在 esp-idf 中大量使用,用于定义项目范围的构建功能,例如 <code>esptool.py</code> 命令行参数和 <code>bootloader</code> “特殊应用程序”.</p><p>请注意,<code>Makefile.projbuild</code> 对于最常见的组件使用不是必需的 - 例如向项目添加 include 目录,或者将 LDFLAGS 添加到最终链接步骤.可以通过 <code>component.mk</code> 文件本身自定义这些值.有关详细信息,请参阅<a href="#可选项目范围的组件变量">可选项目范围的组件变量</a>.</p><p>在此文件中设置变量或目标时要小心.由于这些值包含在顶级项目 makefile 中,因此它们可以影响或破坏所有组件的功能！</p><h4 id="KConfig-projbuild"><a href="#KConfig-projbuild" class="headerlink" title="KConfig.projbuild"></a>KConfig.projbuild</h4><p>这相当于 <code>Makefile.projbuild</code> 的组件配置 KConfig 文件.如果要在 menuconfig 的顶层包含配置选项,而不是在 “Component Configuration” 子菜单中,则可以在 <code>component.mk</code> 文件旁边的 KConfig.projbuild 文件中定义这些选项.</p><p>在此文件中添加配置值时要小心,因为它们将包含在整个项目配置中.在可能的情况下,通常最好为组件配置创建 KConfig 文件.</p><h4 id="Makefile-componentbuild"><a href="#Makefile-componentbuild" class="headerlink" title="Makefile.componentbuild"></a>Makefile.componentbuild</h4><p>对于组件例如,包括从其他文件生成源文件的工具,必须能够将配置,宏或变量定义添加到每个组件的组件构建过程中.这是通过在组件目录中包含 Makefile.componentbuild 来完成的.在包含组件的 component.mk 之前,此文件会包含在 component_wrapper.mk 中.与 Makefile.projbuild 类似,请注意这些文件:因为它们包含在每个组件构建中,所以只有在编译完全不同的组件时才会出现 Makefile.componentbuild 错误.</p><h4 id="仅配置组件"><a href="#仅配置组件" class="headerlink" title="仅配置组件"></a>仅配置组件</h4><p>一些不包含源文件的特殊组件,只有 <code>Kconfig.projbuild</code> 和 <code>Makefile.projbuild</code>,可以在 component.mk 文件中设置标志 <code>COMPONENT_CONFIG_ONLY</code>.如果设置了此标志,则忽略大多数其他组件变量,并且不会为组件运行构建步骤.</p><h3 id="示例组件-Makefile"><a href="#示例组件-Makefile" class="headerlink" title="示例组件 Makefile"></a>示例组件 Makefile</h3><p>因为构建环境试图设置大多数时间都能工作的合理默认值,所以 component.mk 可能非常小甚至是空的(请参阅<a href="#最小组件Makefile">最小组件 Makefile</a>).但是,某些功能通常需要覆盖组件变量.</p><p>以下是<code>component.mk</code> makefile 的一些更高级的示例:</p><h4 id="添加源文件目录"><a href="#添加源文件目录" class="headerlink" title="添加源文件目录"></a>添加源文件目录</h4><p>默认情况下,将忽略子目录.如果您的项目在子目录而不是组件的根目录中有源文件,那么您可以通过设置<code>COMPONENT_SRCDIRS</code> 告诉构建系统:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_SRCDIRS:&#x3D; src1 src2</span><br></pre></td></tr></table></figure><p>这将编译 src1/ 和 src2/ 子目录中的所有源文件.</p><h4 id="指定源文件"><a href="#指定源文件" class="headerlink" title="指定源文件"></a>指定源文件</h4><p>标准 component.mk 逻辑将源目录中的所有 .S 和 .c 文件添加为无条件编译的源.通过将 <code>COMPONENT_OBJS</code> 变量手动设置为需要生成的对象的名称,可以绕过该逻辑并对要编译的对象进行硬编码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_OBJS :&#x3D; file1.o file2.o thing&#x2F;filea.o thing&#x2F;fileb.o anotherthing&#x2F;main.o</span><br><span class="line">COMPONENT_SRCDIRS :&#x3D; . thing anotherthing</span><br></pre></td></tr></table></figure><p>请注意,还必须设置 <code>COMPONENT_SRCDIRS</code>.</p><h4 id="添加条件配置"><a href="#添加条件配置" class="headerlink" title="添加条件配置"></a>添加条件配置</h4><p>配置系统可有条件地编译某些文件,具体取决于 <code>make menuconfig</code> 中选择的选项.为此, ESP-IDF 具有 <code>compile_only_if</code> 和 <code>compile_only_if_not</code> 宏:</p><p><code>Kconfig</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config FOO_ENABLE_BAR</span><br><span class="line">    bool &quot;Enable the BAR feature.&quot;</span><br><span class="line">    help</span><br><span class="line">        This enables the BAR feature of the FOO component.</span><br></pre></td></tr></table></figure><p><code>component.mk</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(call compile_only_if,$(CONFIG_FOO_ENABLE_BAR),bar.o)</span><br></pre></td></tr></table></figure><p>从示例中可以看出,<code>compile_only_if</code> 宏将条件和目标文件列表作为参数.如果条件为真(在这种情况下:如果在 menuconfig 中启用了 BAR 功能),将始终编译目标文件(在本例中为 bar.o).相反的情况也是如此:如果条件不成立, bar.o 将永远不会被编译.<code>compile_only_if_not</code> 执行相反的操作:如果条件为false则编译,如果条件为 true 则不编译.</p><p>这也可用于选择或删除一种实现,如下所示:</p><p><code>Kconfig</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">config ENABLE_LCD_OUTPUT</span><br><span class="line">    bool &quot;Enable LCD output.&quot;</span><br><span class="line">    help</span><br><span class="line">        Select this if your board has a LCD.</span><br><span class="line"></span><br><span class="line">config ENABLE_LCD_CONSOLE</span><br><span class="line">    bool &quot;Output console text to LCD&quot;</span><br><span class="line">    depends on ENABLE_LCD_OUTPUT</span><br><span class="line">    help</span><br><span class="line">        Select this to output debugging output to the lcd</span><br><span class="line"></span><br><span class="line">config ENABLE_LCD_PLOT</span><br><span class="line">    bool &quot;Output temperature plots to LCD&quot;</span><br><span class="line">    depends on ENABLE_LCD_OUTPUT</span><br><span class="line">    help</span><br><span class="line">        Select this to output temperature plots</span><br></pre></td></tr></table></figure><p>component.mk:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># If LCD is enabled, compile interface to it, otherwise compile dummy interface</span><br><span class="line">$(call compile_only_if,$(CONFIG_ENABLE_LCD_OUTPUT),lcd-real.o lcd-spi.o)</span><br><span class="line">$(call compile_only_if_not,$(CONFIG_ENABLE_LCD_OUTPUT),lcd-dummy.o)</span><br><span class="line"></span><br><span class="line">#We need font if either console or plot is enabled</span><br><span class="line">$(call compile_only_if,$(or $(CONFIG_ENABLE_LCD_CONSOLE),$(CONFIG_ENABLE_LCD_PLOT)), font.o)</span><br></pre></td></tr></table></figure><p>请注意使用 Make ‘or’ 功能来包含字体文件.其他替换函数,如 ‘and’ 以及 ‘if’ 也适用于此处.也可以使用不来自 menuconfig 的变量: ESP-IDF 使用默认的构建配置来判断一个空的变量或只包含空格为false,而其中包含任何非空格的变量为true.</p><p>(注意:本文档的旧版本建议有条件地将目标文件名添加到 <code>COMPONENT_OBJS</code>.虽然这仍然可行,但只有当组件的所有目标文件都明确命名时才会起作用,并且不会通过 <code>make clear</code> 中的取消选择的目标文件通过.)</p><h4 id="源代码生成"><a href="#源代码生成" class="headerlink" title="源代码生成"></a>源代码生成</h4><p>某些组件将出现源文件未随组件本身提供但必须从另一个文件生成的情况.假设我们的组件有一个头文件,该文件由 BMP 文件的转换后的二进制数据组成,使用名为 bmp2h 的假设工具进行转换.然后将头文件包含在名为 graphics_lib.c 的 C 源文件中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_EXTRA_CLEAN :&#x3D; logo.h</span><br><span class="line"></span><br><span class="line">graphics_lib.o: logo.h</span><br><span class="line"></span><br><span class="line">logo.h: $(COMPONENT_PATH)&#x2F;logo.bmp</span><br><span class="line">    bmp2h -i $^ -o $@</span><br></pre></td></tr></table></figure><p>在此示例中,将在当前目录(构建目录)中生成 <code>graphics_lib.o</code> 和 <code>logo.h</code>,而 logo.bmp 随组件一起提供并位于组件路径下.因为 logo.h 是一个生成的文件,所以当调用 make clean 时需要清理它,这就是为什么它被添加到 <code>COMPONENT_EXTRA_CLEAN</code> 变量中.</p><h4 id="Cosmetic-Improvements"><a href="#Cosmetic-Improvements" class="headerlink" title="Cosmetic Improvements"></a>Cosmetic Improvements</h4><p>因为 logo.h 是一个生成的文件,所以当调用 make clean 时需要清理它,这就是为什么它被添加到 <code>COMPONENT_EXTRA_CLEAN</code> 变量中.</p><p>将 logo.h 添加到 <code>graphics_lib.o</code> 依赖项会导致在编译 <code>graphics_lib.c</code> 之前生成它.</p><p>如果另一个组件中的源文件包含 <code>logo.h</code>,则必须将此组件的名称添加到另一个组件的 <code>COMPONENT_DEPENDS</code> 列表中,以确保组件按顺序构建.</p><h4 id="嵌入二进制数据"><a href="#嵌入二进制数据" class="headerlink" title="嵌入二进制数据"></a>嵌入二进制数据</h4><p>有时您有一个文件,包含组件需要使用的二进制数据或文本数据 - 但您不希望将文件重新格式化为 C 文件.</p><p>您可以在 component.mk 中设置变量 <code>COMPONENT_EMBED_FILES</code>,以这种方式给出要嵌入的文件的名称:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_EMBED_FILES:&#x3D; server_root_cert.der</span><br></pre></td></tr></table></figure><p>或者,如果文件是字符串,则可以使用变量 <code>COMPONENT_EMBED_TXTFILES</code>.这将把文本文件的内容嵌入为以 null 结尾的字符串:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_EMBED_TXTFILES:&#x3D; server_root_cert.pem</span><br></pre></td></tr></table></figure><p>文件的内容将被添加到 flash 中的 .rodata 部分,并通过符号名称提供,如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern const uint8_t server_root_cert_pem_start [] asm(“_ binary_server_root_cert_pem_start”);</span><br><span class="line">extern const uint8_t server_root_cert_pem_end [] asm(“_ binary_server_root_cert_pem_end”);</span><br></pre></td></tr></table></figure><p>名称是根据文件的全名生成的,如 <code>COMPONENT_EMBED_FILES</code> 中所示.字符 <code>/</code>,<code>.</code>等用下划线代替.符号名称中的 <code>_binary</code> 前缀由 <code>objcopy</code> 添加,对于文本和二进制文件都是相同的.</p><p>有关使用此技术的示例,请参阅<a href="https://github.com/espressif/esp-idf/tree/be81d2c/examples/protocols/https_request" target="_blank" rel="noopener">protocols/https_request</a>-证书文件内容在编译时从文本 .pem 文件加载.</p><h3 id="完全覆盖组件-Makefile"><a href="#完全覆盖组件-Makefile" class="headerlink" title="完全覆盖组件 Makefile"></a>完全覆盖组件 Makefile</h3><p>显然,在某些情况下,所有这些不足以满足某个组件,例如,当组件基本上是另一个第三方组件的包装器时,该第三方组件最初不打算在此构建系统下编译.在这种情况下,可以通过设置 <code>COMPONENT_OWNBUILDTARGET</code> 和可能的 <code>COMPONENT_OWNCLEANTARGET</code> 并在 <code>component.mk</code> 目标中定义名为 <code>build</code> 和 <code>clean</code> 的自己的目标来完全放弃 esp-idf 构建系统.构建目标可以执行任何操作,只要它为项目生成过程创建 $(COMPONENT_LIBRARY) 以链接到应用程序二进制文件.</p><p>(实际上,即使这不是必需的-如果重写 <code>COMPONENT_ADD_LDFLAGS</code> 变量,则组件可以指示链接器链接其他二进制文件.)</p><h3 id="自定义-sdkconfig-默认值"><a href="#自定义-sdkconfig-默认值" class="headerlink" title="自定义 sdkconfig 默认值"></a>自定义 sdkconfig 默认值</h3><p>例如,您不希望指定完整 sdkconfig 配置的项目或其他项目,但您确实希望覆盖 esp-idf 默认值中的某些键值,则可以在项目目录中创建文件 <code>sdkconfig.defaults</code>.运行 <code>make defconfig</code> 或从头创建新配置时将使用此文件.</p><p>要覆盖此文件的名称,请设置 <code>SDKCONFIG_DEFAULTS</code> 环境变量.</p><h3 id="保存-flash-参数"><a href="#保存-flash-参数" class="headerlink" title="保存 flash 参数"></a>保存 flash 参数</h3><p>在某些情况下,我们希望在没有 IDF 的情况下烧写目标板.对于这种情况,我们希望保存构建的二进制文件, <code>esptool.py</code> 和 <code>esptool write_flash</code> 参数.编写脚本以保存二进制文件和 <code>esptool.py</code> 很简单.我们可以使用命令 <code>make print_flash_cmd</code>,它会打印 flash 参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader &#x2F; bootloader.bin 0x10000 example_app.bin 0x8000 partition_table_unit_test_app.bin</span><br></pre></td></tr></table></figure><p>然后使用 flash 参数作为 <code>esptool write_flash</code> 参数的 arguemnts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python esptool.py --chip esp32 --port &#x2F; dev &#x2F; ttyUSB0 --baud 921600 - before default_reset - after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader &#x2F; bootloader.bin 0x10000 example_app .bin 0x8000 partition_table_unit_test_app.bin</span><br></pre></td></tr></table></figure><h2 id="构建-Bootloader"><a href="#构建-Bootloader" class="headerlink" title="构建 Bootloader"></a>构建 Bootloader</h2><p>引导程序默认构建为 “make all” 的一部分,或者可以通过 “make bootloader-clean” 独立构建.还有 “make bootloader-list-components” 来查看引导加载程序构建中包含的组件.</p><p>IDF <code>components/bootloader</code> 中的组件是特殊的,因为第二阶段引导加载程序是主项目的单独.ELF和.BIN文件.但是,它与主项目共享其配置和构建目录.</p><p>这是通过在 <code>components/bootloader/subproject</code> 下添加子项目来完成的.这个子项目有自己的 Makefile,但它希望通过 <code>components/bootloader/Makefile.projectbuild</code> 文件中的一些粘合剂从项目自己的 Makefile 中调用.有关详细信息,请参阅这些文件</p><p><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;构建系统&quot;&gt;&lt;a href=&quot;#构建系统&quot; class=&quot;headerlink&quot; title=&quot;构建系统&quot;&gt;&lt;/a&gt;构建系统&lt;/h1&gt;&lt;p&gt;本文档解释了 Espressif 物联网开发框架构建系统和“组件”的概念.&lt;/p&gt;
&lt;p&gt;如果您想知道如何组织新的 &lt;code&gt;ESP-IDF&lt;/code&gt; 项目,请阅读本文档.&lt;/p&gt;
&lt;p&gt;我们建议使用 &lt;a href=&quot;https://github.com/espressif/esp-idf-template&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;esp-idf-template&lt;/a&gt; 项目作为项目的起点.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（五）严重错误</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%A5%E9%87%8D%E9%94%99%E8%AF%AF/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%A5%E9%87%8D%E9%94%99%E8%AF%AF/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:28:59.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在某些情况下,程序的执行,没有按照定义的方式持续执行.在 ESP-IDF 中,这些情况包括:</p><ul><li>CPU 异常:Illegal Instruction, Load/Store Alignment Error, Load/Store Prohibited error, Double Exception.(非法指令,加载/存储对齐错误,加载/存储禁止错误,双重异常)</li><li>系统级别检查和安全措施:<ul><li>Interrupt watchdog timeout 中断看门狗超时</li><li>Task watchdog timeout  任务监视程序超时(如果设置了 <code>CONFIG_TASK_WDT_PANIC</code>,则仅 fatal)</li><li>Cache access error 缓存访问错误</li><li>Brownout detection event 掉电检测事件</li><li>Stack overflow 堆栈溢出</li><li>Stack smashing protection check 堆栈粉碎保护检查</li><li>Heap integrity check 堆完整性检查</li></ul></li><li>Failed assertions 断言失败,通过 <code>assert</code> ,<code>configASSERT</code> 和类似的宏.</li></ul><p>本指南介绍了 ESP-IDF 中用于处理这些错误的过程,并提供了有关错误故障排除的建议.</p><h2 id="Panic-处理"><a href="#Panic-处理" class="headerlink" title="Panic 处理"></a>Panic 处理</h2><p>概述中列出的每个错误原因都将由 Panic 处理程序处理.</p><p>Panic 处理程序将首先将错误原因打印到控制台. 对于 CPU 异常,消息类似于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Guru Meditation Error: Core 0 panic&#39;ed (IllegalInstruction). Exception was unhandled.</span><br></pre></td></tr></table></figure><p>对于某些系统级别检查(中断监视程序,缓存访问错误),该消息将类似于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Guru Meditation Error: Core 0 panic&#39;ed (Cache disabled but cached memory region accessed)</span><br></pre></td></tr></table></figure><p>在所有情况下,错误原因将打印在括号中. 有关可能的错误原因列表,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html#guru-meditation-errors" target="_blank" rel="noopener">Guru Meditation Errors</a>.</p><p>可以使用 <code>CONFIG_ESP32_PANIC</code> 配置选项设置 Panic 处理程序的后续行为. 可用选项包括:</p><ul><li><p>打印寄存器并重新启动(<code>CONFIG_ESP32_PANIC_PRINT_REBOOT</code>) - 默认选项.<br> 这将在异常点打印寄存器值,打印回溯,然后重新启动芯片.</p></li><li><p>打印寄存器并暂停(<code>CONFIG_ESP32_PANIC_PRINT_HALT</code>)<br> 与上述选项类似,但暂停而不是重新启动. 重启程序需要外部重置.</p></li><li><p>无提示重启(<code>CONFIG_ESP32_PANIC_SILENT_REBOOT</code>)<br> 不要打印寄存器或回溯,立即重启芯片.</p></li><li><p>调用 GDB 存根(<code>CONFIG_ESP32_PANIC_GDBSTUB</code>)<br>  启动 GDB 服务器,它可以通过控制台 UART 端口与 GDB 通信. 有关详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html#gdb-stub" target="_blank" rel="noopener">GDB 存根</a>.</p></li></ul><p>Panic 处理程序的行为受另外两个配置选项的影响.</p><ul><li>如果启用了 <code>CONFIG_ESP32_DEBUG_OCDAWARE</code> (这是默认设置),则 Panic 处理程序将检测 JTAG 调试器是否已连接. 如果是,则执行将暂停,控制权将传递给调试器. 在这种情况下,寄存器和回溯不会转储到控制台,并且不使用 GDBStub/Core Dump 功能.</li><li>如果启用了核心转储功能(<code>CONFIG_ESP32_ENABLE_COREDUMP_TO_FLASH</code> 或 <code>CONFIG_ESP32_ENABLE_COREDUMP_TO_UART</code> 选项),则系统状态(任务堆栈和寄存器)将被转储到 Flash 或 UART,以供以后分析.</li></ul><p>下图说明了 Panic 处理程序的行为:</p><p><img src="https://img-blog.csdn.net/20180901140838695?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Panic 处理程序流程图"></p><h2 id="寄存器转储和回溯"><a href="#寄存器转储和回溯" class="headerlink" title="寄存器转储和回溯"></a>寄存器转储和回溯</h2><p>除非启用了 <code>CONFIG_ESP32_PANIC_SILENT_REBOOT</code> 选项,否则 Panic 处理程序会将一些 CPU 寄存器和回溯打印到控制台:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Core 0 register dump:</span><br><span class="line">PC      : 0x400e14ed  PS      : 0x00060030  A0      : 0x800d0805  A1      : 0x3ffb5030</span><br><span class="line">A2      : 0x00000000  A3      : 0x00000001  A4      : 0x00000001  A5      : 0x3ffb50dc</span><br><span class="line">A6      : 0x00000000  A7      : 0x00000001  A8      : 0x00000000  A9      : 0x3ffb5000</span><br><span class="line">A10     : 0x00000000  A11     : 0x3ffb2bac  A12     : 0x40082d1c  A13     : 0x06ff1ff8</span><br><span class="line">A14     : 0x3ffb7078  A15     : 0x00000000  SAR     : 0x00000014  EXCCAUSE: 0x0000001d</span><br><span class="line">EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0xffffffff</span><br><span class="line"></span><br><span class="line">Backtrace: 0x400e14ed:0x3ffb5030 0x400d0802:0x3ffb5050</span><br></pre></td></tr></table></figure><p>打印的寄存器值是异常帧中的寄存器值,即 CPU 异常或其他严重错误发生时的值.</p><p>如果由于 <code>abort()</code> 调用而执行了 Panic 处理程序,则不会打印寄存器转储.</p><p>在某些情况下,例如中断看门狗超时, Panic 处理程序可能会打印额外的 CPU 寄存器 (EPC1-EPC4) 以及在另一个 CPU 上运行的代码的寄存器/回溯.</p><p>Backtrace 行包含 PC:SP 对,其中 PC 是程序计数器,SP 是堆栈指针,用于当前任务的每个堆栈帧. 如果在 ISR 内发生严重错误,则回溯可能包括来自被中断的任务和来自 ISR 的 PC:SP 对.</p><p>如果使用 IDF Monitor,程序计数器值将转换为代码位置(函数名称,文件名和行号),输出将与其他行进行注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Core 0 register dump:</span><br><span class="line">PC      : 0x400e14ed  PS      : 0x00060030  A0      : 0x800d0805  A1      : 0x3ffb5030</span><br><span class="line">0x400e14ed: app_main at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.cpp:36</span><br><span class="line"></span><br><span class="line">A2      : 0x00000000  A3      : 0x00000001  A4      : 0x00000001  A5      : 0x3ffb50dc</span><br><span class="line">A6      : 0x00000000  A7      : 0x00000001  A8      : 0x00000000  A9      : 0x3ffb5000</span><br><span class="line">A10     : 0x00000000  A11     : 0x3ffb2bac  A12     : 0x40082d1c  A13     : 0x06ff1ff8</span><br><span class="line">0x40082d1c: _calloc_r at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;esp-idf&#x2F;components&#x2F;newlib&#x2F;syscalls.c:51</span><br><span class="line"></span><br><span class="line">A14     : 0x3ffb7078  A15     : 0x00000000  SAR     : 0x00000014  EXCCAUSE: 0x0000001d</span><br><span class="line">EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0xffffffff</span><br><span class="line"></span><br><span class="line">Backtrace: 0x400e14ed:0x3ffb5030 0x400d0802:0x3ffb5050</span><br><span class="line">0x400e14ed: app_main at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.cpp:36</span><br><span class="line"></span><br><span class="line">0x400d0802: main_task at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;esp-idf&#x2F;components&#x2F;esp32&#x2F;cpu_start.c:470</span><br></pre></td></tr></table></figure><p>要查找发生严重错误的位置,请查看“Backtrace”的下一行. 严重错误位置是顶行,后续行显示调用堆栈.</p><h2 id="GDB-存根"><a href="#GDB-存根" class="headerlink" title="GDB 存根"></a>GDB 存根</h2><p>如果启用了 <code>CONFIG_ESP32_PANIC_GDBSTUB</code> 选项,则发生严重错误时, Panic 处理程序不会重置芯片. 相反,它将启动 GDB 远程协议服务器,通常称为 GDB Stub. 发生这种情况时,可以指示主机上运行的 GDB 实例连接到 ESP32 UART 端口.</p><p>如果使用 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/idf-monitor.html" target="_blank" rel="noopener">IDF Monitor</a>,则在 UART 上检测到 GDB Stub 提示时会自动启动 GDB. 输出看起来像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Entering gdb stub now.</span><br><span class="line">$T0b#e6GNU gdb (crosstool-NG crosstool-ng-1.22.0-80-gff1f415) 7.10</span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;--host&#x3D;x86_64-build_apple-darwin16.3.0 --target&#x3D;xtensa-esp32-elf&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;bugs&#x2F;&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;documentation&#x2F;&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;build&#x2F;example.elf...done.</span><br><span class="line">Remote debugging using &#x2F;dev&#x2F;cu.usbserial-31301</span><br><span class="line">0x400e1b41 in app_main ()</span><br><span class="line">    at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.cpp:36</span><br><span class="line">36      *((int*) 0) &#x3D; 0;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>GDB 提示可用于检查 CPU 寄存器,本地和静态变量以及内存中的任意位置. 无法设置断点,更改 PC 或继续执行. 要重置程序,请退出 GDB 并执行外部重置:IDF Monitor 中的 <code>Ctrl-T Ctrl-R</code>,或使用开发板上的外部重置按钮.</p><h2 id="Guru-Meditation-错误"><a href="#Guru-Meditation-错误" class="headerlink" title="Guru Meditation 错误"></a>Guru Meditation 错误</h2><p>本节解释了不同错误原因的含义,打印在 <code>Guru Meditation Error:Core panic&#39;ed message</code> 之后的括号中.</p><blockquote><p>有关“Guru Meditation”的历史渊源,请参阅 <a href="https://en.wikipedia.org/wiki/Guru_Meditation" target="_blank" rel="noopener">Wikipedia 文章</a>.</p></blockquote><h3 id="IllegalInstruction-非法指令"><a href="#IllegalInstruction-非法指令" class="headerlink" title="IllegalInstruction (非法指令)"></a>IllegalInstruction (非法指令)</h3><p>该 CPU 异常表示执行的指令不是有效指令. 此错误的最常见原因有:</p><ul><li>FreeRTOS 任务功能已经返回. 在 FreeRTOS 中,如果任务函数需要终止,它应该调用 vTaskDelete() 函数并删除它自己,而不是返回.</li><li>无法从 SPI Flash 加载下一条指令. 这种情况通常发生在:<ul><li>应用程序已将 SPI Flash 引脚重新配置为其他功能(GPIO,UART 等). 有关 SPI Flash 引脚的详细信息,请参阅硬件设计指南和芯片或模块的数据表.</li><li>某些外部设备意外连接到 SPI Flash 引脚,干扰了 ESP32 和 SPI Flash 之间的通信.</li></ul></li></ul><h3 id="InstrFetchProhibited-禁止指令加载"><a href="#InstrFetchProhibited-禁止指令加载" class="headerlink" title="InstrFetchProhibited (禁止指令加载)"></a>InstrFetchProhibited (禁止指令加载)</h3><p>此 CPU 异常表示 CPU 无法加载指令,因为指令的地址不属于指令 RAM 或 ROM 中的有效区域.</p><p>通常这意味着尝试调用函数指针,该指针不指向有效代码. PC (程序计数器)寄存器可用作指示器:它将为零或将包含垃圾值(不是 0x4xxxxxxx).</p><h3 id="LoadProhibited-StoreProhibited-禁止加载，禁止存储"><a href="#LoadProhibited-StoreProhibited-禁止加载，禁止存储" class="headerlink" title="LoadProhibited,StoreProhibited(禁止加载，禁止存储)"></a>LoadProhibited,StoreProhibited(禁止加载，禁止存储)</h3><p>当应用程序尝试读取或写入无效的内存位置时,会发生此 CPU 异常. 写入/读取的地址可在寄存器转储中的 <code>EXCVADDR</code> 寄存器中找到. 如果此地址为零,则通常表示应用程序尝试取消引用 NULL 指针. 如果此地址接近于零,则通常意味着应用程序尝试访问结构的成员,但指向该结构的指针为 NULL. 如果该地址是别的(垃圾值,不在 <code>0x3fxxxxxx</code> - <code>0x6xxxxxxx</code> 范围内),则可能意味着用于访问数据的指针未初始化或已损坏.</p><h3 id="IntegerDivideByZero-除以-0"><a href="#IntegerDivideByZero-除以-0" class="headerlink" title="IntegerDivideByZero(除以 0)"></a>IntegerDivideByZero(除以 0)</h3><p>应用程序尝试将整数除以零.</p><h3 id="LoadStoreAlignment-对齐方式不对"><a href="#LoadStoreAlignment-对齐方式不对" class="headerlink" title="LoadStoreAlignment(对齐方式不对)"></a>LoadStoreAlignment(对齐方式不对)</h3><p>应用程序尝试读取或写入内存位置,并且地址对齐与加载/存储大小不匹配. 例如,32 位加载只能从 4 字节对齐的地址完成,而 16 位加载只能从 2 字节的对齐地址完成.</p><h3 id="LoadStoreError-加载-存储错误"><a href="#LoadStoreError-加载-存储错误" class="headerlink" title="LoadStoreError(加载/存储错误)"></a>LoadStoreError(加载/存储错误)</h3><p>应用程序尝试从仅支持 32 位加载/存储的内存区域进行 8 位或 16 位加载/存储. 例如,取消引用指向内存存储器的 <code>char *</code> 指针将导致这样的错误.</p><h3 id="Unhandled-debug-exception-堆栈错误"><a href="#Unhandled-debug-exception-堆栈错误" class="headerlink" title="Unhandled debug exception(堆栈错误)"></a>Unhandled debug exception(堆栈错误)</h3><p>通常会出现以下消息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug exception reason: Stack canary watchpoint triggered (task_name)</span><br></pre></td></tr></table></figure><p>此错误表示应用程序已写入 <code>task_name</code> 任务堆栈的末尾. 请注意,并非每个堆栈溢出都可以保证触发此错误. 任务可能会在堆栈 <code>canary</code> 位置之外写入堆栈,在这种情况下,不会触发观察点.</p><h3 id="Interrupt-wdt-timeout-on-CPU0-CPU1-看门狗超时"><a href="#Interrupt-wdt-timeout-on-CPU0-CPU1-看门狗超时" class="headerlink" title="Interrupt wdt timeout on CPU0 / CPU1(看门狗超时)"></a>Interrupt wdt timeout on CPU0 / CPU1(看门狗超时)</h3><p>表示发生了中断看门狗超时. 有关详细信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/wdts.html" target="_blank" rel="noopener">看门狗</a>.</p><h3 id="Cache-disabled-but-cached-memory-region-accessed-Cache-禁止"><a href="#Cache-disabled-but-cached-memory-region-accessed-Cache-禁止" class="headerlink" title="Cache disabled but cached memory region accessed(Cache 禁止)"></a>Cache disabled but cached memory region accessed(Cache 禁止)</h3><p>在某些情况下,ESP-IDF 将暂时禁止通过高速缓存访问外部 SPI Flash 和 SPI RAM. 例如,spi_flash API 用于读取/写入/擦除/mmap SPI Flash 区域. 在这些情况下,任务被挂起,并且未注册 <code>ESP_INTR_FLAG_IRAM</code> 的中断处理程序被禁用. 确保使用此标志注册的任何中断处理程序都具有 IRAM/DRAM 中的所有代码和数据. 有关更多详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/spi_flash.html#iram-safe-interrupt-handlers" target="_blank" rel="noopener">SPI Flash API 文档</a>.</p><h2 id="其他严重错误"><a href="#其他严重错误" class="headerlink" title="其他严重错误"></a>其他严重错误</h2><h3 id="Brownout-欠压"><a href="#Brownout-欠压" class="headerlink" title="Brownout(欠压)"></a>Brownout(欠压)</h3><p>ESP32 有一个内置的掉电检测器,默认启用. 如果电源电压低于安全水平,掉电检测器可以触发系统复位. 可以使用 <code>CONFIG_BROWNOUT_DET</code> 和 <code>CONFIG_BROWNOUT_DET_LVL_SEL</code> 选项配置掉电检测器. 当掉电检测器触发时,将打印以下消息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Brownout detector was triggered</span><br></pre></td></tr></table></figure><p>打印消息后,芯片将复位.</p><p>请注意,如果电源电压快速下降,则控制台上只能看到部分消息.</p><h3 id="Corrupt-Heap"><a href="#Corrupt-Heap" class="headerlink" title="Corrupt Heap"></a>Corrupt Heap</h3><p>ESP-IDF 堆实现包含许多堆结构的运行时检查. 可以在 menuconfig 中启用其他检查(“Heap Stisoning”). 如果其中一项检查失败,将打印类似于以下内容的消息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CORRUPT HEAP: Bad tail at 0x3ffe270a. Expected 0xbaad5678 got 0xbaac5678</span><br><span class="line">assertion &quot;head !&#x3D; NULL&quot; failed: file &quot;&#x2F;Users&#x2F;user&#x2F;esp&#x2F;esp-idf&#x2F;components&#x2F;heap&#x2F;multi_heap_poisoning.c&quot;, line 201, function: multi_heap_free</span><br><span class="line">abort() was called at PC 0x400dca43 on core 0</span><br></pre></td></tr></table></figure><p>有关详细信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/heap_debug.html" target="_blank" rel="noopener">堆内存调试文档</a>.</p><h3 id="Stack-Smashing"><a href="#Stack-Smashing" class="headerlink" title="Stack Smashing"></a>Stack Smashing</h3><p>可以使用 <code>CONFIG_STACK_CHECK_MODE</code> 选项在 ESP-IDF 中启用 Stack Smashing 保护(基于 GCC  <code>-fstack-protector *</code> 标志). 如果检测到 Stack Smashing,将打印类似于以下内容的消息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack smashing protect failure!</span><br><span class="line"></span><br><span class="line">abort() was called at PC 0x400d2138 on core 0</span><br><span class="line"></span><br><span class="line">Backtrace: 0x4008e6c0:0x3ffc1780 0x4008e8b7:0x3ffc17a0 0x400d2138:0x3ffc17c0 0x400e79d5:0x3ffc17e0 0x400e79a7:0x3ffc1840 0x400e79df:0x3ffc18a0 0x400e2235:0x3ffc18c0 0x400e1916:0x3ffc18f0 0x400e19cd:0x3ffc1910 0x400e1a11:0x3ffc1930 0x400e1bb2:0x3ffc1950 0x400d2c44:0x3ffc1a80</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>回溯应该指向 Stack Smashing 发生的函数. 检查功能代码以获得对本地阵列的无限制访问.</p><p><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;严重错误&quot;&gt;&lt;a href=&quot;#严重错误&quot; class=&quot;headerlink&quot; title=&quot;严重错误&quot;&gt;&lt;/a&gt;严重错误&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h
      
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（八）Flash 加密</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%AB%EF%BC%89Flash%20%E5%8A%A0%E5%AF%86/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%AB%EF%BC%89Flash%20%E5%8A%A0%E5%AF%86/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:28:59.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flash-加密"><a href="#Flash-加密" class="headerlink" title="Flash 加密"></a>Flash 加密</h1><p>Flash 加密功能用于加密 ESP32 连接的 SPI  Flash 的内容。启用 Flash 加密后，通过物理方式读取 SPI Flash 的内容不足以恢复大多数 Flash 内容。</p><p>Flash 加密与安全启动功能是分离的，您可以使用 Flash 加密而无需启用<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html" target="_blank" rel="noopener">安全启动</a>。但是，我们建议将这两种功能一起用于安全的环境。在没有安全启动的情况下，需要执行其他配置以确保 Flash 加密的有效性。有关更多详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-without-secure-boot" target="_blank" rel="noopener">使用无安全启动的 Flash 加密</a>.</p><blockquote><p>启用闪存加密会限制您进一步更新 ESP32 的选项。请务必阅读本文档(包括 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-limitations" target="_blank" rel="noopener">Flash 加密限制</a>)并了解启用闪存加密的含义。</p></blockquote><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><ul><li><p>使用带有 256 位密钥的 AES 加密闪存的内容。闪存加密密钥存储在芯片内部的 efuse 中，并且(默认情况下)受软件访问保护。</p></li><li><p>通过 ESP32 的闪存缓存映射功能，Flash 访问是透明的 - 映射到地址空间的任何闪存区域在读取时都将被透明地解密。</p></li><li><p>通过使用明文数据烧录 ESP32 来应用加密，并且(如果启用了加密)引导加载程序会在首次启动时对数据进行加密。</p></li><li><p>并非所有闪存都是加密的。以下类型的闪存数据已加密:</p><ul><li><p>引导程序</p></li><li><p>安全启动引导加载程序摘要(如果启用了安全启动)</p></li><li><p>分区表</p></li><li><p>所有 “app” 类型分区</p></li><li><p>分区表中标有 “encrypted” 标志的任何分区</p><p> 可能希望一些数据分区保持未加密以便于访问，或者使用对于数据被加密时无效的闪存友好更新算法。由于 NVS 库与闪存加密不直接兼容，因此无法加密用于非易失性存储的 NVS 分区。有关更多详细信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html#nvs-encryption" target="_blank" rel="noopener">NVS 加密</a>。</p></li></ul></li><li><p>闪存加密密钥存储在 ESP32 芯片内部的 efuse 密钥块 1 中。默认情况下，此密钥具有读写保护功能，因此软件无法访问或更改密钥。</p></li><li><p>默认情况下，Efuse Block 1 编码方案为 “None”，并且在该块中存储 256 位密钥。在某些 ESP32 上，编码方案设置为 3/4 编码 (CODING_SCHEME efuse 的值为 1)，并且必须在该块中存储 192 位密钥。有关详细信息，请参见 《ESP32 技术参考手册》第 20.3.1.3 节 “系统参数 coding_scheme”。在所有情况下，算法都在 256 位密钥上运行，通过重复一些位（<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-algorithm" target="_blank" rel="noopener">具体细节</a>）来扩展  192 位密钥。当 <code>esptool.py</code> 连接到芯片或 <code>espefuse.py summary</code> 输出时，编码方案显示在 Features 行中。</p></li><li><p>闪存加密算法是 AES-256，其中密钥是“调整”的，每个 32 字节闪存块的偏移地址。这意味着每个 32 字节块(两个连续的 16 字节 AES 块)使用从闪存加密密钥派生的唯一密钥进行加密。</p></li><li><p>虽然芯片上运行的软件可以透明地解密闪存内容，但默认情况下，当启用闪存加密时，UART 引导加载程序无法解密(或加密)数据。</p></li><li><p>如果可以启用闪存加密，则编写<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#using-encrypted-flash" target="_blank" rel="noopener">使用加密闪存</a>的代码时，编程人员必须采取一定的预防措施。</p></li></ul><h2 id="2-Flash-加密初始化"><a href="#2-Flash-加密初始化" class="headerlink" title="2 Flash 加密初始化"></a>2 Flash 加密初始化</h2><p>这是默认(推荐) Flash 加密初始化过程。可以为开发或其他目的自定义此过程，有关详细信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-advanced-features" target="_blank" rel="noopener">Flash 加密高级功能</a>。</p><blockquote><p>在首次启动时启用闪存加密后，硬件通过串行重新闪存最多允许3次后续闪存烧录。必须遵循特殊过程(在<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#updating-encrypted-flash-serial" target="_blank" rel="noopener">串口烧录</a>中记录)才能执行这些更新。</p></blockquote><ul><li>如果启用了安全启动，则使用纯文本数据进行物理重新刷新需要“可重新映射”的安全启动摘要(请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-and-secure-boot" target="_blank" rel="noopener">Flash 加密和安全启动</a>)。</li><li>OTA 更新可用于更新 Flash 内容，而不计入此限制。</li><li>在开发中启用闪存加密时，请使用预生成的闪存加密密钥，以允许使用预加密数据进行无限次重新闪存。</li></ul><p>启用闪存加密的过程:</p><ul><li>必须在启用闪存加密支持的情况下编译引导加载程序。在 <code>make menuconfig</code> 中，导航到“安全功能”，然后选择“是”以“启动时启用闪存加密”。</li><li>如果同时启用安全启动，最好同时选择这些选项。首先阅读<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html" target="_blank" rel="noopener">安全启动</a>文档。</li><li>正常构建并刷新引导加载程序，分区表和工厂应用程序映像。这些分区最初写入未加密的闪存。</li></ul><blockquote><p>启用安全启动和闪存加密时，引导加载程序应用程序二进制 <code>bootloader.bin</code> 可能会变得太大。请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html#secure-boot-bootloader-size" target="_blank" rel="noopener">Bootloader 大小</a>。</p></blockquote><ul><li>首次启动时，引导加载程序会看到 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 设置为 0 (出厂默认值)，因此它使用硬件随机数生成器生成闪存加密密钥。该密钥存储在efuse中。密钥是读写保护，以防止进一步的软件访问。</li><li>然后，引导加载程序就地对所有加密分区进行加密。就地加密可能需要一些时间(对于大型分区，最多需要一分钟.)</li></ul><blockquote><p>第一次启动加密通道运行时，请勿中断ESP32的电源。如果电源中断，闪存内容将被破坏，并且需要再次使用未加密的数据烧录。像这样的重新烧录不会计入烧录限制。</p></blockquote><ul><li>烧录完成后。在 UART 引导加载程序运行时，激活(默认情况下)以禁用加密的闪存访问。有关高级详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#uart-bootloader-encryption" target="_blank" rel="noopener">启用 UART Bootloader 加密/解密</a>。</li><li><code>FLASH_CRYPT_CONFIG efuse</code> 也会被烧制到最大值(0xF)，以最大化闪存算法中调整的关键位数。有关高级详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#setting-flash-crypt-config" target="_blank" rel="noopener">设置 FLASH_CRYPT_CONFIG</a>。</li><li>最后，<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 以初始值 1 进行刻录。这个 efuse 激活透明闪存加密层，并限制后续重新刷新的次数。有关 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 的详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#updating-encrypted-flash" target="_blank" rel="noopener">更新加密的 Flash</a> 部分。</li><li>引导加载程序重置自身以重新加密的闪存重新引导。</li></ul><h2 id="3-使用加密的-Flash"><a href="#3-使用加密的-Flash" class="headerlink" title="3 使用加密的 Flash"></a>3 使用加密的 Flash</h2><p>ESP32 应用程序代码可以通过调用 <code>esp_flash_encryption_enabled()</code> 来检查当前是否启用了闪存加密。</p><p>启用闪存加密后，从代码访问闪存内容时需要注意一些事项。</p><h3 id="3-1-Flash-加密的范围"><a href="#3-1-Flash-加密的范围" class="headerlink" title="3.1 Flash 加密的范围"></a>3.1 Flash 加密的范围</h3><p>只要将 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 设置为设置了奇数位的值，就会透明地解密通过 MMU 的闪存缓存访问的所有闪存内容。这包括:</p><ul><li>Flash 中的可执行应用程序代码 (IROM)。</li><li>存储在闪存 (DROM) 中的所有只读数据。</li><li>通过 <code>esp_spi_flash_mmap()</code> 访问的任何数据。</li><li>ROM 引导加载程序读取软件引导加载程序映像。</li></ul><blockquote><p>MMU Flash 缓存无条件地解密所有数据。在闪存中未加密存储的数据将通过闪存缓存“透明地解密”，并且看起来像随机垃圾这样的软件。</p></blockquote><h3 id="3-2-读取加密的-Flash"><a href="#3-2-读取加密的-Flash" class="headerlink" title="3.2 读取加密的 Flash"></a>3.2 读取加密的 Flash</h3><p>要在不使用闪存缓存 MMU 映射的情况下读取数据，我们建议使用分区读取函数 <code>esp_partition_read()</code>。使用此功能时，只有从加密分区读取数据时才会解密数据。其他分区将以未加密方式读取。通过这种方式，软件可以以相同的方式访问加密和非加密的闪存。</p><p>通过其他 SPI 读取 APIs 读取的数据不会被解密:</p><ul><li>通过 <code>esp_spi_flash_read()</code> 读取的数据不会被解密</li><li>通过 ROM 函数 <code>SPIRead()</code> 读取的数据不会被解密 (esp-idf 应用程序不支持此功能)</li><li>使用非易失性存储 (NVS) API 存储的数据始终存储并读取解密。</li></ul><h3 id="3-3-写加密的-Flash"><a href="#3-3-写加密的-Flash" class="headerlink" title="3.3 写加密的 Flash"></a>3.3 写加密的 Flash</h3><p>在可能的情况下，我们建议使用分区写入函数 <code>esp_partition_write</code>。使用此功能时，只有在写入加密分区时才会加密数据。数据将被写入未加密的其他分区。通过这种方式，软件可以以相同的方式访问加密和非加密的闪存.</p><p>当 <code>write_encrypted</code> 参数设置为 true 时，<code>esp_spi_flash_write</code> 函数将写入数据。否则，数据将以未加密的方式写入.</p><p>ROM 函数 <code>esp_rom_spiflash_write_encrypted</code> 将加密数据写入闪存，ROM 函数 <code>SPIWrite</code> 将未加密写入闪存。(esp-idf 应用程序不支持这些功能).</p><p>未加密数据的最小写入大小为 4 个字节(对齐为 4 个字节)。由于数据是以块为单位加密的，因此加密数据的最小写入大小为 16 字节(对齐为16字节).</p><h2 id="4-更像加密的-Flash"><a href="#4-更像加密的-Flash" class="headerlink" title="4 更像加密的 Flash"></a>4 更像加密的 Flash</h2><h3 id="4-1-OTA-更新"><a href="#4-1-OTA-更新" class="headerlink" title="4.1 OTA 更新"></a>4.1 OTA 更新</h3><p>只要使用 <code>esp_partition_write</code> 函数，对加密分区的 OTA 更新将自动加密写入.</p><h3 id="4-2-串口烧录"><a href="#4-2-串口烧录" class="headerlink" title="4.2 串口烧录"></a>4.2 串口烧录</h3><p><code>FLASH_CRYPT_CNT efuse</code> 允许通过串口烧录(或其他物理方法)使用新的明文数据更新闪存，最多 3 次.</p><p>该过程涉及烧录明文数据，然后碰撞 <code>FLASH_CRYPT_CNT efuse</code> 的值，这会导致引导加载程序重新加密此数据.</p><h4 id="4-2-1-限制更新"><a href="#4-2-1-限制更新" class="headerlink" title="4.2.1 限制更新"></a>4.2.1 限制更新</h4><p>这种类型只有 4 个明文串行更新周期，包括初始加密闪存.</p><p>禁用第四次加密后，<code>FLASH_CRYPT_CNT efuse</code> 的最大值为 0xFF，永久禁用加密.</p><p>通过预生成的 Flash 加密密钥使用 OTA 更新或重新刷新可以超过此限制.</p><h4 id="4-2-2-串口烧录的注意事项"><a href="#4-2-2-串口烧录的注意事项" class="headerlink" title="4.2.2 串口烧录的注意事项"></a>4.2.2 串口烧录的注意事项</h4><ul><li>通过串口重新烧录时，重新刷新最初用明文数据写入的每个分区(包括 bootloader)。可以跳过不是“当前选择的” OTA 分区的应用程序分区(除非在那里找到明文应用程序映像，否则不会重新加密这些分区.)但是，标有“加密”标志的任何分区都将无条件地重新分区。加密，意味着任何已加密的数据将被加密两次并被破坏.<ul><li>使用 <code>make flash</code> 应烧录所有需要闪存的分区.</li></ul></li><li>如果启用了安全启动，则除非您使用“可重新启动”选项进行安全启动，否则无法通过串口重新刷新纯文本数据。请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-and-secure-boot" target="_blank" rel="noopener">Flash加密和安全启动</a>.</li></ul><h3 id="4-3-串口重新烧录程序"><a href="#4-3-串口重新烧录程序" class="headerlink" title="4.3 串口重新烧录程序"></a>4.3 串口重新烧录程序</h3><ul><li>正常的构建应用程序.</li><li>正常的使用明文数据刷新设备 (make flash 或 esptool.py 命令.)闪存所有先前加密的分区，包括引导加载程序(参见上一节).</li><li>此时，设备将无法启动(消息为 flash read err，1000)，因为它希望看到加密的引导加载程序，但引导加载程序是纯文本.</li><li>通过运行命令 <code>espefuse.py burn_efuse FLASH_CRYPT_CNT</code> 来刻录 <code>FLASH_CRYPT_CNT efuse</code>。 <code>espefuse.py</code> 会自动将位数递增 1，从而禁用加密.</li><li>重置设备，它将重新加密明文分区，然后再次刻录 <code>FLASH_CRYPT_CNT efuse</code> 以重新启用加密.</li></ul><h4 id="4-3-1-禁用串口更新"><a href="#4-3-1-禁用串口更新" class="headerlink" title="4.3.1 禁用串口更新"></a>4.3.1 禁用串口更新</h4><p>要防止通过串口进行进一步的明文更新，请在启用闪存加密后(即首次启动完成后)使用 <code>espefuse.py</code> 写保护 <code>FLASH_CRYPT_CNT efuse</code> :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espefuse.py --port PORT write_protect_efuse FLASH_CRYPT_CNT</span><br></pre></td></tr></table></figure><p>这可以防止进一步修改以禁用或重新启用闪存加密.</p><h3 id="4-4-通过预生成的-Flash-加密密钥重新烧录"><a href="#4-4-通过预生成的-Flash-加密密钥重新烧录" class="headerlink" title="4.4 通过预生成的 Flash 加密密钥重新烧录"></a>4.4 通过预生成的 Flash 加密密钥重新烧录</h3><p>可以在主机上预生成闪存加密密钥，并将其刻录到 ESP32 的 efuse 密钥块中。这允许数据在主机上预加密并烧录到 ESP32，而无需明文闪存更新.</p><p>这对于开发很有用，因为它消除了 4 次刷新限制。它还允许在启用安全启动的情况下重新刷新应用程序，因为每次都不需要重新启动引导加载程序.</p><blockquote><p>此方法仅用于协助开发，而不用于生产设备。如果为生产预生成闪存加密，请确保密钥是从高质量的随机数源生成的，并且不要跨多个设备共享相同的闪存加密密钥.</p></blockquote><h4 id="4-4-1-预生成-Flash-加密密钥"><a href="#4-4-1-预生成-Flash-加密密钥" class="headerlink" title="4.4.1 预生成 Flash 加密密钥"></a>4.4.1 预生成 Flash 加密密钥</h4><p>Flash 加密密钥是 32 字节的随机数据。您可以使用 <code>espsecure.py</code> 生成随机密钥:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure><p>(这些数据的随机性仅与操作系统一样好，而且是Python安装的随机数据源.)</p><p>或者，如果您使用安全启动并具有安全启动签名密钥，则可以生成安全启动专用签名密钥的确定性SHA-256摘要，并将其用作闪存加密密钥:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espsecure.py digest_private_key --keyfile secure_boot_signing_key.pem my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure><p>(如果为安全启动启用可重新映射模式，则使用相同的 32 个字节作为安全启动摘要键.)</p><p>以这种方式从安全启动签名密钥生成闪存加密密钥意味着您只需要存储一个密钥文件。然而，该方法根本不适用于生产设备.</p><h4 id="4-4-2-刻录-Flash-加密密钥"><a href="#4-4-2-刻录-Flash-加密密钥" class="headerlink" title="4.4.2 刻录 Flash 加密密钥"></a>4.4.2 刻录 Flash 加密密钥</h4><p>生成闪存加密密钥后，需要将其刻录到 ESP32 的 efuse 密钥块。这必须在首次加密启动之前完成，否则 ESP32 将生成软件无法访问或修改的随机密钥.</p><p>要将密钥刻录到设备(仅限一次):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espefuse.py --port PORT burn_key flash_encryption my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure><h4 id="4-4-3-带有预生成密钥的第一次烧录"><a href="#4-4-3-带有预生成密钥的第一次烧录" class="headerlink" title="4.4.3 带有预生成密钥的第一次烧录"></a>4.4.3 带有预生成密钥的第一次烧录</h4><p>烧录密钥后，按照与默认 Flash 加密初始化相同的步骤操作，并为第一次启动时刷新纯文本图像。引导加载程序将使用预先烧制的密钥启用闪存加密并加密所有分区.</p><h4 id="4-4-4-使用预生成密钥重新烧录"><a href="#4-4-4-使用预生成密钥重新烧录" class="headerlink" title="4.4.4 使用预生成密钥重新烧录"></a>4.4.4 使用预生成密钥重新烧录</h4><p>在首次启动时启用加密后，重新烧录加密镜像需要额外的手动步骤。这是我们预先加密我们希望在闪存中更新的数据的地方.</p><p>假设这是用于刷新明文数据的常规命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --port &#x2F;dev&#x2F;ttyUSB0 --baud 115200 write_flash 0x10000 build&#x2F;my-app.bin</span><br></pre></td></tr></table></figure><p>二进制应用程序映像 build/my-app.bin 写入偏移量 0x10000。此文件名和偏移量需要用于加密数据，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espsecure.py encrypt_flash_data --keyfile my_flash_encryption_key.bin --address 0x10000 -o build&#x2F;my-app-encrypted.bin build&#x2F;my-app.bin</span><br></pre></td></tr></table></figure><p>此示例命令将使用提供的密钥加密 my-app.bin，并生成加密文件 my-app-encrypted.bin。确保 address 参数与计划闪存二进制文件的地址匹配.</p><p>然后，使用esptool.py刷新加密的二进制文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --port &#x2F;dev&#x2F;ttyUSB0 --baud 115200 write_flash 0x10000 build&#x2F;my-app-encrypted.bin</span><br></pre></td></tr></table></figure><p>不需要进一步的步骤或 efuse 操作，因为我们闪存时数据已经加密.</p><h2 id="5-禁用-Flash-加密"><a href="#5-禁用-Flash-加密" class="headerlink" title="5 禁用 Flash 加密"></a>5 禁用 Flash 加密</h2><p>如果由于某种原因意外启用了闪存加密，则下一次明文数据闪存将使ESP32软化(设备将连续重启，打印错误闪存读错误， 1000).</p><p>您可以通过编写 <code>FLASH_CRYPT_CNT efuse</code> 再次禁用闪存加密:</p><ul><li>首先，运行 <code>make menuconfig</code> 并取消选中“安全功能”下的“启用闪存加密启动”.</li><li>退出 <code>menuconfig</code> 并保存新配置.</li><li>再次运行 <code>make menuconfig</code> 并仔细检查你是否真的禁用了这个选项！ 如果启用此选项，则引导加载程序将在引导时立即重新启用加密.</li><li>运行 <code>make flash</code> 以构建并刷新新的引导加载程序和应用程序，而不启用闪存加密.</li><li>运行 <code>espefuse.py</code> (在 components/esptool_py/esptool 中)以禁用 <code>FLASH_CRYPT_CNT efuse</code>)::</li></ul><p>重置 ESP32 并禁用闪存加密，引导加载程序将正常启动.</p><h2 id="6-Flash-加密的局限性"><a href="#6-Flash-加密的局限性" class="headerlink" title="6 Flash 加密的局限性"></a>6 Flash 加密的局限性</h2><p>Flash 加密可防止加密闪存的明文读出，从而保护固件免受未经授权的读取和修改.了解闪存加密系统的局限性非常重要:</p><ul><li>Flash 加密仅与密钥一样强大.因此，我们建议在首次启动时在设备上生成密钥(默认行为).如果在设备外生成密钥(请参阅通过预生成的 Flash 加密密钥重新刷新)，请确保遵循正确的步骤.</li><li>并非所有数据都是加密存储的.如果在闪存上存储数据，请检查您使用的方法(库，API 等)是否支持闪存加密.</li><li>Flash 加密不会阻止攻击者理解闪存的高级布局.这是因为相同的 AES 密钥用于每对相邻的 16 字节 AES 块.当这些相邻的 16 字节块包含相同的内容(例如空或填充区域)时，这些块将加密以产生匹配的加密块对.这可能允许攻击者在加密设备之间进行高级别比较(即判断两个设备是否可能运行相同的固件版本).</li><li>出于同样的原因，攻击者总能知道一对相邻的 16 字节块 (32 字节对齐)何时包含相同的内容.如果将敏感数据存储在闪存中，请记住这一点，设计闪存存储器，以免发生这种情况(使用计数器字节或每 16 字节一些其他不相同的值就足够了).</li></ul><h2 id="7-Flash-加密和安全启动"><a href="#7-Flash-加密和安全启动" class="headerlink" title="7 Flash 加密和安全启动"></a>7 Flash 加密和安全启动</h2><p>建议一起使用闪存加密和安全启动。但是，如果启用了安全启动，则重新刷新设备会有其他限制:</p><ul><li>OTA 更新不受限制(前提是新应用程序使用安全启动签名密钥正确签名).</li><li>只有选择了 Reflashable Secure Boot 模式并且预先生成安全启动密钥并将其刻录到 ESP32 (参见安全启动文档)，才能进行明文串口烧录更新。在此配置中， make bootloader 将生成预先消化的引导加载程序和安全引导摘要文件，以便在偏移量 0x0 处烧录。当遵循明文串行重新刷新步骤时，必须在烧录其他明文数据之前重新刷新该文件.</li><li>如果未重新启动引导加载程序，仍可以通过预生成的 Flash 加密密钥重新刷新。重新刷新引导加载程序需要在安全引导配置中启用相同的 Reflashable 选项.</li></ul><h2 id="8-使用没有安全启动的-Flash-加密"><a href="#8-使用没有安全启动的-Flash-加密" class="headerlink" title="8 使用没有安全启动的 Flash 加密"></a>8 使用没有安全启动的 Flash 加密</h2><p>如果在没有安全启动的情况下使用闪存加密，则可以使用串行重新烧录加载未经授权的代码。有关详细信息，请参阅串行烧录 然后，这个未授权的代码可以读取所有加密的分区(以解密的形式)，使闪存加密无效。这可以通过写保护 <code>FLASH_CRYPT_CNT efuse</code> 来避免，从而禁止串口重新烧录。FLASH_CRYPT_CNT可以使用命令对efuse进行写保护:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">espefuse.py --port PORT write_protect_efuse FLASH_CRYPT_CNT</span><br></pre></td></tr></table></figure><p>或者，应用程序可以在其启动过程中调用 <code>esp_flash_write_protect_crypt_cnt()</code>.</p><h2 id="9-Flash-加密高级功能"><a href="#9-Flash-加密高级功能" class="headerlink" title="9 Flash 加密高级功能"></a>9 Flash 加密高级功能</h2><p>以下信息对于高级使用闪存加密非常有用:</p><h3 id="9-1-加密分区标志"><a href="#9-1-加密分区标志" class="headerlink" title="9.1 加密分区标志"></a>9.1 加密分区标志</h3><p>某些分区默认是加密的。否则，可以将任何分区标记为需要加密:</p><p>在分区表描述 CSV 文件中，有一个标志字段.</p><p>通常留空，如果在此字段中写入 “encrypted” ，则分区将在分区表中标记为已加密，此处写入的数据将被视为已加密(与应用程序分区相同):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000</span><br><span class="line">factory,  app,  factory, 0x10000, 1M</span><br><span class="line">secret_data, 0x40, 0x01, 0x20000, 256K, encrypted</span><br></pre></td></tr></table></figure><ul><li>默认分区表都不包含任何加密数据分区.</li><li>没有必要将 “app” 分区标记为已加密，它们始终被视为已加密.</li><li>如果未启用闪存加密，则“加密”标志不执行任何操作.</li><li>如果您希望保护此数据不受物理访问读取或修改的影响，则可以将 phy_init 数据标记为可选的phy分区.</li><li>无法将 nvs 分区标记为已加密.</li></ul><h3 id="9-2-启用-UART-Bootloader-加密-解密"><a href="#9-2-启用-UART-Bootloader-加密-解密" class="headerlink" title="9.2 启用 UART Bootloader 加密/解密"></a>9.2 启用 UART Bootloader 加密/解密</h3><p>默认情况下，首次启动时，闪存加密过程将刻录 <code>DISABLE_DL_ENCRYPT</code> ， <code>DISABLE_DL_DECRYPT</code> 和 <code>DISABLE_DL_CACHE</code> :</p><p>在 UART 引导加载程序引导模式下运行时， <code>DISABLE_DL_ENCRYPT</code> 禁用闪存加密操作.<br> <code>DISABLE_DL_DECRYPT</code> 在 UART 引导加载程序模式下运行时禁用透明闪存解密，即使 <code>FLASH_CRYPT_CNT efuse</code> 设置为在正常操作中启用它也是如此.<br>在 UART 引导加载程序模式下运行时， <code>DISABLE_DL_CACHE</code> 禁用整个 MMU 闪存缓存.<br>可以仅刻录其中一些 efuses，并在第一次引导之前对其余部分进行写保护(使用未设置值 0)，以便保留它们。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">espefuse.py --port PORT burn_efuse DISABLE_DL_DECRYPT</span><br><span class="line">espefuse.py --port PORT write_protect_efuse DISABLE_DL_ENCRYPT</span><br></pre></td></tr></table></figure><p>(注意，这些 efuse 中的所有 3 个都是通过一个写保护位禁用的，因此写保护将保护所有这些保护位.因此，在写保护之前必须设置任何位.)</p><blockquote><p>由于 esptool.py 不支持写入或读取加密闪存，因此写保护这些 efuse 以保持它们不被设置目前不是非常有用.</p></blockquote><blockquote><p>如果未设置 <code>DISABLE_DL_DECRYPT(0)</code>， 这有效地使闪存加密无效，因为具有物理访问权限的攻击者可以使用UART引导加载程序模式(使用自定义存根代码)来读取闪存内容.</p></blockquote><h3 id="9-3-设置-FLASH-CRYPT-CONFIG"><a href="#9-3-设置-FLASH-CRYPT-CONFIG" class="headerlink" title="9.3 设置 FLASH_CRYPT_CONFIG"></a>9.3 设置 <code>FLASH_CRYPT_CONFIG</code></h3><p><code>FLASH_CRYPT_CONFIG efuse</code> 确定闪存加密密钥中用块偏移“调整”的位数。有关详细信息，请参阅 Flash 加密算法.</p><p>引导加载程序的首次引导始终将此值设置为最大 0xF.</p><p>可以手动编写这些 efuse， 并在首次启动之前写保护，以便选择不同的调整值。不建议这样做.</p><p>强烈建议在值为零时永远不要写保护 <code>FLASH_CRYPT_CONFIG</code>。如果此 efuse 设置为零，则不会调整闪存加密密钥中的任何位，并且闪存加密算法等同于 AES ECB 模式.</p><h2 id="10-技术细节"><a href="#10-技术细节" class="headerlink" title="10 技术细节"></a>10 技术细节</h2><p>以下部分提供有关闪存加密操作的一些参考信息.</p><h3 id="10-1-FLASH-CRYPT-CNT-efuse"><a href="#10-1-FLASH-CRYPT-CNT-efuse" class="headerlink" title="10.1 FLASH_CRYPT_CNT efuse"></a>10.1 <code>FLASH_CRYPT_CNT efuse</code></h3><p><code>FLASH_CRYPT_CNT</code> 是一个 8 位 efuse 字段，用于控制闪存加密。Flash 加密根据此 efuse 中设置为 “1” 的位数启用或禁用:</p><ul><li>设置偶数位 (0,2,4,6,8) 时:禁用闪存加密，无法解密任何加密数据.<ul><li>如果引导加载程序是使用“启动时启用闪存加密”构建的，那么它将看到这种情况并立即重新加密闪存，无论它何时找到未加密的数据.完成后，它会将 efuse 中的另一位设置为 “1”，这意味着现在设置了奇数个位.<ul><li>在第一次纯文本引导时，位计数具有全新值 0，并且引导加载程序在加密后将其更改为位计数 1 (值 0x01).</li><li>在下一次明文闪存更新后，将位计数手动更新为 2 (值 0x03).重新加密引导加载程序后，将 efuse 位计数更改为 3 (值 0x07).</li><li>在下一个明文闪存之后，将位计数手动更新为 4 (值 0x0F).重新加密引导加载程序后，将 efuse 位计数更改为 5 (值 0x1F).</li><li>在最后的明文闪存之后，位计数被手动更新为 6 (值 0x3F).重新加密引导加载程序后，将 efuse 位计数更改为7 (值 0x7F).</li></ul></li></ul></li><li>设置奇数位 (1,3,5,7) 时:启用透明读取加密闪存.</li><li>设置完所有 8 位后(efuse 值 0xFF):禁用透明读取加密闪存，永久无法访问任何加密数据。Bootloader 通常会检测到这种情况并停止.为避免使用此状态加载未经授权的代码，必须使用安全引导或 <code>FLASH_CRYPT_CNT efuse</code> 必须写保护.</li></ul><h3 id="10-2-Flash-加密算法"><a href="#10-2-Flash-加密算法" class="headerlink" title="10.2 Flash 加密算法"></a>10.2 Flash 加密算法</h3><ul><li><p>AES-256 以 16 字节数据块运行.闪存加密引擎以 32 字节块，两个串联的 AES 块加密和解密数据.</p></li><li><p>AES 算法在闪存加密中反转使用，因此闪存加密“加密”操作是 AES 解密，“解密”操作是AES加密.这是出于性能原因，并未改变算法的有效性.</p></li><li><p>主闪存加密密钥存储在 efuse(BLOCK1) 中，默认情况下不受进一步写入或软件读取的影响.</p></li><li><p>每个 32 字节块(两个相邻的 16 字节 AES 块)使用唯一密钥加密.密钥源自efuse中的主闪存加密密钥，与闪存中该块的偏移量进行异或(“键调整”).</p></li><li><p>具体的调整取决于 <code>FLASH_CRYPT_CONFIG efuse</code> 的设置.这是一个 4 位 efuse， 其中每个位都能对特定范围的关键位进行异或运算:</p><ul><li>位 1， 该值的 0-66 位被异或.</li><li>位 2， 该值的 67-131 位被异或.</li><li>位 3， 该值的 132-194 被异或.</li><li>位 4， 该值的 195-256 位被异或.<br>建议始终保留 <code>FLASH_CRYPT_CONFIG</code> 以设置默认值 0xF，以便所有关键位与块偏移进行异或.有关详细信息，请参阅设置 <code>FLASH_CRYPT_CONFIG</code>.</li></ul></li><li><p>块偏移的高 19 位(第 5 位到第 23 位)与主闪存加密密钥进行异或.选择此范围有两个原因:最大闪存大小为 16MB(24 位)，每个块为 32 字节，因此最低有效 5 位 始终为零.</p></li><li><p>从 19 个块偏移位中的每一个到闪存加密密钥的 256 位存在特定映射，以确定哪个位与哪个位进行异或.请参阅 espsecure.py 源代码中的变量 <code>_FLASH_ENCRYPTION_TWEAK_PATTERN</code> 以获取完整的映射.</p></li><li><p>要查看 Python 中实现的完整闪存加密算法，请参阅 espsecure.py 源代码中的 <code>_flash_encryption_operation()</code> 函数.</p></li></ul><h2 id="11-参考资料"><a href="#11-参考资料" class="headerlink" title="11 参考资料"></a>11 参考资料</h2><ul><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html" target="_blank" rel="noopener">原文链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flash-加密&quot;&gt;&lt;a href=&quot;#Flash-加密&quot; class=&quot;headerlink&quot; title=&quot;Flash 加密&quot;&gt;&lt;/a&gt;Flash 加密&lt;/h1&gt;&lt;p&gt;Flash 加密功能用于加密 ESP32 连接的 SPI  Flash 的内容。启用 Fla
      
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（六）深度睡眠唤醒存根</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E7%9D%A1%E7%9C%A0%E5%94%A4%E9%86%92%E5%AD%98%E6%A0%B9/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E7%9D%A1%E7%9C%A0%E5%94%A4%E9%86%92%E5%AD%98%E6%A0%B9/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:28:59.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度睡眠唤醒存根"><a href="#深度睡眠唤醒存根" class="headerlink" title="深度睡眠唤醒存根"></a>深度睡眠唤醒存根</h1><p>ESP32 支持在深度睡眠时运行“深度睡眠唤醒存根”。芯片唤醒后立即运行此功能 - 在任何正常初始化，引导加载程序或 ESP-IDF 代码运行之前。唤醒存根运行后，SoC 可以返回休眠状态或继续正常启动 ESP-IDF。</p><p>深度睡眠唤醒存根代码被加载到“RTC 快速存储器”中，它使用的任何数据也必须加载到 RTC 存储器中。RTC 存储区域在深度睡眠期间保持其内容，</p><h2 id="唤醒存根规则"><a href="#唤醒存根规则" class="headerlink" title="唤醒存根规则"></a>唤醒存根规则</h2><p>必须仔细编写唤醒存根代码:</p><ul><li>由于 SoC 刚刚从睡眠状态中醒来，大多数外设都处于复位状态。SPI Flash 未映射。</li><li>唤醒存根代码只能调用 ROM 中或加载到 RTC 快速存储器中实现的功能(见下文)。</li><li>唤醒存根代码只能访问 RTC 存储器中加载的数据。所有其他 RAM 将无法使用并具有随机内容。唤醒存根可以使用其他 RAM 进行临时存储，但是当 SoC 重新进入休眠状态或启动 ESP-IDF 时,内容将被覆盖。</li><li>RTC 内存必须包含存根使用的任何只读数据(.rodata)。</li><li>每当 SoC 重新启动时，RTC 存储器中的数据都会被初始化，除非从深度睡眠中唤醒。从深度睡眠中醒来时，保持睡眠前存在的值。</li><li>唤醒存根代码是 esp-idf 应用程序的一部分。在 esp-idf 的正常运行期间，函数可以调用唤醒存根函数或访问 RTC 存储器。就好像这些是应用程序的常规部分。</li></ul><h2 id="实现存根"><a href="#实现存根" class="headerlink" title="实现存根"></a>实现存根</h2><p>esp-idf 中的唤醒存根的函数 <code>esp_wake_deep_sleep()</code>。只要 SoC 从深度睡眠中唤醒，该函数就会运行。esp-idf 中提供了此函数的默认版本，但默认函数是弱链接的，因此如果您的应用程序包含名为 <code>esp_wake_deep_sleep()</code> 的函数，那么这将覆盖这个默认版本。</p><p>如果提供自定义唤醒存根，它首先要做的就是调用 <code>esp_default_wake_deep_sleep()</code>。</p><p>没有必要在您的应用程序中实现 <code>esp_wake_deep_sleep()</code> 以使用深度睡眠。只有你想在唤醒时立即有特殊行为才有必要。</p><p>如果要在运行时在不同的深度睡眠存根之间进行交换，也可以通过调用 <code>esp_set_deep_sleep_wake_stub()</code> 函数来执行此操作。如果仅使用默认的 <code>esp_wake_deep_sleep()</code> 函数，则不需要这样做。</p><p>所有这些函数都在 components/esp32 下的 <code>esp_deepsleep.h</code> 头文件中声明。</p><h2 id="将代码加载到-RTC-内存中"><a href="#将代码加载到-RTC-内存中" class="headerlink" title="将代码加载到 RTC 内存中"></a>将代码加载到 RTC 内存中</h2><p>唤醒存根代码必须驻留在 RTC 快速存储器中。这可以通过两种方式之一完成。</p><p>第一种方法是使用 <code>RTC_IRAM_ATTR</code> 属性将函数放入 RTC 内存:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void RTC_IRAM_ATTR esp_wake_deep_sleep(void) &#123;</span><br><span class="line">    esp_default_wake_deep_sleep();</span><br><span class="line">    &#x2F;&#x2F; Add additional functionality here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法是将函数放入名称以 <code>rtc_wake_stub</code> 开头的任何源文件中。文件名 <code>rtc_wake_stub *</code> 中其内容将通过链接器自动放入 <code>RTC</code> 存储器中。</p><p>对于非常简短的代码，或者对于要混合“普通”和 “RTC” 代码的源文件，第一种方法更简单。当你想为 <code>RTC</code> 内存编写更长的代码时，第二种方法更简单。</p><h2 id="将数据加载到-RTC-内存中"><a href="#将数据加载到-RTC-内存中" class="headerlink" title="将数据加载到 RTC 内存中"></a>将数据加载到 RTC 内存中</h2><p>存根代码使用的数据必须驻留在 <code>RTC</code> 慢速存储器中。ULP 也使用该存储器。</p><p>可以通过以下两种方式之一来指定此数据:</p><p>第一种方法是使用 <code>RTC_DATA_ATTR</code> 和 <code>RTC_RODATA_ATTR</code> 来指定应加载到 RTC 慢速内存中的任何数据(可写或只读，相应):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RTC_DATA_ATTR int wake_count;</span><br><span class="line"></span><br><span class="line">void RTC_IRAM_ATTR esp_wake_deep_sleep(void) &#123;</span><br><span class="line">    esp_default_wake_deep_sleep();</span><br><span class="line">    static RTC_RODATA_ATTR const char fmt_str[] &#x3D; &quot;Wake count %d\n&quot;;</span><br><span class="line">    ets_printf(fmt_str, wake_count++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过名为 <code>CONFIG_ESP32_RTCDATA_IN_FAST_MEM</code> 的 menuconfig 选项配置放置此数据的 RTC 存储区。此选项允许为 ULP 程序保留较慢的存储区域，一旦启用，标记为 <code>RTC_DATA_ATTR</code> 和 <code>RTC_RODATA_ATTR</code> 的数据将被放置在 RTC 快速存储器段中，否则将转至 RTC 慢速存储器（默认选项）。此选项取决于 <code>CONFIG_FREERTOS_UNICORE</code>，因为 RTC 快速存储器只能由 PRO_CPU 访问。</p><p>类似的属性 <code>RTC_FAST_ATTR</code> 和 <code>RTC_SLOW_ATTR</code> 用于指定将数据分别强制放入 <code>RTC_FAST</code> 和 <code>RTC_SLOW</code> 存储器。<code>PRO_CPU</code> 仅允许对标记为 <code>RTC_FAST_ATTR</code> 的数据进行访问，并且用户有责任确保它。</p><p>不幸的是，以这种方式使用的任何字符串常量必须声明为数组并用 <code>RTC_RODATA_ATTR</code> 标记，如上例所示。</p><p>第二种方法是将数据放入名称以 <code>rtc_wake_stub</code> 开头的任何源文件中。</p><p>例如，<code>rtc_wake_stub_counter.c</code> 中的等效示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int wake_count;</span><br><span class="line"></span><br><span class="line">void RTC_IRAM_ATTR esp_wake_deep_sleep(void) &#123;</span><br><span class="line">    esp_default_wake_deep_sleep();</span><br><span class="line">    ets_printf(&quot;Wake count %d\n&quot;, wake_count++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您需要使用字符串或编写其他更复杂的代码，第二种方法是更好的选择。</p><p><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度睡眠唤醒存根&quot;&gt;&lt;a href=&quot;#深度睡眠唤醒存根&quot; class=&quot;headerlink&quot; title=&quot;深度睡眠唤醒存根&quot;&gt;&lt;/a&gt;深度睡眠唤醒存根&lt;/h1&gt;&lt;p&gt;ESP32 支持在深度睡眠时运行“深度睡眠唤醒存根”。芯片唤醒后立即运行此功能 - 在任何正
      
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（四）错误处理</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:28:59.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>识别和处理运行时错误对于开发健壮的应用程序非常重要. ESP-IDF 中可能存在多种运行时错误:</p><ul><li>可恢复的错误:<ul><li>函数通过返回值表示的错误(错误代码)</li><li>使用 throw 关键字抛出的 C++ 异常</li></ul></li><li>不可恢复(严重)错误:<ul><li>断言失败(使用断言宏和等效方法)和 abort() 调用.</li><li>CPU 异常:access to protected regions of memory, illegal instruction(访问受保护的内存区域,非法指令)等.</li><li>系统级别检查:watchdog timeout, cache access error, stack overflow, stack smashing, heap corruption(监视程序超时,缓存访问错误,堆栈溢出,堆栈粉碎,堆损坏)等.</li></ul></li></ul><p>本指南介绍了与可恢复错误相关的 ESP-IDF 错误处理机制,并提供了一些常见的错误处理模式.</p><p>有关诊断不可恢复错误的说明,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误</a>.</p><a id="more"></a><h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><p>大多数特定的 ESP-IDF 函数使用 <code>esp_err_t</code> 类型来返回错误代码. <code>esp_err_t</code> 是带符号的整数类型. <code>ESP_OK</code> 代码表示成功(无错误),定义为零.</p><p>各种 ESP-IDF 头文件使用预处理器定义来定义可能的错误代码. 通常这些定义以 <code>ESP_ERR_</code> 前缀开头. 通用错误的常见错误代码(内存不足,超时,无效参数等)在 <code>esp_err.h</code> 文件中定义. ESP-IDF 中的各种组件可以为特定情况定义附加的错误代码.</p><p>有关错误代码的完整列表,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/error-codes.html" target="_blank" rel="noopener">错误代码参考</a>.</p><h2 id="将错误代码转换为错误消息"><a href="#将错误代码转换为错误消息" class="headerlink" title="将错误代码转换为错误消息"></a>将错误代码转换为错误消息</h2><p>对于 ESP-IDF 组件中定义的每个错误代码,可以使用 <code>esp_err_to_name()</code> 或 <code>esp_err_to_name_r()</code> 函数将 <code>esp_err_t</code> 值转换为错误代码名称. 例如,将 <code>0x101</code> 传递给 <code>esp_err_to_name()</code> 将返回 “ESP_ERR_NO_MEM” 字符串. 可以在日志输出中使用此类字符串,以便更容易理解发生了哪个错误.</p><p>此外,如果未找到匹配的 <code>ESP_ERR_</code> 值,<code>esp_err_to_name_r()</code> 函数将尝试将错误代码解释为<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html" target="_blank" rel="noopener">标准 POSIX 错误代码</a>. 这是使用 <code>strerror_r</code> 函数完成的. POSIX 错误代码(例如 <code>ENOENT</code>,<code>ENOMEM</code>)在 <code>errno.h</code> 中定义,通常从 <code>errno</code> 变量获得. 在 ESP-IDF 中,这个变量是线程本地的:多个 FreeRTOS 任务都有自己的 <code>errno</code> 副本. 设置 <code>errno</code> 的函数仅修改它们运行的任务的值.</p><p>默认情况下启用此功能,但可以禁用此功能以减少应用程序二进制文件大小. 请参阅 <code>CONFIG_ESP_ERR_TO_NAME_LOOKUP</code>. 禁用此功能后,仍会定义 <code>esp_err_to_name()</code> 和 <code>esp_err_to_name_r()</code> ,并且可以调用它. 在这种情况下,<code>esp_err_to_name()</code> 将返回<code>UNKNOWN ERROR</code>,并且 <code>esp_err_to_name_r()</code> 将返回 <code>Unknown error 0xXXXX(YYYYY)</code> ,其中<code>0xXXXX</code> 和 <code>YYYYY</code> 分别是错误代码的十六进制和十进制表示.</p><h2 id="ESP-ERROR-CHECK-宏"><a href="#ESP-ERROR-CHECK-宏" class="headerlink" title="ESP_ERROR_CHECK 宏"></a><code>ESP_ERROR_CHECK</code> 宏</h2><p><code>ESP_ERROR_CHECK()</code> 宏与 <code>assert</code> 的用途相似,只是它检查 <code>esp_err_t</code> 值而不是 <code>bool</code> 条件. 如果 <code>ESP_ERROR_CHECK()</code> 的参数不等于 <code>ESP_OK</code> ,则在控制台上打印错误消息,并调用 <code>abort()</code>.</p><p>错误消息通常如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ESP_ERROR_CHECK failed: esp_err_t 0x107 (ESP_ERR_TIMEOUT) at 0x400d1fdf</span><br><span class="line"></span><br><span class="line">file: &quot;&#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.c&quot; line 20</span><br><span class="line">func: app_main</span><br><span class="line">expression: sdmmc_card_init(host, &amp;card)</span><br><span class="line"></span><br><span class="line">Backtrace: 0x40086e7c:0x3ffb4ff0 0x40087328:0x3ffb5010 0x400d1fdf:0x3ffb5030 0x400d0816:0x3ffb5050</span><br></pre></td></tr></table></figure><blockquote><p>如果使用 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/idf-monitor.html" target="_blank" rel="noopener">IDF monitor</a>,则回溯中的地址将转换为文件名和行号.</p></blockquote><ul><li>第一行提到错误代码为十六进制值,以及源代码中用于此错误的标识符. 后者取决于设置的 <code>CONFIG_ESP_ERR_TO_NAME_LOOKUP</code> 选项. 打印出错误的程序中的地址也被打印出来.</li><li>后续行显示程序中调用 <code>ESP_ERROR_CHECK()</code> 宏的位置,以及作为参数传递给宏的表达式.</li><li>最后,打印回溯. 这是所有错误 <code>panic</code> 处理程序输出的公共部分. 有关回溯的更多信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误 Fatal Errors</a>.</li></ul><h2 id="错误处理模式"><a href="#错误处理模式" class="headerlink" title="错误处理模式"></a>错误处理模式</h2><ol><li><p>尝试恢复. 根据具体情况,这可能意味着在一段时间后重试呼叫,或尝试取消初始化驱动程序并重新初始化,或使用带外机制修复错误条件(例如重置外部外围设备) 这没有回应).</p><p>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">esp_err_t err;</span><br><span class="line">do &#123;</span><br><span class="line">    err &#x3D; sdio_slave_send_queue(addr, len, arg, timeout);</span><br><span class="line">    &#x2F;&#x2F; keep retrying while the sending queue is full</span><br><span class="line">&#125; while (err &#x3D;&#x3D; ESP_ERR_TIMEOUT);</span><br><span class="line">if (err !&#x3D; ESP_OK) &#123;</span><br><span class="line">    &#x2F;&#x2F; handle other errors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将错误传播给调用者. 在某些中间件组件中,这意味着函数必须以相同的错误代码退出,从而确保回滚任何资源分配.</p><p>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sdmmc_card_t* card &#x3D; calloc(1, sizeof(sdmmc_card_t));</span><br><span class="line">if (card &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    return ESP_ERR_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line">esp_err_t err &#x3D; sdmmc_card_init(host, &amp;card);</span><br><span class="line">if (err !&#x3D; ESP_OK) &#123;</span><br><span class="line">    &#x2F;&#x2F; Clean up</span><br><span class="line">    free(card);</span><br><span class="line">    &#x2F;&#x2F; Propagate the error to the upper layer (e.g. to notify the user).</span><br><span class="line">    &#x2F;&#x2F; Alternatively, application can define and return custom error code.</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>转换为不可恢复的错误,例如使用 <code>ESP_ERROR_CHECK</code>. 有关详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/error-handling.html#esp-error-check-macro" target="_blank" rel="noopener"><code>ESP_ERROR_CHECK</code> 宏</a>部分.</p><p>在出现错误的情况下终止应用程序通常是中间件组件的不良行为,但有时在应用程序级别可以接受.</p><p>许多 ESP-IDF 示例使用 <code>ESP_ERROR_CHECK</code> 来处理来自各种API的错误. 这不是应用程序的最佳实践,并且可以使示例代码更简洁.</p><p>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ESP_ERROR_CHECK(spi_bus_initialize(host, bus_config, dma_chan));</span><br></pre></td></tr></table></figure></li></ol><h2 id="C-异常"><a href="#C-异常" class="headerlink" title="C++ 异常"></a>C++ 异常</h2><p>默认情况下禁用对 ESP-IDF 中的 C++ 异常的支持,但可以使用 <code>CONFIG_CXX_EXCEPTIONS</code> 选项启用.</p><p>启用异常处理通常会将应用程序二进制大小增加几KB. 此外,可能需要为异常紧急池预留一定量的 RAM. 如果无法从堆中分配异常对象,则将使用此池中的内存. 可以使用 <code>CONFIG_CXX_EXCEPTIONS_EMG_POOL_SIZE</code> 变量设置应急池中的内存量.</p><p>如果抛出异常,但没有 <code>catch</code> 块,程序将被 <code>abort</code> 函数终止,并且将打印 <code>backtrace</code>. 有关回溯的更多信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误</a>.</p><p><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/error-handling.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;错误处理&quot;&gt;&lt;a href=&quot;#错误处理&quot; class=&quot;headerlink&quot; title=&quot;错误处理&quot;&gt;&lt;/a&gt;错误处理&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;识别和处理运行时错误对于开发健壮的应用程序非常重要. ESP-IDF 中可能存在多种运行时错误:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可恢复的错误:&lt;ul&gt;
&lt;li&gt;函数通过返回值表示的错误(错误代码)&lt;/li&gt;
&lt;li&gt;使用 throw 关键字抛出的 C++ 异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不可恢复(严重)错误:&lt;ul&gt;
&lt;li&gt;断言失败(使用断言宏和等效方法)和 abort() 调用.&lt;/li&gt;
&lt;li&gt;CPU 异常:access to protected regions of memory, illegal instruction(访问受保护的内存区域,非法指令)等.&lt;/li&gt;
&lt;li&gt;系统级别检查:watchdog timeout, cache access error, stack overflow, stack smashing, heap corruption(监视程序超时,缓存访问错误,堆栈溢出,堆栈粉碎,堆损坏)等.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本指南介绍了与可恢复错误相关的 ESP-IDF 错误处理机制,并提供了一些常见的错误处理模式.&lt;/p&gt;
&lt;p&gt;有关诊断不可恢复错误的说明,请参阅&lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;错误&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
</feed>
