<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>InfiniteYuan</title>
  
  
  <link href="/InfiniteYuanBlog/atom.xml" rel="self"/>
  
  <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/"/>
  <updated>2020-07-23T06:21:46.545Z</updated>
  <id>https://infiniteyuan.github.io/InfiniteYuanBlog/</id>
  
  <author>
    <name>InfiniteYuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo Blog</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/hexo_blog_log/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/hexo_blog_log/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:21:46.545Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（一）关于 ESP-IDF 编程的一些说明</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%B3%E4%BA%8E%20ESP-IDF%20%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%B3%E4%BA%8E%20ESP-IDF%20%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:21:46.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-ESP-IDF-编程的一些说明"><a href="#关于-ESP-IDF-编程的一些说明" class="headerlink" title="关于 ESP-IDF 编程的一些说明"></a>关于 ESP-IDF 编程的一些说明</h1><h2 id="应用启动流程"><a href="#应用启动流程" class="headerlink" title="应用启动流程"></a>应用启动流程</h2><p>本文档说明了在调用 ESP-IDF 应用程序的 <code>app_main</code> 函数之前发生的一些步骤.</p><p>启动过程如下：<br> <strong>1. 位于 ROM 中的第一阶段引导程序将第二阶段引导程序映像从 flash 0x1000 地址加载到 RAM( IRAM 和 DRAM ).<br> 2. 第二阶段引导程序从 flash 中加载分区表和主应用程序映像.主应用程序包含 RAM 段和通过 flash cache 映射的只读段.<br> 3. 主应用程序映像执行.此时,可以启动第二个 CPU 和 RTOS 调度器.</strong><br>以下各节将详细介绍此过程.</p><a id="more"></a><h2 id="第一阶段引导程序"><a href="#第一阶段引导程序" class="headerlink" title="第一阶段引导程序"></a>第一阶段引导程序</h2><p><strong>SoC 复位后,PRO CPU 会立即开始运行,执行复位向量代码,而 APP CPU 将保持复位状态.</strong> 在启动过程中, PRO CPU 会进行所有有关的初始化.APP CPU 复位状态在应用程序启动代码的 <code>call_start_cpu0</code> 函数中被取消.复位向量代码位于 ESP32 芯片掩模 ROM 中的 0x40000400 地址,并且无法修改.<br>复位向量调用的启动代码通过检查 <code>GPIO_STRAP_REG</code> 寄存器的引导引脚状态来确定引导模式.根据复位原因,有以下情况：</p><ol><li>从深度睡眠(<code>deep sleep</code>)模式复位：如果 <code>RTC_CNTL_STORE6_REG</code> 中的值非零,并且 <code>RTC_CNTL_STORE7_REG</code> 中的 RTC 存储器的 CRC 值有效,则使用 <code>RTC_CNTL_STORE6_REG</code> 作为入口地址并立即跳转到该地址.如果 <code>RTC_CNTL_STORE6_REG</code> 为零,或者 <code>RTC_CNTL_STORE7_REG</code> 包含无效的  CRC 值,或者通过 <code>RTC_CNTL_STORE6_REG</code> 调用的代码执行完毕,则继续启动,就像上电复位一样.注意：此时若要运行自定义的代码,需要提供深度睡眠存根机制.请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档.<ol start="2"><li>对于上电复位,软件 SOC 复位和看门狗 SOC 复位：检查 <code>GPIO_STRAP_REG</code> 寄存器,是否要求 UART 或 SDIO 下载模式.如果是这种情况,配置 UART 或 SDIO,并等待下载代码.否则,继续启动,就好像是由于软件 CPU 复位.</li><li>对于软件 CPU 复位和看门狗 CPU 复位：根据 EFUSE 值配置 SPI flash,并尝试从 flash 中加载代码.在下面的段落中会更详细地描述了该步骤.如果从 flash 中加载代码失败,解压 BASIC 解释器到 RAM 中并启动它.请注意,发生这种情况时 RTC 看门狗仍然是开启的,因此除非解释器接收到任何输入,否则看门狗将在几百毫秒内复位 SOC,重复整个过程.如果解释器收到来自 UART 的任何输入,它将禁用看门狗.</li></ol></li></ol><p><strong>应用程序二进制映像从 flash 的 0x1000 地址开始加载.</strong> 闪存的第一个 4kB 扇区用于存储安全引导IV和应用程序映像的签名.有关详细信息,请查看安全启动文档.</p><h2 id="第二阶段引导程序"><a href="#第二阶段引导程序" class="headerlink" title="第二阶段引导程序"></a>第二阶段引导程序</h2><p>在 ESP-IDF 中,位于 flash 0x1000 地址的二进制映像是第二阶段引导程序. 第二阶段引导程序源代码可在 ESP-IDF 的 <code>components/bootloader</code> 目录中找到.请注意,第二阶段引导程序这样的安排并不是 ESP32 芯片唯一可行的安排.可以编写一个功能齐全的应用程序,当 flash 偏移到 0x1000 地址时可以工作,但这超出了本文档的范围.ESP-IDF 中使用第二阶段引导程序来增加 flash 布局的灵活性(使用分区表),并允许与闪存加密,安全引导和无线更新(OTA)相关的操作执行.</p><p><strong>当第一阶段引导程序完成校验并加载第二阶段引导程序时,它会跳转到在二进制映像头中找到的第二阶段引导程序的入口地址.</strong></p><p><strong>第二阶段引导程序读取在 0x8000 地址的分区表.</strong> 更多有关信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">分区表</a>文档.<strong>引导程序找到 factory 和 OTA 分区,并根据 OTA 信息分区中的数据决定引导哪个分区.</strong></p><p>对于所选分区,第二阶段引导程序将映射到 IRAM 和 DRAM 的数据和代码段拷贝到其加载地址.对于在 DROM 和 IROM 区域中具有加载地址的节,flash MMU 将提供正确的映射.请注意,第二阶段引导程序为 PRO 和 APP CPU 配置了 flash MMU,但它仅为 PRO CPU 启用 flash MMU.原因是第二阶段引导程序代码被加载到 APP CPU 缓存所使用的内存区域.为 APP CPU 启用缓存的任务将交给应用程序.加载代码并配置 flash MMU 后,第二阶段引导程序将跳转到二进制映像头中的应用程序入口地址.</p><p>目前,无法将应用程序定义的挂钩添加到引导程序以自定义应用程序分区的选择逻辑.例如,这可能需要根据 GPIO 的状态加载不同的应用程序映像.此类自定义功能将在未来添加到 ESP-IDF 中.目前,可以通过将 bootloader 组件拷贝到应用程序目录并在那里进行必要的更改来自定义引导程序.在这种情况下,ESP-IDF 构建系统将编译应用程序目录中的组件而不是 ESP-IDF 自身目录中的组件.</p><h2 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h2><p>ESP-IDF 应用程序入口地址是在 <code>components/esp32/cpu_start.c</code>中的<code>call_start_cpu0</code>函数.这个函数的两个主要功能是启用堆分配器并使 APP CPU 跳转到其入口地址<code>call_start_cpu1</code>.PRO CPU 上的代码设置 APP CPU 的入口地址、取消 APP CPU 复位,并等待全局标志被 APP CPU 上运行的代码设置,以表示 APP CPU 已经启动.这个函数执行后,PRO CPU 跳转到<code>start_cpu0</code>函数,APP CPU 跳转到<code>start_cpu1</code>函数.</p><p><code>start_cpu0</code>和<code>start_cpu1</code>都是弱函数,这意味着如果需要对初始化序列进行一些特定于应用程序的更改,则可以在应用程序中覆盖它们.<code>start_cpu0</code>默认启用或初始化 <code>menuconfig</code> 中选择的组件.请参阅<code>components/esp32/cpu_start.c</code>中此函数的源代码,以获取最新的执行步骤.请注意,在此阶段将调用应用程序中存在的任何 C ++ 全局构造函数.初始化完所有必要组件后,将创建主任务并启动 FreeRTOS 调度器.</p><p>当 PRO CPU 在 <code>start_cpu0</code>函数中进行初始化时,APP CPU 将在<code>start_cpu1</code>函数中等待调度器在 PRO CPU 上启动.在 PRO CPU 上启动调器器后,APP CPU 上的代码也会开启调度器.</p><p>主任务是运行 <code>app_main</code>函数. 可以在 <code>menuconfig</code> 中配置主任务堆栈大小和优先级. 应用程序可以将此任务用于特定应用程序的初始化,例如启动其他任务. 应用程序还可以将主任务用于事件循环和其他通用活动. 如果 <code>app_main</code> 函数返回,主任务会被删除.</p><h2 id="应用内存布局"><a href="#应用内存布局" class="headerlink" title="应用内存布局"></a>应用内存布局</h2><p>ESP32 芯片具有灵活的内存映射功能.本节将介绍  ESP-IDF 在默认情况下是如何使用这些功能的.<br>ESP-IDF 中的应用程序代码可以放入以下内存区域之一.</p><h3 id="IRAM-指令RAM"><a href="#IRAM-指令RAM" class="headerlink" title="IRAM(指令RAM)"></a>IRAM(指令RAM)</h3><p>ESP-IDF 为指令 RAM 分配内部 SRAM0 区域的一部分(在技术参考手册中定义).除了第一个 64 kB 块用于 PRO 和 APP CPU 高速缓存之外,该存储器范围的其余部分(即从 <code>0x40080000</code> 到 <code>0x400A0000</code> )用于存储需要从 RAM 中运行的应用程序部分.</p><p>使用链接描述文件将 ESP-IDF 的一些组件和 WiFi 协议栈的一些部分放入该区域.</p><p>如果需要将一些应用程序代码放入 IRAM,可以使用 <code>IRAM_ATTR</code> 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;esp_attr.h&quot;</span><br><span class="line">void IRAM_ATTR gpio_isr_handler(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是部分应用可能或应该放在 IRAM 中的情况.</p><ul><li>如果在注册中断处理程序时使用<code>ESP_INTR_FLAG_IRAM</code>,则必须将中断处理程序放在 IRAM 中.在这种情况下,ISR 可能只调用放在 IRAM 中的函数或存在于 ROM 中的函数.注意：所有 FreeRTOS API 目前都放在 IRAM 中,因此可以安全地从中断处理程序中调用.如果将 ISR 放在 IRAM 中,则必须使用 <code>DRAM_ATTR</code> 将 ISR 使用的所有常量数据和从 ISR 调用的函数(包括但不限于 <code>const char</code> 数组)放在 DRAM 中.</li><li>可以将一些关键性的时序代码放在 IRAM 中以减少从闪存加载代码相关的损耗.ESP32 通过 32 kB 高速缓存从闪存中读取代码和数据.在某些情况下,将函数放入到 IRAM 中可以减少由高速缓存未命中引起的延迟.</li></ul><h3 id="IROM-从Flash执行的代码"><a href="#IROM-从Flash执行的代码" class="headerlink" title="IROM(从Flash执行的代码)"></a>IROM(从Flash执行的代码)</h3><p>如果函数未明确放入到 IRAM 或 RTC 内存中,则将其放置到闪存中.Flash 技术参考手册中介绍了 Flash MMU 用于允许代码从闪存执行的机制. ESP-IDF 从 0x400D0000 - 0x40400000 区域开始放置应该从闪存执行的代码.启动时,第二阶段引导加载程序初始化 Flash MMU 以将代码所在的 flash 中的位置映射到该区域的开头.使用 0x40070000 - 0x40080000 范围内的两个 32kB 块透明地缓存对该区域的访问.<br>请注意,使用 Window ABI CALLx 指令可能无法访问 0x40000000 - 0x40400000 区域外的代码,因此如果应用程序使用 0x40400000 - 0x40800000 或 0x40800000 - 0x40C00000 区域,需要特别小心. ESP-IDF 默认不使用这些区域.</p><h3 id="RTC-高速存储器"><a href="#RTC-高速存储器" class="headerlink" title="RTC 高速存储器"></a>RTC 高速存储器</h3><p>从深度睡眠模式唤醒后,将要运行的代码必须放入 RTC 存储器.请查看<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档中的详细说明.</p><h3 id="DRAM-数据-RAM"><a href="#DRAM-数据-RAM" class="headerlink" title="DRAM (数据 RAM)"></a>DRAM (数据 RAM)</h3><p>链接器将非常量静态数据和零初始化数据放入 256 kB 的 0x3FFB0000 - 0x3FFF0000 区域中.请注意,如果使用蓝牙堆栈,此区域将减少 64kB(通过将开始地址移至 0x3FFC0000).如果使用跟踪存储器,该区域的长度也会减少 16 kB 或 32kB.放置静态数据后,在此区域中的所有剩下的空间都将用于运行时堆.</p><p>常量数据也可以放入 DRAM 中,例如,如果它用在 ISR 中(参见上面 IRAM 部分的注释).为此,可以使用 DRAM_ATTR 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DRAM_ATTR const char[] format_string &#x3D; &quot;%p %x&quot;;</span><br><span class="line">char buffer[64];</span><br><span class="line">sprintf(buffer, format_string, ptr, val);</span><br></pre></td></tr></table></figure><p>不必说,不建议在 ISR 中使用 printf 和其他输出功能.为了进行调试,从中断服务程序打印log时使用 <code>ESP_EARLY_LOGx</code> 宏.在这种情况下,必须确保将 TAG 和格式字符串都放入到 DRAM 中.</p><p><code>__NOINIT_ATTR</code>宏可以用作将数据放入<code>.noinit</code>部分的属性.放入此部分的值不会在启动时初始化,并在软件重新启动后保留其值.<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__NOINIT_ATTR uint32_t noinit_data;</span><br></pre></td></tr></table></figure><h3 id="DROM-存储在-Flash-中的数据"><a href="#DROM-存储在-Flash-中的数据" class="headerlink" title="DROM(存储在 Flash 中的数据)"></a>DROM(存储在 Flash 中的数据)</h3><p>默认情况下,链接器将常量数据放入到一个 4 MB 的区域中(0x3F400000 - 0x3F800000),该区域被用于通过 Flash MMU 和缓存访问外部闪存.但是对于文字常量不同,它们由编译器嵌入到应用程序代码中.</p><h3 id="RTC-低速存储器"><a href="#RTC-低速存储器" class="headerlink" title="RTC 低速存储器"></a>RTC 低速存储器</h3><p>从 RTC 存储器中运行的代码使用的全局和静态变量(即深度睡眠存根代码)必须放入到 RTC 慢速存储器中. 请查看<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档中的详细说明.</p><p><code>RTC_NOINIT_ATTR</code>宏可用于将数据放入到这种类型的内存中.放在此部分中的数据,在从深度睡眠中醒来后也会保持其值.<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTC_NOINIT_ATTR uint32_t rtc_noinit_data;</span><br></pre></td></tr></table></figure><h3 id="DMA-能力要求"><a href="#DMA-能力要求" class="headerlink" title="DMA 能力要求"></a>DMA 能力要求</h3><p>大多数 DMA 控制器(例如 SPI,sdmmc 等)都要求发送/接收缓冲区应放在 DRAM 中并进行字对齐.我们建议将 DMA 缓冲区放在静态变量中而不是堆栈中.使用<code>DMA_ATTR</code>宏声明全局/本地静态变量,如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DMA_ATTR uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;</span><br><span class="line"></span><br><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    DMA_ATTR static uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在堆栈中放置DMA缓冲区仍然是允许的,但必须记住：</p><ol><li>如果堆栈在 pSRAM 中,切勿尝试这样做.如果任务的堆栈放在 pSRAM 中,则必须执行<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/external-ram.html" target="_blank" rel="noopener">支持外部 RAM </a>文档(至少在 menuconfig 中启用 <code>SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY</code> 选项)中所述的几个步骤.确保你的任务不在 pSRAM 中.</li><li>在将变量放在适当的位置之前的函数中使用 <code>WORD_ALIGNED_ATTR</code> 宏,如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t stuff;</span><br><span class="line">    WORD_ALIGNED_ATTR uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;   &#x2F;&#x2F;or the buffer will be placed right after stuff.</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><a href="https://esp-idf.readthedocs.io/en/latest/api-guides/general-notes.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于-ESP-IDF-编程的一些说明&quot;&gt;&lt;a href=&quot;#关于-ESP-IDF-编程的一些说明&quot; class=&quot;headerlink&quot; title=&quot;关于 ESP-IDF 编程的一些说明&quot;&gt;&lt;/a&gt;关于 ESP-IDF 编程的一些说明&lt;/h1&gt;&lt;h2 id=&quot;应用启动流程&quot;&gt;&lt;a href=&quot;#应用启动流程&quot; class=&quot;headerlink&quot; title=&quot;应用启动流程&quot;&gt;&lt;/a&gt;应用启动流程&lt;/h2&gt;&lt;p&gt;本文档说明了在调用 ESP-IDF 应用程序的 &lt;code&gt;app_main&lt;/code&gt; 函数之前发生的一些步骤.&lt;/p&gt;
&lt;p&gt;启动过程如下：&lt;br&gt; &lt;strong&gt;1. 位于 ROM 中的第一阶段引导程序将第二阶段引导程序映像从 flash 0x1000 地址加载到 RAM( IRAM 和 DRAM ).&lt;br&gt; 2. 第二阶段引导程序从 flash 中加载分区表和主应用程序映像.主应用程序包含 RAM 段和通过 flash cache 映射的只读段.&lt;br&gt; 3. 主应用程序映像执行.此时,可以启动第二个 CPU 和 RTOS 调度器.&lt;/strong&gt;&lt;br&gt;以下各节将详细介绍此过程.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（三）分区表</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%8C%BA%E8%A1%A8/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:21:46.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>单个 ESP32 的 flash 可以包含多个应用程序,以及许多不同类型的数据(校准数据,文件系统,参数存储等). 因此,分区表被下载到 flash 中的 0x8000 地址(默认偏移量).</p><p>分区表长度为 0xC00 字节(最多 95 个分区表条目). 在表数据之后附加 MD5 校验和. 如果分区表由于安全引导而签名,则签名将附加在分区表之后.</p><p>分区表中的每个条目都有一个 <code>name</code> (label),<code>type</code>(app,data 或其他),<code>subtype</code>以及加载分区的 flash 中的 <code>offset</code> (偏移量).</p><p>使用分区表的最简单方法是 <code>make menuconfig</code> 并选择一个简单的预定义分区表:</p><ul><li>“Single factory app, no OTA”</li><li>“Factory app, two OTA definitions”</li></ul><p>在这两种情况下,<code>factory</code> 应用程序下载到 0x10000 地址. 如果您 <code>make partition_table</code>,那么它将打印分区表的摘要.</p><a id="more"></a><h2 id="内置分区表"><a href="#内置分区表" class="headerlink" title="内置分区表"></a>内置分区表</h2><p>以下是 <code>Single factory app, no OTA</code> 的分区表配置信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Espressif ESP32 Partition Table</span><br><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  app,  factory, 0x10000, 1M,</span><br></pre></td></tr></table></figure><ul><li>flash 中的 0x10000(64KB) 偏移量被标记为 <code>factory</code> 应用程序. 默认情况下,引导加载程序将运行此应用程序.</li><li>在分区表中还定义了两个用于存储 NVS 库分区和 PHY 初始化数据的数据区域.</li></ul><p>以下是 <code>Factory app, two OTA definitions</code> 的分区表配置信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Espressif ESP32 Partition Table</span><br><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x4000,</span><br><span class="line">otadata,  data, ota,     0xd000,  0x2000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  0,    0,       0x10000, 1M,</span><br><span class="line">ota_0,    0,    ota_0,  0x110000, 1M,</span><br><span class="line">ota_1,    0,    ota_1,  0x210000, 1M,</span><br></pre></td></tr></table></figure><ul><li>现在有三个应用程序分区定义.</li><li>这三种 <code>Type</code> 都设置为 <code>app</code>,但在 0x10000 位置的 <code>factory</code> 应用程序和后面的两个 <code>OTA</code> 应用程序的子类型有所不同.</li><li>还有一个新的 <code>ota data</code> 区域,用于保存 OTA 更新的数据. 引导加载程序会查询此数据,以便了解要执行的应用程序. 如果 <code>ota data</code> 为空,它将执行 <code>factory</code> 应用程序.</li></ul><h2 id="创建自定义分区表"><a href="#创建自定义分区表" class="headerlink" title="创建自定义分区表"></a>创建自定义分区表</h2><p>如果在 menuconfig 中选择 “Custom partition table CSV”,还应该输入要用于分区表的 CSV 文件的名称(在项目目录中). CSV 文件中有将要用于分区表配置的任意数量的定义.</p><p>CSV 格式与上面摘要中打印的格式相同. 但是,CSV 中并非所有字段都是必需的. 例如,以下是 OTA 分区表的“输入” CSV:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Custom partition table</span><br><span class="line"># Name,   Type, SubType, Offset, Size, Flags</span><br><span class="line">nvs,      data, nvs,     ,       0x4000,</span><br><span class="line">otadata,  data, ota,     ,       0x2000,</span><br><span class="line">phy_init, data, phy,     ,       0x1000,</span><br><span class="line">factory,  app,  factory, ,       1M,</span><br><span class="line">ota_0,    app,  ota_0,   ,       1M,</span><br><span class="line">ota_1,    app,  ota_1,   ,       1M,</span><br></pre></td></tr></table></figure><ul><li>字段之间的空格被忽略,任何以＃(注释)开头的行也是如此.</li><li>CSV 文件中的每个非注释行都是分区定义.</li><li>每个分区的 “Offset” 字段为空. <code>gen_esp32part.py</code> 工具填充每个空白偏移量,从分区表开始并确保每个分区正确对齐.</li></ul><h3 id="名字字段"><a href="#名字字段" class="headerlink" title="名字字段"></a>名字字段</h3><p>名称字段可以是任何有意义的名称. 这对 ESP32 来说并不重要. 超过 16 个字符的名称将被截取.</p><h3 id="类型字段"><a href="#类型字段" class="headerlink" title="类型字段"></a>类型字段</h3><p>分区类型字段可以指定为 app(0) 或 data(1). 或者它可以是数字 0-254(或十六进制 0x00-0xFE). 类型 0x00-0x3F 保留用于 esp-idf 核心功能.</p><p>如果您的应用程序需要存储数据,请在 0x40-0xFE 范围内添加自定义分区类型.</p><p>引导加载程序忽略 app(0) 和 data(1) 以外的任何分区类型.</p><h3 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a>子类型</h3><p>8 位子类型字段特定于给定的分区类型.</p><p>esp-idf 当前仅指定 “app” 和 “data” 分区类型的子类型字段的含义.</p><h3 id="App-子类型"><a href="#App-子类型" class="headerlink" title="App 子类型"></a>App 子类型</h3><p>当 type 为 “app” 时,子类型字段可以指定为 factory(0),ota_0(0x10)… ota_15(0x1F) 或 test(0x20).</p><ul><li>factory(0) 是默认的应用程序分区. 引导加载程序将执行工厂应用程序,除非它看到类型为 data/ota 的分区,在这种情况下,它会读取此分区以确定要引导的 OTA 映像.<ul><li>OTA 永远不会更新 <code>factory</code> 分区.</li><li>如果要保留 OTA 项目中的闪存使用率,可以删除 <code>factory</code> 分区并改为使用 ota_0.</li></ul></li><li>ota_0(0x10)… ota_15(0x1F) 是 OTA app 区域. 有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html" target="_blank" rel="noopener">OTA文档</a>,然后使用 OTA 数据分区配置引导加载程序应引导的应用程序. 如果使用 OTA,则应用程序应至少具有两个 OTA 应用程序槽(<code>ota_0</code>＆<code>ota_1</code>). 有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html" target="_blank" rel="noopener">OTA文档</a>.</li><li>test(0x2) 是 <code>factory</code> 测试程序的保留子类型. esp-idf 引导程序当前不支持它.</li></ul><h3 id="数据子类型"><a href="#数据子类型" class="headerlink" title="数据子类型"></a>数据子类型</h3><p>当 type 为 “data” 时,子类型字段可以指定为 ota(0),phy(1),nvs(2).</p><ul><li>ota(0) 是<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html#ota-data-partition" target="_blank" rel="noopener">OTA数据分区</a>,它存储有关当前所选 OTA 应用程序的信息.此分区的大小应为 0x2000 字节.有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html#ota-data-partition" target="_blank" rel="noopener">OTA文档</a>.</li><li>phy(1) 用于存储 PHY 初始化数据.这允许 PHY 到每个设备被配置,而不是在固件.<ul><li>在默认配置中,不使用 phy 分区,并且 PHY 初始化数据被编译到 app 本身.因此,可以从分区表中删除此分区以节省空间.</li><li>要从此分区加载 PHY 数据,请运行 <code>make menuconfig</code> 并启用 <code>CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</code> 选项.您还需要使用 <code>phy init</code> 数据刷新(flash)设备,因为 esp-idf 构建系统不会自动执行此操作.</li></ul></li><li>nvs(2) 用于<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/storage/nvs_flash.html" target="_blank" rel="noopener">非易失性存储(NVS)API</a>.<ul><li>NVS 用于存储每个设备 PHY 校准数据(与初始化数据不同).</li><li>如果使用<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/wifi/esp_wifi.html" target="_blank" rel="noopener">esp_wifi_set_storage(WIFI_STORAGE_FLASH)</a>初始化功能,则 NVS 用于存储 WiFi 数据.</li><li>NVS API 还可用于其他应用程序数据.</li><li>强烈建议您在项目中包含至少 0x3000 字节的 NVS 分区.</li><li>如果使用 NVS API 存储大量数据,请将 NVS 分区默认的 0x6000 字节大小增加.</li></ul></li></ul><p>其他数据子类型保留用于将来的 esp-idf 用途.</p><h3 id="偏移量-amp-大小"><a href="#偏移量-amp-大小" class="headerlink" title="偏移量 &amp; 大小"></a>偏移量 &amp; 大小</h3><p>具有空白偏移的分区将在前一个分区之后开始,或者第一个分区是在分区表之后开始.</p><p>应用程序分区必须处于与 0x10000(64K) 对齐的偏移量. 如果将偏移字段留空,工具将自动对齐分区. 如果为应用程序分区指定未对齐的偏移量,该工具将返回错误.</p><p>大小和偏移量可以指定为十进制数,带前缀 0x 的十六进制数,或大小乘数 K 或 M(1024 和 1024 * 1024 字节).</p><p>如果希望分区表中的分区与表本身的任何起始偏移量(<code>CONFIG_PARTITION_TABLE_OFFSET</code>)一起使用,请将所有分区的偏移字段(在 CSV 文件中)留空. 类似地,如果更改分区表偏移,则要注意所有空白分区偏移可能会更改为匹配,并且任何固定偏移现在可能与分区表冲突(导致错误).</p><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>目前仅支持一个加密的标志. 如果此字段设置为加密,则在启用 Flash 加密时将对此分区进行加密.</p><p>(请注意,无论是否设置此标志,应用程序类型分区都将始终加密.)</p><h2 id="生成二进制分区表"><a href="#生成二进制分区表" class="headerlink" title="生成二进制分区表"></a>生成二进制分区表</h2><p>下载到 ESP32 的分区表是二进制格式,而不是 CSV 格式. 工具 <code>partition_table/gen_esp32part.py</code> 用于在 CSV 和二进制格式之间进行转换.</p><p>如果在 <code>make menuconfig</code> 中配置分区表 CSV 名称,然后生成 <code>partition_table</code>,则此转换将在构建过程中完成.</p><p>要手动将 CSV 转换为二进制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python gen_esp32part.py input_partitions.csv binary_partitions.bin</span><br></pre></td></tr></table></figure><p>要将二进制格式转换回 CSV:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python gen_esp32part.py binary_partitions.bin input_partitions.csv</span><br></pre></td></tr></table></figure><p>在 stdout 上显示二进制分区表的内容(这是生成 <code>make partition_table</code> 时显示的摘要的方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python gen_esp32part.py binary_partitions.bin</span><br></pre></td></tr></table></figure><h3 id="MD5-校验和"><a href="#MD5-校验和" class="headerlink" title="MD5 校验和"></a>MD5 校验和</h3><p>分区表的二进制格式包含基于分区表计算的 MD5 校验和. 此校验和用于在引导期间检查分区表的完整性.</p><p>可以通过 <code>gen_esp32part.py</code> 的 <code>--disable-md5sum</code> 选项或 <code>CONFIG_PARTITION_TABLE_MD5</code> 选项禁用 MD5 校验和生成. 例如,当使用传统引导加载程序无法处理 MD5 校验和且引导失败并且错误消息无效幻数 0xebeb 时,这很有用.</p><h2 id="烧录分区表"><a href="#烧录分区表" class="headerlink" title="烧录分区表"></a>烧录分区表</h2><ul><li><code>make partition_table-flash</code>:将使用 `esptool.py 下载分区表.</li><li><code>make flash</code>:会下载所有固件,包括分区表.</li></ul><p>手动下载命令也会打印在 <code>make partition_table</code> 中.</p><p>请注意,更新分区表不会擦除已根据旧分区表存储的数据. 您可以使用 <code>make erase_flash</code> (或 <code>esptool.py erase_flash</code>)来擦除整个闪存内容.</p><p><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分区表&quot;&gt;&lt;a href=&quot;#分区表&quot; class=&quot;headerlink&quot; title=&quot;分区表&quot;&gt;&lt;/a&gt;分区表&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;单个 ESP32 的 flash 可以包含多个应用程序,以及许多不同类型的数据(校准数据,文件系统,参数存储等). 因此,分区表被下载到 flash 中的 0x8000 地址(默认偏移量).&lt;/p&gt;
&lt;p&gt;分区表长度为 0xC00 字节(最多 95 个分区表条目). 在表数据之后附加 MD5 校验和. 如果分区表由于安全引导而签名,则签名将附加在分区表之后.&lt;/p&gt;
&lt;p&gt;分区表中的每个条目都有一个 &lt;code&gt;name&lt;/code&gt; (label),&lt;code&gt;type&lt;/code&gt;(app,data 或其他),&lt;code&gt;subtype&lt;/code&gt;以及加载分区的 flash 中的 &lt;code&gt;offset&lt;/code&gt; (偏移量).&lt;/p&gt;
&lt;p&gt;使用分区表的最简单方法是 &lt;code&gt;make menuconfig&lt;/code&gt; 并选择一个简单的预定义分区表:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“Single factory app, no OTA”&lt;/li&gt;
&lt;li&gt;“Factory app, two OTA definitions”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这两种情况下,&lt;code&gt;factory&lt;/code&gt; 应用程序下载到 0x10000 地址. 如果您 &lt;code&gt;make partition_table&lt;/code&gt;,那么它将打印分区表的摘要.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（二）构建系统</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:21:46.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h1><p>本文档解释了 Espressif 物联网开发框架构建系统和“组件”的概念.</p><p>如果您想知道如何组织新的 <code>ESP-IDF</code> 项目,请阅读本文档.</p><p>我们建议使用 <a href="https://github.com/espressif/esp-idf-template" target="_blank" rel="noopener">esp-idf-template</a> 项目作为项目的起点.</p><a id="more"></a><h2 id="使用构建系统"><a href="#使用构建系统" class="headerlink" title="使用构建系统"></a>使用构建系统</h2><p>esp-idf 中的 <code>README</code> 文件有如何使用构建系统构建项目的说明.</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>一个 <code>ESP-IDF</code> 项目可以看作是多个组件的组合.例如,对于显示当前湿度的网络服务器,可能有:</p><ul><li>ESP32 基础库( libc,rom bindings 等)</li><li>WiFi 驱动</li><li>TCP / IP 协议堆栈</li><li>FreeRTOS 操作系统</li><li>Web 服务器</li><li>湿度传感器驱动</li><li>主程序</li></ul><p><code>ESP-IDF</code> 使这些组件结构更清晰并具有可配置性.为此,在编译项目时,构建环境将查找 <code>ESP-IDF</code> 目录、项目目录和(可选)其他自定义组件目录中的所有组件.之后,它允许用户使用基于文本的菜单系统去自定义每个组件来配置 <code>ESP-IDF</code> 项目.在配置完项目中的组件之后,构建程序将编译项目.</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>“项目”是一个目录,其中包含构建单个 “app” (可执行文件)所需的文件和配置,以及其他附加文件,如:分区表,数据/文件系统分区和引导程序.</li><li>“项目配置”保存在项目根目录中的 <code>sdkconfig</code>  文件中.通过 <code>make menuconfig</code> 修改此文件以自定义项目配置.单个项目只包含一个项目配置.</li><li>“app” 是由 esp-idf 构建的可执行文件.单个项目通常会构建两个应用程序 - 一个“项目应用程序”(主要可执行文件,即您的自定义固件)和一个“引导程序”(启动项目应用程序的初始引导程序).</li><li>“组件”是独立代码的模块化部分,它们被编译成静态库(.a文件)并链接到应用程序.有些是由 esp-idf 本身提供的,有些则可能来自其他地方.</li></ul><p>有些东西不是项目的一部分:</p><ul><li>“ESP-IDF” 不是该项目的一部分.相反,它是独立的,并通过 <code>IDF_PATH</code> 环境变量链接到项目,该变量保存 <code>esp-idf</code> 目录的路径.这允许 IDF 框架与您的项目分离.</li><li>用于编译的工具链不是项目的一部分.工具链应安装在系统命令行 <code>PATH</code> 中,或者工具链的路径设置为项目配置中编译器前缀的一部分.</li></ul><h3 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h3><p>一个示例项目目录结构可能如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- myProject&#x2F;</span><br><span class="line">            - Makefile</span><br><span class="line">            - sdkconfig</span><br><span class="line">            - components&#x2F; - component1&#x2F; - component.mk</span><br><span class="line">                                        - Kconfig</span><br><span class="line">                                        - src1.c</span><br><span class="line">                          - component2&#x2F; - component.mk</span><br><span class="line">                                        - Kconfig</span><br><span class="line">                                        - src1.c</span><br><span class="line">                                        - include&#x2F; - component2.h</span><br><span class="line">            - main&#x2F;       - src1.c</span><br><span class="line">                          - src2.c</span><br><span class="line">                          - component.mk</span><br><span class="line"></span><br><span class="line">            - build&#x2F;</span><br></pre></td></tr></table></figure><p>“myProject” 示例包含以下元素:</p><ul><li>顶层项目 Makefile .此 Makefile 设置 <code>PROJECT_NAME</code> 变量,并(可选)定义项目范围的 make 变量.它包括核心的 <code>$(IDF_PATH)/make/project.mk</code> Makefile 文件,它实现了 <code>ESP-IDF</code> 构建系统的其余部分.</li><li>“sdkconfig” 项目配置文件.当 “make menuconfig” 运行时,将创建/更新此文件,并保存项目中所有组件的配置(包括 esp-idf 本身).“sdkconfig” 文件可能会也可能不会添加到项目的源代码管理系统中.</li><li>可选的 “components” 目录包含属于项目一部分的组件.项目不必包含此类自定义组件,但它可用于构造可重用代码或包括不属于 ESP-IDF 的第三方组件.</li><li>“main” 目录是一个特殊的“伪组件(pseudo-component)”,它包含项目本身的源代码.“main” 是默认名称,Makefile 变量<code>COMPONENT_DIRS</code>包含此组件,但您可以修改此变量(或设置 <code>EXTRA_COMPONENT_DIRS</code>)以查找其他位置的组件.</li><li>“build” 目录是项目编译时创建的,包含项目编译时产生的文件.运行 make 后,该目录被创建,并包含临时目标文件和库以及最终的二进制输出文件 <code>bin</code>.此目录通常不会添加到源代码管理中,也不会随项目源代码一起发布.</li></ul><p>组件目录包含一个组件 makefile 文件 - <code>component.mk</code>.这可能包含变量定义,以控制组件的构建过程,以及它与整个项目的集成.有关更多详细信息,请参阅[组件Makefile](#组件 Makefile).</p><p>每个组件还可以包括一个 <code>Kconfig</code> 文件,用于定义通过项目配置设置的组件配置选项.某些组件还可能包含 <code>Kconfig.projbuild</code> 和 <code>Makefile.projbuild</code> 文件,这些文件是用于覆盖项目部分的特殊文件.</p><h3 id="项目-Makefile"><a href="#项目-Makefile" class="headerlink" title="项目 Makefile"></a>项目 Makefile</h3><p>每个项目都有一个 Makefile,其中包含整个项目的构建配置.默认情况下,项目 Makefile 可以非常小.</p><h4 id="最小示例-Makefile"><a href="#最小示例-Makefile" class="headerlink" title="最小示例 Makefile"></a>最小示例 Makefile</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROJECT_NAME :&#x3D; myProject</span><br><span class="line"></span><br><span class="line">include $(IDF_PATH)&#x2F;make&#x2F;project.mk</span><br></pre></td></tr></table></figure><h4 id="强制项目变量"><a href="#强制项目变量" class="headerlink" title="强制项目变量"></a>强制项目变量</h4><ul><li>PROJECT_NAME:项目名称.二进制输出文件将使用此名称 - 即 myProject.bin, myProject.elf.</li></ul><h4 id="可选项目变量"><a href="#可选项目变量" class="headerlink" title="可选项目变量"></a>可选项目变量</h4><p>这些变量都有默认值,并可以被自定义操作覆盖.查看 <code>make/project.mk</code> 以获取所有实现细节.</p><ul><li><code>PROJECT_PATH</code>:顶级项目目录.默认为包含 Makefile 的目录.许多其他项目变量都基于此变量.项目路径不能包含空格.</li><li><code>BUILD_DIR_BASE</code>:所有 objects/libraries/binaries 文件的构建输出目录.默认为<code>$(PROJECT_PATH)/build</code>.</li><li><code>COMPONENT_DIRS</code>:搜索组件的目录.默认为<code>$(IDF_PATH)/components</code>( idf 组件),<code>$(PROJECT_PATH)/components</code>(项目组件),<code>$(PROJECT_PATH)/main</code> 和 <code>EXTRA_COMPONENT_DIRS</code> (其他组件).如果您不想在这些位置搜索组件,请覆盖此变量.</li><li><code>EXTRA_COMPONENT_DIRS</code>:用于搜索组件的其他目录的可选列表.</li><li><code>COMPONENTS</code>:要构建到项目中的组件名称列表.默认为<code>COMPONENT_DIRS</code>目录中的所有组件.</li><li><code>EXCLUDE_COMPONENTS</code>:在构建过程中要排除的组件名称的可选列表.请注意,这会减少构建时间,但不会减少二进制大小.</li><li><code>TEST_EXCLUDE_COMPONENTS</code>:在单元测试的构建过程中要排除的可选组件名称列表.</li></ul><p>这些 Makefile 变量中的任何路径都应该是绝对路径.您可以使用<code>$(PROJECT_PATH)/ xxx</code>,<code>$(IDF_PATH)/ xxx</code>转换相对路径,或使用 Make 函数<code>$(abspath xxx)</code>.</p><p>这些都变量应该在 Makefile 中的 <code>include $(IDF_PATH)/make/project.mk</code> 行之前设置.</p><h3 id="组件-Makefile"><a href="#组件-Makefile" class="headerlink" title="组件 Makefile"></a>组件 Makefile</h3><p>每个项目都包含一个或多个组件,这些组件可以是 esp-idf 的一部分,也可以从其他组件目录添加.</p><p>组件是包含 <code>component.mk</code> 文件的任何目录.</p><h3 id="搜索组件"><a href="#搜索组件" class="headerlink" title="搜索组件"></a>搜索组件</h3><p>在<code>COMPONENT_DIRS</code>中的目录列表中搜索项目的组件.此列表中的目录可以是组件本身(即它们包含 <code>component.mk</code> 文件),也可以是子目录为组件的顶级目录(包含组件的目录).</p><p>运行 <code>make list-components</code> 后,会输出这些变量,这可以帮助调试组件目录是否被找到.</p><h4 id="具有相同名称的多个组件"><a href="#具有相同名称的多个组件" class="headerlink" title="具有相同名称的多个组件"></a>具有相同名称的多个组件</h4><p>当 esp-idf 找到所有要编译的组件时,它将按照 <code>COMPONENT_DIRS</code> 指定的顺序执行此操作; 默认情况下,首先是 idf 组件,第二个是项目组件,最后是 <code>EXTRA_COMPONENT_DIRS</code> 中的组件.如果这些目录中的两个或多个包含具有相同名称的组件子目录,则使用搜索的最后一个位置中的组件.例如,这允许通过简单地将组件从 esp-idf 组件目录复制到项目组件树然后在那里修改它来覆盖具有修改版本的 esp-idf 组件.如果以这种方式使用,esp-idf 目录本身可以保持不变.</p><h4 id="最小组件-Makefile"><a href="#最小组件-Makefile" class="headerlink" title="最小组件 Makefile"></a>最小组件 Makefile</h4><p>最小的 <code>component.mk</code> 文件是一个空文件.如果文件为空,则设置默认组件行为:</p><ul><li>与 makefile 在相同的目录中的所有源文件(<code>*.c</code>,<code>*.cpp</code>,<code>*.cc</code>,<code>*.S</code>)将被编译到组件库中</li><li>子目录 “include” 将被添加到所有其他组件的全局 include 搜索路径中.</li><li>组件库将链接到项目应用程序中.</li></ul><p>有关更完整的示例组件 makefile,请参阅[示例组件 makefile](#示例组件 Makefile).</p><p>请注意,空的 <code>component.mk</code> 文件(调用默认组件构建行为)和没有 <code>component.mk</code> 文件(这意味着不会发生默认组件构建行为)之间存在差异.组件可能没有 <code>component.mk</code> 文件,如果它只包含影响项目配置或构建过程的其他文件.</p><h4 id="预设组件变量"><a href="#预设组件变量" class="headerlink" title="预设组件变量"></a>预设组件变量</h4><p>以下特定组件的变量可在<code>component.mk</code>中使用,但不应修改:</p><ul><li><code>COMPONENT_PATH</code>:组件目录.计算包含 <code>component.mk</code> 的目录的绝对路径.组件路径不能包含空格.</li><li><code>COMPONENT_NAME</code>:组件的名称.默认为组件目录的名称.</li><li><code>COMPONENT_BUILD_DIR</code>:组件构建目录.计算 <code>$(BUILD_DIR_BASE)</code> 中要构建此组件源文件的目录的绝对路径.每次构建组件时,这也是当前工作目录,因此 make 等目标中的相对路径都是相对于此目录.</li><li><code>COMPONENT_LIBRARY</code>:将为此组件构建的静态库文件的名称(相对于组件构建目录).默认为 <code>$(COMPONENT_NAME).a</code>.</li></ul><p>以下变量在项目级别设置,但会导出在组件构建中使用:</p><ul><li><code>PROJECT_NAME</code>:项目名称,在项目 Makefile 中设置</li><li><code>PROJECT_PATH</code>:包含项目 Makefile 的项目目录的绝对路径.</li><li><code>COMPONENTS</code>:此构建中包含的所有组件的名称.</li><li><code>CONFIG_ *</code>:项目配置中的每个值都有一个 make 中可用的对应变量.所有名称都以 <code>CONFIG_</code> 开头.</li><li><code>CC</code>,<code>LD</code>,<code>AR</code>,<code>OBJCOPY</code>:gcc xtensa 交叉工具链中每个工具的完整路径.</li><li><code>HOSTCC</code>,<code>HOSTLD</code>,<code>HOSTAR</code>:来自主机本机工具链的每个工具的全名.</li><li><code>IDF_VER</code>:ESP-IDF 版本,使用 git 命令 <code>git describe</code> 从 <code>$(IDF_PATH)/version.txt</code> 文件(如果存在)中检索.这里推荐的格式是单独的一行指定主要 IDF 发布版本,例如标记版本的 <code>v2.0</code> 或任意提交的 <code>v2.0-275-g0efaa4f</code>.应用程序可以通过调用 <code>esp_get_idf_version()</code> 来使用它.</li><li><code>PROJECT_VER</code>: 项目版本<ul><li>如果 <code>PROJECT_VER</code> 变量在项目 Makefile 文件中设置，则将使用其值。</li><li>否则，如果 <code>$PROJECT_PATH/version.txt</code> 存在，其内容将用作 <code>PROJECT_VER</code>。</li><li>否则，如果项目位于 Git 存储库中，则将使用git describe的输出。</li><li>否则，<code>PROJECT_VER</code> 将为“1”。</li></ul></li></ul><p>如果您修改 <code>component.mk</code> 中的任何这些变量,那么这不会阻止构建其他组件,但它可能使您的组件难以构建或者调试.</p><h4 id="可选项目范围的组件变量"><a href="#可选项目范围的组件变量" class="headerlink" title="可选项目范围的组件变量"></a>可选项目范围的组件变量</h4><p>可以在 <code>component.mk</code> 中设置以下变量来控制整个项目中的构建设置:</p><ul><li><code>COMPONENT_ADD_INCLUDEDIRS</code>:相对于组件目录的路径,将添加到项目中所有组件的 “include” 搜索路径.如果未被覆盖,则默认<code>include</code>.如果仅需要编译此特定组件的 “include” 目录,请将其添加到 <code>COMPONENT_PRIV_INCLUDEDIRS</code></li><li><code>COMPONENT_ADD_LDFLAGS</code>:为 LDFLAGS 添加链接器参数以用于应用程序可执行文件.默认为 <code>-l$(COMPONENT_NAME)</code>.如果将预编译库添加到此目录,请将它们添加为绝对路径 <code>-e$(COMPONENT_PATH)/libwhatever.a</code></li><li><code>COMPONENT_DEPENDS</code>:应在此组件之前编译的组件名称的可选列表.对于链接时依赖性,这不是必需的,因为所有组件”include”目录始终可用.如果一个组件生成一个”include”文件,然后您想要包含在另一个组件中,则这是必要的.大多数组件不需要设置此变量.</li><li><code>COMPONENT_ADD_LINKER_DEPS</code>:相对组件路径的文件的可选列表，如果它们发生更改，应触发 ELF 文件的重新链接。 通常用于链接描述文件和二进制库。大多数组件不需要设置此变量。</li></ul><p>以下变量仅适用于属于 esp-idf 本身的组件:</p><ul><li><code>COMPONENT_SUBMODULES</code>:组件使用的 git 子模块路径(相对于 COMPONENT_PATH)的可选列表.这些将由构建过程检查(并在必要时初始化).如果组件位于 IDF_PATH 目录之外,则忽略此变量.</li></ul><h4 id="可选特定的组件变量"><a href="#可选特定的组件变量" class="headerlink" title="可选特定的组件变量"></a>可选特定的组件变量</h4><p>可以在<code>component.mk</code>中设置以下变量来控制该组件的构建:</p><ul><li><code>COMPONENT_PRIV_INCLUDEDIRS</code>:目录路径,必须相对于组件目录,该组件目录将仅添加到此组件源文件的”include”搜索路径中.</li><li><code>COMPONENT_EXTRA_INCLUDES</code>:编译组件源文件时使用的任何额外包含路径.这些将以’-I’为前缀,并按原样传递给编译器.与<code>COMPONENT_PRIV_INCLUDEDIRS</code>变量类似,但这些路径不会相对于组件目录进行扩展.</li><li><code>COMPONENT_SRCDIRS</code>:目录路径,必须相对于组件目录,将用以搜索源文件(<code>* .cpp</code>,<code>* .c</code>,<code>* .S</code>).默认为’.’,即组件目录本身.覆盖它以指定包含源文件的不同目录列表.</li><li><code>COMPONENT_OBJS</code>:要编译的对象文件.默认值是<code>COMPONENT_SRCDIRS</code>中找到的每个源文件的 a.o 文件.覆盖此列表允许您排除<code>COMPONENT_SRCDIRS</code>中的源文件,否则将被编译.请参阅指定源文件</li><li><code>COMPONENT_EXTRA_CLEAN</code>:相对于组件构建目录的路径,使用<code>component.mk</code>文件中的自定义make规则生成的任何文件,以及作为make clean的一部分需要删除的文件.有关示例,请参阅<a href="#_428">源代码生成</a>.</li><li><code>COMPONENT_OWNBUILDTARGET</code>＆<code>COMPONENT_OWNCLEANTARGET</code>:这些目标允许您完全覆盖组件的默认构建行为.有关详细信息,请参阅[完全覆盖组件 Makefile](#完全覆盖组件 Makefile).</li><li><code>COMPONENT_CONFIG_ONLY</code>:如果设置,则此标志指示组件根本不生成任何内置输出(即未构建 <code>COMPONENT_LIBRARY</code>),并忽略大多数其他组件变量.此标志用于 IDF 内部组件,其中仅包含 KConfig.projbuild 和/或 Makefile.projbuild 文件以配置项目,但没有源文件.</li><li><code>CFLAGS</code>:传递给 C 编译器的标志.根据项目设置定义一组默认 <code>CFLAGS</code>.可以通过 <code>CFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li><li><code>CPPFLAGS</code>:传递给 C 预处理器的标志(用于. c , .cpp 和 .S 文件).根据项目设置定义一组默认的 <code>CPPFLAGS</code>.可以通过 <code>CPPFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li><li><code>CXXFLAGS</code>:传递给 C++ 编译器的标志.根据项目设置定义一组默认的 <code>CXXFLAGS</code>.可以通过 <code>CXXFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li></ul><p>要将编译标志应用于单个源文件,可以将变量覆盖添加为目标,即:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apps&#x2F;dhcpserver.o: CFLAGS +&#x3D; -Wno-unused-variable</span><br></pre></td></tr></table></figure><h3 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h3><p>每个组件还可以有一个 Kconfig 文件,与 <code>component.mk</code> 在同一目录下.Kconfig 中包含要添加到此组件的 “make menuconfig” 的配置设置.</p><p>运行 menuconfig 时,可在 “Component Settings” 菜单下找到这些设置.</p><p>要创建组件 KConfig 文件,最简单的方法是使用 esp-idf 中的 KConfig 文件做修改.</p><p>有关示例,请参阅<a href="#添加条件配置">添加条件配置</a>.</p><h3 id="示例：添加二进制库、组件配置文件-Kconfig"><a href="#示例：添加二进制库、组件配置文件-Kconfig" class="headerlink" title="示例：添加二进制库、组件配置文件 Kconfig"></a>示例：添加二进制库、组件配置文件 Kconfig</h3><p><img src="https://img-blog.csdnimg.cn/20190131111141734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># Component Makefile</span><br><span class="line">#</span><br><span class="line">ifdef CONFIG_BT_ENABLED</span><br><span class="line"></span><br><span class="line">COMPONENT_SRCDIRS :&#x3D; .</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_INCLUDEDIRS :&#x3D; include</span><br><span class="line"></span><br><span class="line"># add pre-compiled libraries</span><br><span class="line">LIBS :&#x3D; btdm_app</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_LDFLAGS     :&#x3D; -lbt -L $(COMPONENT_PATH)&#x2F;lib \</span><br><span class="line">                           $(addprefix -l,$(LIBS))</span><br><span class="line"></span><br><span class="line"># re-link program if BT binary libs change</span><br><span class="line">COMPONENT_ADD_LINKER_DEPS :&#x3D; $(patsubst %,$(COMPONENT_PATH)&#x2F;lib&#x2F;lib%.a,$(LIBS))</span><br><span class="line"></span><br><span class="line">COMPONENT_SUBMODULES +&#x3D; lib</span><br><span class="line"></span><br><span class="line">ifeq ($(GCC_NOT_5_2_0), 1)</span><br><span class="line"># TODO: annotate fallthroughs in Bluedroid code with comments</span><br><span class="line">CFLAGS +&#x3D; -Wno-implicit-fallthrough</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifdef CONFIG_BLUEDROID_ENABLED</span><br><span class="line"></span><br><span class="line">COMPONENT_PRIV_INCLUDEDIRS +&#x3D;   bluedroid&#x2F;bta&#x2F;include                   \</span><br><span class="line">                                bluedroid&#x2F;bta&#x2F;ar&#x2F;include</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_INCLUDEDIRS +&#x3D;    bluedroid&#x2F;api&#x2F;include&#x2F;api</span><br><span class="line"></span><br><span class="line">COMPONENT_SRCDIRS +&#x3D;    bluedroid&#x2F;bta&#x2F;dm                      \</span><br><span class="line">                        bluedroid&#x2F;bta&#x2F;gatt </span><br><span class="line"></span><br><span class="line">ifeq ($(GCC_NOT_5_2_0), 1)</span><br><span class="line">bluedroid&#x2F;bta&#x2F;sdp&#x2F;bta_sdp_act.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;btc&#x2F;core&#x2F;btc_config.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;stack&#x2F;btm&#x2F;btm_sec.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;stack&#x2F;smp&#x2F;smp_keys.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h3 id="预处理器定义"><a href="#预处理器定义" class="headerlink" title="预处理器定义"></a>预处理器定义</h3><p>ESP-IDF 构建系统在命令行上添加以下 C 预处理器定义:</p><ul><li><code>ESP_PLATFORM</code> - 可用于检测在 ESP-IDF 内发生的构建.</li><li><code>IDF_VER</code> - ESP-IDF 版本,有关详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/build-system.html#preset-component-variables" target="_blank" rel="noopener">预设组件变量</a>.</li><li><code>PROJECT_VER</code>：项目版本，有关详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/build-system.html#preset-component-variables" target="_blank" rel="noopener">预设组件变量</a>.</li><li><code>PROJECT_NAME</code>：项目名称，在项目 Makefile 中设置.</li></ul><h3 id="构建过程内部"><a href="#构建过程内部" class="headerlink" title="构建过程内部"></a>构建过程内部</h3><h4 id="顶级-Project-Makefile"><a href="#顶级-Project-Makefile" class="headerlink" title="顶级:Project Makefile"></a>顶级:Project Makefile</h4><ul><li>“make” 总是从项目目录和项目 makefile 运行,通常名为 Makefile.</li><li>项目 makefile 设置 <code>PROJECT_NAME</code>,并可选择自定义其他可选项目变量</li><li>项目 makefile 包含 <code>$(IDF_PATH)/make/project.mk</code>,其中包含项目级的 Make 逻辑.</li><li><code>project.mk</code> 填写默认的项目级 make 变量,并包含项目配置中的 make 变量.如果生成的包含项目配置的 makefile 已过期,则会重新生成(通过 <code>project_config.mk</code> 中的 targets),然后 make 进程从顶部重新开始.</li><li><code>project.mk</code> 根据默认组件目录或可选项目变量中设置的自定义组件列表构建需要要构建的组件列表.</li><li>每个组件都可以设置一些<a href="#可选项目范围的组件变量">可选项目范围的组件变量</a>.这些包含在 <code>component_project_vars.mk</code> 生成的 makefile 中 - 每个组件有一个.这些生成的 makefile 包含在 <code>project.mk</code>中.如果有任何缺失或过时,它们将被重新生成(通过对组件 makefile 的递归调用),然后 make 进程从顶部重新开始.</li><li>组件中的 Makefile.projbuild 文件包含在 make 进程中,以添加额外的目标或配置.</li><li>默认情况下,项目 makefile 还为每个组件生成顶级构建和清理目标,并设置 app 和 clean 目标以调用这些子目标.</li><li>为了编译每个组件,对组件 makefile 执行递归 make.</li></ul><p>为了更好地理解项目构建过程,请通读 <code>project.mk</code> 文件本身.</p><h4 id="第二级-组件Makefile"><a href="#第二级-组件Makefile" class="headerlink" title="第二级:组件Makefile"></a>第二级:组件Makefile</h4><ul><li>每次调用组件 makefile 都是通过 <code>$(IDF_PATH)/make/component_wrapper.mk</code> 包装器 makefile 进行的.</li><li>此组件包装器包含所有组件 <code>Makefile.componentbuild</code> 文件,使这些文件中的任何配方,变量等可用于每个组件.</li><li>调用<code>component_wrapper.mk</code>时将当前目录设置为组件构建目录,并将<code>COMPONENT_MAKEFILE</code>变量设置为<code>component.mk</code>的绝对路径.</li><li><code>component_wrapper.mk</code>为所有组件变量设置默认值,然后包括可以覆盖或修改这些变量的component.mk文件.</li><li>如果未定义 <code>COMPONENT_OWNBUILDTARGET</code> 和 <code>COMPONENT_OWNCLEANTARGET</code>,则会为组件的源文件和必备组件 <code>COMPONENT_LIBRARY</code> 静态库文件创建缺省构建和清除目标.</li><li><code>component_project_vars.mk</code> 文件在 <code>component_wrapper.mk</code> 中有自己的目标,如果由于组件 makefile 或项目配置的更改而需要重建此文件,则从 <code>project.mk</code> 进行评估.</li></ul><p>为了更好地理解组件制作过程,请通读 <code>component_wrapper.mk</code> 文件和 esp-idf 中包含的一些 <code>component.mk</code> 文件.</p><h3 id="以非交互方式运行"><a href="#以非交互方式运行" class="headerlink" title="以非交互方式运行"></a>以非交互方式运行</h3><p>在不希望交互式提示的情况下运行 <code>make</code> 时(例如:在 IDE 或自动构建系统中)将 <code>BATCH_BUILD = 1</code> 附加到 make 参数(或将其设置为环境变量).</p><p>设置 <code>BATCH_BUILD</code> 意味着以下内容:</p><ul><li>详细输出(与 <code>V = 1</code> 相同,见下文).如果您不想要详细输出,设置 <code>V = 0</code>.</li><li>如果项目配置缺少新配置项(来自新组件或 esp-idf 更新),则项目使用默认值,而不是提示用户输入每个项目.</li><li>如果构建系统需要调用<code>menuconfig</code>,则会打印错误并且构建失败.</li></ul><h3 id="高级-Make-用法"><a href="#高级-Make-用法" class="headerlink" title="高级 Make 用法"></a>高级 Make 用法</h3><ul><li><code>make app</code>，<code>make bootloader</code>，<code>make partition table</code> 可用于仅根据需要从项目中构建 <code>app</code>，<code>bootloader</code> 或 <code>partition table</code>。</li><li><code>make erase_flash</code> 和 <code>make erase_ota</code> 将分别使用 <code>esptool.py</code> 从 Flash 中擦除整个 Flash 和 OTA 分区选择配置。</li><li><code>make size</code> 打印有关应用程序的一些大小信息。<code>make size-components</code> 和 <code>make size-files</code> 是类似的目标，分别打印更详细的每个组件或每个源文件信息。</li></ul><h3 id="调试-Make-Process"><a href="#调试-Make-Process" class="headerlink" title="调试 Make Process"></a>调试 Make Process</h3><p>调试 esp-idf 构建系统的一些技巧:</p><ul><li>将 <code>V = 1</code> 附加到 make 参数(或将其设置为环境变量)将使 make 回显所有已执行的命令,以及为 sub-make 输入的每个目录.</li><li>运行 <code>make -w</code> 将导致 make 在为 sub-make 输入时回显每个目录 - 与 <code>V = 1</code> 相同但不回显所有命令.</li><li>运行 <code>make --trace</code> (可能除了上述参数之一)将打印出构建时的每个目标,以及导致它构建的依赖项.</li><li>运行 <code>make -p</code> 会打印每个 makefile 中每个生成的目标的(非常详细的)摘要.</li></ul><p>有关更多调试技巧和一般制作信息,请参阅 GNU制作手册.</p><h4 id="警告未定义的变量"><a href="#警告未定义的变量" class="headerlink" title="警告未定义的变量"></a>警告未定义的变量</h4><p>默认情况下,如果引用了未定义的变量(如<code>$(DOES_NOT_EXIST)</code>),构建过程将打印警告.这对于查找变量名称中的错误非常有用.</p><p>如果您不想要此行为,可以在 SDK 工具配置下的 menuconfig 顶级菜单中禁用它.</p><p>请注意,如果在 Makefile 中使用<code>ifdef</code>或<code>ifndef</code>,则此选项不会触发警告.</p><h3 id="覆盖项目的部分内容"><a href="#覆盖项目的部分内容" class="headerlink" title="覆盖项目的部分内容"></a>覆盖项目的部分内容</h3><h4 id="Makefile-projbuild"><a href="#Makefile-projbuild" class="headerlink" title="Makefile.projbuild"></a>Makefile.projbuild</h4><p>对于具有必须在顶级项目 make pass 中进行求值的构建要求的组件,可以在组件目录中创建名为 <code>Makefile.projbuild</code> 的文件.在计算 <code>project.mk</code> 时会包含此 makefile.</p><p>例如,如果您的组件需要为整个项目添加 CFLAGS (不仅仅是为了自己的源文件),那么您可以在 Makefile.projbuild 中设置 <code>CFLAGS +=</code>.</p><p><code>Makefile.projbuild</code> 文件在 esp-idf 中大量使用,用于定义项目范围的构建功能,例如 <code>esptool.py</code> 命令行参数和 <code>bootloader</code> “特殊应用程序”.</p><p>请注意,<code>Makefile.projbuild</code> 对于最常见的组件使用不是必需的 - 例如向项目添加 include 目录,或者将 LDFLAGS 添加到最终链接步骤.可以通过 <code>component.mk</code> 文件本身自定义这些值.有关详细信息,请参阅<a href="#可选项目范围的组件变量">可选项目范围的组件变量</a>.</p><p>在此文件中设置变量或目标时要小心.由于这些值包含在顶级项目 makefile 中,因此它们可以影响或破坏所有组件的功能！</p><h4 id="KConfig-projbuild"><a href="#KConfig-projbuild" class="headerlink" title="KConfig.projbuild"></a>KConfig.projbuild</h4><p>这相当于 <code>Makefile.projbuild</code> 的组件配置 KConfig 文件.如果要在 menuconfig 的顶层包含配置选项,而不是在 “Component Configuration” 子菜单中,则可以在 <code>component.mk</code> 文件旁边的 KConfig.projbuild 文件中定义这些选项.</p><p>在此文件中添加配置值时要小心,因为它们将包含在整个项目配置中.在可能的情况下,通常最好为组件配置创建 KConfig 文件.</p><h4 id="Makefile-componentbuild"><a href="#Makefile-componentbuild" class="headerlink" title="Makefile.componentbuild"></a>Makefile.componentbuild</h4><p>对于组件例如,包括从其他文件生成源文件的工具,必须能够将配置,宏或变量定义添加到每个组件的组件构建过程中.这是通过在组件目录中包含 Makefile.componentbuild 来完成的.在包含组件的 component.mk 之前,此文件会包含在 component_wrapper.mk 中.与 Makefile.projbuild 类似,请注意这些文件:因为它们包含在每个组件构建中,所以只有在编译完全不同的组件时才会出现 Makefile.componentbuild 错误.</p><h4 id="仅配置组件"><a href="#仅配置组件" class="headerlink" title="仅配置组件"></a>仅配置组件</h4><p>一些不包含源文件的特殊组件,只有 <code>Kconfig.projbuild</code> 和 <code>Makefile.projbuild</code>,可以在 component.mk 文件中设置标志 <code>COMPONENT_CONFIG_ONLY</code>.如果设置了此标志,则忽略大多数其他组件变量,并且不会为组件运行构建步骤.</p><h3 id="示例组件-Makefile"><a href="#示例组件-Makefile" class="headerlink" title="示例组件 Makefile"></a>示例组件 Makefile</h3><p>因为构建环境试图设置大多数时间都能工作的合理默认值,所以 component.mk 可能非常小甚至是空的(请参阅<a href="#最小组件Makefile">最小组件 Makefile</a>).但是,某些功能通常需要覆盖组件变量.</p><p>以下是<code>component.mk</code> makefile 的一些更高级的示例:</p><h4 id="添加源文件目录"><a href="#添加源文件目录" class="headerlink" title="添加源文件目录"></a>添加源文件目录</h4><p>默认情况下,将忽略子目录.如果您的项目在子目录而不是组件的根目录中有源文件,那么您可以通过设置<code>COMPONENT_SRCDIRS</code> 告诉构建系统:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_SRCDIRS:&#x3D; src1 src2</span><br></pre></td></tr></table></figure><p>这将编译 src1/ 和 src2/ 子目录中的所有源文件.</p><h4 id="指定源文件"><a href="#指定源文件" class="headerlink" title="指定源文件"></a>指定源文件</h4><p>标准 component.mk 逻辑将源目录中的所有 .S 和 .c 文件添加为无条件编译的源.通过将 <code>COMPONENT_OBJS</code> 变量手动设置为需要生成的对象的名称,可以绕过该逻辑并对要编译的对象进行硬编码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_OBJS :&#x3D; file1.o file2.o thing&#x2F;filea.o thing&#x2F;fileb.o anotherthing&#x2F;main.o</span><br><span class="line">COMPONENT_SRCDIRS :&#x3D; . thing anotherthing</span><br></pre></td></tr></table></figure><p>请注意,还必须设置 <code>COMPONENT_SRCDIRS</code>.</p><h4 id="添加条件配置"><a href="#添加条件配置" class="headerlink" title="添加条件配置"></a>添加条件配置</h4><p>配置系统可有条件地编译某些文件,具体取决于 <code>make menuconfig</code> 中选择的选项.为此, ESP-IDF 具有 <code>compile_only_if</code> 和 <code>compile_only_if_not</code> 宏:</p><p><code>Kconfig</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config FOO_ENABLE_BAR</span><br><span class="line">    bool &quot;Enable the BAR feature.&quot;</span><br><span class="line">    help</span><br><span class="line">        This enables the BAR feature of the FOO component.</span><br></pre></td></tr></table></figure><p><code>component.mk</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(call compile_only_if,$(CONFIG_FOO_ENABLE_BAR),bar.o)</span><br></pre></td></tr></table></figure><p>从示例中可以看出,<code>compile_only_if</code> 宏将条件和目标文件列表作为参数.如果条件为真(在这种情况下:如果在 menuconfig 中启用了 BAR 功能),将始终编译目标文件(在本例中为 bar.o).相反的情况也是如此:如果条件不成立, bar.o 将永远不会被编译.<code>compile_only_if_not</code> 执行相反的操作:如果条件为false则编译,如果条件为 true 则不编译.</p><p>这也可用于选择或删除一种实现,如下所示:</p><p><code>Kconfig</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">config ENABLE_LCD_OUTPUT</span><br><span class="line">    bool &quot;Enable LCD output.&quot;</span><br><span class="line">    help</span><br><span class="line">        Select this if your board has a LCD.</span><br><span class="line"></span><br><span class="line">config ENABLE_LCD_CONSOLE</span><br><span class="line">    bool &quot;Output console text to LCD&quot;</span><br><span class="line">    depends on ENABLE_LCD_OUTPUT</span><br><span class="line">    help</span><br><span class="line">        Select this to output debugging output to the lcd</span><br><span class="line"></span><br><span class="line">config ENABLE_LCD_PLOT</span><br><span class="line">    bool &quot;Output temperature plots to LCD&quot;</span><br><span class="line">    depends on ENABLE_LCD_OUTPUT</span><br><span class="line">    help</span><br><span class="line">        Select this to output temperature plots</span><br></pre></td></tr></table></figure><p>component.mk:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># If LCD is enabled, compile interface to it, otherwise compile dummy interface</span><br><span class="line">$(call compile_only_if,$(CONFIG_ENABLE_LCD_OUTPUT),lcd-real.o lcd-spi.o)</span><br><span class="line">$(call compile_only_if_not,$(CONFIG_ENABLE_LCD_OUTPUT),lcd-dummy.o)</span><br><span class="line"></span><br><span class="line">#We need font if either console or plot is enabled</span><br><span class="line">$(call compile_only_if,$(or $(CONFIG_ENABLE_LCD_CONSOLE),$(CONFIG_ENABLE_LCD_PLOT)), font.o)</span><br></pre></td></tr></table></figure><p>请注意使用 Make ‘or’ 功能来包含字体文件.其他替换函数,如 ‘and’ 以及 ‘if’ 也适用于此处.也可以使用不来自 menuconfig 的变量: ESP-IDF 使用默认的构建配置来判断一个空的变量或只包含空格为false,而其中包含任何非空格的变量为true.</p><p>(注意:本文档的旧版本建议有条件地将目标文件名添加到 <code>COMPONENT_OBJS</code>.虽然这仍然可行,但只有当组件的所有目标文件都明确命名时才会起作用,并且不会通过 <code>make clear</code> 中的取消选择的目标文件通过.)</p><h4 id="源代码生成"><a href="#源代码生成" class="headerlink" title="源代码生成"></a>源代码生成</h4><p>某些组件将出现源文件未随组件本身提供但必须从另一个文件生成的情况.假设我们的组件有一个头文件,该文件由 BMP 文件的转换后的二进制数据组成,使用名为 bmp2h 的假设工具进行转换.然后将头文件包含在名为 graphics_lib.c 的 C 源文件中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_EXTRA_CLEAN :&#x3D; logo.h</span><br><span class="line"></span><br><span class="line">graphics_lib.o: logo.h</span><br><span class="line"></span><br><span class="line">logo.h: $(COMPONENT_PATH)&#x2F;logo.bmp</span><br><span class="line">    bmp2h -i $^ -o $@</span><br></pre></td></tr></table></figure><p>在此示例中,将在当前目录(构建目录)中生成 <code>graphics_lib.o</code> 和 <code>logo.h</code>,而 logo.bmp 随组件一起提供并位于组件路径下.因为 logo.h 是一个生成的文件,所以当调用 make clean 时需要清理它,这就是为什么它被添加到 <code>COMPONENT_EXTRA_CLEAN</code> 变量中.</p><h4 id="Cosmetic-Improvements"><a href="#Cosmetic-Improvements" class="headerlink" title="Cosmetic Improvements"></a>Cosmetic Improvements</h4><p>因为 logo.h 是一个生成的文件,所以当调用 make clean 时需要清理它,这就是为什么它被添加到 <code>COMPONENT_EXTRA_CLEAN</code> 变量中.</p><p>将 logo.h 添加到 <code>graphics_lib.o</code> 依赖项会导致在编译 <code>graphics_lib.c</code> 之前生成它.</p><p>如果另一个组件中的源文件包含 <code>logo.h</code>,则必须将此组件的名称添加到另一个组件的 <code>COMPONENT_DEPENDS</code> 列表中,以确保组件按顺序构建.</p><h4 id="嵌入二进制数据"><a href="#嵌入二进制数据" class="headerlink" title="嵌入二进制数据"></a>嵌入二进制数据</h4><p>有时您有一个文件,包含组件需要使用的二进制数据或文本数据 - 但您不希望将文件重新格式化为 C 文件.</p><p>您可以在 component.mk 中设置变量 <code>COMPONENT_EMBED_FILES</code>,以这种方式给出要嵌入的文件的名称:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_EMBED_FILES:&#x3D; server_root_cert.der</span><br></pre></td></tr></table></figure><p>或者,如果文件是字符串,则可以使用变量 <code>COMPONENT_EMBED_TXTFILES</code>.这将把文本文件的内容嵌入为以 null 结尾的字符串:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPONENT_EMBED_TXTFILES:&#x3D; server_root_cert.pem</span><br></pre></td></tr></table></figure><p>文件的内容将被添加到 flash 中的 .rodata 部分,并通过符号名称提供,如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern const uint8_t server_root_cert_pem_start [] asm(“_ binary_server_root_cert_pem_start”);</span><br><span class="line">extern const uint8_t server_root_cert_pem_end [] asm(“_ binary_server_root_cert_pem_end”);</span><br></pre></td></tr></table></figure><p>名称是根据文件的全名生成的,如 <code>COMPONENT_EMBED_FILES</code> 中所示.字符 <code>/</code>,<code>.</code>等用下划线代替.符号名称中的 <code>_binary</code> 前缀由 <code>objcopy</code> 添加,对于文本和二进制文件都是相同的.</p><p>有关使用此技术的示例,请参阅<a href="https://github.com/espressif/esp-idf/tree/be81d2c/examples/protocols/https_request" target="_blank" rel="noopener">protocols/https_request</a>-证书文件内容在编译时从文本 .pem 文件加载.</p><h3 id="完全覆盖组件-Makefile"><a href="#完全覆盖组件-Makefile" class="headerlink" title="完全覆盖组件 Makefile"></a>完全覆盖组件 Makefile</h3><p>显然,在某些情况下,所有这些不足以满足某个组件,例如,当组件基本上是另一个第三方组件的包装器时,该第三方组件最初不打算在此构建系统下编译.在这种情况下,可以通过设置 <code>COMPONENT_OWNBUILDTARGET</code> 和可能的 <code>COMPONENT_OWNCLEANTARGET</code> 并在 <code>component.mk</code> 目标中定义名为 <code>build</code> 和 <code>clean</code> 的自己的目标来完全放弃 esp-idf 构建系统.构建目标可以执行任何操作,只要它为项目生成过程创建 $(COMPONENT_LIBRARY) 以链接到应用程序二进制文件.</p><p>(实际上,即使这不是必需的-如果重写 <code>COMPONENT_ADD_LDFLAGS</code> 变量,则组件可以指示链接器链接其他二进制文件.)</p><h3 id="自定义-sdkconfig-默认值"><a href="#自定义-sdkconfig-默认值" class="headerlink" title="自定义 sdkconfig 默认值"></a>自定义 sdkconfig 默认值</h3><p>例如,您不希望指定完整 sdkconfig 配置的项目或其他项目,但您确实希望覆盖 esp-idf 默认值中的某些键值,则可以在项目目录中创建文件 <code>sdkconfig.defaults</code>.运行 <code>make defconfig</code> 或从头创建新配置时将使用此文件.</p><p>要覆盖此文件的名称,请设置 <code>SDKCONFIG_DEFAULTS</code> 环境变量.</p><h3 id="保存-flash-参数"><a href="#保存-flash-参数" class="headerlink" title="保存 flash 参数"></a>保存 flash 参数</h3><p>在某些情况下,我们希望在没有 IDF 的情况下烧写目标板.对于这种情况,我们希望保存构建的二进制文件, <code>esptool.py</code> 和 <code>esptool write_flash</code> 参数.编写脚本以保存二进制文件和 <code>esptool.py</code> 很简单.我们可以使用命令 <code>make print_flash_cmd</code>,它会打印 flash 参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader &#x2F; bootloader.bin 0x10000 example_app.bin 0x8000 partition_table_unit_test_app.bin</span><br></pre></td></tr></table></figure><p>然后使用 flash 参数作为 <code>esptool write_flash</code> 参数的 arguemnts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python esptool.py --chip esp32 --port &#x2F; dev &#x2F; ttyUSB0 --baud 921600 - before default_reset - after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader &#x2F; bootloader.bin 0x10000 example_app .bin 0x8000 partition_table_unit_test_app.bin</span><br></pre></td></tr></table></figure><h2 id="构建-Bootloader"><a href="#构建-Bootloader" class="headerlink" title="构建 Bootloader"></a>构建 Bootloader</h2><p>引导程序默认构建为 “make all” 的一部分,或者可以通过 “make bootloader-clean” 独立构建.还有 “make bootloader-list-components” 来查看引导加载程序构建中包含的组件.</p><p>IDF <code>components/bootloader</code> 中的组件是特殊的,因为第二阶段引导加载程序是主项目的单独.ELF和.BIN文件.但是,它与主项目共享其配置和构建目录.</p><p>这是通过在 <code>components/bootloader/subproject</code> 下添加子项目来完成的.这个子项目有自己的 Makefile,但它希望通过 <code>components/bootloader/Makefile.projectbuild</code> 文件中的一些粘合剂从项目自己的 Makefile 中调用.有关详细信息,请参阅这些文件</p><p><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;构建系统&quot;&gt;&lt;a href=&quot;#构建系统&quot; class=&quot;headerlink&quot; title=&quot;构建系统&quot;&gt;&lt;/a&gt;构建系统&lt;/h1&gt;&lt;p&gt;本文档解释了 Espressif 物联网开发框架构建系统和“组件”的概念.&lt;/p&gt;
&lt;p&gt;如果您想知道如何组织新的 &lt;code&gt;ESP-IDF&lt;/code&gt; 项目,请阅读本文档.&lt;/p&gt;
&lt;p&gt;我们建议使用 &lt;a href=&quot;https://github.com/espressif/esp-idf-template&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;esp-idf-template&lt;/a&gt; 项目作为项目的起点.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 官方文档（四）错误处理</title>
    <link href="https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://infiniteyuan.github.io/InfiniteYuanBlog/2012/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</id>
    <published>2012-07-22T09:43:43.000Z</published>
    <updated>2020-07-23T06:21:46.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>识别和处理运行时错误对于开发健壮的应用程序非常重要. ESP-IDF 中可能存在多种运行时错误:</p><ul><li>可恢复的错误:<ul><li>函数通过返回值表示的错误(错误代码)</li><li>使用 throw 关键字抛出的 C++ 异常</li></ul></li><li>不可恢复(严重)错误:<ul><li>断言失败(使用断言宏和等效方法)和 abort() 调用.</li><li>CPU 异常:access to protected regions of memory, illegal instruction(访问受保护的内存区域,非法指令)等.</li><li>系统级别检查:watchdog timeout, cache access error, stack overflow, stack smashing, heap corruption(监视程序超时,缓存访问错误,堆栈溢出,堆栈粉碎,堆损坏)等.</li></ul></li></ul><p>本指南介绍了与可恢复错误相关的 ESP-IDF 错误处理机制,并提供了一些常见的错误处理模式.</p><p>有关诊断不可恢复错误的说明,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误</a>.</p><a id="more"></a><h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><p>大多数特定的 ESP-IDF 函数使用 <code>esp_err_t</code> 类型来返回错误代码. <code>esp_err_t</code> 是带符号的整数类型. <code>ESP_OK</code> 代码表示成功(无错误),定义为零.</p><p>各种 ESP-IDF 头文件使用预处理器定义来定义可能的错误代码. 通常这些定义以 <code>ESP_ERR_</code> 前缀开头. 通用错误的常见错误代码(内存不足,超时,无效参数等)在 <code>esp_err.h</code> 文件中定义. ESP-IDF 中的各种组件可以为特定情况定义附加的错误代码.</p><p>有关错误代码的完整列表,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/error-codes.html" target="_blank" rel="noopener">错误代码参考</a>.</p><h2 id="将错误代码转换为错误消息"><a href="#将错误代码转换为错误消息" class="headerlink" title="将错误代码转换为错误消息"></a>将错误代码转换为错误消息</h2><p>对于 ESP-IDF 组件中定义的每个错误代码,可以使用 <code>esp_err_to_name()</code> 或 <code>esp_err_to_name_r()</code> 函数将 <code>esp_err_t</code> 值转换为错误代码名称. 例如,将 <code>0x101</code> 传递给 <code>esp_err_to_name()</code> 将返回 “ESP_ERR_NO_MEM” 字符串. 可以在日志输出中使用此类字符串,以便更容易理解发生了哪个错误.</p><p>此外,如果未找到匹配的 <code>ESP_ERR_</code> 值,<code>esp_err_to_name_r()</code> 函数将尝试将错误代码解释为<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html" target="_blank" rel="noopener">标准 POSIX 错误代码</a>. 这是使用 <code>strerror_r</code> 函数完成的. POSIX 错误代码(例如 <code>ENOENT</code>,<code>ENOMEM</code>)在 <code>errno.h</code> 中定义,通常从 <code>errno</code> 变量获得. 在 ESP-IDF 中,这个变量是线程本地的:多个 FreeRTOS 任务都有自己的 <code>errno</code> 副本. 设置 <code>errno</code> 的函数仅修改它们运行的任务的值.</p><p>默认情况下启用此功能,但可以禁用此功能以减少应用程序二进制文件大小. 请参阅 <code>CONFIG_ESP_ERR_TO_NAME_LOOKUP</code>. 禁用此功能后,仍会定义 <code>esp_err_to_name()</code> 和 <code>esp_err_to_name_r()</code> ,并且可以调用它. 在这种情况下,<code>esp_err_to_name()</code> 将返回<code>UNKNOWN ERROR</code>,并且 <code>esp_err_to_name_r()</code> 将返回 <code>Unknown error 0xXXXX(YYYYY)</code> ,其中<code>0xXXXX</code> 和 <code>YYYYY</code> 分别是错误代码的十六进制和十进制表示.</p><h2 id="ESP-ERROR-CHECK-宏"><a href="#ESP-ERROR-CHECK-宏" class="headerlink" title="ESP_ERROR_CHECK 宏"></a><code>ESP_ERROR_CHECK</code> 宏</h2><p><code>ESP_ERROR_CHECK()</code> 宏与 <code>assert</code> 的用途相似,只是它检查 <code>esp_err_t</code> 值而不是 <code>bool</code> 条件. 如果 <code>ESP_ERROR_CHECK()</code> 的参数不等于 <code>ESP_OK</code> ,则在控制台上打印错误消息,并调用 <code>abort()</code>.</p><p>错误消息通常如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ESP_ERROR_CHECK failed: esp_err_t 0x107 (ESP_ERR_TIMEOUT) at 0x400d1fdf</span><br><span class="line"></span><br><span class="line">file: &quot;&#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.c&quot; line 20</span><br><span class="line">func: app_main</span><br><span class="line">expression: sdmmc_card_init(host, &amp;card)</span><br><span class="line"></span><br><span class="line">Backtrace: 0x40086e7c:0x3ffb4ff0 0x40087328:0x3ffb5010 0x400d1fdf:0x3ffb5030 0x400d0816:0x3ffb5050</span><br></pre></td></tr></table></figure><blockquote><p>如果使用 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/idf-monitor.html" target="_blank" rel="noopener">IDF monitor</a>,则回溯中的地址将转换为文件名和行号.</p></blockquote><ul><li>第一行提到错误代码为十六进制值,以及源代码中用于此错误的标识符. 后者取决于设置的 <code>CONFIG_ESP_ERR_TO_NAME_LOOKUP</code> 选项. 打印出错误的程序中的地址也被打印出来.</li><li>后续行显示程序中调用 <code>ESP_ERROR_CHECK()</code> 宏的位置,以及作为参数传递给宏的表达式.</li><li>最后,打印回溯. 这是所有错误 <code>panic</code> 处理程序输出的公共部分. 有关回溯的更多信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误 Fatal Errors</a>.</li></ul><h2 id="错误处理模式"><a href="#错误处理模式" class="headerlink" title="错误处理模式"></a>错误处理模式</h2><ol><li><p>尝试恢复. 根据具体情况,这可能意味着在一段时间后重试呼叫,或尝试取消初始化驱动程序并重新初始化,或使用带外机制修复错误条件(例如重置外部外围设备) 这没有回应).</p><p>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">esp_err_t err;</span><br><span class="line">do &#123;</span><br><span class="line">    err &#x3D; sdio_slave_send_queue(addr, len, arg, timeout);</span><br><span class="line">    &#x2F;&#x2F; keep retrying while the sending queue is full</span><br><span class="line">&#125; while (err &#x3D;&#x3D; ESP_ERR_TIMEOUT);</span><br><span class="line">if (err !&#x3D; ESP_OK) &#123;</span><br><span class="line">    &#x2F;&#x2F; handle other errors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将错误传播给调用者. 在某些中间件组件中,这意味着函数必须以相同的错误代码退出,从而确保回滚任何资源分配.</p><p>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sdmmc_card_t* card &#x3D; calloc(1, sizeof(sdmmc_card_t));</span><br><span class="line">if (card &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    return ESP_ERR_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line">esp_err_t err &#x3D; sdmmc_card_init(host, &amp;card);</span><br><span class="line">if (err !&#x3D; ESP_OK) &#123;</span><br><span class="line">    &#x2F;&#x2F; Clean up</span><br><span class="line">    free(card);</span><br><span class="line">    &#x2F;&#x2F; Propagate the error to the upper layer (e.g. to notify the user).</span><br><span class="line">    &#x2F;&#x2F; Alternatively, application can define and return custom error code.</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>转换为不可恢复的错误,例如使用 <code>ESP_ERROR_CHECK</code>. 有关详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/error-handling.html#esp-error-check-macro" target="_blank" rel="noopener"><code>ESP_ERROR_CHECK</code> 宏</a>部分.</p><p>在出现错误的情况下终止应用程序通常是中间件组件的不良行为,但有时在应用程序级别可以接受.</p><p>许多 ESP-IDF 示例使用 <code>ESP_ERROR_CHECK</code> 来处理来自各种API的错误. 这不是应用程序的最佳实践,并且可以使示例代码更简洁.</p><p>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ESP_ERROR_CHECK(spi_bus_initialize(host, bus_config, dma_chan));</span><br></pre></td></tr></table></figure></li></ol><h2 id="C-异常"><a href="#C-异常" class="headerlink" title="C++ 异常"></a>C++ 异常</h2><p>默认情况下禁用对 ESP-IDF 中的 C++ 异常的支持,但可以使用 <code>CONFIG_CXX_EXCEPTIONS</code> 选项启用.</p><p>启用异常处理通常会将应用程序二进制大小增加几KB. 此外,可能需要为异常紧急池预留一定量的 RAM. 如果无法从堆中分配异常对象,则将使用此池中的内存. 可以使用 <code>CONFIG_CXX_EXCEPTIONS_EMG_POOL_SIZE</code> 变量设置应急池中的内存量.</p><p>如果抛出异常,但没有 <code>catch</code> 块,程序将被 <code>abort</code> 函数终止,并且将打印 <code>backtrace</code>. 有关回溯的更多信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误</a>.</p><p><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/error-handling.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;错误处理&quot;&gt;&lt;a href=&quot;#错误处理&quot; class=&quot;headerlink&quot; title=&quot;错误处理&quot;&gt;&lt;/a&gt;错误处理&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;识别和处理运行时错误对于开发健壮的应用程序非常重要. ESP-IDF 中可能存在多种运行时错误:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可恢复的错误:&lt;ul&gt;
&lt;li&gt;函数通过返回值表示的错误(错误代码)&lt;/li&gt;
&lt;li&gt;使用 throw 关键字抛出的 C++ 异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不可恢复(严重)错误:&lt;ul&gt;
&lt;li&gt;断言失败(使用断言宏和等效方法)和 abort() 调用.&lt;/li&gt;
&lt;li&gt;CPU 异常:access to protected regions of memory, illegal instruction(访问受保护的内存区域,非法指令)等.&lt;/li&gt;
&lt;li&gt;系统级别检查:watchdog timeout, cache access error, stack overflow, stack smashing, heap corruption(监视程序超时,缓存访问错误,堆栈溢出,堆栈粉碎,堆损坏)等.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本指南介绍了与可恢复错误相关的 ESP-IDF 错误处理机制,并提供了一些常见的错误处理模式.&lt;/p&gt;
&lt;p&gt;有关诊断不可恢复错误的说明,请参阅&lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;错误&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="ESP32 官方文档" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/categories/ESP32-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="ESP32" scheme="https://infiniteyuan.github.io/InfiniteYuanBlog/tags/ESP32/"/>
    
  </entry>
  
</feed>
