<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo Blog</title>
    <url>/InfiniteYuanBlog/2012/07/22/hexo_blog_log/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<a id="more"></a>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（一）开发环境搭建</title>
    <url>/InfiniteYuanBlog/2018/01/16/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="ESP32-开发环境搭建"><a href="#ESP32-开发环境搭建" class="headerlink" title="ESP32 开发环境搭建"></a>ESP32 开发环境搭建</h1><p>ESP32 整体的开发资料相对比较多,官方网站在 github 上提供了详细的开发环境搭建步骤:<a href="https://esp-idf.readthedocs.io/en/latest/index.html#" target="_blank" rel="noopener">ESP-IDF Programming Guide</a></p>
<a id="more"></a>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（七）I2S - Inter—IC Sound</title>
    <url>/InfiniteYuanBlog/2018/08/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89I2S%20-%20Inter%E2%80%94IC%20Sound/</url>
    <content><![CDATA[<h1 id="I2S"><a href="#I2S" class="headerlink" title="I2S"></a>I2S</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 包含两个 I2S 外设. 这些外设可配置为通过 I2S 驱动程序输入和输出样本数据.</p>
<p>I2S 标准总线定义了三种信号:时钟信号 BCK、声道选择信号 WS 和串行数据信号 SD.一个基本的 I2S 数据总线有一个主机和一个从机.主机和从机的角色在通信过程中保持不变.ESP32 的 I2S 模块包含独立的发送和接收声道,能够保证优良的通信性能.</p>
<p>I2S 外设支持 DMA,这意味着它可以传输使用样本数据流,而无需 CPU 读取或写入每个样本.</p>
<p>I2S 输出也可以直接路由到数字/模拟转换器输出通道(GPIO 25 和 GPIO 26),直接产生模拟输出,而不是通过外部 I2S 编解码器.</p>
<a id="more"></a>

<blockquote>
<p>对于高精度时钟应用,APLL 时钟源可与.use_apll = true 一起使用,ESP32 将自动计算 APLL 参数.</p>
</blockquote>
<clear>
>如果 use_apll = true 且 fixed_mclk> 0,则 I2S 的主时钟输出固定且等于 fixed_mclk 值. 音频时钟速率(LRCK)始终为 MCLK 除数,`0<MCLK / LRCK / channels / bits_per_sample <64`

<p><img src="https://img-blog.csdn.net/20180812222632469?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<center>图 1 I2S 系统框图</center>

<p>图 1 是 ESP32 I2S 模块的结构框图,图中 “n”  对应为 0 或 1,即 I2S0 或 I2S1.每个 I2S 模块包含一个独立的发送单元(Tx) 和一个独立的接收单元(Rx).发送和接收单元各自有一组三线接口,分别为时钟线 BCK,声道选择线 WS 和串行数据线 SD.其中,发送单元的串行数据线固定为输出,接收单元的串行数据线固定为接收.发送单元和接收单元的时钟线和声道选择线均可配置为主机发送和从机接收.在 LCD 模式下,串行数据线扩展为并行数据总线.I2S 模块发送和接收单元各有一块宽 32 bit、深 64 bit 的 FIFO.此外,只有 I2S0 支持接收/发送 PDM 信号并且支持片上 DAC/ADC 模块.</p>
<p>图 1 右侧为 I2S 模块的信号总线.Rx 和 Tx 模块的信号命名规则为: I2SnA_B_C.其中 “n” 为模块名,表示 I2S0 或 I2S1；”A” 表示 I2S 模块的数据总线信号的方向,”I” 表示输入,”O” 表示输出；”B” 表示信号功能；”C” 表示该信号的方向,”in” 表示该信号输入I2S 模块,”out” 表示该信号自 I2S 模块输出.各信号总线的具体描述见表 1.除 I2Sn_CLK 信号外,其他信号均需要经过 GPIO 交换矩阵和 IO_MUX 映射到芯片的管脚.I2Sn_CLK 信号需要经过 IO_MUX 映射到芯片管脚.</p>
<p><img src="https://img-blog.csdn.net/20180812223349366?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="I2S 信号总线描述"></p>
<center>表 1 I2S 信号总线描述</center>

<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><p>I2S 模式</p>
<ul>
<li>可配置高精度输出时钟；</li>
<li>支持全双工和半双工收发数据；</li>
<li>支持多种音频标准；</li>
<li>内嵌 A 律压缩/解压缩模块；</li>
<li>可配置时钟；</li>
<li>支持 PDM 信号输入输出；</li>
<li>收发数据模式可配置.</li>
</ul>
<p>LCD 模式</p>
<ul>
<li>支持外接 LCD；</li>
<li>支持外接 Camera；</li>
<li>支持多种 LCD 模式；</li>
<li>支持连接片上 DAC/ADC 模式.</li>
</ul>
<p>I2S 中断</p>
<ul>
<li>I2S 接口中断；</li>
<li>I2S DMA 接口中断.</li>
</ul>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>esp-idf 中提供了完整的 I2S 示例:<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/i2s" target="_blank" rel="noopener">peripherals/i2s</a>.</p>
<p>I2S 配置的简短示例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"driver/i2s.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"freertos/queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> i2s_num = <span class="number">0</span>; <span class="comment">// i2s port number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">i2s_config_t</span> i2s_config = &#123;</span><br><span class="line">     .mode = I2S_MODE_MASTER | I2S_MODE_TX,</span><br><span class="line">     .sample_rate = <span class="number">44100</span>,</span><br><span class="line">     .bits_per_sample = <span class="number">16</span>,</span><br><span class="line">     .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,</span><br><span class="line">     .communication_format = I2S_COMM_FORMAT_I2S | I2S_COMM_FORMAT_I2S_MSB,</span><br><span class="line">     .intr_alloc_flags = <span class="number">0</span>, <span class="comment">// default interrupt priority</span></span><br><span class="line">     .dma_buf_count = <span class="number">8</span>,</span><br><span class="line">     .dma_buf_len = <span class="number">64</span>,</span><br><span class="line">     .use_apll = <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">i2s_pin_config_t</span> pin_config = &#123;</span><br><span class="line">    .bck_io_num = <span class="number">26</span>,</span><br><span class="line">    .ws_io_num = <span class="number">25</span>,</span><br><span class="line">    .data_out_num = <span class="number">22</span>,</span><br><span class="line">    .data_in_num = I2S_PIN_NO_CHANGE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    i2s_driver_install(i2s_num, &amp;i2s_config, <span class="number">0</span>, <span class="literal">NULL</span>);   <span class="comment">//install and start i2s driver</span></span><br><span class="line"></span><br><span class="line">    i2s_set_pin(i2s_num, &amp;pin_config);</span><br><span class="line"></span><br><span class="line">    i2s_set_sample_rates(i2s_num, <span class="number">22050</span>); <span class="comment">//set sample rates</span></span><br><span class="line"></span><br><span class="line">    i2s_driver_uninstall(i2s_num); <span class="comment">//stop &amp; destroy i2s driver</span></span><br></pre></td></tr></table></figure>

<p>配置 I2S 以使用内部 DAC 进行模拟输出的简短示例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"driver/i2s.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"freertos/queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> i2s_num = <span class="number">0</span>; <span class="comment">// i2s port number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">i2s_config_t</span> i2s_config = &#123;</span><br><span class="line">     .mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN,</span><br><span class="line">     .sample_rate = <span class="number">44100</span>,</span><br><span class="line">     .bits_per_sample = <span class="number">16</span>, <span class="comment">/* the DAC module will only take the 8bits from MSB */</span></span><br><span class="line">     .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,</span><br><span class="line">     .communication_format = I2S_COMM_FORMAT_I2S_MSB,</span><br><span class="line">     .intr_alloc_flags = <span class="number">0</span>, <span class="comment">// default interrupt priority</span></span><br><span class="line">     .dma_buf_count = <span class="number">8</span>,</span><br><span class="line">     .dma_buf_len = <span class="number">64</span>,</span><br><span class="line">     .use_apll = <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    i2s_driver_install(i2s_num, &amp;i2s_config, <span class="number">0</span>, <span class="literal">NULL</span>);   <span class="comment">//install and start i2s driver</span></span><br><span class="line"></span><br><span class="line">    i2s_set_pin(i2s_num, <span class="literal">NULL</span>); <span class="comment">//for internal DAC, this will enable both of the internal channels</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//You can call i2s_set_dac_mode to set built-in DAC output mode.</span></span><br><span class="line">    <span class="comment">//i2s_set_dac_mode(I2S_DAC_CHANNEL_BOTH_EN);</span></span><br><span class="line"></span><br><span class="line">    i2s_set_sample_rates(i2s_num, <span class="number">22050</span>); <span class="comment">//set sample rates</span></span><br><span class="line"></span><br><span class="line">    i2s_driver_uninstall(i2s_num); <span class="comment">//stop &amp; destroy i2s driver</span></span><br></pre></td></tr></table></figure>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/i2s.h" target="_blank" rel="noopener">driver/include/driver/i2s.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/i2s.html" target="_blank" rel="noopener">I2S</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（三十） ESP32 性能分析，与 Cortex-M4 性能比较</title>
    <url>/InfiniteYuanBlog/2020/07/04/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%20ESP32%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%8E%20Cortex-M4%20%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="关于-EEMBC"><a href="#关于-EEMBC" class="headerlink" title="关于 EEMBC"></a>关于 EEMBC</h1><p><a href="https://www.eembc.org/about/" target="_blank" rel="noopener">About EEMBC</a></p>
<p>EEMBC 为自动驾驶，移动成像，物联网，移动设备和许多其他应用程序中使用的硬件和软件制定性能基准。</p>
<p>EEMBC 基准测试得分的主要受众是创建依赖嵌入式微控制器和微处理器的系统的公司：从智能手机到太阳能电池板的所有产品。尽管此类制造商通常具有自己的专有基准，但是 EEMBC 提供了一种有吸引力的替代方案，可替代购买硬件，进行设置，然后在候选处理器组上进行所有测量的所有复杂性。 EEMBC 基准套件通过提供统一，严格定义的测量标准，使制造商可以轻松地比较替代解决方案，从而使制造商避免了此繁琐的过程。这不仅使大型制造商受益，而且使开发人员，集成商，</p>
<a id="more"></a>

<h2 id="ESP32-8266-与-Cortex-M3-M4-性能比较"><a href="#ESP32-8266-与-Cortex-M3-M4-性能比较" class="headerlink" title="ESP32/8266 与 Cortex-M3/M4 性能比较"></a>ESP32/8266 与 Cortex-M3/M4 性能比较</h2><p><a href="https://www.eembc.org/coremark/view.php?benchmark_seq=13244,13243,1139,1506" target="_blank" rel="noopener">ESP32/8266 与 Cortex-M3/M4 性能比较</a><br><img src="https://img-blog.csdnimg.cn/20200704114043419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（三）UART - Universal Asynchronous Receiver/Transmitter</title>
    <url>/InfiniteYuanBlog/2018/08/11/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89UART%20-%20Universal%20Asynchronous%20Receiver%20Transmitter/</url>
    <content><![CDATA[<h1 id="UART-Universal-Asynchronous-Receiver-Transmitter"><a href="#UART-Universal-Asynchronous-Receiver-Transmitter" class="headerlink" title="UART - Universal Asynchronous Receiver/Transmitter"></a>UART - Universal Asynchronous Receiver/Transmitter</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>嵌入式应用通常要求一个简单的并且占用系统资源少的方法来传输数据.通用异步收发传输器(UART) 即可以满足这些要求,它能够灵活地与外部设备进行全双工数据交换.ESP32 芯片中有 3 个UART 控制器可供使用,并且兼容不同的 UART 设备.另外,UART 还可以用作红外数据交换(IrDA) 或 RS-485 调制解调器.</p>
<p>3 个 UART 控制器有一组功能相同的寄存器.本文以 UARTn 指代 3 个 UART 控制器,n 为0、1、2.</p>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul>
<li>可编程收发波特率</li>
<li>3 个 UART 的发送 FIFO 以及接收 FIFO 共享1024 x 8-bit RAM</li>
<li>全双工异步通信</li>
<li>支持输入信号波特率自检功能</li>
<li>支持 5/6/7/8 位数据长度</li>
<li>支持 1/1.5/2/3/4 个停止位</li>
<li>支持奇偶校验位</li>
<li>支持 RS485 协议</li>
<li>支持 IrDA 协议</li>
<li>支持 DMA 高速数据通信</li>
<li>支持 UART 唤醒模式</li>
</ul>
<a id="more"></a>

<h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>UART 是一种以字符为导向的通用数据链,可以实现设备间的通信.异步传输的意思是不需要在发送数据上添加时钟信息.这也要求发送端和接收端的速率、停止位、奇偶校验位等都要相同,通信才能成功.</p>
<p>一个典型的 UART 帧开始于一个起始位,紧接着是有效数据,然后是奇偶校验位(可有可无),最后是停止位.ESP32 上的 UART 控制器支持多种字符长度和停止位.另外,控制器还支持软硬件流控和 DMA,可以实现无缝高速的数据传输.开发者可以使用多个 UART 端口,同时又能保证很少的软件开销.<br><img src="https://img-blog.csdn.net/2018081119230686?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="UART 基本架构图"></p>
<center>图1 UART 基本架构图</center>

<p>UART 有两个时钟源:80-MHz APB_CLK 以及参考时钟 REF_TICK (详情请参考章节复位和时钟).可以通过配置 UART_TICK_REF_ALWAYS_ON 来选择时钟源.时钟中的分频器用于对时钟源进行分频,然后产生时钟信号来驱动 UART 模块.ART_CLKDIV_REG 将分频系数分成两个部分:UART_CLKDIV 用于配置整数部分,UART_CLKDIV_FRAG 用于配置小数部分.</p>
<p>UART 控制器可以分为两个功能块:发送块和接收块.</p>
<p>发送块包含一个发送 FIFO 用于缓存待发送的数据.软件可以通过 APB 总线写 Tx_FIFO,也可以通过 DMA 将数据搬入 Tx_FIFO.Tx_FIFO_Ctrl 用于控制 Tx_FIFO 的读写过程,当 Tx_FIFO 非空时,Tx_FSM 通过 Tx_FIFO_Ctrl读取数据,并将数据按照配置的帧格式转化成比特流.比特流输出信号 txd_out 可以通过配置 UART_TXD_INV 寄存器实现取反功能.</p>
<p>接收块包含一个接收 FIFO 用于缓存待处理的数据.输入比特流 rxd_in 可以输入到 UART 控制器.可以通过 UART_RXD_INV 寄存器实现取反.Baudrate_Detect 通过检测最小比特流输入信号的脉宽来测量输入信号的波特率.Start_Detect 用于检测数据的 START 位,当检测到 START 位之后,RX_FSM 通过 Rx_FIFO_Ctrl 将帧解析后的数据存入 Rx_FIFO 中.</p>
<p>软件可以通过 APB 总线读取 Rx_FIFO 中的数据.为了提高数据传输效率,可以使用 DMA 方式进行数据发送或接收.</p>
<p>HW_Flow_Ctrl 通过标准 UART RTS 和 CTS(rtsn_out 和 ctsn_in)流控信号来控制 rxd_in 和 txd_out 的数据流.SW_Flow_Ctrl 通过在发送数据流中插入特殊字符以及在接收数据流中检测特殊字符来进行数据流的控制.当 UART 处于 Light-sleep(详情请参考章节低功耗管理)状态时,Wakeup_Ctrl 开始计算 rxd_in 的脉冲个数,当脉冲个数大于 UART_ACTIVE_THRESHOLD 时产生 wake_up 信号给 RTC 模块,由 RTC 来唤醒 UART 控制器.<br><img src="https://img-blog.csdn.net/20180811193508599?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="UART 共享RAM 图"></p>
<center>UART 共享 RAM 图</center>

<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>配置 UART 设置并使用 UART1 接口安装 UART 驱动程序进行读/写:<a href="https://github.com/espressif/esp-idf/tree/f9a4496/examples/peripherals/uart_echo" target="_blank" rel="noopener">peripherals/uart_echo</a>.</p>
<p>演示如何报告各种通信事件以及如何使用模式检测中断:<a href="https://github.com/espressif/esp-idf/tree/f9a4496/examples/peripherals/uart_events" target="_blank" rel="noopener">peripherals/uart_events</a>.</p>
<p>在两个独立的 FreeRTOS 任务中使用相同的 UART 进行发送和接收:<a href="https://github.com/espressif/esp-idf/tree/f9a4496/examples/peripherals/uart_async_rxtxtasks" target="_blank" rel="noopener">peripherals/uart_async_rxtxtasks</a>.</p>
<p>对 UART 文件描述符使用同步 I/O 多路复用:<a href="https://github.com/espressif/esp-idf/tree/f9a4496/examples/peripherals/uart_select" target="_blank" rel="noopener">peripherals/uart_select</a>.</p>
<p>设置 UART 驱动程序以半双工模式通过 RS485 接口进行通信:<a href="https://github.com/espressif/esp-idf/tree/f9a4496/examples/peripherals/uart_echo_rs485" target="_blank" rel="noopener">peripherals/uart_echo_rs485</a>. 此示例类似于 uart_echo,但通过连接到 ESP32 引脚的 RS485 接口芯片提供通信.</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/f9a4496/components/driver/include/driver/uart.h" target="_blank" rel="noopener">driver/include/driver/uart.h</a></li>
</ul>
<h2 id="API-使用"><a href="#API-使用" class="headerlink" title="API 使用"></a>API 使用</h2><p>以下概述描述了用于在 ESP32 和某些其他 UART 设备之间建立通信的功能和数据类型. 概述反映了编程 ESP32 的UART驱动程序时的典型工作流程,并分为以下几个部分:</p>
<ol>
<li>设置通信参数 - 波特率,数据位,停止位等</li>
<li>设置通信引脚 - 连接另一个 UART 的引脚</li>
<li>驱动程序安装 - 为 UART 驱动程序分配 ESP32 的资源</li>
<li>运行 UART 通信 - 发送/接收数据</li>
<li>使用中断 - 触发特定通信事件的中断</li>
<li>删除驱动程序 - 如果不再需要 UART 通信,则释放 ESP32 的资源</li>
</ol>
<p>使 UART 能开始工作是完成前面的四个步骤,后两个步骤是可选的.</p>
<p>驱动程序由<code>uart_port_t</code>标识,它对应于一个组 UART 控制器. 这种识别存在于以下所有函数调用中.</p>
<h3 id="设置通信参数"><a href="#设置通信参数" class="headerlink" title="设置通信参数"></a>设置通信参数</h3><p>有两种方法可以设置 UART 的通信参数. 一种是通过调用<code>uart_param_config()</code>在<code>uart_config_t</code>结构中提供配置参数来一次性完成.</p>
<p>另一种方法是通过调用函数单独配置特定参数:</p>
<ul>
<li>波特率 - <code>uart_set_baudrate()</code></li>
<li>传输的位数 - <code>uart_set_word_length()</code>指定<code>uart_word_length_t</code>的值</li>
<li>奇偶校验控制 - <code>uart_set_parity()</code>指定<code>uart_parity_t</code> 的值</li>
<li>停止位数目 - <code>uart_set_stop_bits()</code>指定<code>uart_stop_bits_t</code>的值</li>
<li>硬件流控制模式 - <code>uart_set_hw_flow_ctrl()</code>指定<code>uart_hw_flowcontrol_t</code> 的值</li>
<li>通信模式 - <code>uart_set_mode()</code>指定<code>uart_mode_t</code>的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> uart_num = UART_NUM_2;</span><br><span class="line"><span class="keyword">uart_config_t</span> uart_config = &#123;</span><br><span class="line">    .baud_rate = <span class="number">115200</span>,</span><br><span class="line">    .data_bits = UART_DATA_8_BITS,</span><br><span class="line">    .parity = UART_PARITY_DISABLE,</span><br><span class="line">    .stop_bits = UART_STOP_BITS_1,</span><br><span class="line">    .flow_ctrl = UART_HW_FLOWCTRL_CTS_RTS,</span><br><span class="line">    .rx_flow_ctrl_thresh = <span class="number">122</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Configure UART parameters</span></span><br><span class="line">ESP_ERROR_CHECK(uart_param_config(uart_num, &amp;uart_config));</span><br></pre></td></tr></table></figure>

<h3 id="设置通信引脚"><a href="#设置通信引脚" class="headerlink" title="设置通信引脚"></a>设置通信引脚</h3><p>通过调用函数 <code>uart_set_pin()</code>我们可以输入宏<code>UART_PIN_NO_CHANGE</code>而不是 GPIO 引脚编号,并且不会更改当前分配的引脚. 如果不使用某个引脚,则应输入相同的宏.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set UART pins(TX: IO16 (UART2 default), RX: IO17 (UART2 default), RTS: IO18, CTS: IO19)</span></span><br><span class="line">ESP_ERROR_CHECK(uart_set_pin(UART_NUM_2, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, <span class="number">18</span>, <span class="number">19</span>));</span><br></pre></td></tr></table></figure>

<h3 id="驱动程序安装"><a href="#驱动程序安装" class="headerlink" title="驱动程序安装"></a>驱动程序安装</h3><p>完成驱动程序配置后,我们可以通过调用 <code>uart_driver_install()</code>来安装 UART 驱动. 并分配给 UART 所需的若干资源. 资源的类型/大小被指定为函数参数并需要考虑:</p>
<ul>
<li>发送缓冲区的大小</li>
<li>接收缓冲区的大小</li>
<li>事件队列句柄和大小</li>
<li>用于分配中断的标志</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Setup UART buffered IO with event queue</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> uart_buffer_size = (<span class="number">1024</span> * <span class="number">2</span>);</span><br><span class="line">QueueHandle_t uart_queue;</span><br><span class="line"><span class="comment">// Install UART driver using an event queue here</span></span><br><span class="line">ESP_ERROR_CHECK(uart_driver_install(UART_NUM_2, uart_buffer_size, \</span><br><span class="line">                                        uart_buffer_size, <span class="number">10</span>, &amp;uart_queue, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>如果上述所有步骤均已完成,我们就可以连接其他 UART 设备并开始通信.</p>
<h3 id="运行-UART-通信"><a href="#运行-UART-通信" class="headerlink" title="运行 UART 通信"></a>运行 UART 通信</h3><p>串行通信的过程受 UART 硬件 FSM 的控制. 要发送的数据应放入 Tx FIFO 缓冲区, FSM 将序列化并发送出去. 完成类似的过程,但是以相反的顺序,接收数据. 传入的串行流由 FSM 处理并移至 Rx FIFO 缓冲区. 因此, API 的通信功能的任务仅限于向/从相应缓冲区写入和读取数据. 这反映在一些函数名称中,例如:<code>uart_write_bytes()</code>用于传输数据,或<code>uart_read_bytes()</code>用于读取传入数据.</p>
<h3 id="使用中断"><a href="#使用中断" class="headerlink" title="使用中断"></a>使用中断</h3><p>报告了 UART 的特定状态或检测到的错误有 19 个中断. ESP32 技术参考手册(PDF)中介绍了可用中断的完整列表. 要启用特定中断,请调用<code>uart_enable_intr_mask()</code>,以禁用调用<code>uart_disable_intr_mask()</code>. 所有中断的掩码都以<code>UART_INTR_MASK</code>的形式提供. 使用<code>uart_isr_register()</code>完成向服务中断注册处理程序,使用<code>uart_isr_free()</code>释放处理程序. 要在调用处理程序后清除中断状态位,请使用<code>uart_clear_intr_status()</code>.</p>
<h3 id="删除驱动程序"><a href="#删除驱动程序" class="headerlink" title="删除驱动程序"></a>删除驱动程序</h3><p>如果与<code>uart_driver_install()</code>建立通信一段特定时间,然后不需要,则可以通过调用<code>uart_driver_delete()</code>来删除驱动程序以释放分配的资源.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/uart.html" target="_blank" rel="noopener">UART</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（九）SPI - SPI Slave</title>
    <url>/InfiniteYuanBlog/2018/08/13/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89SPI%20-%20SPI%20Slave/</url>
    <content><![CDATA[<h1 id="SPI-Slave"><a href="#SPI-Slave" class="headerlink" title="SPI Slave"></a>SPI Slave</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 有四个 SPI 外设,称为 SPI0,SPI1,HSPI 和 VSPI. SPI0 是专用于 flash 缓存, ESP32 将连接的 SPI flash 设备映射到存储器. SPI1 和 SPI0 使用相同的硬件线,SPI1 用于写入 flash 芯片. HSPI 和 VSPI 可以任意使用，并使用 spi_slave 驱动程序用作 SPI 从设备，由连接的 SPI 主设备驱动。</p>
<h3 id="spi-slave-驱动"><a href="#spi-slave-驱动" class="headerlink" title="spi_slave 驱动"></a>spi_slave 驱动</h3><p><code>spi_slave</code> 驱动程序允许将 HSPI 和/或 VSPI 外设用作全双工 SPI 从设备。它可以使用 DMA 来发送/接收任意长度的事务。</p>
<a id="more"></a>

<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>spi_slave 驱动程序使用以下术语：</p>
<ul>
<li>主机：ESP32 内部的 SPI 外设启动 SPI 传输。HSPI 或 VSPI 之一。</li>
<li>总线：SPI 总线，与连接到一个主机的所有 SPI 设备共用。通常，总线由 miso，mosi，sclk 和可选的 quadwp 和 quadhd 信号组成。SPI 从设备并联连接到这些信号。每个 SPI 从设备也连接到一个 CS 信号。<ul>
<li>miso - 也称为 q，这是从 ESP32 到 SPI 主设备的串行流输出</li>
<li>mosi - 也称为 d，这是从 SPI 主设备到 ESP32 的串行流输出</li>
<li>sclk - 时钟信号。每个数据位在该信号的正或负边沿输出</li>
<li>cs - 芯片选择。有效芯片选择描述与从属设备之间的单个事务。</li>
</ul>
</li>
<li>事务：一个 CS 活动的实例，来自和/或发送到主设备的一次数据传输，以及 CS 再次变为非活动状态。事务具有原子性，因为它们永远不会被另一个事务中断。</li>
</ul>
<h2 id="SPI-transactions"><a href="#SPI-transactions" class="headerlink" title="SPI transactions"></a>SPI transactions</h2><p>全双工 SPI 事务从主机拉低 CS 开始。发生这种情况后，主机开始在 CLK 线上发出时钟脉冲：每个时钟脉冲使一个数据位在 MOSI 线上从主机移位到从机，反之亦然在 MISO 线上。在传输结束时，主机再次使 CS 成为高电平。</p>
<h2 id="使用-spi-slave-驱动"><a href="#使用-spi-slave-驱动" class="headerlink" title="使用 spi_slave 驱动"></a>使用 spi_slave 驱动</h2><ul>
<li>通过调用 <code>spi_slave_initialize</code> 将 SPI 外设初始化为从设备。确保在 <code>bus_config</code> 结构中设置正确的 IO 引脚。注意将不需要的信号设置为 -1。如果事务将大于 32 字节，则必须给出 DMA 通道（1或2），否则 <code>dma_chan</code> 参数可能为 0。</li>
<li>要设置事务，请使用您需要的任何事务参数填充一个或多个 <code>spi_transaction_t</code> 结构。通过调用 <code>spi_slave_queue_trans</code> 将所有事务添加到队列中，之后使用 <code>spi_slave_get_trans_result</code> 查询结果，或者通过将它们交给 <code>spi_slave_transmit</code> 来处理所有请求。后两个函数将阻塞，直到主设备启动并完成一个事务，使队列中的数据被发送和接收。</li>
<li>可选：要卸载 SPI 从设备驱动程序，请调用 <code>spi_slave_free</code>。</li>
</ul>
<h2 id="传输数据和主-从机长度不匹配"><a href="#传输数据和主-从机长度不匹配" class="headerlink" title="传输数据和主/从机长度不匹配"></a>传输数据和主/从机长度不匹配</h2><p>通常，要发送到设备或从设备接收的数据将从事务结构的 <code>rx_buffer</code> 和 <code>tx_buffer</code> 成员指向的一块存储器中读取或写入。SPI 驱动程序可能决定使用 DMA 进行传输，因此应使用 <code>pvPortMallocCaps(size，MALLOC_CAP_DMA)</code> 在具有 DMA 功能的内存中分配这些缓冲区。</p>
<p>写入缓冲区的数据量受事务结构的 <code>length</code> 成员的限制：驱动程序永远不会读取/写入比指定的长度更多的数据。长度不能定义 SPI 事务的实际长度;这是由主机驱动时钟和 CS 线路决定的。在传输事务结束后，可以从 <code>spi_slave_transaction_t</code> 结构的 <code>trans_len</code> 成员读取传输的实际长度。在传输长度大于缓冲区长度的情况下，仅发送和接收传输的开始，并且将 <code>trans_len</code> 设置为长度而不是实际长度。如果需要 <code>trans_len</code>，建议设置长度超过预期的最大长度。如果传输长度短于缓冲区长度，则只交换缓冲区长度的数据。</p>
<blockquote>
<p>警告：由于 ESP32 的设计特性，如果主机发送的字节数或从设备驱动中传输队列的长度（以字节为单位）不大于8且可分为4，则 SPI 硬件可以无法将最后一到七个字节写到接收缓冲区。</p>
</blockquote>
<h2 id="限制、已知问题"><a href="#限制、已知问题" class="headerlink" title="限制、已知问题"></a>限制、已知问题</h2><ul>
<li>如果 DMA 被使能，则接收缓冲区应该是字对齐的，即从 32 位的边界开始，并且长度为 4 个字节的倍数。否则 DMA 可能会错误地写入或跳出边界。驱动程序将检查此情况。</li>
</ul>
<p>此外，master 应写入长度为 4 个字节的倍数。超过该数据的数据将被丢弃。</p>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>主/从机通信：<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/spi_slave" target="_blank" rel="noopener">peripherals/spi_slave</a>.</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/spi_slave.h" target="_blank" rel="noopener">driver/include/driver/spi_slave.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/spi_slave.html" target="_blank" rel="noopener">SPI Slave driver</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二十一）电源管理</title>
    <url>/InfiniteYuanBlog/2019/03/11/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-IDF 中包含的电源管理算法可以根据应用组件的要求调整 APB 频率，CPU 频率，并使芯片进入 light sleep 模式，以尽可能低的功耗运行应用程序。</p>
<p>应用程序组件可以通过创建和获取电源管理锁来表达其要求。</p>
<p>例如，由 APB 提供时钟的外围设备的驱动器可以在使用外围设备的时间内请求将 APB 频率设置为80MHz。另一个例子是，当有任务准备好运行时，RTOS 将请求 CPU 以最高配置频率运行。又一个例子是需要启用中断的外围驱动器。这样的驱动程序可以请求禁用 light sleep。</p>
<p>当然，要求更高的 APB 或 CPU 频率或禁用 light sleep 会导致更高的电流消耗。组件应尽可能在最短的时间内限制电源管理锁的使用。</p>
<a id="more"></a>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>可以使用 <code>CONFIG_PM_ENABLE</code> 选项在编译时启用电源管理。</p>
<p>启用电源管理功能的代价是增加了中断延迟。额外延迟取决于许多因素，其中包括 CPU 频率，单/双核模式，是否需要执行频率切换。最小额外延迟为 0.2us（当 CPU 频率为 240MHz，并且未启用频率调整时），最大额外延迟为 40us（启用频率调整时，在中断输入时执行从 40MHz 到 80MHz 的切换）。</p>
<p>通过调用 <code>esp_pm_configure()</code> 函数，可以在应用程序中启用动态频率调整（DFS）和自动光睡眠。它的参数是定义频率缩放设置的结构，<code>esp_pm_config_esp32_t</code>。在此结构中，需要初始化 3 个字段：</p>
<ul>
<li><code>max_freq_mhz</code>  - 最大 CPU 频率，以 MHZ 为单位（即采用 <code>ESP_PM_CPU_FREQ_MAX</code> 时使用的频率）。 这通常设置为 <code>CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ</code>。</li>
<li><code>min_freq_mhz</code>  - 最小 CPU 频率，以 MHz 为单位（即仅采用 <code>ESP_PM_APB_FREQ_MAX</code> 锁定时使用的频率）。 这可以设置为 XTAL 频率，或 XTAL 频率除以整数。 请注意，10MHz 是可以生成 1MHz 的默认 REF_TICK 时钟的最低频率。</li>
<li><code>light_sleep_enable</code>  - 当没有锁定时，系统是否应自动进入 light sleep 状态（true/false）。</li>
</ul>
<blockquote>
<p>自动 light sleep 模式基于 FreeRTOS Tickless Idle 功能。如果在 menuconfig 中未启用 <code>CONFIG_FREERTOS_USE_TICKLESS_IDLE</code>选项，则 <code>esp_pm_configure()</code> 将返回 <code>ESP_ERR_NOT_SUPPORTED</code> 错误，但请求自动 light sleep。</p>
</blockquote>
<blockquote>
<p>在 light sleep 模式下，外设是时钟门控的，不会产生中断（来自 GPIO 和内部外设）。睡眠模式文档中描述的唤醒源可用于从 light sleep 状态唤醒。例如，EXT0 和 EXT1 唤醒源可用于从 GPIO 唤醒。</p>
</blockquote>
<p>或者，可以在 menuconfig 中启用 <code>CONFIG_PM_DFS_INIT_AUTO</code> 选项。如果启用，最大 CPU 频率由 <code>CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ</code> 设置决定，最小 CPU 频率设置为 XTAL 频率。</p>
<h2 id="电源管理锁"><a href="#电源管理锁" class="headerlink" title="电源管理锁"></a>电源管理锁</h2><p>如概述中所述，应用程序可以获取/释放锁以控制电源管理算法。当应用程序锁定时，对于每个锁定，电源管理算法操作以下面描述的方式受到限制。释放锁定时，将删除此类限制。</p>
<p>应用程序的不同部分可以采用相同的锁定。 在这种情况下，锁定必须被释放的次数与获取的次数相同，以便恢复功率管理算法。</p>
<p>在 ESP32 中，支持三种类型的锁：</p>
<ul>
<li><code>ESP_PM_CPU_FREQ_MAX</code><br>请求 CPU 频率为 <code>esp_pm_configure()</code> 设置的最大值。对于 ESP32，此值可以设置为 80,160 或 240MHz。</li>
<li><code>ESP_PM_APB_FREQ_MAX</code><br>请求 APB 频率处于最大支持值。对于 ESP32，这是 80MHz。</li>
<li><code>ESP_PM_NO_LIGHT_SLEEP</code><br>防止使用自动 light sleep 模式。</li>
</ul>
<h2 id="ESP32-的电源管理算法"><a href="#ESP32-的电源管理算法" class="headerlink" title="ESP32 的电源管理算法"></a>ESP32 的电源管理算法</h2><p>启用动态频率调整后，CPU 频率将按如下方式切换：</p>
<ul>
<li><p>如果最大 CPU 频率（使用 <code>esp_pm_configure()</code> 或 <code>CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ</code> 设置）为 240 MHz：</p>
<ol>
<li>获取 <code>ESP_PM_CPU_FREQ_MAX</code> 或 <code>ESP_PM_APB_FREQ_MAX</code> 时，CPU 频率为 240 MHz，APB 频率为 80 MHz。</li>
<li>否则，频率将切换到使用 <code>esp_pm_configure()</code>设置的最小值。</li>
</ol>
</li>
<li><p>如果最大 CPU 频率为 160 MHz：</p>
<ol>
<li>获取 <code>ESP_PM_CPU_FREQ_MAX</code> 时，CPU 频率设置为 160 MHz，APB 频率设置为 80 MHz。</li>
<li>当未获取 <code>ESP_PM_CPU_FREQ_MAX</code> 但 <code>ESP_PM_APB_FREQ_MAX</code> 为时，CPU 和 APB 频率设置为 80 MHz。</li>
<li>否则，频率将切换到使用 <code>esp_pm_configure()</code> 设置的最小值。</li>
</ol>
</li>
<li><p>如果最大 CPU 频率为 80 MHz：</p>
<ol>
<li>获取 <code>ESP_PM_CPU_FREQ_MAX</code> 或 <code>ESP_PM_APB_FREQ_MAX</code> 锁时，CPU 和 APB 频率将为 80 MHz。</li>
<li>否则，频率将切换到使用 <code>esp_pm_configure()</code> 设置的最小值。</li>
</ol>
</li>
<li><p>如果未获取任何锁定，并且在调用 <code>esp_pm_configure()</code> 时启用了轻度睡眠，则系统将进入轻度睡眠模式(light sleep)。轻度睡眠的持续时间将由以下因素确定：</p>
<ul>
<li>FreeRTOS 任务因有限超时而被阻止<ul>
<li>定时器使用高分辨率计时器 API 注册</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>轻度睡眠持续时间将被选择为在最近的事件之前唤醒（任务被解锁或计时器过去）。</p>
<h2 id="动态频率调整和外设驱动程序"><a href="#动态频率调整和外设驱动程序" class="headerlink" title="动态频率调整和外设驱动程序"></a>动态频率调整和外设驱动程序</h2><p>启用 DFS 后，APB 频率可在单个 RTOS 滴答内多次更改。即使 APB 频率发生变化，一些外围设备也能正常工作; 有些不能。</p>
<p>即使 APB 频率发生变化，以下外设也能正常工作：</p>
<ul>
<li>UART：如果 REF_TICK 用作时钟源（请参阅 uart_config_t 的 use_ref_tick 成员）。</li>
<li>LEDC：如果 REF_TICK 用作时钟源（参见 <code>ledc_timer_config()</code> 函数）。</li>
<li>RMT：如果 REF_TICK 用作时钟源。 目前，驱动程序不支持 REF_TICK，但可以通过清除相应通道的 <code>RMT_REF_ALWAYS_ON_CHx</code> 位来启用它。</li>
</ul>
<p>目前，以下外围驱动程序知道 DFS，并将在事务持续时间内使用 <code>ESP_PM_APB_FREQ_MAX</code> 锁定：</p>
<ul>
<li>SPI master</li>
<li>SDMMC</li>
</ul>
<p>启用驱动程序时，以下驱动程序将保持 <code>ESP_PM_APB_FREQ_MAX</code> 锁定：</p>
<ul>
<li>SPI slave  - 在调用 <code>spi_slave_initialize()</code> 和 <code>spi_slave_free()</code> 之间。</li>
<li>以太网 - 在调用 <code>esp_eth_enable()</code> 和 <code>esp_eth_disable()</code> 之间。</li>
<li>WiFi  - 在调用 <code>esp_wifi_start()</code> 和 <code>esp_wifi_stop()</code> 之间。 如果启用了调制解调器睡眠(modem sleep)，则在禁用无线电时的一段时间内将释放锁定。</li>
<li>蓝牙 - 在调用 <code>esp_bt_controller_enable()</code> 和 <code>esp_bt_controller_disable()</code> 之间。</li>
<li>CAN  - 调用 <code>can_driver_install()</code> 和 <code>can_driver_uninstall()</code> 之间</li>
</ul>
<p>以下外围驱动程序尚未处理 DFS。应用程序需要在必要时获取/释放锁定：</p>
<ul>
<li>I2C</li>
<li>I2S</li>
<li>MCPWM</li>
<li>PCNT</li>
<li>Sigma-delta</li>
<li>Timer group</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/system/power_management.html" target="_blank" rel="noopener">Power Management</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二十七） ESP32 的启动过程 [转]</title>
    <url>/InfiniteYuanBlog/2020/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%20ESP32%20%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%20%5B%E8%BD%AC%5D/</url>
    <content><![CDATA[<h1 id="ESP32-的启动过程"><a href="#ESP32-的启动过程" class="headerlink" title="ESP32 的启动过程"></a>ESP32 的启动过程</h1><p>原文来自：<a href="https://www.esp32.com/viewtopic.php?f=25&amp;t=8030&amp;p=33812#p33812" target="_blank" rel="noopener">https://www.esp32.com/viewtopic.php?f=25&amp;t=8030&amp;p=33812#p33812</a></p>
<h2 id="关于-ROM"><a href="#关于-ROM" class="headerlink" title="[关于 ROM]"></a>[关于 ROM]</h2><p>在 esp32 上电运行后，芯片运行的第一个程序。这段程序是芯片设计与生产的时候，固化在硬件电路中的。所以它是不可修改的(Read Only Memory)。<br>esp32 的 ROM 负责检测芯片的strapping配置，来决定芯片应该处于什么状态。比如，esp32 上电后，ROM 程序会检查 [GPIO0, GPIO2, GPIO4, MTDO, GPIO5]的状态。<br>如果 GPIO0 / GPIO2 同时为低电平，则会进入下载模式，等待串口通信信息。<br>如果GPIO0为高电平，则会进入Flash 运行模式，启动SPI 驱动，并加载Flash中的程序段。</p>
<a id="more"></a>

<p>BOOT_MODE[5:0]:<br>(pull-up, pull-down, pull-down, pull-up, pull-up, SW4 /5/4/3/2/1/ )<br>[GPIO0, GPIO2, GPIO4, MTDO, GPIO5]<br>1 x x x x –&gt; SPI Boot<br>0 0 x x x –&gt; Download Boot (Jonit-Detection of UART0+UART1+SDIO_Slave)</p>
<p>下载模式的串口输出如下(115200), ROM默认会输出当前所处的模式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rst:<span class="number">0x1</span> (POWERON_RESET),boot:<span class="number">0x3</span> (DOWNLOAD_BOOT(UART0/UART1/SDIO_REI_REO_V2))</span><br><span class="line">waiting <span class="keyword">for</span> download</span><br></pre></td></tr></table></figure>

<p>其中，boot:0x3 表示的是芯片strapping pin脚的状态，<br>0x03对应 [GPIO0, GPIO2, GPIO4, MTDO, GPIO5] 的值为 [ 0, 0, 0, 1, 1]<br>所以处于 Download Boot 模式。</p>
<h2 id="关于下载模式"><a href="#关于下载模式" class="headerlink" title="[关于下载模式]"></a>[关于下载模式]</h2><p>当 esp32 处于下载模式时，会等待串口通信同步，并按照通信协议等待接收指令(协议可参考该文档：<a href="https://github.com/espressif/esptool/wiki/Serial-Protocol" target="_blank" rel="noopener">Serial-Protocol</a><br>通过esptool脚本，可以进行寄存器的读写，固件下载，程序运行等操作。</p>
<h2 id="关于STUB"><a href="#关于STUB" class="headerlink" title="[关于STUB]"></a>[关于STUB]</h2><p>在 ROM 模式，由于芯片处于低频工作的状态，通信速率受限。<br>在 esptool 中，会将一段小程序加载到 esp32 的 RAM 中，并跳转执行 RAM 中的小程序。这段小程序包含了 ROM 中相同的串口通信协议，并对其进行了扩充。感兴趣的开发者，(可以参考这里 <a href="https://github.com/espressif/esptool/tree/master/flasher_stub" target="_blank" rel="noopener">flasher_stub</a>)</p>
<h2 id="关于-Flash-Boot-模式"><a href="#关于-Flash-Boot-模式" class="headerlink" title="[关于 Flash Boot 模式]"></a>[关于 Flash Boot 模式]</h2><p>如果芯片启动时，GPIO0 为高电平，芯片会进入 Flash 运行模式。 此时，启动 SPI 驱动，并加载 Flash 中的程序段。ROM 会读取外置 Flash 的 0x1000 地址，加载并运行二级 bootloader。</p>
<h2 id="关于-Bootloader"><a href="#关于-Bootloader" class="headerlink" title="[关于 Bootloader]"></a>[关于 Bootloader]</h2><p>bootloader 可以认为是一个独立的小程序，bootloader 会对芯片频率进行初始化，并且读取系统 SPI 的配置信息，对 Flash 运行模式以及频率进行配置，然后根据分区表的定义，从对应的地址加载应用程序，并且运行应用程序固件。</p>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二十三）看门狗</title>
    <url>/InfiniteYuanBlog/2019/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
    <content><![CDATA[<h1 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗"></a>看门狗</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-IDF 支持两种类型的看门狗：中断看门狗定时器和任务看门狗定时器（TWDT）。中断看门狗定时器和 TWDT 都可以使用 make menuconfig 启用，但 TWDT 也可以在运行时启用。中断看门狗负责检测 FreeRTOS 任务切换长时间被阻止的情况。TWDT 负责检测运行的任务在长时间没有让出 CPU 的情况。</p>
<h2 id="中断看门狗"><a href="#中断看门狗" class="headerlink" title="中断看门狗"></a>中断看门狗</h2><p>中断看门狗可确保 FreeRTOS 任务切换中断长时间不被阻止。这种情况很不好，因为没有其他任务能获得 CPU 运行时间，包括可能重要的任务，如 WiFi 任务和空闲任务。阻塞的任务切换中断可能发生当一个程序运行到无限循环并且中断被禁用或挂起中断。</p>
<p>中断监视程序的默认操作是调用 panic 处理程序。将会把寄存器转储以便于使用 OpenOCD 或 gdbstub找到，在禁用中断的情况下会阻塞哪些代码。根据 panic 处理程序的配置，它还可以盲目地重置 CPU，这在生产环境中可能是首选。</p>
<p>中断看门狗是围绕定时器组 1 中的硬件看门狗构建的。如果由于某种原因这个看门狗无法执行调用 panic 处理程序的 NMI 处理程序（例如，因为 IRAM 被垃圾覆盖），它将硬重置 SOC。</p>
<a id="more"></a>

<h2 id="任务看门狗定时器"><a href="#任务看门狗定时器" class="headerlink" title="任务看门狗定时器"></a>任务看门狗定时器</h2><p>负责检测运行的任务在长时间没有让出 CPU 的情况。这是 CPU “饥饿”的症状，通常是由一个高优先级任务不让出 CPU 资源的循环引起，从而使较低优先级任务无法获得 CPU 资源。这可能是外围设备上的代码写得不好，也可能是陷入无限循环的任务。</p>
<p>默认情况下，TWDT 将监视每个 CPU 的空闲任务，但任何任务都可以选择由 TWDT 监视。每个观察任务必须定期“重置” TWDT 以指示它们已被分配 CPU 时间。如果任务未在 TWDT 超时期限内重置，则将打印一条警告，其中包含有关哪些任务未能及时重置 TWDT 以及哪些任务当前正在 ESP32 CPU 上运行的信息。并且还有可能在用户代码中重新定义函数 <code>esp_task_wdt_isr_user_handler</code> 以接收此事件。</p>
<p>TWDT 围绕定时器组 0 中的硬件看门狗定时器构建。可以通过调用 <code>esp_task_wdt_init（）</code> 来初始化 TWDT，这将配置硬件定时器。然后，任务可以使用 <code>esp_task_wdt_add（）</code> 订阅 TWDT 监视。每个订阅的任务必须定期调用 <code>esp_task_wdt_reset（）</code> 来重置 TWDT。任何订阅任务无法定期调用 <code>esp_task_wdt_reset（）</code> 表示一个或多个任务已经缺乏 CPU 资源或者陷入某个循环。</p>
<p>可以使用 <code>esp_task_wdt_delete（）</code> 从 TWDT 取消订阅监视的任务。已取消订阅的任务不应再调用 <code>esp_task_wdt_reset（）</code>。一旦所有任务都从 TWDT 取消订阅，可以通过调用 <code>esp_task_wdt_deinit（）</code> 来取消初始化 TWDT。</p>
<p>默认情况下，make menuconfig 中的 CONFIG_TASK_WDT 将被启用，导致 TWDT 在启动期间自动初始化。同样，CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0 和 CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU1 也会默认启用，导致两个空闲任务在启动期间订阅 TWDT。</p>
<h2 id="JTAG-和-看门狗"><a href="#JTAG-和-看门狗" class="headerlink" title="JTAG 和 看门狗"></a>JTAG 和 看门狗</h2><p>在使用 OpenOCD 进行调试时，每次到达断点时都会暂停 CPU。但是，如果看门狗定时器在遇到断点时继续运行，它们最终会触发复位，从而很难调试代码。 因此，OpenOCD 将在每个断点处禁用中断和任务看门狗的硬件定时器。 此外，OpenOCD 在离开断点时不会重新启用它们。 这意味着中断看门狗和任务看门狗功能将基本上被禁用。 当 ESP32 通过 JTAG 连接到 OpenOCD 时，不会产生任何看门狗警告或 panic。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/system/wdts.html" target="_blank" rel="noopener">Watchdogs</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二十九） ESP32 低功耗模式</title>
    <url>/InfiniteYuanBlog/2020/05/31/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%20ESP32%20%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="ESP32-低功耗模式"><a href="#ESP32-低功耗模式" class="headerlink" title="ESP32 低功耗模式"></a>ESP32 低功耗模式</h1><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1 概要"></a>1 概要</h2><p>ESP32 系列芯片提供三种可配置的睡眠模式，针对这些睡眠模式,我们提供了了多种低功耗解决方案，用户可以结合具体需求选择睡眠模式并进行配置。三种睡眠模式如下:</p>
<ul>
<li>Modem-sleep 模式：CPU 可运行，时钟可被配置。Wi-Fi/蓝牙基带和射频关闭。</li>
<li>Light-sleep 模式：CPU 暂停运行，Wi-Fi/蓝牙基带和射频关闭。<strong>RTC 存储器和外设以及 ULP 协处理器运行</strong>。任何唤醒事件(MAC、主机、RTC 定时器或外部中断)都会唤醒芯片。</li>
<li>Deep-sleep 模式：CPU 和大部分外设都会掉电，Wi-Fi/蓝牙基带和射频关闭，只有 <strong>RTC 存储器和 RTC 外设以及 ULP 协处理器</strong>可以工作。Wi-Fi 和蓝牙连接数据存储在 RTC 中。</li>
</ul>
<p>三种模式的区别如下：</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/2020061714483194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70#pic_center" alt="三种模式的区别"></p>
<hr>
<h2 id="2-Modem-sleep-模式"><a href="#2-Modem-sleep-模式" class="headerlink" title="2 Modem-sleep 模式"></a>2 Modem-sleep 模式</h2><p>目前 ESP32 的 Modem-sleep 仅工作在 Station 模式下,连接路由器后生效。Station 会周期性在工作状态和睡眠状态两者之间切换。<br>ESP32 通过 Wi-Fi 的 DTIM Beacon 机制与路由器保持连接。在 Modem-sleep 模式下，系统可以自动被唤醒，无需配置唤醒源。</p>
<blockquote>
<p>一般路由器的 DTIM Beacon 间隔为 100 ms ~ 1,000 ms。</p>
</blockquote>
<blockquote>
<p>DTIM (Delivery Traffic Indication Message): 使用无线路由器时无线发送数据包的频率。</p>
</blockquote>
<p>在 Modem-sleep 模式下，ESP32 会在两次 DTIM Beacon 间隔时间内，关闭 Wi-Fi 模块电路，达到省电效果，在下次 Beacon 到来前自动唤醒。睡眠时间由路由器的 DTIM Beacon 时间决定。Modem-sleep 模式可以保持与路由器的 Wi-Fi 连接，并通过路由器接收来自手机或者服务器的交互信息。</p>
<h3 id="2-1-API-说明"><a href="#2-1-API-说明" class="headerlink" title="2.1 API 说明"></a>2.1 API 说明</h3><p>通过以下接口配置 Modem-sleep 模式，<code>type</code> 可选参数：</p>
<ul>
<li><code>WIFI_PS_NONE</code>: 不使用 Modem-sleep 模式</li>
<li><code>WIFI_PS_MIN_MODEM</code>: ESP32 接收 Beacon 的间隔与路由器的 DTIM 间隔相同，即 1 个路由器间隔</li>
<li><code>WIFI_PS_MAX_MODEM</code>: ESP32 接收 Beacon 的间隔可由程序进行配置，间隔周期 <code>wifi_sta_config_t</code> 结构体中 <code>listen_interval</code> 值决定，单位为 路由器的 Beacon 间隔，默认值为 3（即 3 个路由器 Beacon 间隔）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    WIFI_PS_NONE,        <span class="comment">/**&lt; No power save */</span></span><br><span class="line">    WIFI_PS_MIN_MODEM,   <span class="comment">/**&lt; Minimum modem power saving. In this mode, station wakes up to receive beacon every DTIM period */</span></span><br><span class="line">    WIFI_PS_MAX_MODEM,   <span class="comment">/**&lt; Maximum modem power saving. In this mode, interval to receive beacons is determined by the listen_interval parameter in wifi_sta_config_t */</span></span><br><span class="line">&#125; <span class="keyword">wifi_ps_type_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_wifi_set_ps</span><span class="params">(<span class="keyword">wifi_ps_type_t</span> type)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>type</code> 参数为 <code>WIFI_PS_MAX_MODEM</code> ，ESP32 接收 Beacon 的间隔 <code>listen_interval</code> 配置方法：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTEN_INTERVAL 3</span></span><br><span class="line"><span class="keyword">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">    .sta = &#123;</span><br><span class="line">        .ssid = <span class="string">"SSID"</span>,</span><br><span class="line">        .password = <span class="string">"Password"</span>,</span><br><span class="line">        .listen_interval = LISTEN_INTERVAL,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &amp;wifi_config));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_start());</span><br></pre></td></tr></table></figure>

<h3 id="2-2-应用"><a href="#2-2-应用" class="headerlink" title="2.2 应用"></a>2.2 应用</h3><p>Modem-sleep 一般用于 CPU 持续处于工作状态并需要保持 Wi-Fi 连接的应用场景，例如，使用 ESP32 本地语音唤醒功能，CPU 需要持续采集和处理音频数据。</p>
<hr>
<h2 id="3-Light-sleep-模式"><a href="#3-Light-sleep-模式" class="headerlink" title="3 Light-sleep 模式"></a>3 Light-sleep 模式</h2><p>Light-sleep 的工作模式与 Modem-sleep 相似，不同的是，除了关闭 Wi-Fi 模块电路以外，在 Light-sleep 模式下，还会关闭时钟并暂停内部 CPU，比 Modem-sleep 功耗更低。有两种方式使 CPU 进入 Light-sleep 模式：</p>
<ul>
<li>强制 Light-sleep： 通过调用 API 强制 CPU 进入 Light-sleep 模式，强制进入 Light-sleep 模式后，<strong>不能通过路由器接收</strong>来自手机或者服务器的交互信息</li>
<li>自动 Light-sleep： 配置为自动休眠方式后，会在 CPU 处于空闲的状态下自动进入 Light-sleep 模式，<strong>能通过路由器接收</strong>来自手机或者服务器的交互信息</li>
</ul>
<h3 id="3-1-强制-Light-sleep"><a href="#3-1-强制-Light-sleep" class="headerlink" title="3.1 强制 Light-sleep"></a>3.1 强制 Light-sleep</h3><p>参考示例: <a href="https://github.com/espressif/esp-idf/tree/release/v3.2/examples/system/light_sleep" target="_blank" rel="noopener">light_sleep</a></p>
<p>开发者可以使系统强制进入 Light-sleep 模式，即调用强制 Light-sleep 接口，强制关闭 Wi-Fi 模块电路并暂停内部 CPU。强制休眠后，能通过定时器、 GPIO（RTC IO 和 Digital IO）和 UART 唤醒。从 Light-sleep 唤醒后，会从进入休眠的位置继续执行程序。强制进入 Light-sleep 模式后，可以保持与路由器的 Wi-Fi 连接，但不能通过路由器接收来自手机或者服务器的交互信息。</p>
<blockquote>
<p>注意：</p>
</blockquote>
<blockquote>
<ol>
<li>强制 Light-sleep 接口调用后，并不会立即休眠，而是等到系统空闲后才进入休眠，</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>强制进入 Light-sleep 模式后，不能接收 IP 网络发送的网络数据。</li>
</ol>
</blockquote>
<h4 id="3-1-1-API-说明"><a href="#3-1-1-API-说明" class="headerlink" title="3.1.1 API 说明"></a>3.1.1 API 说明</h4><ol>
<li>配置唤醒源后，可使用 <code>esp_light_sleep_start()</code>  函数进入 Light-sleep 模式。在没有配置唤醒源的情况下也可以进入轻度睡眠状态，在这种情况下，芯片将无限期地处于 Light-sleep 模式，直到外部复位。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Enter sleep mode */</span></span><br><span class="line">esp_light_sleep_start();</span><br><span class="line"><span class="comment">/* Execution continues here after wakeup */</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-应用"><a href="#3-1-2-应用" class="headerlink" title="3.1.2 应用"></a>3.1.2 应用</h4><p>强制 Light-sleep 模式可用于需要保持与路由器的连接，不需要实时响应路由器发来的数据的场景。</p>
<h3 id="3-2-自动-Light-sleep"><a href="#3-2-自动-Light-sleep" class="headerlink" title="3.2 自动 Light-sleep"></a>3.2 自动 Light-sleep</h3><p>参考示例: <a href="https://github.com/espressif/esp-idf/tree/release/v3.2/examples/wifi/power_save" target="_blank" rel="noopener">power_save</a></p>
<p>开发者可配置系统在空闲时自动进入 Light-sleep 模式，并能在需要 CPU 工作时自动唤醒，无需配置唤醒源。在配置为自动 Light-sleep 后，可以保持与路由器的 Wi-Fi 连接，并通过路由器接收来自手机或者服务器的交互信息，对用户体验没有影响。<br>通常自动 Light-sleep 会与 Modem-sleep 模式 以及电源管理功能共同使用，电源管理功能允许系统根据 CPU 负载动态调节 CPU 频率以降低功耗。</p>
<blockquote>
<p>若系统应用中有小于 DTIM Beacon 间隔时间的循环定时,系统将不能进入 Light-sleep 模式。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200617144640674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70#pic_center" alt="此处输入图片的描述"></p>
<h4 id="3-2-1-API-说明"><a href="#3-2-1-API-说明" class="headerlink" title="3.2.1 API 说明"></a>3.2.1 API 说明</h4><ol>
<li>通过 <code>esp_err_t esp_pm_configure(const void* vconfig)</code> 接口配置电源管理功能，参数 <code>light_sleep_enable</code> 为 true 时使能自动休眠功能。</li>
</ol>
<blockquote>
<p>使能 自动 Light-sleep 功能，需要使能 <a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/kconfig.html#config-freertos-use-tickless-idle" target="_blank" rel="noopener">CONFIG_FREERTOS_USE_TICKLESS_IDLE</a> 和 <a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/kconfig.html#config-pm-enable" target="_blank" rel="noopener">CONFIG_PM_ENABLE</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_PM_ENABLE</span></span><br><span class="line">    <span class="comment">// Configure dynamic frequency scaling:</span></span><br><span class="line">    <span class="comment">// maximum and minimum frequencies are set in sdkconfig,</span></span><br><span class="line">    <span class="comment">// automatic light sleep is enabled if tickless idle support is enabled.</span></span><br><span class="line">    <span class="keyword">esp_pm_config_esp32_t</span> pm_config = &#123;</span><br><span class="line">            .max_freq_mhz = CONFIG_EXAMPLE_MAX_CPU_FREQ_MHZ,</span><br><span class="line">            .min_freq_mhz = CONFIG_EXAMPLE_MIN_CPU_FREQ_MHZ,</span><br><span class="line">#<span class="keyword">if</span> CONFIG_FREERTOS_USE_TICKLESS_IDLE</span><br><span class="line">            .light_sleep_enable = <span class="literal">true</span></span><br><span class="line">#endif</span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_ERROR_CHECK( esp_pm_configure(&amp;pm_config) );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CONFIG_PM_ENABLE</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-应用"><a href="#3-2-2-应用" class="headerlink" title="3.2.2 应用"></a>3.2.2 应用</h4><p>自动 Light-sleep 模式可用于需要保持与路由器的连接，可以实时响应路由器发来的数据的场景。并且在未接收到命令时，CPU 可以处于空闲状态。比如 Wi-Fi 开关的应用，大部分时间 CPU 都是空闲的，直到收到控制命令，CPU 才需要进行 GPIO 的操作。</p>
<hr>
<h2 id="3-3-Deep-sleep-模式"><a href="#3-3-Deep-sleep-模式" class="headerlink" title="3.3 Deep-sleep 模式"></a>3.3 Deep-sleep 模式</h2><p>参考示例: <a href="https://github.com/espressif/esp-idf/tree/release/v3.2/examples/system/deep_sleep" target="_blank" rel="noopener">deep_sleep</a></p>
<p>相对于其他两种模式，系统无法自动进入 Deep-sleep，需要由用户调用接口函数 <code>esp_deep_sleep_start()</code> 进入 Deep-sleep 模式。在该模式下，芯片会断开所有 Wi-Fi 连接与数据连接，进入 Deep-sleep 模式，只有 <strong>RTC 存储器和 RTC 外设以及 ULP 协处理器</strong>可以工作。从 Deep-sleep 唤醒后，CPU 将软件复位重启。</p>
<h3 id="3-3-1-API-说明"><a href="#3-3-1-API-说明" class="headerlink" title="3.3.1 API 说明"></a>3.3.1 API 说明</h3><ol>
<li>配置唤醒源后，可使用 <code>esp_deep_sleep_start()</code> 函数进入 Deep-sleep 模式。在没有配置唤醒源的情况下也可以进入 Deep-sleep 状态，在这种情况下，芯片将无限期地处于 Deep-sleep 模式，直到外部复位。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Enter deep sleep */</span></span><br><span class="line">esp_deep_sleep_start();</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-应用"><a href="#3-3-2-应用" class="headerlink" title="3.3.2 应用"></a>3.3.2 应用</h3><p>Deep-sleep 可以用于低功耗的传感器应用,或者大部分时间都不需要进行数据传输的情况。设备可以每隔一段时间从 Deep-sleep 状态醒来测量数据并上传,之后继续进入 Deep-sleep。也可以将多个数据存储于 RTC memory(RTC memory 在 Deep-sleep 模式下仍然可以保存数据),然后一次发送出去。</p>
<hr>
<h2 id="4-唤醒方式"><a href="#4-唤醒方式" class="headerlink" title="4 唤醒方式"></a>4 唤醒方式</h2><p>针对 <strong>强制 Lighe-sleep</strong> 和 <strong>Deep-sleep</strong> 需要配置唤醒源的情况，有以下唤醒方式可以选择：</p>
<blockquote>
<p>部分唤醒方式仅支持 Light-sleep</p>
</blockquote>
<h3 id="4-1-GPIO"><a href="#4-1-GPIO" class="headerlink" title="4.1 GPIO"></a>4.1 GPIO</h3><ol>
<li><p>External wakeup (ext0)</p>
<p>RTC IO 模块包含当其中 <strong>一个 RTC IO</strong> 的电平为唤醒电平（可配置为逻辑高或低）触发唤醒的逻辑。</p>
<p>RTC IO 是 RTC 外设电源域的一部分，因此如果使能该唤醒源，RTC 外设将在睡眠期间保持上电状态。在 ESP32 的修订版 0 和 1 中，此唤醒源与 ULP 和触摸唤醒源不兼容。</p>
<p>由于在此模式下启用了 RTC IO 模块，因此也可以使用内部上拉或下拉电阻。</p>
<p><code>esp_sleep_enable_ext0_wakeup()</code> 函数可用于启用此唤醒源。</p>
</li>
<li><p>External wakeup (ext1)</p>
<p>RTC 控制器包含使用 <strong>多个 RTC IO</strong> 触发唤醒的逻辑。两个逻辑功能之一可用于触发唤醒：</p>
<ul>
<li>如果任何一个所选 IO 为高电平，则唤醒（<code>ESP_EXT1_WAKEUP_ANY_HIGH</code>）</li>
<li>如果所有选定的 IO 都为低电平，则唤醒（<code>ESP_EXT1_WAKEUP_ALL_LOW</code>）</li>
</ul>
<p>该唤醒源由 RTC 控制器实现。因此，RTC 外设和 RTC 存储器可以在此模式下断电。</p>
<p>但是，如果 RTC 外设断电，内部上拉和下拉电阻将被禁用。要使用内部上拉或下拉电阻，请在睡眠期间请求 RTC 外设电源域保持上电。</p>
<p><code>esp_sleep_enable_ext1_wakeup()</code> 函数可用于启用此唤醒源。</p>
</li>
<li><p>Touch pad wakeup</p>
<p>RTC IO 模块包含触摸传感器中断时触发唤醒的逻辑。您需要在芯片开始睡眠之前配置触摸传感器中断。</p>
<p>当 RTC 外设未被强制上电时，ESP32 的修订版 0 和 1 仅支持此唤醒模式。</p>
<p><code>esp_sleep_enable_touchpad_wakeup()</code> 函数可用于启用此唤醒源。</p>
</li>
<li><p>GPIO wakeup <strong>(light sleep only)</strong></p>
<p>除了上面描述的 EXT0 和 EXT1 唤醒源之外，在 Light-sleep 模式下还有一种从外部输入唤醒的方法。通过该唤醒源，每个引脚可以使用 <code>gpio_wakeup_enable()</code> 函数单独配置为高电平或低电平唤醒。与 EXT0 和 EXT1 唤醒源（只能与 RTC IO 一起使用）不同，此唤醒源可用于任何 IO（RTC 或数字）。</p>
<p><code>esp_sleep_enable_gpio_wakeup()</code> 函数可用于启用此唤醒源。</p>
</li>
</ol>
<h3 id="4-2-ULP-协处理器唤醒"><a href="#4-2-ULP-协处理器唤醒" class="headerlink" title="4.2 ULP 协处理器唤醒"></a>4.2 ULP 协处理器唤醒</h3><p>参考示例: <a href="https://github.com/espressif/esp-idf/tree/release/v3.2/examples/system/ulp" target="_blank" rel="noopener">system/ulp</a></p>
<p>ULP 协处理器可以在芯片处于睡眠模式时运行，并且可以用于轮询传感器，监视 ADC 或触摸传感器值，并在检测到特定事件时唤醒芯片。ULP 协处理器是 RTC 外设电源域的一部分，它运行存储在 RTC 慢速存储器中的程序。如果请求此唤醒模式，RTC 慢速存储器将在睡眠期间启动。在 ULP 协处理器开始运行程序之前，RTC 外设将自动上电; 程序停止运行后，RTC 外设将再次自动关闭。</p>
<p>当 RTC 外设未被强制上电时，ESP32 的修订版 0 和 1 仅支持此唤醒模式。</p>
<p><code>esp_sleep_enable_ulp_wakeup()</code> 函数可用于启用此唤醒源。</p>
<h3 id="4-3-Timer"><a href="#4-3-Timer" class="headerlink" title="4.3 Timer"></a>4.3 Timer</h3><p>RTC 控制器具有内置定时器，可用于在预定义的时间后唤醒芯片。时间以微秒精度指定，但实际分辨率取决于为 RTC SLOW_CLK 选择的时钟源。</p>
<p>此唤醒模式不需要在睡眠期间打开 RTC 外设或 RTC 存储器。</p>
<p><code>esp_sleep_enable_timer_wakeup()</code> 函数可用于启用此唤醒源。</p>
<h3 id="4-4-UART-wakeup-light-sleep-only"><a href="#4-4-UART-wakeup-light-sleep-only" class="headerlink" title="4.4 UART wakeup (light sleep only)"></a>4.4 UART wakeup (light sleep only)</h3><p>仅支持  Light-sleep 模式。当 ESP32 从外部设备接收 UART 输入时，通常需要在输入数据可用时唤醒芯片。UART 外设包含一项功能，当看到 RX 引脚上的一定数量的上升沿时，可以将芯片从 Light-sleep 状态唤醒。可以使用 <code>uart_set_wakeup_threshold()</code> 函数设置此上升沿数。请注意，唤醒后 UART 不会接收触发唤醒的字符（及其前面的任何字符）。这意味着外部设备通常需要在发送数据之前向 ESP32 发送额外字符以触发唤醒。</p>
<p><code>esp_sleep_enable_uart_wakeup()</code> 函数可用于启用此唤醒源。</p>
<h2 id="5-GPIO-Hold-功能"><a href="#5-GPIO-Hold-功能" class="headerlink" title="5 GPIO Hold 功能"></a>5 GPIO Hold 功能</h2><p>每个 IO pad(包括 RTC pad)都有单独的 hold 功能，由 RTC 寄存器控制。pad 的 hold 功能被置上后，pad 在置上 hold 那一刻的状态被强制保持，无论内部信号如何变化，修改 IO_MUX 配置或者 GPIO 配置，都不会改变 pad 的状态。应用如果希望在看门狗超时触发内核复位和系统复位时或者 Deep-sleep 时 pad 的状态不被改变，就需要提前把 hold 置上。</p>
<blockquote>
<p>在 Deep-sleep 模式下使用 Hold 功能，可能会增加功耗。并且如果使用内部上拉或下拉电阻，需要在睡眠期间使 RTC 外设电源域保持上电。</p>
</blockquote>
<blockquote>
<p>在睡眠模式下，部分引脚的电源域可能关掉了，所以无法 Hold 功能无法生效，这时需要确认能否打开电源域。例如：GPIO16、17 会在 light sleep 下关闭电源域 VDD_SDIO，所以无法 Hold，这时需要在 esp_light_sleep_start() 中修改代码打开电源域。</p>
</blockquote>
<p>针对 RTC IO，可对<strong>单个 RTC Pad 使能 Hold 功能</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rtc_gpio_init(<span class="number">27</span>);</span><br><span class="line">rtc_gpio_set_direction(<span class="number">27</span>, RTC_GPIO_MODE_OUTPUT_ONLY);</span><br><span class="line">rtc_gpio_set_level(<span class="number">27</span>, <span class="number">1</span>);</span><br><span class="line">rtc_gpio_pullup_en(<span class="number">27</span>);</span><br><span class="line">rtc_gpio_hold_en(<span class="number">27</span>);</span><br></pre></td></tr></table></figure>

<p>针对 数字 IO，会对<strong>所有 数字 IO 使能 Hold 功能</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio_pad_select_gpio(<span class="number">26</span>);</span><br><span class="line">gpio_set_direction(<span class="number">26</span>, GPIO_MODE_OUTPUT);</span><br><span class="line">gpio_set_level(<span class="number">26</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">gpio_hold_en(<span class="number">26</span>);</span><br><span class="line"><span class="comment">/*When the chip is in Deep-sleep mode, all digital gpio will hold the state before sleep, and when the chip is woken up, the status of digital gpio will not be held.*/</span></span><br><span class="line">gpio_deep_sleep_hold_en();</span><br></pre></td></tr></table></figure>

<h2 id="6-常见问题"><a href="#6-常见问题" class="headerlink" title="6 常见问题"></a>6 常见问题</h2><ol>
<li><p>进入 Deep-sleep 后，功耗较高</p>
<p> 有这些原因可能会导致功耗较高：</p>
<ul>
<li><code>esp_sleep_enable_ext0_wakeup()</code> 需要打开 RTC 外设，产生额外的 100mA 左右的电流消耗，调用 <code>esp_sleep_enable_ext1_wakeup()</code> 则不需要打开 RTC 外设，即不会产生额外的电流。</li>
<li>在 IDF 3.1.1 前的版本可能存在使用 wifi 并关闭后进入睡眠模式，功耗比未使用 wifi 后进入睡眠模式高 1mA 左右。这种情况下，需要在进入睡眠模式前调用 <code>adc_power_off()</code> 关闭 ADC 以解决这个问题。</li>
<li>使用 Hold 功能保持一个固定电平，可能会增加功耗 1mA 左右，这种情况也是由于打开 RTC 外设导致。</li>
<li>某些 GPIO 漏电，一些 ESP32 IO 具有内部上拉或下拉，默认情况下启用。如果外部电路在 Deep-sleep 模式下驱动此引脚，则由于流过这些上拉和下拉的电流，电流消耗可能会增加。要隔离引脚，防止额外的电流消耗，请调用 <code>rtc_gpio_isolate()</code> 函数。例如：ESP32-WROVER 模组上，外部上拉 GPIO12。GPIO12 在 ESP32 芯片中也有内部下拉。这意味着在 Deep-sleep 中，一些电流将流过这些外部和内部电阻，从而增加电流消耗。</li>
<li>某些 IO 芯片内外电压不匹配，可能会增加电流消耗。如果存在电压不匹配的情况，需要在进入睡眠模式前配置 IO 为 Disable 模式，并使能 Hold 功能。</li>
</ul>
</li>
<li><p>使能 自动 Light-sleep 后，功耗较高</p>
<ul>
<li>存在任务持续运行占用 CPU 资源，导致 CPU 负载过大无法休眠。若是这种情况，请检测是否存在 任务 持续运行，并优化当前应用程序流程使 CPU 能周期性空闲进入 Light-sleep 模式。</li>
<li>若系统应用中有小于 DTIM Beacon 间隔时间的循环定时，系统将不能进入 Light-sleep 模式。</li>
<li>若未使用最新 IDF 3.2 版本，可能会因为某些外设使用（例如：I2C、I2S），导致无法自动进入 Light-sleep 模式。若是这个问题，请更新到最新的 IDF 3.2 版本。</li>
<li>若系统不需要 FreeRTOS 时钟配置为 1000 Hz，可将 FreeRTOS 时钟降低为 100 Hz，可显著降低功耗。</li>
</ul>
</li>
<li><p>自动 Light-sleep 调试方法</p>
<ul>
<li>在 menuconfig 中使能 <a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/kconfig.html#config-pm-profiling" target="_blank" rel="noopener">CONFIG_PM_PROFILING</a> ，如果使能，<code>esp_pm_*</code> 函数将跟踪每个电源管理锁的保留时间，<code>esp_pm_dump_locks</code> 函数将打印此信息。 此功能可用于分析哪些锁阻止芯片进入低功耗状态，并查看芯片在每种省电模式下花费的时间，并应在应用程序中保持禁用状态。</li>
<li>在 menuconfig 中使能 <a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/kconfig.html#config-pm-trace" target="_blank" rel="noopener">CONFIG_PM_TRACE</a>，如果使能，某些 GPIO 将用于发出 RTOS 滴答，频率切换，进入/退出空闲状态等事件的信号。有关 GPIO 列表，请参阅 <code>pm_trace.c</code> 文件。 此功能旨在用于分析/调试电源管理实现的行为时使用，并应在应用程序中保持禁用状态。</li>
</ul>
</li>
</ol>
<h2 id="7-不同功耗模式下的功耗"><a href="#7-不同功耗模式下的功耗" class="headerlink" title="7 不同功耗模式下的功耗"></a>7 不同功耗模式下的功耗</h2><p><img src="https://img-blog.csdnimg.cn/20200617144756531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70#pic_center" alt="不同功耗模式下的功耗"></p>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二十二）睡眠模式</title>
    <url>/InfiniteYuanBlog/2019/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%E7%9D%A1%E7%9C%A0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="睡眠模式"><a href="#睡眠模式" class="headerlink" title="睡眠模式"></a>睡眠模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 有轻度睡眠(light sleep)和深度睡眠(deep sleep)两种省电模式。</p>
<p>在轻度睡眠模式下，数字外设，大多数 RAM 和 CPU 都是时钟门控的，电源电压会降低。从轻度睡眠退出后，外围设备和 CPU 恢复运行，其内部状态将得以保留。</p>
<p>在深度睡眠模式下，CPU，大多数 RAM 以及从 APB_CLK 提供时钟的所有数字外设都将断电。芯片中仍然可以通电的唯一部分是：RTC 控制器，RTC 外设（包括 ULP 协处理器）和 RTC 存储器（慢速和快速）。</p>
<p>可以使用多种唤醒源从深度和轻度睡眠模式唤醒。可以组合这些唤醒源，在这种情况下，当触发任何一个源时芯片将被唤醒。可以使用 <code>esp_sleep_enable_X_wakeup</code> API 启用唤醒源，并可以使用 <code>esp_sleep_disable_wakeup_source()</code> API 禁用唤醒源。下一节将详细介绍这些 API。在进入浅色或深度睡眠模式之前，可以随时配置唤醒源。</p>
<p>此外，应用程序可以使用 <code>esp_sleep_pd_config()</code> API 强制 RTC 外设和 RTC 存储器的特定掉电模式。</p>
<p>配置唤醒源后，应用程序可以使用 <code>esp_light_sleep_start()</code> 或 <code>esp_deep_sleep_start()</code> API 进入睡眠模式。此时，将根据请求的唤醒源配置硬件，RTC 控制器将关闭 CPU 或数字外设的电源或关闭电源。</p>
<a id="more"></a>

<h2 id="WiFi-BT-和睡眠模式"><a href="#WiFi-BT-和睡眠模式" class="headerlink" title="WiFi/BT 和睡眠模式"></a>WiFi/BT 和睡眠模式</h2><p>在深度睡眠和轻度睡眠模式下，无线外围设备断电。 在进入深度睡眠或轻度睡眠模式之前，应用程序必须调用适当的函数（<code>esp_bluedroid_disable()</code>，<code>esp_bt_controller_disable()</code>，<code>esp_wifi_stop()</code>）禁用 WiFi 和 BT。 即使不调用这些功能，也不会在深度睡眠或轻度睡眠中保持 WiFi 和 BT 连接。</p>
<p>如果需要维护 WiFi 连接，请启用 WiFi 调制解调器睡眠(modem sleep)，并启用自动轻度睡眠功能（请参阅<a href="https://blog.csdn.net/qq_27114397/article/details/88411347" target="_blank" rel="noopener">电源管理 API</a>）。这将允许系统在需要 WiFi 驱动程序时自动从睡眠中唤醒，从而保持与 AP 的连接。</p>
<h2 id="唤醒源"><a href="#唤醒源" class="headerlink" title="唤醒源"></a>唤醒源</h2><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>RTC 控制器具有内置定时器，可用于在预定义的时间后唤醒芯片。时间以微秒精度指定，但实际分辨率取决于为 RTC SLOW_CLK 选择的时钟源。有关 RTC 时钟选项的详细信息，请参见“ESP32 技术参考手册”的“复位和时钟”一章。</p>
<p>此唤醒模式不需要在睡眠期间打开 RTC 外围设备或 RTC 存储器。</p>
<p><code>esp_sleep_enable_timer_wakeup()</code> 函数可用于使用定时器启用深度睡眠唤醒。</p>
<h3 id="Touch-pad"><a href="#Touch-pad" class="headerlink" title="Touch pad"></a>Touch pad</h3><p>RTC IO 模块包含触摸传感器中断时触发唤醒的逻辑。您需要在芯片开始深度睡眠之前配置触摸传感器。</p>
<p>当 RTC 外设未被强制上电时（即 <code>ESP_PD_DOMAIN_RTC_PERIPH</code> 应设置为 <code>ESP_PD_OPTION_AUTO</code>），ESP32 的修订版 0 和 1 仅支持此唤醒模式。</p>
<p><code>esp_sleep_enable_touchpad_wakeup()</code> 函数可用于启用此唤醒源。</p>
<h3 id="External-唤醒-ext0"><a href="#External-唤醒-ext0" class="headerlink" title="External 唤醒(ext0)"></a>External 唤醒(ext0)</h3><p>RTC IO 模块包含当其中 <strong>一个 RTC GPIO</strong> 的电平为预定义的逻辑电平时触发唤醒的逻辑。RTC IO 是 RTC 外设电源域的一部分，因此如果请求唤醒源，RTC 外设将在深度睡眠期间保持通电状态。</p>
<p>由于在此模式下启用了 RTC IO 模块，因此也可以使用内部上拉或下拉电阻。在调用 <code>esp_sleep_start()</code> 之前，需要使用 <code>rtc_gpio_pullup_en()</code> 和 <code>rtc_gpio_pulldown_en()</code> 函数由应用程序配置它们。</p>
<p>在 ESP32 的修订版 0 和 1 中，此唤醒源与 ULP 和触摸唤醒源不兼容。</p>
<p><code>esp_sleep_enable_ext0_wakeup()</code> 函数可用于启用此唤醒源。</p>
<blockquote>
<p>从睡眠状态唤醒后，用于唤醒的 IO pad 将被配置为 RTC IO。在将此 pad 用作数字 GPIO 之前，请使用 <code>rtc_gpio_deinit(gpio_num)</code> 函数重新配置它。</p>
</blockquote>
<h3 id="External-唤醒-ext1"><a href="#External-唤醒-ext1" class="headerlink" title="External 唤醒(ext1)"></a>External 唤醒(ext1)</h3><p>RTC 控制器包含使用 <strong>多个 RTC GPIO</strong> 触发唤醒的逻辑。两个逻辑功能之一可用于触发唤醒：</p>
<ul>
<li>如果任何所选引脚为高电平，则唤醒（<code>ESP_EXT1_WAKEUP_ANY_HIGH</code>）</li>
<li>如果所有选定的引脚都为低电平，则唤醒（<code>ESP_EXT1_WAKEUP_ALL_LOW</code>）</li>
</ul>
<p>该唤醒源由 RTC 控制器实现。因此，RTC 外设和 RTC 存储器可以在此模式下断电。但是，如果 RTC 外设断电，内部上拉和下拉电阻将被禁用。要使用内部上拉或下拉电阻，请在睡眠期间请求 RTC 外设电源域保持开启，并在进入睡眠模式之前使用 rtc_gpio_ 函数配置上拉/下拉电阻：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);</span><br><span class="line">gpio_pullup_dis(gpio_num);</span><br><span class="line">gpio_pulldown_en(gpio_num);</span><br></pre></td></tr></table></figure>

<p><code>esp_sleep_enable_ext1_wakeup()</code>  函数可用于启用此唤醒源。</p>
<blockquote>
<p>从睡眠状态唤醒后，用于唤醒的 IO pad 将被配置为 RTC IO。在将此 pad 用作数字 GPIO 之前，请使用 <code>rtc_gpio_deinit(gpio_num)</code> 函数重新配置它。</p>
</blockquote>
<h3 id="ULP-协处理器唤醒"><a href="#ULP-协处理器唤醒" class="headerlink" title="ULP 协处理器唤醒"></a>ULP 协处理器唤醒</h3><p>ULP 协处理器可以在芯片处于睡眠模式时运行，并且可以用于轮询传感器，监视 ADC 或触摸传感器值，并在检测到特定事件时唤醒芯片。ULP 协处理器是 RTC 外设电源域的一部分，它运行存储在 RTC 慢速存储器中的程序。如果请求此唤醒模式，RTC 慢速内存将在睡眠期间启动。在 ULP 协处理器开始运行程序之前，RTC 外设将自动上电; 程序停止运行后，RTC 外设将再次自动关闭。</p>
<p>当 RTC 外设未被强制上电时（即 <code>ESP_PD_DOMAIN_RTC_PERIPH</code> 应设置为 <code>ESP_PD_OPTION_AUTO</code>），ESP32 的修订版 0 和 1 仅支持此唤醒模式。</p>
<p><code>esp_sleep_enable_ulp_wakeup()</code>  函数可用于启用此唤醒源。</p>
<h3 id="GPIO-唤醒-仅-light-sleep"><a href="#GPIO-唤醒-仅-light-sleep" class="headerlink" title="GPIO 唤醒(仅 light sleep)"></a>GPIO 唤醒(仅 light sleep)</h3><p>除了上面描述的 EXT0 和 EXT1 唤醒源之外，在轻度睡眠模式下还有一种从外部输入唤醒的方法。通过该唤醒源，每个引脚可以单独使用 <code>gpio_wakeup_enable()</code> 函数配置为高电平或低电平唤醒。与 EXT0 和 EXT1 唤醒源（只能与 RTC IO 一起使用）不同，此唤醒源可用于任何 IO（RTC 或数字）。</p>
<p><code>esp_sleep_enable_gpio_wakeup()</code> 函数可用于启用此唤醒源。</p>
<h3 id="UART-唤醒-仅-light-sleep"><a href="#UART-唤醒-仅-light-sleep" class="headerlink" title="UART 唤醒(仅 light sleep)"></a>UART 唤醒(仅 light sleep)</h3><p>当 ESP32 从外部设备接收 UART 输入时，通常需要在输入数据可用时唤醒芯片。UART 外设包含一项功能，当看到 RX 引脚上的一定数量的上升沿时，可以将芯片从轻度睡眠状态唤醒。可以使用 <code>uart_set_wakeup_threshold()</code> 函数设置此上升沿数。请注意，唤醒后 UART 不会接收触发唤醒的字符（及其前面的任何字符）。 这意味着外部设备通常需要在发送数据之前向 ESP32 发送额外字符以触发唤醒。</p>
<p><code>esp_sleep_enable_uart_wakeup()</code> 函数可用于启用此唤醒源。</p>
<h2 id="RTC外设和存储器掉电"><a href="#RTC外设和存储器掉电" class="headerlink" title="RTC外设和存储器掉电"></a>RTC外设和存储器掉电</h2><p>默认情况下，<code>esp_deep_sleep_start()</code> 和 <code>esp_light_sleep_start()</code> 函数将关闭所有启用的唤醒源不再需要的 RTC 电源域。要覆盖此行为，请提供 <code>esp_sleep_pd_config()</code> 函数。</p>
<p>注意：在 ESP32 的版本 0 中，RTC 快速存储器将始终在深度睡眠中保持启用状态，以便深度睡眠存根可以在复位后运行。 如果应用程序在深度睡眠后不需要干净的重置行为，则可以覆盖此项。</p>
<p>如果程序中的某些变量放入RTC慢速存储器（例如，使用 <code>RTC_DATA_ATTR</code> 属性），RTC 慢速存储器将默认保持通电状态。 如果需要，可以使用 <code>esp_sleep_pd_config()</code> 函数覆盖它。</p>
<h2 id="进入轻度睡眠"><a href="#进入轻度睡眠" class="headerlink" title="进入轻度睡眠"></a>进入轻度睡眠</h2><p>配置唤醒源后，可使用 <code>esp_light_sleep_start()</code> 函数进入轻度睡眠模式。在没有配置唤醒源的情况下也可以进入轻度睡眠状态，在这种情况下，芯片将无限期地处于轻度睡眠模式，直到外部复位。</p>
<h2 id="进入深度睡眠"><a href="#进入深度睡眠" class="headerlink" title="进入深度睡眠"></a>进入深度睡眠</h2><p>配置唤醒源后，可使用 <code>esp_deep_sleep_start()</code> 函数进入深度睡眠模式。在没有配置唤醒源的情况下也可以进入深度睡眠状态，在这种情况下，芯片将无限期地处于深度睡眠模式，直到外部复位。</p>
<h2 id="IO-配置"><a href="#IO-配置" class="headerlink" title="IO 配置"></a>IO 配置</h2><p>一些 ESP32 IO 具有内部上拉或下拉，默认情况下启用。如果外部电路在深度睡眠模式下驱动此引脚，则由于流过这些上拉和下拉的电流，电流消耗可能会增加。</p>
<p>要隔离引脚，防止额外的电流消耗，请调用 <code>rtc_gpio_isolate()</code> 函数。</p>
<p>例如，在 ESP32-WROVER 模块上，外部上拉 GPIO12。GPIO12 在 ESP32 芯片中也有内部下拉。这意味着在深度睡眠中，一些电流将流过这些外部和内部电阻，从而将深度睡眠电流增加到最小可能值以上。在 <code>esp_deep_sleep_start()</code> 之前添加以下代码以删除此额外电流：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtc_gpio_isolate(GPIO_NUM_12);</span><br></pre></td></tr></table></figure>

<h2 id="UART-输出处理"><a href="#UART-输出处理" class="headerlink" title="UART 输出处理"></a>UART 输出处理</h2><p>在进入睡眠模式之前，<code>esp_deep_sleep_start()</code> 将刷新 UART FIFO 的内容。</p>
<p>使用 <code>esp_light_sleep_start()</code> 进入轻度睡眠模式时，UART FIFO 不会被刷新。相反，UART 输出将被暂停，FIFO 中的剩余字符将在从轻度睡眠唤醒后发送出去。</p>
<h2 id="检查睡眠唤醒原因"><a href="#检查睡眠唤醒原因" class="headerlink" title="检查睡眠唤醒原因"></a>检查睡眠唤醒原因</h2><p><code>esp_sleep_get_wakeup_cause()</code> 函数可用于检查哪个唤醒源触发了从睡眠模式中唤醒。</p>
<p>对于 TouchPad 和 ext1 唤醒源，可以使用 <code>esp_sleep_get_touchpad_wakeup_status()</code> 和 <code>esp_sleep_get_ext1_wakeup_status()</code> 函数识别引起唤醒的引脚或 TouchPad。</p>
<h2 id="禁用睡眠唤醒源"><a href="#禁用睡眠唤醒源" class="headerlink" title="禁用睡眠唤醒源"></a>禁用睡眠唤醒源</h2><p>先前配置的唤醒源可以在之后使用 <code>esp_sleep_disable_wakeup_source()</code> API 禁用。此功能将停用触发对给定唤醒源。此外，如果参数为 ESP_SLEEP_WAKEUP_ALL，它可以禁用所有触发器。</p>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>深度睡眠的基本功能的实现在 protocols/sntp 示例中给出，其中 ESP 模块被周期性地唤醒以从 NTP 服务器检索时间。</p>
<p>system/deep_sleep 示例中更广泛的说明了各种深度睡眠唤醒触发器和 ULP 协处理器编程的使用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/system/sleep_modes.html" target="_blank" rel="noopener">Sleep Modes</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二十五）脉冲计数器</title>
    <url>/InfiniteYuanBlog/2019/03/26/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="脉冲计数器"><a href="#脉冲计数器" class="headerlink" title="脉冲计数器"></a>脉冲计数器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PCNT（脉冲计数器）模块用于计算输入信号的上升沿和/或下降沿的数量。每个脉冲计数器单元都有一个 16 位有符号计数器寄存器和两个通道，可配置为递增或递减计数器。每个通道都有一个接收待检测信号边沿的信号输入，以及一个可用于启用或禁用信号输入的控制输入。输入具有可选滤波器，可用于丢弃信号中不需要的毛刺。</p>
<h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>此 API 的功能描述分为四个部分：</p>
<ul>
<li>配置 - 描述计数器的配置参数以及如何设置计数器。</li>
<li>操作计数器 - 提供有关暂停，测量和清除计数器的控制功能相关信息。</li>
<li>滤波脉冲 - 介绍滤波脉冲和计数器控制信号的可选项。</li>
<li>使用中断 - 介绍如何在计数器的特定状态上触发中断。</li>
</ul>
<a id="more"></a>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>PCNT 模块有 8 个独立的计数“单元”，编号从 0 到 7. 在 API 中，它们使用 <code>pcnt_unit_t</code> 引用。每个单元有两个独立的通道，编号为 0 和 1，并用 <code>pcnt_channel_t</code> 指定。</p>
<p>使用 <code>pcnt_config_t</code> 为每个单元的通道单独提供配置，并涵盖：</p>
<ul>
<li>此配置所指的单元和通道编号。</li>
<li>脉冲输入和脉冲门输入的GPIO编号。</li>
<li>两对参数：<code>pcnt_ctrl_mode_t</code> 和 <code>pcnt_count_mode_t</code>，用于定义计数器如何响应，具体取决于控制信号的状态以及如何计算脉冲的正/负边沿。</li>
<li>当脉冲计数满足特定限制时，用于建立观察点和触发中断的两个极限值（最小值/最大值）。</li>
</ul>
<p>然后通过调用上面的 <code>pcnt_config_t</code> 作为输入参数的函数 <code>pcnt_unit_config()</code> 来完成特定通道的设置。</p>
<p>要在配置中禁用脉冲或控制输入引脚，请提供 <code>PCNT_PIN_NOT_USED</code> 而不是 GPIO 编号。</p>
<h2 id="操作计数器"><a href="#操作计数器" class="headerlink" title="操作计数器"></a>操作计数器</h2><p>使用 <code>pcnt_unit_config()</code> 进行设置后，计数器立即开始运行。可以通过调用 <code>pcnt_get_counter_value()</code> 获取累积的脉冲计数。</p>
<p>有几个函数可以控制计数器的操作：<code>pcnt_counter_pause()</code>，<code>pcnt_counter_resume()</code> 和 <code>pcnt_counter_clear()</code></p>
<p>也可以通过调用 <code>pcnt_set_mode()</code> 使用 <code>pcnt_unit_config()</code> 动态更改计数器模式。</p>
<p>如果需要，可以使用 <code>pcnt_set_pin()</code> “动态”更改脉冲输入引脚和控制输入引脚。要禁用特定输入，请提供功能参数 <code>PCNT_PIN_NOT_USED</code> 而不是 GPIO 编号。</p>
<blockquote>
<p>为了使计数器不会错过任何脉冲，脉冲持续时间应该长于一个 APB_CLK 周期（12.5 ns）。脉冲在 APB_CLK 时钟的边沿上采样，如果在边缘之间落下，则可能会丢失。这适用于对带或不带过滤器的操作。</p>
</blockquote>
<h2 id="滤波脉冲"><a href="#滤波脉冲" class="headerlink" title="滤波脉冲"></a>滤波脉冲</h2><p>PCNT 单元在每个脉冲和控制输入上都有滤波器，增加了忽略信号中短暂毛刺的选项。</p>
<p>通过调用 <code>pcnt_set_filter_value()</code> 在 APB_CLK 时钟周期中提供忽略脉冲的长度。可以使用 <code>pcnt_get_filter_value()</code> 检查当前过滤器设置。APB_CLK 时钟以 80 MHz运行。</p>
<p>通过调用 <code>pcnt_filter_enable()</code>/<code>pcnt_filter_disable()</code> 将过滤器投入运行/暂停。</p>
<h2 id="使用中断"><a href="#使用中断" class="headerlink" title="使用中断"></a>使用中断</h2><p>在 <code>pcnt_evt_type_t</code> 中定义的五个计数器状态监视事件能够触发中断。事件发生在脉冲计数器达到特定值：</p>
<ul>
<li>最小或最大计数值：在配置中讨论的 <code>pcnt_config_t</code> 中提供的 <code>counter_l_lim</code> 或 <code>counter_h_lim</code></li>
<li>使用函数 <code>pcnt_set_event_value()</code> 设置阈值 0 或阈值 1 值。</li>
<li>脉冲计数=0</li>
</ul>
<p>要注册，启用或禁用中断以服务上述事件，请调用 <code>pcnt_isr_register()</code>，<code>pcnt_intr_enable()</code> 和 <code>pcnt_intr_disable()</code>。要在达到阈值时启用或禁用事件，还需要调用函数 <code>pcnt_event_enable()</code> 和 <code>pcnt_event_disable()</code>。</p>
<p>要检查当前设置的阈值，请使用函数 <code>pcnt_get_event_value()</code>。</p>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>带控制信号和事件中断的脉冲计数器示例：<a href="https://github.com/espressif/esp-idf/tree/106dc0590/examples/peripherals/pcnt" target="_blank" rel="noopener">peripherals/pcnt</a>.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/pcnt.html" target="_blank" rel="noopener">Pulse Counter</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二十八） ESP32 串口下载过程(使用 esptool) [转]</title>
    <url>/InfiniteYuanBlog/2020/03/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%20ESP32%20%E4%B8%B2%E5%8F%A3%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B(%E4%BD%BF%E7%94%A8%20esptool)%20%5B%E8%BD%AC%5D/</url>
    <content><![CDATA[<h1 id="ESP32-串口下载过程-使用-esptool"><a href="#ESP32-串口下载过程-使用-esptool" class="headerlink" title="ESP32 串口下载过程(使用 esptool)"></a>ESP32 串口下载过程(使用 esptool)</h1><p>原文链接：<a href="https://www.esp32.com/viewtopic.php?f=25&amp;t=8161&amp;p=34283#p34283" target="_blank" rel="noopener">https://www.esp32.com/viewtopic.php?f=25&amp;t=8161&amp;p=34283#p34283</a></p>
<p>通常，我们会通过 python 脚本，从 PC 端，通过串口给 esp32 芯片或者模块下载固件程序。<br>通过 esptool (<a href="https://github.com/espressif/esptool" target="_blank" rel="noopener">https://github.com/espressif/esptool</a>) 脚本，我们可以很方便的实现。</p>
<p>但有时，我们也希望能通过其他单片机的串口，给 esp32/esp8266 进行固件更新。（前提是外部单片机能够控制esp32 进入串口下载模式)。<br>完整的串口通信协议可以参考这里(<a href="https://github.com/espressif/esptool/w" target="_blank" rel="noopener">https://github.com/espressif/esptool/w</a> … -Protocol)<br>为了方便调试，我们可以通过运行 esptool，来查看上位机与esp32之间的通信过程。</p>
<a id="more"></a>

<p>首先，esp32 的串口通信协议基于 SLIP (Serial Line Internet Protocol)。任何一个数据包以0xC0开始，以0xC0结尾。数据包内容中的0xC0替换为0xDB 0xDC。数据包内容中的0xDB替换为0xDB 0xDD.</p>
<p>在运行esptool的同时，在命令中添加 –trace 参数，即可查看通信过程中的串口数据。</p>
<p>以读取 flash id 的过程为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python esptool.py -b <span class="number">115200</span> -p /dev/cu.SLAB_USBtoUART --trace --no-stub flash_id</span><br></pre></td></tr></table></figure>

<p>从输出的 log 中，我们可以看到串口通信的具体内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRACE +<span class="number">0.000</span> command op=<span class="number">0x09</span> data len=<span class="number">16</span> wait_response=<span class="number">1</span> timeout=<span class="number">3.000</span> data=<span class="number">1</span>c20006040000080ffffffff00000000</span><br><span class="line">TRACE +<span class="number">0.000</span> Write <span class="number">26</span> bytes: </span><br><span class="line">    c000091000000000 <span class="number">001</span>c200060400000 | .......... .`@..</span><br><span class="line">    <span class="number">80f</span>fffffff000000 <span class="number">00</span>c0             | ..........</span><br><span class="line">TRACE +<span class="number">0.004</span> Read <span class="number">1</span> bytes: c0</span><br><span class="line">TRACE +<span class="number">0.000</span> Read <span class="number">13</span> bytes: <span class="number">01090400</span>c840160000000000c0</span><br><span class="line">TRACE +<span class="number">0.000</span> Received full packet: <span class="number">01090400</span>c840160000000000</span><br></pre></td></tr></table></figure>

<p>上面的 log 中，串口向 esp32 发送 26 字节十六进制序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c000091000000000001c20006040000080ffffffff00000000c0</span><br></pre></td></tr></table></figure>

<p>esp32 向串口返回13字节十六进制序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c001090400c840160000000000c0</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二十六）NVS</title>
    <url>/InfiniteYuanBlog/2019/04/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89NVS/</url>
    <content><![CDATA[<h1 id="NVS-Non-volatile-storage"><a href="#NVS-Non-volatile-storage" class="headerlink" title="NVS - Non-volatile storage"></a>NVS - Non-volatile storage</h1><p>非易失性存储（NVS）库主要用于在闪存中存储键值对。本节介绍 NVS 使用的一些概念。</p>
<h2 id="底层存储"><a href="#底层存储" class="headerlink" title="底层存储"></a>底层存储</h2><p>目前，NVS 通过 <code>spi_flash_{read|write|erase}</code>  API 使用主闪存的一部分。该库使用具有 data 类型和 nvs 子类型的所有分区。应用程序可以通过 <code>nvs_open</code> API 选择使用带有标签 nvs 的分区或通过 <code>nvs_open_from_part</code> API 使用指定名称的任意分区。</p>
<blockquote>
<p>如果 NVS 分区被截断（例如，更改分区表布局时），则应擦除其内容。ESP-IDF 构建系统提供 <code>make erase_flash</code> 以擦除闪存芯片的所有内容。</p>
</blockquote>
<blockquote>
<p>NVS 最适合存储许多小值，而不是 “string” 和 “blob” 类型的大值。如果需要存储大的 blob 或字符串，请考虑使用在损耗均衡库之上的 FAT 文件系统提供的功能。</p>
</blockquote>
<a id="more"></a>

<h2 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h2><p>NVS 在键值对上操作。键是 ASCII 字符串，最大键长度当前为 15 个字符。值可以具有以下类型之一：</p>
<ul>
<li>整形: uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t</li>
<li>以0结尾的字符串</li>
<li>可变长的二进制数据(blob)</li>
</ul>
<blockquote>
<p>字符串值目前限制为 4000 字节。这包括空终止符。Blob 值限制为 508000 字节或（分区大小的 97.6％- 4000）字节，以较低者为准。</p>
</blockquote>
<p>键必须是唯一的。为已存在的键写入值的行为如下：</p>
<ul>
<li>如果新值相同，则更新值</li>
<li>如果新值与旧值的数据类型不同，则返回错误</li>
</ul>
<p>读取值时也会执行数据类型检查。如果读取操作的数据类型与值的数据类型不匹配，则返回错误。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>为了缓解不同组件之间键名称中的潜在冲突，NVS 将每个键值对分配给一个命名空间。命名空间名称遵循与键名相同的规则，即最多15个字符的长度。命名空间名称在 <code>nvs_open</code> 或 <code>nvs_open_from_part</code> 调用中指定。此调用返回一个不透明句柄，该句柄用于后续调用 <code>nvs_read_ *</code>，<code>nvs_write_ *</code> 和 <code>nvs_commit</code> 函数。这样，handle 与命名空间相关联，并且键名不会与其他命名空间中的相同名称冲突。 请注意，不同 NVS 分区中具有相同名称的命名空间被视为单独的命名空间。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>NVS 与 ESP32 闪存加密系统不直接兼容。然而，如果 NVS 加密与 ESP32 闪存加密一起使用，数据仍可以加密形式存储。</p>
<h2 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h2><h3 id="键值对的日志"><a href="#键值对的日志" class="headerlink" title="键值对的日志"></a>键值对的日志</h3><p>NVS 按顺序存储键值对，新的键值对添加在最后。当必须更新任何给定密钥的值时，在日志的末尾添加新的键值对，并将旧的键值对标记为已擦除。</p>
<h3 id="页面和条目"><a href="#页面和条目" class="headerlink" title="页面和条目"></a>页面和条目</h3><p>NVS 库在其操作中使用两个主要实体：页面和条目。Page 是一个逻辑结构，用于存储整个日志的一部分。逻辑页面对应于闪存的一个物理扇区。正在使用的页面具有与之关联的序列号。序列号在页面上强制排序。较高的序列号对应于稍后创建的页面。</p>
<h3 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h3><p>页面由三部分组成：标题，条目状态位图和条目本身。要与 ESP32 闪存加密兼容，条目大小为 32 个字节。对于整数类型，条目包含一个键值对。对于字符串和 blob，条目包含键值对的一部分。</p>
<h3 id="条目状态位图和条目"><a href="#条目状态位图和条目" class="headerlink" title="条目状态位图和条目"></a>条目状态位图和条目</h3><p>每个条目可以处于以下三种状态之一。每个状态在入口状态位图中用两位表示。位图中的最后四位（256-2 * 126）未使用。</p>
<ul>
<li>空（2’b11）</li>
<li>被写（2’b10）</li>
<li>删除（2’b00）</li>
</ul>
<h3 id="条目结构"><a href="#条目结构" class="headerlink" title="条目结构"></a>条目结构</h3><p>对于基本类型的值（当前长度为 1 到 8 个字节的整数），条目包含一个键值对。对于字符串和 blob 类型，条目包含整个键值对的一部分。对于字符串，如果键值对跨越多个条目，则所有条目都存储在同一页面中。通过将 Blob 划分为更小的块，允许Blob跨越多个页面。为了跟踪这些块，存储称为“blob 索引”条目的附加固定长度元数据条目。早期格式的 blob 仍然受支持（可以读取和修改）。但是，一旦修改了blob，就会使用新格式存储它们。</p>
<p>可变长度值（字符串和 blob）写入后续条目，每个条目 32 个字节。第一个条目的 Span 字段表示使用了多少条目。</p>
<h3 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a>命名空间</h3><p>如上所述，每个键值对属于一个名称空间。命名空间标识符（字符串）存储为名称空间中键值对的键，索引为0。与这些键对应的值是这些命名空间的索引。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/storage/nvs_flash.html" target="_blank" rel="noopener">Non-volatile storage library</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二十四）SPIFFS 文件系统</title>
    <url>/InfiniteYuanBlog/2019/03/23/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89SPIFFS%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="SPIFFS-文件系统"><a href="#SPIFFS-文件系统" class="headerlink" title="SPIFFS 文件系统"></a>SPIFFS 文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SPIFFS 是一个文件系统，用于嵌入式目标上的 SPI NOR 闪存设备。它支持磨损均衡，文件系统一致性检查等。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>目前，spiffs 不支持目录。它产生扁平结构。如果 SPIFFS 安装在 /spiffs 下创建一个带有路径 /spiffs/tmp/myfile.txt 的文件，则会在 SPIFFS 中创建一个名为 /tmp/myfile.txt 的文件，而不是在目录 /spiffs/tmp 下创建一个名为的 myfile.txt。</li>
<li>它不是实时堆栈。一次写入操作可能持续时间比另一次更长。</li>
<li>目前，它没法检测或处理块被损坏的情况。</li>
</ul>
<a id="more"></a>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>主机端工具用于创建 SPIFS 分区镜像文件(.bin)，其中一个工具是 <a href="https://github.com/igrr/mkspiffs" target="_blank" rel="noopener">mkspiffs</a>。您可以使用它从给定文件夹创建镜像文件，然后使用 <code>esptool.py</code> 下载该镜像文件到设备中</p>
<p>为此，您需要获取一些参数：</p>
<ul>
<li>块大小：4096（SPI Flash的标准）</li>
<li>页面大小：256（SPI Flash标准）</li>
<li>图像大小：分区大小（以字节为单位）（可以从分区表中获取）</li>
<li>分区偏移：分区的起始地址（可以从分区表中获取）</li>
</ul>
<p>例如：<br>将目标文件夹打包为 1 兆字节镜像文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkspiffs -c [src_folder] -b 4096 -p 256 -s 0x100000 spiffs.bin</span><br></pre></td></tr></table></figure>

<p>要在偏移量 0x110000 处将镜像文件烧录到 ESP32：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python esptool.py --chip esp32 --port [port] --baud [baud] write_flash -z 0x110000 spiffs.bin</span><br></pre></td></tr></table></figure>

<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ol>
<li>无法从 SPIFFS 中读取到文件内容</li>
</ol>
<p>这种情况是由于通过工具制作的文件系统格式与程序中的文件系统格式不同导致，可通过运行 <code>./mkspiffs --version</code> 在你的 mkspiffs 目录和 <code>grep SPIFFS sdkconfig</code> 在你的工程目录，之后对比两者配置的不同之处。</p>
<p>例如：</p>
<p>运行 <code>./mkspiffs --version</code> 在 mkspiffs 目录中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkspiffs ver. <span class="number">0.2</span><span class="number">.3</span><span class="number">-6</span>-g983970e</span><br><span class="line">Build configuration name: generic</span><br><span class="line">SPIFFS ver. <span class="number">0.3</span><span class="number">.7</span><span class="number">-5</span>-gf5e26c4</span><br><span class="line">Extra build flags: (none)</span><br><span class="line">SPIFFS configuration:</span><br><span class="line">  SPIFFS_OBJ_NAME_LEN: <span class="number">32</span></span><br><span class="line">  SPIFFS_OBJ_META_LEN: <span class="number">0</span></span><br><span class="line">  SPIFFS_USE_MAGIC: <span class="number">1</span></span><br><span class="line">  SPIFFS_USE_MAGIC_LENGTH: <span class="number">1</span></span><br><span class="line">  SPIFFS_ALIGNED_OBJECT_INDEX_TABLES: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>运行 <code>grep SPIFFS sdkconfig</code> 在工程目录中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># SPIFFS Configuration</span><br><span class="line">CONFIG_SPIFFS_MAX_PARTITIONS=<span class="number">3</span></span><br><span class="line"># SPIFFS Cache Configuration</span><br><span class="line">CONFIG_SPIFFS_CACHE=y</span><br><span class="line">CONFIG_SPIFFS_CACHE_WR=y</span><br><span class="line">CONFIG_SPIFFS_CACHE_STATS=</span><br><span class="line">CONFIG_SPIFFS_PAGE_CHECK=y</span><br><span class="line">CONFIG_SPIFFS_GC_MAX_RUNS=<span class="number">10</span></span><br><span class="line">CONFIG_SPIFFS_GC_STATS=</span><br><span class="line">CONFIG_SPIFFS_PAGE_SIZE=<span class="number">256</span></span><br><span class="line">CONFIG_SPIFFS_OBJ_NAME_LEN=<span class="number">32</span></span><br><span class="line">CONFIG_SPIFFS_USE_MAGIC=y</span><br><span class="line">CONFIG_SPIFFS_USE_MAGIC_LENGTH=y</span><br><span class="line">CONFIG_SPIFFS_META_LENGTH=<span class="number">4</span></span><br><span class="line">CONFIG_SPIFFS_USE_MTIME=y</span><br><span class="line">CONFIG_SPIFFS_DBG=</span><br><span class="line">CONFIG_SPIFFS_API_DBG=</span><br><span class="line">CONFIG_SPIFFS_GC_DBG=</span><br><span class="line">CONFIG_SPIFFS_CACHE_DBG=</span><br><span class="line">CONFIG_SPIFFS_CHECK_DBG=</span><br><span class="line">CONFIG_SPIFFS_TEST_VISUALISATION=</span><br></pre></td></tr></table></figure>

<p>对比之后我们发现有 <code>SPIFFS_OBJ_META_LEN:0</code>（mkspiffs）和 <code>CONFIG_SPIFFS_META_LENGTH=4</code>（sdkconfig） 不同，这个可能就是导致无法从文件系统中读取的原因。那我们重新构建一下 <code>mkspiffs</code>，通过在 mkspiffs 目录中运行以下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make dist BUILD_CONFIG_NAME=<span class="string">"-esp-idf"</span> CPPFLAGS=<span class="string">"-DSPIFFS_OBJ_META_LEN=4"</span></span><br></pre></td></tr></table></figure>

<p>这时，我们重新比较下两者的差别:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkspiffs ver. <span class="number">0.2</span><span class="number">.3</span><span class="number">-6</span>-g983970e</span><br><span class="line">Build configuration name: esp-idf</span><br><span class="line">SPIFFS ver. <span class="number">0.3</span><span class="number">.7</span><span class="number">-5</span>-gf5e26c4</span><br><span class="line">Extra build flags: -DSPIFFS_OBJ_META_LEN=<span class="number">4</span></span><br><span class="line">SPIFFS configuration:</span><br><span class="line">  SPIFFS_OBJ_NAME_LEN: <span class="number">32</span></span><br><span class="line">  SPIFFS_OBJ_META_LEN: <span class="number">4</span>			<span class="comment">// 这里已经改变为和工程中的 SPIFFS 格式配置相同</span></span><br><span class="line">  SPIFFS_USE_MAGIC: <span class="number">1</span></span><br><span class="line">  SPIFFS_USE_MAGIC_LENGTH: <span class="number">1</span></span><br><span class="line">  SPIFFS_ALIGNED_OBJECT_INDEX_TABLES: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># SPIFFS Configuration</span><br><span class="line">CONFIG_SPIFFS_MAX_PARTITIONS=<span class="number">3</span></span><br><span class="line"># SPIFFS Cache Configuration</span><br><span class="line">CONFIG_SPIFFS_CACHE=y</span><br><span class="line">CONFIG_SPIFFS_CACHE_WR=y</span><br><span class="line">CONFIG_SPIFFS_CACHE_STATS=</span><br><span class="line">CONFIG_SPIFFS_PAGE_CHECK=y</span><br><span class="line">CONFIG_SPIFFS_GC_MAX_RUNS=<span class="number">10</span></span><br><span class="line">CONFIG_SPIFFS_GC_STATS=</span><br><span class="line">CONFIG_SPIFFS_PAGE_SIZE=<span class="number">256</span></span><br><span class="line">CONFIG_SPIFFS_OBJ_NAME_LEN=<span class="number">32</span></span><br><span class="line">CONFIG_SPIFFS_USE_MAGIC=y</span><br><span class="line">CONFIG_SPIFFS_USE_MAGIC_LENGTH=y</span><br><span class="line">CONFIG_SPIFFS_META_LENGTH=<span class="number">4</span></span><br><span class="line">CONFIG_SPIFFS_USE_MTIME=y</span><br><span class="line">CONFIG_SPIFFS_DBG=</span><br><span class="line">CONFIG_SPIFFS_API_DBG=</span><br><span class="line">CONFIG_SPIFFS_GC_DBG=</span><br><span class="line">CONFIG_SPIFFS_CACHE_DBG=</span><br><span class="line">CONFIG_SPIFFS_CHECK_DBG=</span><br><span class="line">CONFIG_SPIFFS_TEST_VISUALISATION=</span><br></pre></td></tr></table></figure>

<p>这样应该就可以解决不能从文件系统中读取文件内容了。</p>
<h2 id="mkspiffs-工具构建"><a href="#mkspiffs-工具构建" class="headerlink" title="mkspiffs 工具构建"></a>mkspiffs 工具构建</h2><p>构建 mkspiffs 的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/igrr/mkspiffs.git</span></span><br><span class="line">git submodule update --init</span><br><span class="line">make dist</span><br><span class="line"><span class="meta"># make dist CPPFLAGS=<span class="meta-string">"-DSPIFFS_OBJ_META_LEN=4"</span> BUILD_CONFIG_NAME=-custom <span class="comment">//可选</span></span></span><br></pre></td></tr></table></figure>

<h3 id="SPIFFS-配置"><a href="#SPIFFS-配置" class="headerlink" title="SPIFFS 配置"></a>SPIFFS 配置</h3><p>在 mkspiffs 构建时设置的某些 SPIFFS 选项会影响生成的文件系统映像的格式。在构建 mkspiffs 和构建使用 SPIFFS 的应用程序时，请确保将此类选项设置为相同的值。</p>
<p>这些选项包括：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SPIFFS_OBJ_NAME_LEN</span><br><span class="line">SPIFFS_OBJ_META_LEN</span><br><span class="line">SPIFFS_USE_MAGIC</span><br><span class="line">SPIFFS_USE_MAGIC_LENGTH</span><br><span class="line">SPIFFS_ALIGNED_OBJECT_INDEX_TABLES</span><br></pre></td></tr></table></figure>

<p>可能是其他人要查看这些选项的默认值，请检查此存储库中的 <code>include/spiffs_config.h</code> 文件。</p>
<p>要在构建时覆盖某些选项，请传递额外的 CPPFLAGS。您还可以设置 BUILD_CONFIG_NAME 变量以区分构建的二进制文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make dist CPPFLAGS=<span class="string">"-DSPIFFS_OBJ_META_LEN=4"</span> BUILD_CONFIG_NAME=-custom</span><br></pre></td></tr></table></figure>

<p>要检查构建mkspiff时设置的选项，请使用 <code>--version</code> 命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ mkspiffs --version</span><br><span class="line">mkspiffs ver. <span class="number">0.2</span><span class="number">.2</span></span><br><span class="line">Build configuration name: custom</span><br><span class="line">SPIFFS ver. <span class="number">0.3</span><span class="number">.7</span><span class="number">-5</span>-gf5e26c4</span><br><span class="line">Extra build flags: -DSPIFFS_OBJ_META_LEN=<span class="number">4</span></span><br><span class="line">SPIFFS configuration:</span><br><span class="line">  SPIFFS_OBJ_NAME_LEN: <span class="number">32</span></span><br><span class="line">  SPIFFS_OBJ_META_LEN: <span class="number">4</span></span><br><span class="line">  SPIFFS_USE_MAGIC: <span class="number">1</span></span><br><span class="line">  SPIFFS_USE_MAGIC_LENGTH: <span class="number">1</span></span><br><span class="line">  SPIFFS_ALIGNED_OBJECT_INDEX_TABLES: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/storage/spiffs.html" target="_blank" rel="noopener">SPIFFS Filesystem</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二十）RTC 和低功耗管理</title>
    <url>/InfiniteYuanBlog/2019/03/04/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89RTC%20%E5%92%8C%E4%BD%8E%E5%8A%9F%E8%80%97%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="RTC-和低功耗管理"><a href="#RTC-和低功耗管理" class="headerlink" title="RTC 和低功耗管理"></a>RTC 和低功耗管理</h1><p>ESP32 采用了先进的电源管理技术，可以在不同的功耗模式之间切换。</p>
<h2 id="1-功耗模式"><a href="#1-功耗模式" class="headerlink" title="1 功耗模式"></a>1 功耗模式</h2><ul>
<li>Active 模式:芯片射频处于工作状态。芯片可以接收、发射和侦听信号。</li>
<li>Modem-sleep 模式:CPU 可运行，时钟可被配置。Wi-Fi/蓝牙基带和射频关闭。</li>
<li>Light-sleep 模式:CPU 暂停运行。RTC 存储器和外设以及 ULP 协处理器运行。任何唤醒事件(MAC、主机、RTC 定时器或外部中断)都会唤醒芯片。</li>
<li>Deep-sleep 模式:CPU 和大部分外设都会掉电，只有 RTC 存储器和 RTC 外设处于工作状态。Wi-Fi 和蓝牙连接数据存储在 RTC 中。ULP 协处理器可以工作。</li>
<li>Hibernation 模式:内置的 8 MHz 振荡器和 ULP 协处理器均被禁用。RTC 内存恢复电源被切断。只有1 个位于低速时钟上的 RTC 时钟定时器和某些 RTC GPIO 在工作。RTC 时钟定时器或 RTC GPIO 可以将芯片从 Hibernation 模式中唤醒。</li>
</ul>
<a id="more"></a>

<h2 id="2-低功耗模式功耗"><a href="#2-低功耗模式功耗" class="headerlink" title="2 低功耗模式功耗"></a>2 低功耗模式功耗</h2><p>设备在不同的功耗模式下有不同的电流消耗，详情请见下表。</p>
<p><img src="https://img-blog.csdnimg.cn/20190304100817958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="不同功耗模式下的功耗">)<img src="https://img-blog.csdnimg.cn/201903041011254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="射频功耗参数"></p>
<h2 id="3-说明"><a href="#3-说明" class="headerlink" title="3 说明"></a>3 说明</h2><ul>
<li>ESP32 系列芯片中，ESP32-D0WDQ6 与 ESP32-D0WD 的 CPU 最大频率为 240 MHz;ESP32-D2WD 与 ESP32-S0WD 的 CPU 最大频率为 160 MHz。</li>
<li>在 Wi-Fi 开启的场景中，芯片会在 Active 和 Modem-sleep 模式之间切换，功耗也会在两种模式间变化。</li>
<li>Modem-sleep 模式下，CPU 频率自动变化，频率取决于 CPU 负载和使用的外设。</li>
<li>Deep-sleep 模式下，仅 ULP 协处理器处于工作状态时，可以操作 GPIO 及低功耗 I2C。</li>
<li>当系统处于超低功耗传感器监测模式时，ULP 协处理器和传感器周期性工作,ADC 以 1% 占空比工作，系统功耗典型值为 100 μA。</li>
</ul>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h2><ul>
<li><a href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf" target="_blank" rel="noopener">ESP32 技术参考手册</a></li>
<li><a href="https://infiniteyuan.blog.csdn.net/article/details/106451678" target="_blank" rel="noopener">ESP32 学习笔记（二十九） ESP32 低功耗模式</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二）GPIO &amp; RTC GPIO</title>
    <url>/InfiniteYuanBlog/2018/08/08/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89GPIO%20&amp;%20RTC%20GPIO/</url>
    <content><![CDATA[<h1 id="GPIO-amp-RTC-GPIO"><a href="#GPIO-amp-RTC-GPIO" class="headerlink" title="GPIO &amp; RTC GPIO"></a>GPIO &amp; RTC GPIO</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 芯片具有 40 个物理 GPIO pads (焊盘).某些 GPIO pad 既不能使用,在芯片封装上也没有相应的引脚(请参阅技术参考手册).所以只有 34 个物理 GPIO pads 可供使用.每个 pad 都可用作一个通用 IO,或连接一个内部的外设信号.IO_MUX、RTC IO_MUX 和 GPIO 交换矩阵用于将信号从外设传输至 GPIO pad.这些模块共同组成了芯片的 IO 控制.</p>
<p>注意:</p>
<ul>
<li>管脚 SCK/CLK,SDO/SD0,SDI/SD1,SHD/SD2,SWP/SD3,和 SCS/CMD,即 GPIO6 至 GPIO11 用于连接模组上集成的 SPI flash,不建议用于其他功能.</li>
<li>ESP32-D2WD 的管脚 GPIO16,GPIO17,SD_CMD,SD_CLK,SD_DATA_0 和 SD_DATA_1 用于连接嵌入式 Flash,不建议用于其他功能.</li>
<li>GPIO 34-39 只能设置为输入模式,没有软件上拉或下拉功能.</li>
<li>这 34 个物理 GPIO pad 的序列号为:0-19, 21-23, 25-27, 32-39.其中 GPIO 34-39 仅用作输入管脚,其他的既可以作为输入又可以作为输出管脚.</li>
</ul>
<a id="more"></a>

<p>当 GPIO 被连接到 “RTC” 低功耗和模拟子系统时,还有独立的 “RTC GPIO” 支持. 这些引脚功能可在深度睡眠,<a href="https://esp-idf.readthedocs.io/zh_CN/latest/api-guides/ulp.html" target="_blank" rel="noopener">超低功耗协处理器</a>运行时或使用 ADC/DAC/等 模拟功能时使用.</p>
<p>下图描述了数字 pad(控制信号:FUNC_SEL、IE、OE、WPU、WDU 等)和 162 个外设输入以及 176 个外设输出信号(控制信号:SIG_IN_SEL、SIG_OUT_SEL、IE、OE 等)和快速外设输入/输出信号(控制信号:IE、OE 等)以及 RTC IO_MUX 之间的信号选择和连接关系.<br><img src="https://img-blog.csdn.net/20180811133142567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图1: IO_MUX、RTC IO_MUX 和GPIO 交换矩阵结构框图"></p>
<center>图1: IO_MUX、RTC IO_MUX 和GPIO 交换矩阵结构框图</center>

<ol>
<li>IO_MUX 中每个 GPIO pad 有一组寄存器.每个 pad 可以配置成 GPIO 功能(连接 GPIO 交换矩阵)或者直连功能(旁路 GPIO 交换矩阵,快速信号如以太网、SDIO、SPI、JTAG、UART 等会旁路 GPIO 交换矩阵以实现更好的高频数字特性.所以高速信号会直接通过 IO_MUX 输入和输出.)</li>
<li>GPIO 交换矩阵是外设输入和输出信号和 pad 之间的全交换矩阵.<ul>
<li>芯片输入方向:162 个外设输入信号都可以选择任意一个 GPIO pad 的输入信号.</li>
<li>芯片输出方向:每个 GPIO pad 的输出信号可来自 176 个外设输出信号中的任意一个.</li>
</ul>
</li>
<li>RTC IO_MUX 用于控制 GPIO pad 的低功耗和模拟功能.只有部分 GPIO pad 具有这些功能.</li>
</ol>
<h2 id="通过-GPIO-交换矩阵的外设输入"><a href="#通过-GPIO-交换矩阵的外设输入" class="headerlink" title="通过 GPIO 交换矩阵的外设输入"></a>通过 GPIO 交换矩阵的外设输入</h2><p>为实现通过 GPIO 交换矩阵接收外设输入信号,需要配置 GPIO 交换矩阵从 34 个 GPIO(0-19,21-23,25-27,32-39)中获取外设输入信号的索引号(0-18,23-36,39-58,61-90,95-124,140-155,164-181,190-195,198-206).</p>
<p>输入信号通过 IO_MUX 从 GPIO pad 中读取.IO_MUX 必须设置相应 pad 为 GPIO 功能.这样 GPIO pad 的输入信号就可进入 GPIO 交换矩阵然后通过 GPIO 交换矩阵进入选择的外设输入.<br><img src="https://img-blog.csdn.net/20180811135015590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图2: 通过IO_MUX、GPIO 交换矩阵的外设输入"></p>
<center>图2: 通过IO_MUX、GPIO 交换矩阵的外设输入</center>

<h2 id="通过-GPIO-交换矩阵的外设输出"><a href="#通过-GPIO-交换矩阵的外设输出" class="headerlink" title="通过 GPIO 交换矩阵的外设输出"></a>通过 GPIO 交换矩阵的外设输出</h2><p>为实现通过 GPIO 交换矩阵输出外设信号,需要配置 GPIO 交换矩阵将输出索引号为 0-18,23-37,61-121,140-215,224-228 的外设信号输出到 28 个 GPIO (0-19, 21-23, 25-27, 32-33).</p>
<p>输出信号从外设输出到 GPIO 交换矩阵,然后到达 IO_MUX.IO_MUX 必须设置相应 pad 为 GPIO 功能.这样输出 GPIO 信号就能连接到相应 pad.</p>
<p>图3 所示为 176 个输出信号中的某一个信号通过 GPIO 交换矩阵到达 IO_MUX 然后连接到某个 pad.<br><img src="https://img-blog.csdn.net/20180811135319400?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图3: 通过GPIO 交换矩阵输出信号"></p>
<center>图3: 通过GPIO 交换矩阵输出信号</center>

<h2 id="IO-MUX-的直接-I-O-功能"><a href="#IO-MUX-的直接-I-O-功能" class="headerlink" title="IO_MUX 的直接 I/O 功能"></a>IO_MUX 的直接 I/O 功能</h2><p>快速信号如以太网、SDIO、SPI、JTAG、UART 等会使用直连功能(旁路 GPIO 交换矩阵)以实现更好的高频数字特性.所以高速信号会直接通过 IO_MUX 输入和输出.</p>
<p>这样比使用 GPIO 交换矩阵的灵活度要低,即每个 GPIO pad 的 IO_MUX 寄存器只有较少的功能选择,但可以实现更好的高频数字特性.</p>
<p>为实现外设 I/O 旁路 GPIO 交换矩阵必须配置两个寄存器:</p>
<ul>
<li>GPIO pad 的 IO_MUX 必须设置为相应的 pad 功能,表1列出了 pad 功能.</li>
<li>对于输入信号,必须置位 SIG_IN_SEL 寄存器,直接将输入信号输出到外设.</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180811140112726?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="IO_MUX Pad 列表"></p>
<center>表1: IO_MUX Pad 列表</center>

<h2 id="RTC-IO-MUX-的低功耗和模拟-I-O-功能"><a href="#RTC-IO-MUX-的低功耗和模拟-I-O-功能" class="headerlink" title="RTC IO_MUX 的低功耗和模拟 I/O 功能"></a>RTC IO_MUX 的低功耗和模拟 I/O 功能</h2><p>18 个 GPIO 管脚具有低功耗(低功耗 RTC)性能和模拟功能,由 ESP32 的 RTC 子系统控制.这些功能不使用 IO_MUX 和 GPIO 交换矩阵,而是使用 RTC_MUX 将 I/O 指向 RTC 子系统.</p>
<p>当这些管脚被配置为 RTC GPIO 管脚,作为输出管脚时仍然能够在芯片处于 Deep-sleep 睡眠模式下保持输出电平值或者作为输入管脚使用时可以将芯片从 Deep-sleep 中唤醒.</p>
<p>每个 pad 的模拟和 RTC 功能是由 RTC_GPIO_PINx 寄存器中的 RTC_IO_TOUCH_PADx_TO_GPIO 位控制的.此位默认置为 1,通过 IO_MUX 子系统输入输出信号,如前文所述.</p>
<p>如果清零 RTC_IO_TOUCH_PADx_TO_GPIO 位,则输入输出信号会经过 RTC 子系统.在这种模式下,RTC_GPIO_PINx 寄存器用于数字 I/O,pad 的模拟功能也可以实现.</p>
<h2 id="Light-sleep-模式管脚功能"><a href="#Light-sleep-模式管脚功能" class="headerlink" title="Light-sleep 模式管脚功能"></a>Light-sleep 模式管脚功能</h2><p>当 ESP32 处于 Light-sleep 模式时管脚可以有不同的功能.如果某一 GPIO pad 的 IO_MUX 寄存器中 GPIOxx_SLP_SEL 位置为 1,芯片处于 Light-sleep 模式下将由另一组不同的寄存器控制 pad.</p>
<p>如果 GPIOxx_SLP_SEL 置为 0,则芯片在正常工作和 Light-sleep 模式下,管脚的功能一样.</p>
<h2 id="Pad-Hold-特性"><a href="#Pad-Hold-特性" class="headerlink" title="Pad Hold 特性"></a>Pad Hold 特性</h2><p>每个 IO pad(包括 RTC pad)都有单独的 hold 功能,由 RTC 寄存器控制.pad 的 hold 功能被置上后,pad 在置上 hold 那一刻的状态被强制保持,无论内部信号如何变化,修改 IO_MUX 配置或者 GPIO 配置,都不会改变 pad 的状态.应用如果希望在看门狗超时触发内核复位和系统复位时或者 Deep-sleep 时 pad 的状态不被改变,就需要提前把 hold 置上.</p>
<ul>
<li>对于数字 pad 而言, 若要在深度睡眠掉电之后保持 pad 输入输出的状态值,需要在掉电之前把寄存器 REG_DG_PAD_FORCE_UNHOLD 设置成 0.对于 RTC pad 而言,pad 的输入输出值,由寄存器 RTC_CNTL_HOLD_FORCE_REG 中相应的位来控制 Hold 和 Unhold pad 的值.</li>
<li>在芯片被唤醒之后,若要关闭 Hold 功能,将寄存器 REG_DG_PAD_FORCE_UNHOLD 设置成 1.若想继续保持 pad 的值,可把 RTC_CNTL_HOLD_FORCE_REG 寄存器中相应的位设置成1.</li>
</ul>
<p>示例：</p>
<p>RTC GPIO （deep sleep）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtc_gpio_init(27);</span><br><span class="line">rtc_gpio_set_direction(27, RTC_GPIO_MODE_OUTPUT_ONLY);</span><br><span class="line">rtc_gpio_set_level(27, 1);</span><br><span class="line">rtc_gpio_pullup_en(27);</span><br><span class="line">rtc_gpio_hold_en(27);</span><br></pre></td></tr></table></figure>

<p>Digital GPIO：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * The state of digital gpio cannot be held during Deep-sleep, and it will resume the hold function</span><br><span class="line">  * when the chip wakes up from Deep-sleep. If the digital gpio also needs to be held during Deep-sleep,</span><br><span class="line">  * &#96;gpio_deep_sleep_hold_en&#96; should also be called.</span><br><span class="line">  *</span><br><span class="line">  * Power down or call gpio_hold_dis will disable this function.</span><br><span class="line">  *&#x2F;</span><br><span class="line">gpio_pad_select_gpio(26);</span><br><span class="line">gpio_set_direction(26, GPIO_MODE_OUTPUT);</span><br><span class="line">gpio_set_level(26, 1);</span><br><span class="line"></span><br><span class="line">gpio_hold_en(26);</span><br><span class="line">gpio_deep_sleep_hold_en();</span><br></pre></td></tr></table></figure>

<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>GPIO 输出/输入中断示例:<a href="https://github.com/espressif/esp-idf/tree/f9a4496/examples/peripherals/gpio" target="_blank" rel="noopener">peripherals/gpio</a>.</p>
<h2 id="API-Reference-Normal-GPIO"><a href="#API-Reference-Normal-GPIO" class="headerlink" title="API Reference - Normal GPIO"></a>API Reference - Normal GPIO</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/f9a4496/components/driver/include/driver/gpio.h" target="_blank" rel="noopener">driver/include/driver/gpio.h</a></li>
</ul>
<h2 id="API-Reference-RTC-GPIO"><a href="#API-Reference-RTC-GPIO" class="headerlink" title="API Reference - RTC GPIO"></a>API Reference - RTC GPIO</h2><h3 id="Header-File-1"><a href="#Header-File-1" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/7abed5f/components/driver/include/driver/rtc_io.h" target="_blank" rel="noopener">driver/include/driver/rtc_io.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/gpio.html" target="_blank" rel="noopener">GPIO &amp; RTC GPIO</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（五）DAC - Digital To Analog Converter</title>
    <url>/InfiniteYuanBlog/2018/08/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89DAC%20-%20Digital%20To%20Analog%20Converter/</url>
    <content><![CDATA[<h1 id="DAC-Digital-To-Analog-Converter"><a href="#DAC-Digital-To-Analog-Converter" class="headerlink" title="DAC - Digital To Analog Converter"></a>DAC - Digital To Analog Converter</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 有两个 8 位 DAC (数模转换器)通道，连接到 GPIO25 (通道 1)和 GPIO26(通道 2)。</p>
<p>DAC 驱动器允许将这些通道设置为任意电压。</p>
<p>当使用“内置 DAC模式”时，DAC 通道也可以通过 I2S 驱动器使用 DMA 写入采样数据进行驱动。</p>
<p>有关其他模拟输出选项，请参阅 <a href="https://esp-idf.readthedocs.io/en/latest/api-reference/peripherals/sigmadelta.html" target="_blank" rel="noopener">Sigma-Delta 调制模块</a>和 <a href="https://esp-idf.readthedocs.io/en/latest/api-reference/peripherals/ledc.html" target="_blank" rel="noopener">LED 控制模块</a>。这两个模块都产生高频 PWM 输出，可以进行硬件低通滤波，以产生较低频率的模拟输出。</p>
<a id="more"></a>

<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>将 DAC 通道 1(GPIO 25)电压设置为 VDD_A 电压(VDD * 200/255)的约 0.78。对于 VDD_A 3.3V，这是 2.59V：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;driver/dac.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">    dac_output_enable(DAC_CHANNEL_1);</span><br><span class="line">    dac_output_voltage(DAC_CHANNEL_1, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/dac.h" target="_blank" rel="noopener">driver/include/driver/dac.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/dac.html" target="_blank" rel="noopener">DAC</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（八）SPI - SPI Master</title>
    <url>/InfiniteYuanBlog/2018/08/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89SPI%20-%20SPI%20Master/</url>
    <content><![CDATA[<h1 id="SPI-Master"><a href="#SPI-Master" class="headerlink" title="SPI Master"></a>SPI Master</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 有四个 SPI 外设,称为 SPI0,SPI1,HSPI 和 VSPI. SPI0 是专用于 flash 缓存, ESP32 将连接的 SPI flash 设备映射到存储器. SPI1 和 SPI0 使用相同的硬件线,SPI1 用于写入 flash 芯片. HSPI 和 VSPI 可以任意使用. SPI1,HSPI 和 VSPI 都有三条片选线,作为 SPI 主机允许它们最多驱动三个 SPI 设备.</p>
<h3 id="spi-master-驱动"><a href="#spi-master-驱动" class="headerlink" title="spi_master 驱动"></a>spi_master 驱动</h3><p>即使在多线程环境中,spi_master 驱动程序也可以轻松与 SPI 从设备进行通信. 它完全透明地处理 DMA 传输以读取和写入数据,并自动处理同一主机上不同 SPI 从站之间的多路复用.</p>
<a id="more"></a>

<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>spi_master 驱动程序使用以下术语:</p>
<ul>
<li>主机:ESP32 内部的 SPI 外设启动 SPI 传输. SPI,HSPI 或 VSPI 之一. (目前,驱动程序实际上只支持 HSPI 或 VSPI;它将在未来的某个地方支持所有 3个外设.)</li>
<li>总线:SPI总线,与连接到一个主机的所有 SPI 设备共用.通常,总线由 miso,mosi,sclk 和可选的 quadwp 和 quadhd 信号组成. SPI 从设备并联连接到这些信号.<ul>
<li>miso - 也称为 q,这是将串行流输入到 ESP32中</li>
<li>mosi - 也称为 d,这是来自 ESP32 的串行流的输出</li>
<li>sclk - 时钟信号.每个数据位在该信号的正或负边沿输出或输出</li>
<li>quadwp - 写保护信号.仅用于 4 位(qio/qout)事务.</li>
<li>quadhd - 保持信号.仅用于 4 位(qio/qout)事务.</li>
</ul>
</li>
<li>设备:SPI 从设备.每个 SPI 从设备都有自己的片选(CS)线,当发生到/从 SPI 从设备的传输时,该线被激活.</li>
<li>事务:一个 CS 活动的实例,来自和/或发生的设备的数据传输,以及 CS 再次变为非活动状态.事务是原子的,因为它们永远不会被另一个事务中断.</li>
</ul>
<h2 id="SPI-transactions"><a href="#SPI-transactions" class="headerlink" title="SPI transactions"></a>SPI transactions</h2><p>SPI 总线上的事务由五个阶段组成,其中任何阶段都可以跳过:</p>
<ul>
<li>命令阶段. 在此阶段,命令(0-16 位)被输出.</li>
<li>地址阶段. 在此阶段,地址(0-64 位)被输出.</li>
<li>写阶段. 主设备将数据发送到从设备.</li>
<li>虚拟阶段. 该阶段是可配置的,用于满足时序要求.</li>
<li>阅读阶段. 从站将数据发送给主站.</li>
</ul>
<p>在全双工模式下,读写阶段被组合,SPI 主机同时读写数据.<strong>总事务长度</strong>由 <code>command_bits + address_bits + trans_conf.length</code> 决定,而 <code>trans_conf.rx_length</code> <strong>仅确定</strong>接收到缓冲区的数据长度.</p>
<p>在半双工模式下,主机具有独立的写和读阶段.写入阶段和读取阶段的<strong>长度分别</strong>由 <code>trans_conf.length</code> 和 <code>trans_conf.rx_length</code> 决定.</p>
<p>命令和地址阶段是可选的,因为不是每个 SPI 设备都需要发送命令和/或地址.这反映在设备配置中:当 <code>command_bits</code> 或 <code>address_bits</code> 字段设置为零时,不执行命令或地址阶段.</p>
<p>读写阶段的情况类似:并非每个事务都需要写入数据以及要读取的数据.当 <code>rx_buffer</code> 为 NULL(并且未设置 <code>SPI_USE_RXDATA</code>)时,将跳过读取阶段.当 <code>tx_buffer</code> 为 NULL(并且未设置 <code>SPI_USE_TXDATA</code>)时,将跳过写入阶段.</p>
<h3 id="Interrupt-transactions"><a href="#Interrupt-transactions" class="headerlink" title="Interrupt transactions"></a>Interrupt transactions</h3><p>中断事务将阻塞事务例程，直到事务完成为止，从而使CPU可以运行其他任务。</p>
<p>当事务在传输中时，中断事务使用中断驱动的逻辑。程序将被阻塞，允许 CPU 在等待事务完成时运行其他任务。</p>
<p>中断事务可以排队到设备中，驱动程序会自动在 ISR 中逐个发送它们。任务可以将多个事务加入到队列中，并且能在事务完成之前执行其他操作。</p>
<h3 id="Polling-transactions"><a href="#Polling-transactions" class="headerlink" title="Polling transactions"></a>Polling transactions</h3><p>轮询事务不依赖于中断，程序将持续轮询 SPI 外设的状态位，直到事务完成。</p>
<p>执行中断事务的所有任务可能会被队列阻塞，此时他们需要等待 ISR 在事务完成之前运行两次。轮询事务节省了在队列处理和上下文切换上花费的时间，从而导致较小的事务间隔。缺点是当这些事务在传输中时 CPU 正忙不能运行其他任务。</p>
<p>当事务完成时，<code>spi_device_polling_end</code> 例程至少花费 1us 开销来解除阻塞其他任务。强烈建议在 <code>spi_device_acquire_bus</code> 和 <code>spi_device_release_bus</code> 中包含一系列轮询事务以避免开销。</p>
<h2 id="Command-and-address-phases"><a href="#Command-and-address-phases" class="headerlink" title="Command and address phases"></a>Command and address phases</h2><p>在命令和地址阶段，<code>spi_transaction_t</code> 结构中的 <code>cmd</code> 和 <code>addr</code> 字段将发送到总线，而不会同时读取任何内容。命令和地址阶段的默认长度在 <code>spi_device_interface_config_t</code> 和 <code>spi_bus_add_device</code> 中设置。当 <code>spi_transaction_t</code> 中未设置标志 <code>SPI_TRANS_VARIABLE_CMD</code> 和 <code>SPI_TRANS_VARIABLE_ADDR</code> 时，驱动程序会自动将这些阶段的长度分别设置为初始化设备时设置的默认值。</p>
<p>如果命令和地址阶段的长度需要更改，则声明一个 <code>spi_transaction_ext_t</code> 描述符，在 <code>base</code> 成员的 <code>flag</code> 中设置标志 <code>SPI_TRANS_VARIABLE_CMD</code> 或/和 <code>SPI_TRANS_VARIABLE_ADDR</code>，并像往常一样配置 <code>base</code> 的其余部分。然后每个阶段的长度将是 <code>spi_transaction_ext_t</code> 中设置的 <code>command_bits</code> 和 <code>address_bits</code>。</p>
<h2 id="Write-and-read-phases"><a href="#Write-and-read-phases" class="headerlink" title="Write and read phases"></a>Write and read phases</h2><p>通常，要写入到设备或从设备读取的数据将从事务结构的 <code>rx_buffer</code> 和 <code>tx_buffer</code> 成员指向的一块存储器中读取或写入。为传输启用 DMA 时，强烈建议使用这些缓冲区以满足以下要求：</p>
<ul>
<li>使用 <code>pvPortMallocCaps(size，MALLOC_CAP_DMA)</code> 在支持 <code>DMA</code> 的内存中分配;</li>
<li>32 位对齐（从边界开始，长度为 4 个字节的倍数）。</li>
</ul>
<p>如果不满足这些要求，由于临时缓冲区的分配和 <code>memcpy</code>，事务效率将受到影响。</p>
<blockquote>
<p>使用 DMA 时，不支持有读和写两个阶段的半双工事务。有关详细信息和解决方法，请参阅已知问题。</p>
</blockquote>
<h2 id="Bus-acquiring"><a href="#Bus-acquiring" class="headerlink" title="Bus acquiring"></a>Bus acquiring</h2><p>有时您可能希望不断地连续发送spi事务，以使其尽可能快。您可以使用 <code>spi_device_acquire_bus</code> 和 <code>spi_device_release_bus</code> 来实现这一点。获取总线后，与其他设备（无论是轮询还是中断）的事务处于待处理状态，直到总线被释放。</p>
<h2 id="使用-spi-master-驱动"><a href="#使用-spi-master-驱动" class="headerlink" title="使用 spi_master 驱动"></a>使用 spi_master 驱动</h2><ul>
<li>通过调用 <code>spi_bus_initialize</code> 初始化 SPI 总线. 确保在 <code>bus_config</code> 结构中设置正确的 IO 引脚. 注意将不需要的信号设置为 -1.</li>
<li>通过调用 <code>spi_bus_add_device</code> 告诉驱动程序连接到总线的 SPI 从设备. 确保在 <code>dev_config</code> 结构中配置设备具有的任何时序要求. 您现在应该拥有该设备的句柄,以便在发送事务时使用.</li>
<li>要与设备交互,请使用您需要的任何事务参数填充一个或多个 <code>spi_transaction_t</code> 结构. 然后以轮询方式或中断方式发送它们：<ul>
<li>中断方式：通过调用 <code>spi_device_queue_trans</code> 将事务添加到队列中,之后使用 <code>spi_device_get_trans_result</code> 查询结果,或者通过将它们提供给 <code>spi_device_transmit</code> 来处理所有请求.</li>
<li>轮询方式：调用 <code>spi_device_polling_transmit</code> 发送轮询事务。或者，如果要在它们之间插入内容，可以通过 <code>spi_device_polling_start</code> 和 <code>spi_device_polling_end</code> 发送轮询事务。</li>
</ul>
</li>
<li>可选：要对设备执行事务，请在事务之前调用 <code>spi_device_acquire_bus</code>，并在事务之后调用 <code>spi_device_release_bus</code>。</li>
<li>可选：要卸载设备的驱动程序,请以设备句柄作为参数调用 <code>spi_bus_remove_device</code></li>
<li>可选：要删除总线的驱动程序,请确保没有连接更多驱动程序并调用 <code>spi_bus_free</code>.</li>
</ul>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ol>
<li><p>少量数据的事务：</p>
<p> 有时，数据量非常小，因此不足以为其分配单独的缓冲区。如果要传输的数据是 32 位或更少，则可以将其存储在事务结构本身中。对于传输的数据，请使用 <code>tx_data</code> 成员并在传输上设置 <code>SPI_USE_TXDATA</code> 标志。对于接收的数据，使用 <code>rx_data</code> 并设置 <code>SPI_USE_RXDATA</code>。在这两种情况下，请勿触摸 <code>tx_buffer</code> 或 <code>rx_buffer</code> 成员，因为它们使用与 <code>tx_data</code> 和 <code>rx_data</code> 相同的内存位置。</p>
</li>
<li><p>除了 <code>uint8_t</code> 之外的整数事务</p>
<p> SPI 外设逐字节地读写存储器。默认情况下，SPI 工作在 MSB 优先模式，每个字节从 MSB 发送或接收到 LSB。但是，如果要发送长度不是 8 位倍数的数据，则会发送未使用的位。</p>
<p> 例如：你写 <code>uint8_t data = 0x15（00010101B）</code>，并设置长度只有 5 位，发送的数据是 00010B 而不是预期的 10101B。</p>
<p> 此外，ESP32 是一个小端芯片，其最低字节存储在 <code>uint16_t</code> 和 <code>uint32_t</code> 变量的起始地址。因此，如果 <code>uint16_t</code> 存储在存储器中，则首先发送第 7 位，然后将第 6 位发送到 0，然后将第 15 位发送到第 8 位。</p>
<p> 要发送 <code>uint8_t</code> 数组以外的数据，提供宏 <code>SPI_SWAP_DATA_TX</code> 以将数据转移到 <code>MSB</code> 并将 <code>MSB</code> 交换到最低地址;而 <code>SPI_SWAP_DATA_RX</code> 可用于将接收到的数据从 MSB 交换到正确的位置。</p>
</li>
</ol>
<h2 id="GPIO-matrix-and-IOMUX"><a href="#GPIO-matrix-and-IOMUX" class="headerlink" title="GPIO matrix and IOMUX"></a>GPIO matrix and IOMUX</h2><p>ESP32 中的大多数外设信号可以直接连接到特定的 GPIO,称为 IOMUX 引脚. 当外设信号路由到 IOMUX 引脚以外的引脚时,ESP32 使用较不直接的 GPIO matrix 进行连接.</p>
<p>如果驱动器配置了所有 SPI 信号设置为其特定的 IOMUX 引脚(或未连接),它将绕过 GPIO matrix. 如果任何 SPI 信号配置到 IOMUx 引脚以外的引脚,驱动器将自动通过 GPIO matrix 路由所有信号. GPIO matrix对 80MHz 的所有信号进行采样,并在 GPIO 和外设之间发送.</p>
<p>当使用 GPIO matrix 时,由于 MISO 信号的输入延迟增加,因此超过 40MHz 的信号不能传播并且 MISO 的建立时间更容易被违反. GPIO Matrix 的最大时钟频率为 40MHz 或更低,而使用所有 IOMUX 引脚允许 80MHz.</p>
<blockquote>
<p>有关输入延迟对最大时钟频率影响的更多详细信息,请参阅下面的<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/peripherals/spi_master.html#timing-considerations" target="_blank" rel="noopener">时序注意事项</a>.</p>
</blockquote>
<p>SPI 控制器的 IOMUX 引脚如下:<br>|Pin Name|HSPI(GPIO Number)|VSPI(GPIO Number)|<br>|————-|:————-:|:————-:|<br>|CS0*|15|5|<br>|SCLK|14|18|<br>|MISO|12|19|<br>|MOSI|13|23|<br>|QUADWP|2|22|<br>|QUADHD|4|21|</p>
<blockquote>
<p>只有连接到总线的第一个设备才能使用 CS0 引脚.</p>
</blockquote>
<h2 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h2><ol>
<li><p>当存在写入和读取阶段时，半双工模式与 DMA 不兼容。</p>
<p> 如果需要此类交易，则必须使用其中一种替代解决方案：</p>
<ol>
<li><p>改为使用全双工模式。</p>
</li>
<li><p>通过在总线初始化函数中将最后一个参数设置为 0 来禁用 DMA，如下所示：<code>ret = spi_bus_initialize(VSPI_HOST，＆buscfg，0);</code> 这可能会禁止您发送和接收超过 64 个字节的数据。</p>
</li>
<li><p>尝试使用命令和地址字段来替换写入阶段。</p>
</li>
</ol>
</li>
<li><p>全双工模式与虚拟位解决方案不兼容，因此频率有限。</p>
</li>
<li><p><code>cs_ena_pretrans</code> 与全双工模式下的命令，地址阶段不兼容。</p>
</li>
</ol>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h2 id="API-Reference-SPI-Common"><a href="#API-Reference-SPI-Common" class="headerlink" title="API Reference - SPI Common"></a>API Reference - SPI Common</h2><p>在 WROVER-Kits 的 320x240 LCD 上显示图形:<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/spi_master" target="_blank" rel="noopener">peripherals/spi_master</a>.</p>
<h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/spi_common.h" target="_blank" rel="noopener">driver/include/driver/spi_common.h</a></li>
</ul>
<h2 id="API-Reference-SPI-Master"><a href="#API-Reference-SPI-Master" class="headerlink" title="API Reference - SPI Master"></a>API Reference - SPI Master</h2><h3 id="Header-File-1"><a href="#Header-File-1" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/spi_master.h" target="_blank" rel="noopener">driver/include/driver/spi_master.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/spi_master.html" target="_blank" rel="noopener">SPI Master driver</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（六）I2C - Inter-Integrated Circuit</title>
    <url>/InfiniteYuanBlog/2018/08/12/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89I2C%20-%20Inter-Integrated%20Circuit/</url>
    <content><![CDATA[<h1 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h1><p>I2C (内部集成电路)总线可用于与连接到与 ESP32 相同的总线的多个外部设备进行通信。ESP32 板上有两个 I2C 控制器，每个控制器可以设置为主模式或从模式。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>以下部分将指导您完成配置和操作 I2C 驱动程序的基本步骤：</p>
<ol>
<li><a href="#配置驱动程序">配置驱动程序</a> - 选择驱动程序的参数，如主模式或从模式，设置特定的 GPIO 引脚作为 SDA 和 SCL，设置时钟速度等。</li>
<li><a href="#安装驱动程序">安装驱动程序</a> - 在主站或从站模式下激活驱动程序，以便在 ESP32 上运行两个 I2C 控制器其中一个。</li>
<li><a href="#进行通讯">进行通讯</a>：<ul>
<li>主机模式 - 作为主机运行通信</li>
<li>从机模式 - 从机响应来自主机的消息</li>
</ul>
</li>
<li><a href="#中断处理">中断处理</a> - 配置和 I2C 中断服务。</li>
<li><a href="#超出默认值">超出默认值</a> - 调整 I2C 通信的时序，引脚配置和其他参数。</li>
<li><a href="#错误处理">错误处理</a> - 如何识别和处理驱动程序配置和通信错误。</li>
<li><a href="#删除驱动程序">删除驱动程序</a> - 在通信结束时释放 I2C 驱动程序所使用的资源。</li>
</ol>
<p>I2C 驱动程序标识是从 <code>i2c_port_t</code> 中选择的两个端口号之一。在驱动程序配置期间通过 <code>i2c_mode_t</code> 选择 “master” 或 “slave” 指定端口的操作模式。</p>
<a id="more"></a>

<h2 id="配置驱动程序"><a href="#配置驱动程序" class="headerlink" title="配置驱动程序"></a>配置驱动程序</h2><p>建立 I2C 通信的第一步是配置驱动程序。这是通过设置 <code>i2c_config_t</code> 结构中包含的几个参数来完成的：</p>
<ul>
<li>I2C 操作模式 - 从 <code>i2c_opmode_t</code> 中选择 slave 或 master</li>
<li>通讯引脚配置：<ul>
<li>分配给 SDA 和 SCL 信号的 GPIO 引脚编号</li>
<li>是否为各个引脚启用 ESP32 的内部上拉</li>
</ul>
</li>
<li>I2C 时钟速度，如果此配置涉及主模</li>
<li>如果此配置涉及从属模式：<ul>
<li>是否应启用 10 位地址模式</li>
<li>从机地址</li>
</ul>
</li>
</ul>
<p>然后，要初始化给定 I2C 端口的配置，请使用端口号和 <code>i2c_config_t</code> 结构作为函数调用参数调用函数 <code>i2c_param_config()</code>。</p>
<p>在此阶段，<code>i2c_param_config()</code> 还将“其他 I2C 配置参数”设置为常用的默认值。要检查值是什么以及如何更改它们，请参阅<a href="#超出默认值">超出默认值</a>。</p>
<h2 id="安装驱动程序"><a href="#安装驱动程序" class="headerlink" title="安装驱动程序"></a>安装驱动程序</h2><p>初始化配置后，下一步是通过调用 <code>i2c_driver_install()</code> 来安装 I2C 驱动程序。此函数调用需要以下参数：</p>
<ul>
<li>端口号，可用的两个端口之一，从 <code>i2c_port_t</code> 中选择</li>
<li>从 <code>i2c_opmode_t</code> 中选择的操作模式，从机或主机</li>
<li>将分配用于在从机模式下发送和接收数据的缓冲区的大小</li>
<li>用于分配中断的标志</li>
</ul>
<h2 id="进行通讯"><a href="#进行通讯" class="headerlink" title="进行通讯"></a>进行通讯</h2><p>安装 I2C 驱动程序后，ESP32 即可与其他 I2C 设备通信。通信编程取决于所选 I2C 端口是以主机模式还是从机模式工作。</p>
<h3 id="主机模式"><a href="#主机模式" class="headerlink" title="主机模式"></a>主机模式</h3><p>ESP32 工作在主机模式的 I2C 端口负责与从 I2C 设备建立通信，并发送命令以触发从机设备工作，如进行测量和发回结果。</p>
<p>为了组织这个过程，驱动程序提供了一个称为 “command link” 的容器，该容器应填充一系列命令，然后传递给 I2C 控制器执行。</p>
<h4 id="主机-Write"><a href="#主机-Write" class="headerlink" title="主机 Write"></a>主机 Write</h4><p>构建 I2C 主设备向从设备发送 n 个字节的命令链接的示例如下所示：<br><img src="https://img-blog.csdn.net/20180812211151469?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="I2C command link - master write example"></p>
<p>下面介绍如何设置“主写入”的命令链接以及内部的内容：</p>
<ol>
<li>第一步是使用 <code>i2c_cmd_link_create()</code> 创建命令链接。然后命令链接填充一系列要发送给从站的数据：<ul>
<li>起始位 -  <code>i2c_master_start()</code></li>
<li>单字节从机地址 - <code>i2c_master_write_byte()</code>。该地址作为此函数调用的参数提供。</li>
<li>一个或多个字节的数据作为 <code>i2c_master_write()</code> 的参数。</li>
<li>停止位 -  <code>i2c_master_stop()</code></li>
</ul>
</li>
</ol>
<p><code>i2c_master_write_byte()</code> 和 <code>i2c_master_write()</code> 命令都有另外的参数来定义 slave 是否应该确认接收的数据。<br> 2. 通过调用 <code>i2c_master_cmd_begin()</code> 来触发 I2C 控制器执行命令链接。<br> 3. 最后一步，完成命令发送后，通过调用 <code>i2c_cmd_link_delete()</code> 释放命令链接使用的资源。</p>
<h4 id="主机-Read"><a href="#主机-Read" class="headerlink" title="主机 Read"></a>主机 Read</h4><p>和主机类似的步骤序列，用于从从机读取数据。<br><img src="https://img-blog.csdn.net/20180812214852217?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="I2C command link - master read example"></p>
<p>在读取数据时，不是 “i2c_master_read …”，而是使用 <code>i2c_master_read_byte()</code> 和/或 <code>i2c_master_read()</code> 填充命令链接。此外，最后一次读取配置为不提供主机的确认。</p>
<p>发送从机地址后，请参见上图中的步骤 3，主机可以写入或从从机读取数据。主设备实际执行的操作信息隐藏在从设备地址的最低位。</p>
<p>因此，命令链接指示从机主机将写入数据包含地址，如 <code>(ESP_SLAVE_ADDR &lt;&lt; 1)| I2C_MASTER_WRITE</code>，如下所示：</p>
<h3 id="从机模式"><a href="#从机模式" class="headerlink" title="从机模式"></a>从机模式</h3><p>API 提供了从属设备读取和写入数据的功能 - * <code>i2c_slave_read_buffer()</code> 和 <code>i2c_slave_write_buffer()</code>。<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/i2c" target="_blank" rel="noopener">peripherals/i2c</a>中提供了使用这些功能的示例。</p>
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>调用函数 <code>i2c_isr_register()</code> 注册中断处理程序，调用 <code>i2c_isr_free()</code> 删除处理程序。<a href="https://espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf" target="_blank" rel="noopener">ESP32技术参考手册(PDF)</a>中提供了 I2C 控制器触发的中断描述。</p>
<h2 id="超出默认值"><a href="#超出默认值" class="headerlink" title="超出默认值"></a>超出默认值</h2><p>在驱动程序配置期间(调用 <code>i2c_param_config()</code> 时，请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/peripherals/i2c.html#i2c-api-configure-driver" target="_blank" rel="noopener">配置驱动程序</a>)，有一些 I2C 通信参数设置为某些默认的常用值。某些参数也已在 I2C 控制器的寄存器中配置。通过调用专用函数，可以将这些参数更改为用户定义的值：</p>
<ul>
<li><p>SCL 脉冲周期为高和低 - <code>i2c_set_period()</code></p>
</li>
<li><p>在产生启动/停止信号期间使用的 SCL 和 SDA 信号时序 - <code>i2c_set_start_timing()</code>/ <code>i2c_set_stop_timing()</code></p>
</li>
<li><p>从器件采样时以及通过主器件发送时 SCL 和 SDA 信号之间的时序关系 - <code>i2c_set_data_timing()</code></p>
</li>
<li><p>I2C 超时 - <code>i2c_set_timeout()</code></p>
<blockquote>
<p>定时值在 APB 时钟周期中定义。APB 的频率在 <code>I2C_APB_CLK_FREQ</code> 中指定。</p>
</blockquote>
</li>
<li><p>首先发送/接收 LSB 或 MSB -<code>i2c_set_data_mode()</code> 可在 <code>i2c_trans_mode_t</code> 中定义的模式中选择</p>
</li>
</ul>
<p>上述每个函数都有一个<code>_get_</code>对应项来检查当前设置的值。</p>
<p>要在驱动程序配置期间查看参数设置的默认值，请参阅文件<a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/i2c.c" target="_blank" rel="noopener">driver / i2c.c</a>查找定义了<code>_DEFAULT</code>后缀。</p>
<p>通过功能<code>i2c_set_pin()</code>，还可以选择不同的 SDA 和 SCL 引脚并改变上拉配置，改变已经输入的 <code>i2c_param_config()</code>。</p>
<blockquote>
<p>ESP32 的内部上拉电阻范围为几十 kOhm，因此在大多数情况下，它们本身不足以用作 I2C 上拉电阻。我们建议添加外部上拉电阻，其值如 I2C 标准中所述。</p>
</blockquote>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>大多数驱动程序的函数在成功完成时返回 <code>ESP_OK</code>，或者在失败时返回特定的错误代码。始终检查返回的值并实现错误处理是一种好习惯。例如，驱动程序也打印出志消息。检查输入配置的正确性，其中包含错误说明。有关详细信息，请参阅文件<a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/i2c.c" target="_blank" rel="noopener">driver / i2c.c</a>查找定义 <code>_ERR_STR后</code> 缀。</p>
<p>使用专用中断来捕获通信故障。例如，当 I2C 花费太长时间来接收数据时，会触发 <code>I2C_TIME_OUT_INT</code> 中断。有关相关信息，请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/peripherals/i2c.html#i2c-api-interrupt-handling" target="_blank" rel="noopener">中断处理</a>。</p>
<p>要在通信失败时重置内部硬件缓冲区，可以使用<code>i2c_reset_tx_fifo()</code>和<code>i2c_reset_rx_fifo()</code>。</p>
<h2 id="删除驱动程序"><a href="#删除驱动程序" class="headerlink" title="删除驱动程序"></a>删除驱动程序</h2><p>如果使用 <code>i2c_driver_install()</code> 建立 I2C 通信一段时间之后不再需要 I2C 通信，则可以通过调用 <code>i2c_driver_delete()</code> 来移除驱动程序以释放分配的资源。</p>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>I2C 主机和从机示例：<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/i2c" target="_blank" rel="noopener">peripherals/i2c</a>.</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/i2c.h" target="_blank" rel="noopener">driver/include/driver/i2c.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/i2c.html" target="_blank" rel="noopener">I2C</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（十一）LED Control</title>
    <url>/InfiniteYuanBlog/2018/08/13/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89LED%20Control/</url>
    <content><![CDATA[<h1 id="LED-Control"><a href="#LED-Control" class="headerlink" title="LED Control"></a>LED Control</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>LED 控制(LEDC)模块主要用于控制 LED 的强度，尽管它也可用于生成 PWM 信号以用于其他目的。它有16个通道可以产生独立的波形，可以用来驱动例如: RGB LED设备。</p>
<p>所有 LEDC 通道中有一半提供高速操作模式。该模式提供硬件实现，自动和无干扰的 PWM 占空比改变。另一半通道在低速模式下运行，其中变化的时刻取决于应用软件。每组通道也能够使用不同的时钟源，但 API 中未实现此功能。</p>
<p>PWM 控制器还能够逐渐自动增加或减少占空比，允许在没有任何处理器干扰的情况下衰减。</p>
<a id="more"></a>

<h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>让 LEDC 在高速或低速模式下在特定通道上工作分三步完成：</p>
<ul>
<li>配置定时器以确定 PWM 信号的频率和数字(占空比范围分辨率)。</li>
<li>通过将通道与定时器和 GPIO 相关联来配置通道，以输出 PWM 信号。</li>
<li>更改 PWM 信号，驱动输出以改变 LED 的强度。这可以在软件的完全控制下或在硬件衰落功能的帮助下完成。</li>
</ul>
<p>在可选步骤中，还可以在淡入淡出端设置中断。<br><img src="https://img-blog.csdn.net/20180813204054898?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h3 id="配置定时器"><a href="#配置定时器" class="headerlink" title="配置定时器"></a>配置定时器</h3><p>通过调用函数 <code>ledc_timer_config()</code> 来完成定时器的设置。应为此函数提供包含以下配置设置的数据结构 <code>ledc_timer_config_t</code>：</p>
<ul>
<li>定时器号 <code>ledc_timer_t</code> 和速度模式 <code>ledc_mode_t</code>。</li>
<li>PWM 信号的频率和 PWM 占空比值的分辨率会发生变化。</li>
</ul>
<p>频率和占空比分辨率是相互依赖的。PWM 频率越高，可提供更低的占空比分辨率，反之亦然。如果您计划将此 API 用于其他改变 LED 强度的目的，这种关系可能会变得很重要。有关更多详细信息，请查看<a href="#支持的频率范围和占空比分辨率">支持的频率范围和占空比分辨率</a>。</p>
<h3 id="配置通道"><a href="#配置通道" class="headerlink" title="配置通道"></a>配置通道</h3><p>设置定时器后，下一步是配置所选通道( <code>ledc_channel_t</code> 中的一个)。这是通过调用函数 <code>ledc_channel_config()</code> 来完成的。</p>
<p>以类似的方式，与定时器配置类似，应为通道设置功能提供特定结构 <code>ledc_channel_config_t</code>，其中包含通道的配置参数。</p>
<p>此时，通道应开始工作，并开始生成由定时器设置和所选 GPIO 上的占空比确定的频率 PWM 信号，如 <code>ledc_channel_config_t</code> 中所配置。可以通过调用函数 <code>ledc_stop()</code> 随时暂停通道操作/信号生成。</p>
<h3 id="改变-PWM-信号"><a href="#改变-PWM-信号" class="headerlink" title="改变 PWM 信号"></a>改变 PWM 信号</h3><p>一旦通道工作并产生恒定占空比和频率的PWM信号，有几种方法可以改变这个信号。在驱动LED时，我们主要改变了改变光强度的占空比。请参阅下面的两部分，了解如何通过软件或硬件衰减来更改占空比。如果需要，我们也可以更改信号的频率，这将在<a href="#更改PWM频率">更改PWM频率</a>部分中介绍。</p>
<h4 id="通过软件更改PWM占空比"><a href="#通过软件更改PWM占空比" class="headerlink" title="通过软件更改PWM占空比"></a>通过软件更改PWM占空比</h4><p>通过首先调用专用函数 <code>ledc_set_duty()</code> 然后调用 <code>ledc_update_duty()</code> 来使更改生效来完成占空比的设置。要检查当前设置的值，有一个相应的 <code>_get_</code> 函数 <code>ledc_get_duty()</code>。</p>
<p>设置占空比和其他一些通道参数的另一种方法是调用上一节中讨论的 <code>ledc_channel_config()</code>。</p>
<p>输入函数的占空比值的范围取决于所选的 <code>duty_resolution</code>，并且应该从 0 到 (2 ** duty_resolution) - 1。例如，如果选择的占空比分辨率为 10，则占空比范围为 0 到 1023。这提供了分辨率为~0.1％。</p>
<h4 id="通过硬件衰落改变PWM占空比"><a href="#通过硬件衰落改变PWM占空比" class="headerlink" title="通过硬件衰落改变PWM占空比"></a>通过硬件衰落改变PWM占空比</h4><p>LEDC 硬件提供了从一个占空值逐渐淡入另一个值的方法。要使用此功能，首先使用 <code>ledc_fade_func_install()</code> 启用淡入淡出。然后通过调用一个可用的淡入淡出函数来配置它：</p>
<ul>
<li><code>ledc_set_fade_with_time()</code></li>
<li><code>ledc_set_fade_with_step()</code></li>
<li><code>ledc_set_fade()</code></li>
</ul>
<p>最后用 <code>ledc_fade_start()</code> 开始淡出。</p>
<p>如果不再需要，可以使用 <code>ledc_fade_func_uninstall()</code> 禁用衰落和相关中断。</p>
<h4 id="更改PWM频率"><a href="#更改PWM频率" class="headerlink" title="更改PWM频率"></a>更改PWM频率</h4><p>LEDC API 提供了几种“动态”改变 PWM 频率的方法。</p>
<ul>
<li>其中一个选项是调用 <code>ledc_set_freq()</code>。有一个相应的函数 <code>ledc_get_freq()</code> 来检查当前设置的频率。</li>
<li>另一种改变频率和占空比分辨率的方法是调用 <code>ledc_bind_channel_timer()</code> 将其他定时器绑定到通道。</li>
<li>最后，可以通过调用 <code>ledc_channel_config()</code> 来更改通道的计时器。</li>
</ul>
<h4 id="更多控制PWM"><a href="#更多控制PWM" class="headerlink" title="更多控制PWM"></a>更多控制PWM</h4><p>有几个低级定时器特定功能，可用于提供更改 PWM 设置的其他方法：</p>
<ul>
<li><code>ledc_timer_set()</code></li>
<li><code>ledc_timer_rst()</code></li>
<li><code>ledc_timer_pause()</code></li>
<li><code>ledc_timer_resume()</code></li>
</ul>
<p>前两个函数被 <code>ledc_channel_config()</code> 称为“幕后”，以便在配置后提供“干净”的计时器启动。</p>
<h3 id="使用中断"><a href="#使用中断" class="headerlink" title="使用中断"></a>使用中断</h3><p>配置 LEDC 通道时，在 <code>ledc_channel_config_t</code> 中选择的参数之一是 <code>ledc_intr_type_t</code>，并允许在淡入淡出完成时启用中断。</p>
<p>通过调用 <code>ledc_isr_register()</code> 来注册处理此中断的处理程序。</p>
<h2 id="LEDC高低速模式"><a href="#LEDC高低速模式" class="headerlink" title="LEDC高低速模式"></a>LEDC高低速模式</h2><p>LED PWM 控制器中共有 8 个定时器和 16 个通道，其中一半专用于高速模式，另一半专用于低速模式。选择低速或高速“有能力”定时器或通道是通过适用的函数调用中存在的参数 <code>ledc_mode_t</code> 来完成的。</p>
<p>高速模式的优点是支持 h/w，定时器设置无故障切换。这意味着如果修改了定时器设置，则在定时器的下一个溢出中断后将自动应用更改。相反，在更新低速定时器时，应特别由软件触发设置更改。LEDC API 正在“幕后”进行，例如，当调用 <code>ledc_timer_config()</code> 或 <code>ledc_timer_set()</code> 时。</p>
<p>有关速度模式的更多详细信息，请参阅 ESP32 技术参考手册(PDF)。请注意，本手册中提到的对 <code>SLOW_CLOCK</code> 的支持未在LEDC API 中实现。</p>
<h2 id="支持的频率和占空比分辨率范围"><a href="#支持的频率和占空比分辨率范围" class="headerlink" title="支持的频率和占空比分辨率范围"></a>支持的频率和占空比分辨率范围</h2><p>LED PWM 控制器主要用于驱动 LED，并提供宽泛的 PWM 占空比设置。例如，对于 5 kHz 的 PWM 频率，最大占空比分辨率为 13 位。这意味着占空比可以设置在 0 到 100％ 之间，分辨率为~0.012％(13 ** 2 = 8192 LED 强度的离散电平)。</p>
<p>LEDC 可以用于以更高的频率提供信号以对其他设备进行计时，例如，数码相机模块。在这种情况下，最大可用频率为 40 MHz，占空比分辨率为 1 位。这意味着频率固定在 50％，无法调整。</p>
<p>API 用于在尝试设置超出 LEDC 硬件范围的频率和占空比分辨率时报告错误。例如，尝试将频率设置为 20 MHz 且占空比分辨率为 3 位将导致串行监视器上报告以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E (196) ledc: requested frequency and duty resolution can not be achieved, try reducing freq_hz or duty_resolution. div_param&#x3D;128</span><br></pre></td></tr></table></figure>

<p>在这种情况下，应降低占空比分辨率或频率。例如，将占空比分辨率设置为 2 将解决该问题，并提供以 25％ 步长设置占空比的可能性，即 25％，50％或75％。</p>
<p>LEDC API 还将捕获并报告尝试配置低于支持的最小值的频率/任务分辨率组合，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E (196) ledc: requested frequency and duty resolution can not be achieved, try increasing freq_hz or duty_resolution. div_param&#x3D;128000000</span><br></pre></td></tr></table></figure>

<p>通常使用 <code>ledc_timer_bit_t</code> 来设置占空比分辨率。该枚举涵盖 10 到 15 位的范围。如果需要较小的占空比分辨率(低于 10 至 1)，请直接输入等效数值。</p>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>LEDC 改变占空比和衰落控制示例：<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/ledc" target="_blank" rel="noopener">peripherals/ledc</a>.</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/ledc.h" target="_blank" rel="noopener">driver/include/driver/ledc.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/ledc.html" target="_blank" rel="noopener">LED Control</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（十七）SDMMC Host Driver</title>
    <url>/InfiniteYuanBlog/2018/11/15/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89SDMMC%20Host%20Driver/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 ESP32 上，SDMMC 主机外设有两个插槽：</p>
<ul>
<li>插槽 0(<code>SDMMC_HOST_SLOT_0</code>)是一个 8 位插槽。它使用 <code>PIN MUX</code> 中的 <code>HS1_ *</code> 信号。</li>
<li>插槽 1(<code>SDMMC_HOST_SLOT_1</code>)是一个 4 位插槽。它使用 <code>PIN MUX</code> 中的 <code>HS2_ *</code> 信号。</li>
</ul>
<p>这些插槽的引脚映射如下表所示：<br>|Signal|Slot 0|Slot 1|<br>|:—:|:—:|:—:|<br>|CMD |    GPIO11     |GPIO15|<br>CLK     |GPIO6|     GPIO14|<br>|D0 |    GPIO7     |GPIO2|<br>|D1     |GPIO8 |    GPIO4|<br>|D2     |GPIO9     |GPIO12|<br>|D3     |GPIO10     |GPIO13|<br>|D4     |GPIO16      ||<br>|D5     |GPIO17|     |<br>|D6     |GPIO5|      |<br>|D7     |GPIO18||<br>|CD     |any input via GPIO matrix|any input via GPIO matrix|<br>|WP     |any input via GPIO matrix|any input via GPIO matrix|</p>
<p>可以使用 GPIO 矩阵将卡检测和写保护信号路由到任意引脚。要使用这些引脚，请在调用 <code>sdmmc_host_init_slot()</code> 之前设置 <code>sdmmc_slot_config_t</code> 结构的 <code>gpio_cd</code> 和 <code>gpio_wp</code> 成员。请注意，在使用 SDIO 卡时，建议不要指定卡检测引脚，因为在 ESP32 卡检测信号中也可以触发 SDIO 从机中断。</p>
<blockquote>
<p>插槽0(HS1_ *)使用的引脚也用于连接 ESP-WROOM32 和 ESP32-WROVER 模块中的 SPI 闪存芯片。这些引脚不能在 SD 卡和 SPI 闪存之间共享。如果需要使用 Slot 0，请将 SPI flash连接到不同的引脚并相应地设置 Efuses。</p>
</blockquote>
<a id="more"></a>

<h2 id="支持的速度模式"><a href="#支持的速度模式" class="headerlink" title="支持的速度模式"></a>支持的速度模式</h2><p>SDMMC 主机驱动程序支持以下速度模式：</p>
<ul>
<li>默认速度(20MHz)，4 线/1 线(带 SD 卡)和8 线(带 3.3V eMMC)。</li>
<li>高速(40MHz)，4 线/1 线(带 SD 卡)和8 线(带 3.3V eMMC)</li>
<li>高速DDR(40MHz)，4 线(带 3.3V eMMC)</li>
</ul>
<p>目前不支持的是：</p>
<ul>
<li>高速 DDR 模式，8 线 eMMC</li>
<li>UHS-I 1.8V 模式，4 线 SD 卡</li>
</ul>
<h2 id="使用SDMMC主机驱动程序"><a href="#使用SDMMC主机驱动程序" class="headerlink" title="使用SDMMC主机驱动程序"></a>使用SDMMC主机驱动程序</h2><p>在下面列出的所有功能中，大多数应用程序将直接使用 <code>sdmmc_host_init()</code>，<code>sdmmc_host_init_slot()</code> 和 <code>sdmmc_host_deinit()</code>。</p>
<p>其他函数，例如 <code>sdmmc_host_set_bus_width()</code>，<code>sdmmc_host_set_card_clk()</code> 和 <code>sdmmc_host_do_transaction()</code> 将由 SD/MMC 协议层通过 <code>sdmmc_host_t</code> 结构中的函数指针调用。</p>
<h2 id="配置总线宽度和频率"><a href="#配置总线宽度和频率" class="headerlink" title="配置总线宽度和频率"></a>配置总线宽度和频率</h2><p>使用 <code>sdmmc_host_t</code> 和 <code>sdmmc_slot_config_t</code>(<code>SDMMC_HOST_DEFAULT</code> 和 <code>SDMMC_SLOT_CONFIG_DEFAULT</code>)的默认初始化程序，SDMMC 主机驱动程序将尝试使用该卡支持的最宽总线(SD 为 4 行，eMMC 为 8 行)和 20MHz 频率。</p>
<p>在可以实现 40MHz 频率通信的设计中，可以通过更改 <code>sdmmc_host_t</code> 的 <code>max_freq_khz</code> 字段来增加总线频率：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sdmmc_host_t</span> host = SDMMC_HOST_DEFAULT();</span><br><span class="line">host.max_freq_khz = SDMMC_FREQ_HIGHSPEED;</span><br></pre></td></tr></table></figure>

<p>要配置总线宽度，请设置 <code>sdmmc_slot_config_t</code> 的宽度字段。例如，要设置 1 位模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sdmmc_slot_config_t</span> slot = SDMMC_SLOT_CONFIG_DEFAULT();</span><br><span class="line">slot.<span class="built_in">width</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>有关实现协议层的更高级别驱动程序，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/sdmmc.html" target="_blank" rel="noopener">SD/SDIO/MMC驱动程序</a>。</p>
<p>有关使用 SPI 控制器的类似驱动程序，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/sdspi_host.html" target="_blank" rel="noopener">SD SPI主机驱动程序</a>，并且仅限于 SD 协议的 SPI 模式。</p>
<p>有关上拉支持以及有关模块和设备的兼容性，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/sd_pullup_requirements.html" target="_blank" rel="noopener">SD上拉要求</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/sdmmc_host.html" target="_blank" rel="noopener">SDMMC Host Driver</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（十三）Pulse Counter</title>
    <url>/InfiniteYuanBlog/2018/08/13/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89Pulse%20Counter/</url>
    <content><![CDATA[<h1 id="Pulse-Counter"><a href="#Pulse-Counter" class="headerlink" title="Pulse Counter"></a>Pulse Counter</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PCNT（脉冲计数器）模块用于计算输入信号的上升沿和/或下降沿的数量。每个脉冲计数器单元都有一个 16 位有符号计数器寄存器和两个通道，可配置为递增或递减计数器。每个通道都有一个接收待检测信号边沿的信号输入，以及一个可用于启用或禁用信号输入的控制输入。输入具有可选滤波器，可用于丢弃信号中不需要的毛刺。</p>
<h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>此API的功能描述分为四个部分：</p>
<ul>
<li>配置 - 描述计数器的配置参数以及如何设置计数器。</li>
<li>操作计数器 - 提供有关暂停，测量和清除计数器的控制功能的信息。</li>
<li>滤波脉冲 - 描述滤波脉冲和计数器控制信号的选项。</li>
<li>使用中断 - 介绍如何在计数器的特定状态上触发中断。</li>
</ul>
<a id="more"></a>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>PCNT 模块有 8 个独立的计数“单位”，编号从 0 到 7。在 API 中，它们使用 <code>pcnt_unit_t</code> 引用。每个单元有两个独立的通道，编号为 0 和 1，并用 <code>pcnt_channel_t</code> 指定。</p>
<p>使用 <code>pcnt_config_t</code> 为每个单元的通道单独提供配置，并涵盖：</p>
<ul>
<li>此配置所指的单元和通道编号。</li>
<li>脉冲输入和脉冲门输入的 GPIO 编号。</li>
<li>两对参数：<code>pcnt_ctrl_mode_t</code> 和 <code>pcnt_count_mode_t</code>，用于定义计数器如何响应，具体取决于控制信号的状态以及如何计算脉冲的正/负边沿。</li>
<li>当脉冲计数满足特定限制时，用于建立观察点和触发中断的两个极限值（最小值/最大值）。</li>
</ul>
<p>然后通过调用上面的 <code>pcnt_config_t</code> 作为输入参数的函数 <code>pcnt_unit_config()</code> 来完成特定通道的设置。</p>
<p>要在配置中禁用脉冲或控制输入引脚，请提供 <code>PCNT_PIN_NOT_USED</code> 而不是 GPIO 编号。</p>
<h3 id="操作计数器"><a href="#操作计数器" class="headerlink" title="操作计数器"></a>操作计数器</h3><p>在使用 <code>pcnt_unit_config()</code> 进行设置后，计数器立即开始运行。可以通过调用 <code>pcnt_get_counter_value()</code> 来检查累积的脉冲计数。</p>
<p>有几个函数可以控制计数器的操作：<code>pcnt_counter_pause()</code>，<code>pcnt_counter_resume()</code> 和 <code>pcnt_counter_clear()</code></p>
<p>也可以通过调用 <code>pcnt_set_mode()</code> 使用 <code>pcnt_unit_config()</code> 动态更改先前设置的计数器模式。</p>
<p>如果需要，可以使用 <code>pcnt_set_pin()</code> “动态”更改脉冲输入引脚和控制输入引脚。要禁用特定输入，请提供功能参数 <code>PCNT_PIN_NOT_USED</code> 而不是GPIO编号。</p>
<blockquote>
<p>为了使计数器不会错过任何脉冲，脉冲持续时间应该长于一个APB_CLK周期（12.5 ns）。脉冲在APB_CLK时钟的边沿上采样，如果在边缘之间落下，则可能会丢失。这适用于有或没有文件管理器的计数器操作。</p>
</blockquote>
<h3 id="滤波脉冲"><a href="#滤波脉冲" class="headerlink" title="滤波脉冲"></a>滤波脉冲</h3><p>PCNT 单元在每个脉冲和控制输入上都有滤波器，增加了忽略信号中短毛刺的选项。</p>
<p>通过调用 <code>pcnt_set_filter_value()</code> 在 APB_CLK 时钟周期中提供忽略脉冲的长度。可以使用 <code>pcnt_get_filter_value()</code> 检查当前过滤器设置。APB_CLK 时钟以 80 MHz 运行。</p>
<p>通过调用 <code>pcnt_filter_enable()</code>/<code>pcnt_filter_disable()</code> 将过滤器置于操作/暂停状态。</p>
<h3 id="使用中断"><a href="#使用中断" class="headerlink" title="使用中断"></a>使用中断</h3><p>在 <code>pcnt_evt_type_t</code> 中定义的五个计数器状态监视事件能够触发中断。事件发生在脉冲计数器达到特定值：</p>
<ul>
<li>最小或最大计数值：在配置中讨论的 <code>pcnt_config_t</code> 中提供的 <code>counter_l_lim</code> 或 <code>counter_h_lim</code></li>
<li>使用函数 <code>pcnt_set_event_value()</code> 设置阈值 0 或阈值 1 值。</li>
<li>脉冲计数 = 0</li>
</ul>
<p>要注册，启用或禁用中断以服务上述事件，请调用 <code>pcnt_isr_register()</code>，<code>pcnt_intr_enable()</code> 和 <code>pcnt_intr_disable()</code>。要在达到阈值时启用或禁用事件，您还需要调用函数 <code>pcnt_event_enable()</code> 和 <code>pcnt_event_disable()</code>。</p>
<p>要检查当前设置的阈值，请使用函数 <code>pcnt_get_event_value()</code>。</p>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>带控制信号和事件中断的脉冲计数器示例：<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/pcnt" target="_blank" rel="noopener">peripherals/pcnt</a>.</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/pcnt.h" target="_blank" rel="noopener">driver/include/driver/pcnt.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/pcnt.html" target="_blank" rel="noopener">Pulse Counter</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（十九）High Resolution Timer</title>
    <url>/InfiniteYuanBlog/2018/12/24/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89High%20Resolution%20Timer/</url>
    <content><![CDATA[<h1 id="高分辨率定时器"><a href="#高分辨率定时器" class="headerlink" title="高分辨率定时器"></a>高分辨率定时器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虽然 FreeRTOS 提供软件定时器，但这些定时器有一些限制：</p>
<ul>
<li>最大分辨率等于 RTOS 滴答周期</li>
<li>低优先级任务调度定时器回调</li>
</ul>
<p>硬件定时器没有这两个限制，但通常使用起来不方便。例如，应用程序组件可能需要在将来的某些时间触发定时器事件，但硬件定时器仅包含一个用于中断生成的“比较”值。这意味着需要在硬件计时器之上构建一些设施来管理待处理事件列表，可以在发生相应的硬件中断时为这些事件调度回调。</p>
<p><code>esp_timer</code> API 集提供了这样的功能。在内部，<code>esp_timer</code> 使用 32 位硬件定时器（FRC1，“传统”定时器）。<code>esp_timer</code> 提供单次和周期定时器，微秒时间分辨率和 64 位范围。</p>
<p>从高优先级的 <code>esp_timer</code> 任务调度定时器回调。由于所有回调都是从同一任务调度的，因此建议仅从回调本身执行尽可能少的工作，而是使用队列将事件发布到优先级较低的任务。</p>
<p>如果优先级高于 <code>esp_timer</code> 的其他任务正在运行，则回调调度将延迟，直到 <code>esp_timer</code> 任务有机会运行。例如，如果正在进行 <code>SPI</code> 闪存操作，则会发生这种情况。</p>
<p>创建和启动计时器，并调度回调需要一些时间。因此，单触发 <code>esp_timer</code> 的超时值有一个下限。如果调用 <code>esp_timer_start_once()</code> 时超时值小于20us，则仅在大约 20us 后调度回调。</p>
<p>周期性 <code>esp_timer</code> 还对最小定时器周期施加 50us 限制。周期小于 50us 的定期软件定时器不实用，因为它们会占用大部分 CPU 时间。如果发现需要小周期的定时器，请考虑使用专用硬件外设或 DMA 功能。</p>
<a id="more"></a>

<h2 id="使用-esp-timer-API"><a href="#使用-esp-timer-API" class="headerlink" title="使用 esp_timer API"></a>使用 <code>esp_timer</code> API</h2><p>单个计时器由 <code>esp_timer_handle_t</code> 类型表示。定时器有与之关联的回调函数。每次计时器过去时，都会从 <code>esp_timer</code> 任务调用此回调函数。</p>
<ul>
<li>要创建计时器，请调用 <code>esp_timer_create()</code>。</li>
<li>要在不再需要时删除计时器，请调用 <code>esp_timer_delete()</code>。</li>
</ul>
<p>定时器可以以单次模式或定期模式启动。</p>
<ul>
<li>要以单次模式启动计时器，请调用 <code>esp_timer_start_once()</code>，传递应该调用回调的时间间隔。调用回调时，会认为计时器已停止。</li>
<li>要以周期模式启动定时器，请调用 <code>esp_timer_start_periodic()</code>，传递应调用回调的周期。计时器一直运行，直到调用 <code>esp_timer_stop()</code>。</li>
</ul>
<p>请注意，调用 <code>esp_timer_start_once()</code> 或 <code>esp_timer_start_periodic()</code> 时，计时器不能运行。要重新启动正在运行的计时器，请先调用 <code>esp_timer_stop()</code>，然后调用其中一个启动函数。</p>
<h2 id="获得当前时间"><a href="#获得当前时间" class="headerlink" title="获得当前时间"></a>获得当前时间</h2><p><code>esp_timer</code> 还提供了一个便捷函数来获取自启动以来经过的时间，精度为微秒：<code>esp_timer_get_time()</code>。此函数返回自 <code>esp_timer</code> 初始化以来的微秒数，这通常在调用 <code>app_main</code> 函数之前不久发生。</p>
<p>与 <code>gettimeofday</code> 函数不同，<code>esp_timer_get_time()</code> 返回的值：</p>
<ul>
<li>芯片从深度睡眠中唤醒后，从零开始</li>
<li>没有应用时区或 DST 调整</li>
</ul>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><ul>
<li><a href="https://github.com/espressif/esp-idf/tree/7b13308/examples/system/esp_timer" target="_blank" rel="noopener">system/esp_timer</a></li>
</ul>
<h2 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h2><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/7b13308/components/esp32/include/esp_timer.h" target="_blank" rel="noopener">esp32/include/esp_timer.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/system/esp_timer.html" target="_blank" rel="noopener">High Resolution Timer</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（十二）MCPWM</title>
    <url>/InfiniteYuanBlog/2018/08/13/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89MCPWM/</url>
    <content><![CDATA[<h1 id="MCPWM"><a href="#MCPWM" class="headerlink" title="MCPWM"></a>MCPWM</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 有两个 MCPWM 单元，可用于控制不同的电机。每个单元有三对 PWM 输出。</p>
<p><img src="https://img-blog.csdnimg.cn/20181228185337698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此外，在文档中，单个单元的输出标记为 PWMxA/PWMxB。</p>
<a id="more"></a>

<p>MCPWM 单元的更详细框图如下所示。每个 A/B 对可以由定时器 0,1 和 2 的三个定时器中的任何一个定时。相同的定时器可以用于为一对以上的 PWM 输出提供时钟。每个单元还能够收集诸如 <code>SYNC SIGNALS</code> 之类的输入，检测诸如电动机过电流或过电压之类的 <code>FAULT SIGNALS</code>，以及使用 <code>CAPTURE SIGNALS</code> 获得反馈信号例如：转子位置。</p>
<p><img src="https://img-blog.csdnimg.cn/20181228185639802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此 API 的说明首先配置 MCPWM 的定时器和操作子模块，以提供基本的电机控制功能。然后讨论了故障处理程序，信号捕获，载波和中断等更高级的子模块和功能。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>配置输出的基本功能</li>
<li>操作输出以驱动电机</li>
<li>调整电机的驱动方式</li>
<li>捕获外部信号以提供额外的控制</li>
<li>使用 <code>Fault Handler</code> 检测和管理故障</li>
<li>如果输出信号通过隔离变压器，则添加更高频率的载波</li>
<li>中断的配置和处理。</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置范围取决于电机类型，特别是需要多少输出和输入，以及驱动电机的信号序列。</p>
<p>在这种情况下，我们将描述一种简单的配置来控制仅使用一些可用 MCPWM 资源的有刷直流电机。示例电路如下所示。它包括一个 H 桥，用于切换施加在电机（M）上的电压的极化，并提供足够的电流来驱动它。</p>
<p><img src="https://img-blog.csdnimg.cn/20181228190041789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置包括以下步骤：</p>
<ul>
<li>选择将用于驱动电机的 MPWM 单元。ESP32 上有两个可用的单元，并在 <code>mcpwm_unit_t</code> 中枚举。</li>
<li>通过调用 <code>mcpwm_gpio_init()</code> 将两个 GPIO 初始化为选定单元内的输出信号。两个输出信号通常用于命令电机向右或向左旋转。所有可用的信号选项都列在 <code>mcpwm_io_signals_t</code> 中。要一次设置多个引脚，请将函数 <code>mcpwm_set_pin()</code> 与 <code>mcpwm_pin_config_t</code> 一起使用。</li>
<li>选择计时器。该装置内有三个定时器。计时器列在 <code>mcpwm_timer_t</code> 中。</li>
<li>在 <code>mcpwm_config_t</code> 结构中设置定时器频率和初始占空比。</li>
<li>使用上述参数调用 <code>mcpwm_init()</code> 以使配置生效。</li>
</ul>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>使用 MCPWM 进行电机控制的示例：<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/mcpwm" target="_blank" rel="noopener">peripherals/mcpwm</a>.</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/mcpwm.h" target="_blank" rel="noopener">driver/include/driver/mcpwm.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/mcpwm.html" target="_blank" rel="noopener">MCPWM</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（十五）Touch Sensor</title>
    <url>/InfiniteYuanBlog/2018/08/13/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89Touch%20Sensor/</url>
    <content><![CDATA[<h1 id="Touch-Sensor"><a href="#Touch-Sensor" class="headerlink" title="Touch Sensor"></a>Touch Sensor</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>触摸传感器系统构建在基板上，该基板在保护性平坦表面下承载电极和相关连接。当用户触摸表面时，触发电容变化并产生二进制信号以指示触摸是否有效。</p>
<p>ESP32 可提供多达 10 个电容式触摸板/GPIO。传感垫可以以不同的组合（例如矩阵，滑块）布置，从而可以检测更大面积或更多点。触摸板感测过程在硬件实现的有限状态机（FSM）的控制下，该有限状态机由软件或专用硬件定时器启动。</p>
<p><a href="https://espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf" target="_blank" rel="noopener">ESP32 技术参考手册（PDF）</a>中讨论了触摸传感器的设计，操作和控制寄存器。有关此子系统如何工作的更多详细信息，请参阅它。</p>
<p>有关ESP32的触摸传感器设计和固件开发指南的详细信息，请参阅<a href="https://github.com/espressif/esp-iot-solution/blob/master/documents/touch_pad_solution/touch_sensor_design_en.md" target="_blank" rel="noopener">触摸传感器应用说明</a>。如果您想在各种配置下测试触摸传感器而无需自行构建，请查看<a href="https://github.com/espressif/esp-iot-solution/blob/master/documents/evaluation_boards/esp32_sense_kit_guide_en.md" target="_blank" rel="noopener">ESP32-Sense 开发套件指南</a>。</p>
<h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>API 的描述分为几组功能，以提供以下功能的快速概述：</p>
<ul>
<li>触摸板驱动器的初始化</li>
<li>触摸板 GPIO 引脚的配置</li>
<li>进行测量</li>
<li>调整测量参数</li>
<li>过滤测量值</li>
<li>触摸检测方法</li>
<li>设置中断以报告触摸检测</li>
<li>在中断时从睡眠模式唤醒</li>
</ul>
<p>有关特定功能的详细说明，请转到 <a href="#API-Reference">API 参考</a>部分。<a href="#%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B">应用示例</a>部分介绍了此 API 的实际实现。</p>
<a id="more"></a>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>触摸板驱动程序应在使用前通过调用函数 <code>touch_pad_init()</code> 进行初始化。此函数在“宏”下的 <a href="#API-Reference">API 参考</a>中设置了几个 <code>.._ DEFAULT</code> 驱动程序参数。它还清除之前触摸过的焊盘信息（如果有）并禁用中断。</p>
<p>如果不再需要，可以通过调用 <code>touch_pad_deinit()</code> 来禁用驱动程序。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用 <code>touch_pad_config()</code> 可以为特定 GPIO 启用触摸传感器功能。</p>
<p>函数 <code>touch_pad_set_fsm_mode()</code> 用于选择是否由硬件定时器或软件自动启动触摸板测量（由 FSM 操作）。如果选择了软件模式，则使用 <code>touch_pad_sw_start()</code> 启动 FSM。</p>
<h3 id="触摸状态测量"><a href="#触摸状态测量" class="headerlink" title="触摸状态测量"></a>触摸状态测量</h3><p>以下两个功能可以方便地从传感器读取原始或过滤的测量值：</p>
<ul>
<li><code>touch_pad_read()</code></li>
<li><code>touch_pad_read_filtered()</code></li>
</ul>
<p>通过在触摸或释放垫时检查传感器读数的范围，它们可用于表征特定的触摸板设计。然后可以使用该信息来建立触摸阈值。</p>
<blockquote>
<p>通过调用下面描述的特定过滤器函数，在使用<code>touch_pad_read_filtered()</code>之前启动并配置过滤器。</p>
</blockquote>
<p>要了解如何使用这两种读取功能，请检查 <a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/touch_pad_read" target="_blank" rel="noopener">peripherals/touch_pad_read</a>应用示例。</p>
<h3 id="优化测量"><a href="#优化测量" class="headerlink" title="优化测量"></a>优化测量</h3><p>触摸传感器具有多个可配置参数，以匹配特定触摸板设计的特性。例如，为了感测较小的容量变化，可以缩小触摸板充电/放电的参考电压范围。使用 <code>touch_pad_set_voltage()</code> 函数设置高和低参考电压。除了识别较小容量变化的能力之外，积极的副作用还将是降低低功率应用的功耗。可能的负面影响是测量噪声的增加。如果获得的读数的动态范围仍然令人满意，则可以通过用 <code>touch_pad_set_meas_time()</code> 降低测量时间来进一步降低功耗。</p>
<p>以下总结了可用的测量参数和相应的“设置”功能：</p>
<ul>
<li>触摸板充电/放电参数：<ul>
<li>电压范围：<code>touch_pad_set_voltage()</code></li>
<li>速度（斜率）：<code>touch_pad_set_cnt_mode()</code></li>
</ul>
</li>
<li>测量时间：<code>touch_pad_set_meas_time()</code></li>
</ul>
<p>电压范围（高/低参考电压），速度（斜率）和测量时间之间的关系如下图所示。</p>
<p><img src="https://img-blog.csdn.net/2018081321171024?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>最后一个图表“输出”表示触摸传感器读数，即在测量时间内收集的脉冲计数。</p>
<p>所有函数成对提供以“设置”特定参数并“获取”当前参数的值，例如，<code>touch_pad_set_voltage()</code> 和 <code>touch_pad_get_voltage()</code>。</p>
<h3 id="过滤测量"><a href="#过滤测量" class="headerlink" title="过滤测量"></a>过滤测量</h3><p>如果测量结果有噪音，您可以使用提供的 API 过滤它们。首次使用前应通过调用 <code>touch_pad_filter_start()</code> 启动过滤器。</p>
<p>滤波器类型是 IIR（无限脉冲响应），它具有可配置的周期，可以通过功能 <code>touch_pad_set_filter_period()</code> 进行设置。</p>
<p>您可以使用 <code>touch_pad_filter_stop()</code> 停止过滤器。如果不再需要，可以通过调用 <code>touch_pad_filter_delete()</code> 删除过滤器。</p>
<h3 id="触摸检测"><a href="#触摸检测" class="headerlink" title="触摸检测"></a>触摸检测</h3><p>触摸检测在 ESP32 的硬件中实现，基于用户配置的阈值和 FSM 执行的原始测量。使用 <code>touch_pad_get_status()</code> 函数检查触摸的触摸板和<code>touch_pad_clear_status()</code>以清除触摸状态信息。</p>
<p>硬件触摸检测也可以连接到中断，这将在下一节中介绍。</p>
<p>如果测量结果有噪声且容量变化很小，则硬件触摸检测可能不可靠。要解决此问题，请在您自己的应用程序中实施测量过滤并执行触摸检测，而不是使用硬件检测/提供的中断。有关两种触摸检测方法的示例实现，请参阅<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/touch_pad_interrupt" target="_blank" rel="noopener">peripherals / touch_pad_interrupt</a>。</p>
<h3 id="触摸触发中断"><a href="#触摸触发中断" class="headerlink" title="触摸触发中断"></a>触摸触发中断</h3><p>在触摸检测中启用中断之前，用户应建立触摸检测阈值。当触摸和释放打击垫时，使用上述功能读取和显示传感器测量值。当测量结果有噪声并且相对变化很小时，应用滤波器。根据您的应用和环境条件，测试温度和电源电压变化对测量值的影响。</p>
<p>一旦建立了检测阈值，就可以在初始化时使用 <code>touch_pad_config()</code> 或在运行时使用 <code>touch_pad_set_thresh()</code> 进行设置。</p>
<p>在下一步中，配置如何触发中断。可以在低于或高于阈值的情况下触发它们，并使用函数 <code>touch_pad_set_trigger_mode()</code> 进行设置。</p>
<p>最后使用以下函数配置和管理中断调用：</p>
<ul>
<li><code>touch_pad_isr_register()</code>/ <code>touch_pad_isr_deregister()</code></li>
<li><code>touch_pad_intr_enable()</code>/ <code>touch_pad_intr_disable()</code></li>
</ul>
<p>当中断运行时，您可以通过调用 <code>touch_pad_get_status()</code> 并使用 <code>touch_pad_clear_status()</code> 清除焊盘状态来获取特定焊盘触发中断的信息。</p>
<blockquote>
<p>触摸检测中断根据用户建立的阈值检查原始/未过滤测量，并在硬件中实现。启用软件过滤API（请参阅过滤度量）不会影响此过程。</p>
</blockquote>
<h3 id="从睡眠模式唤醒"><a href="#从睡眠模式唤醒" class="headerlink" title="从睡眠模式唤醒"></a>从睡眠模式唤醒</h3><p>如果使用触摸板中断将芯片从休眠模式唤醒，则用户可以选择应触摸的某些焊盘配置（SET1 或 SET1 和 SET2），以触发中断并导致后续唤醒。为此，请使用 <code>touch_pad_set_trigger_source()</code> 函数。</p>
<p>可以通过以下方式为每个 ‘SET’ 管理所需的焊盘位模式的配置：</p>
<ul>
<li><code>touch_pad_set_group_mask()</code>/<code>touch_pad_get_group_mask()</code></li>
<li><code>touch_pad_clear_group_mask()</code></li>
</ul>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>触摸传感器读取示例：<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/touch_pad_read" target="_blank" rel="noopener">peripherals/touch_pad_read</a>.<br>触摸传感器中断示例：<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/touch_pad_interrupt" target="_blank" rel="noopener">peripherals/touch_pad_interrupt</a>.</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/touch_pad.h" target="_blank" rel="noopener">driver/include/driver/touch_pad.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/touch_pad.html" target="_blank" rel="noopener">Touch Sensor</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（十八）Virtual filesystem</title>
    <url>/InfiniteYuanBlog/2018/11/15/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89Virtual%20filesystem/</url>
    <content><![CDATA[<h1 id="Virtual-filesystem-component"><a href="#Virtual-filesystem-component" class="headerlink" title="Virtual filesystem component"></a>Virtual filesystem component</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟文件系统(VFS)组件为可以对类文件对象执行操作的驱动程序提供统一的接口。这可以是真实的文件系统(FAT，SPIFFS 等)，也可以是有文件类接口的设备驱动程序。</p>
<p>该组件允许 C 库函数(如 <code>fopen</code> 和<code>fprintf</code> )与 FS 驱动程序一起使用。在高层次，每个 FS 驱动程序与某些路径前缀相关联。当其中一个 C 库函数需要打开文件时，VFS 组件将搜索与该文件路径关联的 FS 驱动程序，并将该调用转发给该驱动程序。VFS 还将给定文件的读取，写入和其他调用转发到同一 FS 驱动程序。</p>
<p>例如，可以使用 <code>/fat</code> 前缀注册 FAT 文件系统驱动程序，并调用 <code>fopen(“/fat/file.txt”，“w”)</code>。然后，VFS 组件将调用 FAT 驱动程序的 <code>open</code> 函数并将 <code>/file.txt</code> 参数传递给它(以及适当的模式标志)。对返回的 <code>FILE *</code> 流的所有后续 C 库函数调用也将被转发到 FAT 驱动程序。</p>
<a id="more"></a>

<h2 id="FS注册"><a href="#FS注册" class="headerlink" title="FS注册"></a>FS注册</h2><p>要注册 FS 驱动程序，应用程序需要在 <code>esp_vfs_t</code> 结构的实例中定义，并使用 <code>FS API</code> 的函数指针填充它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esp_vfs_t myfs &#x3D; &#123;</span><br><span class="line">    .flags &#x3D; ESP_VFS_FLAG_DEFAULT,</span><br><span class="line">    .write &#x3D; &amp;myfs_write,</span><br><span class="line">    .open &#x3D; &amp;myfs_open,</span><br><span class="line">    .fstat &#x3D; &amp;myfs_fstat,</span><br><span class="line">    .close &#x3D; &amp;myfs_close,</span><br><span class="line">    .read &#x3D; &amp;myfs_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ESP_ERROR_CHECK(esp_vfs_register(&quot;&#x2F;data&quot;, &amp;myfs, NULL));</span><br></pre></td></tr></table></figure>
<p>根据 FS 驱动程序声明其 API 的方式，应使用 <code>read</code>，<code>write</code> 等，或 <code>read_p</code>，<code>write_p</code> 等。</p>
<p>情况1：声明 API 函数时没有额外的上下文指针(FS 驱动程序是单例)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssize_t myfs_write(int fd, const void * data, size_t size);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; In definition of esp_vfs_t:</span><br><span class="line">    .flags &#x3D; ESP_VFS_FLAG_DEFAULT,</span><br><span class="line">    .write &#x3D; &amp;myfs_write,</span><br><span class="line">&#x2F;&#x2F; ... other members initialized</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; When registering FS, context pointer (third argument) is NULL:</span><br><span class="line">ESP_ERROR_CHECK(esp_vfs_register(&quot;&#x2F;data&quot;, &amp;myfs, NULL));</span><br></pre></td></tr></table></figure>
<p>情况2：使用额外的上下文指针声明 API 函数(FS 驱动程序支持多个实例)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssize_t myfs_write(myfs_t* fs, int fd, const void * data, size_t size);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; In definition of esp_vfs_t:</span><br><span class="line">    .flags &#x3D; ESP_VFS_FLAG_CONTEXT_PTR,</span><br><span class="line">    .write_p &#x3D; &amp;myfs_write,</span><br><span class="line">&#x2F;&#x2F; ... other members initialized</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; When registering FS, pass the FS context pointer into the third argument</span><br><span class="line">&#x2F;&#x2F; (hypothetical myfs_mount function is used for illustrative purposes)</span><br><span class="line">myfs_t* myfs_inst1 &#x3D; myfs_mount(partition1-&gt;offset, partition1-&gt;size);</span><br><span class="line">ESP_ERROR_CHECK(esp_vfs_register(&quot;&#x2F;data1&quot;, &amp;myfs, myfs_inst1));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Can register another instance:</span><br><span class="line">myfs_t* myfs_inst2 &#x3D; myfs_mount(partition2-&gt;offset, partition2-&gt;size);</span><br><span class="line">ESP_ERROR_CHECK(esp_vfs_register(&quot;&#x2F;data2&quot;, &amp;myfs, myfs_inst2));</span><br></pre></td></tr></table></figure>

<h2 id="同步输入-输出多路复用"><a href="#同步输入-输出多路复用" class="headerlink" title="同步输入/输出多路复用"></a>同步输入/输出多路复用</h2><p>如果要通过 <code>select()</code> 使用同步输入/输出多路复用，则需要使用 <code>start_select()</code> 和 <code>end_select()</code> 函数注册 VFS，类似于以下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; In definition of esp_vfs_t:</span><br><span class="line">    .start_select &#x3D; &amp;uart_start_select,</span><br><span class="line">    .end_select &#x3D; &amp;uart_end_select,</span><br><span class="line">&#x2F;&#x2F; ... other members initialized</span><br></pre></td></tr></table></figure>
<p>调用 <code>start_select()</code> 以设置用于检测属于给定 VFS 的文件描述符的读/写/错误条件的环境。调用 <code>end_select()</code> 来停止/取消初始化/释放由 <code>start_select()</code> 设置的环境。请参阅 <a href="https://github.com/espressif/esp-idf/blob/fb7ba1b/components/vfs/vfs_uart.c" target="_blank" rel="noopener"><code>vfs/vfs_uart.c</code></a> 中 UART 外设的参考实现，尤其是函数 <code>esp_vfs_dev_uart_register()</code>，<code>uart_start_select()</code> 和 <code>uart_end_select()</code>。</p>
<p>演示使用带有 VFS 文件描述符的 <code>select()</code> 的示例是 <a href="https://github.com/espressif/esp-idf/tree/fb7ba1b/examples/peripherals/uart_select" target="_blank" rel="noopener"><code>peripherals/uart_select</code></a> 和 <a href="https://github.com/espressif/esp-idf/tree/fb7ba1b/examples/system/select" target="_blank" rel="noopener"></a> 示例。</p>
<p>如果 <code>select()</code> 仅用于套接字文件描述符，那么可以启用 <code>CONFIG_USE_ONLY_LWIP_SELECT</code> 选项，这可以减少代码大小并提高性能。</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>每个注册的 FS 都有一个与之关联的路径前缀。该前缀可以被认为是该分区的 <code>“mount point”</code>(挂载点)。</p>
<p>如果嵌套安装点，则在打开文件时将使用具有最长匹配路径前缀的安装点。例如，假设以下文件系统在 VFS 中注册：</p>
<ul>
<li>FS 1 on /data</li>
<li>FS 2 on /data/static<br>然后：</li>
<li>打开名为 <code>/data/log.txt</code> 的文件时将使用 FS 1</li>
<li>打开名为 <code>/data/static/index.html</code> 的文件时将使用 FS 2</li>
<li>即使 FS 2 中不存在 <code>/index.html</code>，也不会搜索 FS 1 <code>/static/index.html</code>。</li>
</ul>
<p>作为一般规则，挂载点名称必须以路径分隔符(<code>/</code>)开头，并且必须在路径分隔符后包含至少一个字符。但是，也支持空挂载点名称，并且可以在应用程序需要提供“回退”文件系统或完全覆盖VFS功能的情况下使用。如果没有前缀匹配给定的路径，则将使用此类文件系统。</p>
<p>VFS 不以任何特殊方式处理路径名中的点(.)。VFS 不会将 <code>...</code> 视为对父目录的引用。即在上面的例子中，使用路径 <code>/data/static/../log.txt</code> 不会导致调用 FS 1 来打开 <code>/log.txt</code>。特定 FS 驱动程序(如 FATFS)可能以不同方式处理文件名中的点。</p>
<p>打开文件时，FS 驱动程序只会获得文件的相对路径。例如：</p>
<ul>
<li><code>myfs</code> 驱动程序使用 <code>/data</code> 注册为路径前缀</li>
<li>和应用程序调用 <code>fopen(“/data/config.json”，...)</code></li>
<li>然后 VFS 组件将调用 <code>myfs_open(“/config.json”，...)</code>。</li>
<li><code>myfs</code> 驱动程序将打开 <code>/config.json</code> 文件</li>
</ul>
<p>VFS 不会对总文件路径长度施加限制，但会将 FS 路径前缀限制为 <code>ESP_VFS_PATH_MAX</code> 字符。各个 FS 驱动程序可能有自己的文件名长度限制。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>文件描述符是从 <code>0</code> 到 <code>FD_SETSIZE -1</code> 其中 <code>FD_SETSIZE</code> 在newlib的 <code>sys/types.h</code> 中定义。最大的文件描述符(由 <code>CONFIG_LWIP_MAX_SOCKETS</code> 配置)保留给套接字。VFS 组件包含一个名为 <code>s_fd_table</code> 的查找表，用于将全局文件描述符映射到 <code>s_vfs</code> 数组中注册的 VFS 驱动程序索引。</p>
<h2 id="标准-IO-流-stdin，stdout，stderr"><a href="#标准-IO-流-stdin，stdout，stderr" class="headerlink" title="标准 IO 流(stdin，stdout，stderr)"></a>标准 IO 流(stdin，stdout，stderr)</h2><p>如果“UART for console output”menuconfig选项未设置为“None”，则 <code>stdin</code>，<code>stdout</code> 和 <code>stderr</code> 配置为读取和写入 UART。可以将 UART0 或 UART1 用于标准 IO。默认情况下，使用 UART0，波特率为 115200，TX 引脚为 GPIO1，RX 引脚为 GPIO3。可以在 menuconfig 中更改这些参数。</p>
<p>写入 <code>stdout</code> 或 <code>stderr</code> 会将字符发送到 UART 发送 FIFO。从 <code>stdin</code> 读取将从 UART 接收 FIFO 中检索字符。</p>
<p>默认情况下，VFS 使用简单的函数来读取和写入 UART。写入忙 - 等待直到所有数据都被放入 UART FIFO，并且读取是非阻塞的，只返回 FIFO 中的数据。由于这种非阻塞读取行为，更高级别的 C 库调用，例如 <code>fscanf(“％d \ n”，＆var);</code> 可能没有预期的结果。</p>
<p>使用 UART 驱动程序的应用程序可能会指示 VFS 使用驱动程序的中断驱动，阻塞读写功能。这可以通过调用 <code>esp_vfs_dev_uart_use_driver</code> 函数来完成。也可以使用 <code>esp_vfs_dev_uart_use_nonblocking</code> 调用恢复到基本的非阻塞函数。</p>
<p>VFS 还为输入和输出提供可选的换行转换功能。在内部，大多数应用程序发送和接收由 LF(‘n’’)字符终止的行。不同的终端程序可能需要不同的线路终端，例如 CR 或 CRLF。应用程序可以通过 menuconfig 或通过调用 <code>esp_vfs_dev_uart_set_rx_line_endings</code> 和 <code>esp_vfs_dev_uart_set_tx_line_endings</code> 函数单独为输入和输出配置它。</p>
<h2 id="标准流和-FreeRTOS-任务"><a href="#标准流和-FreeRTOS-任务" class="headerlink" title="标准流和 FreeRTOS 任务"></a>标准流和 FreeRTOS 任务</h2><p><code>stdin</code>，<code>stdout</code> 和 <code>stderr</code> 的 <code>FILE</code> 对象在所有 FreeRTOS 任务之间共享，但指向这些对象的指针存储在每个任务的 <code>struct _reent</code> 中。以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fprintf(stderr，“42\n”);</span><br></pre></td></tr></table></figure>
<p>实际上被翻译成这个(由预处理器)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fprintf(__ getreent() -&gt; _stderr，“42\n”);</span><br></pre></td></tr></table></figure>
<p>其中 <code>__getreent()</code>函数返回一个指向 <code>struct _reent</code>的每个任务指针 <code>(newlib/include/sys/reent.h＃L370-L417)</code>。此结构在每个任务的 TCB 上分配。初始化任务时，<code>struct _reent</code> 的 <code>_stdin</code>，<code>_stdout</code> 和 <code>_stderr</code> 成员被设置为 <code>_GLOBAL_REENT</code> 的 <code>_stdin</code>，<code>_stdout</code> 和 <code>_stderr</code> 的值(即在 FreeRTOS 启动之前使用的结构)。</p>
<p>这样的设计会产生以下后果：</p>
<ul>
<li>可以为任何给定任务设置 <code>stdin</code>，<code>stdout</code> 和 <code>stderr</code>，而不会影响其他任务，例如通过做 <code>stdin = fopen(“/dev/uart/1”，“r”)</code>。</li>
<li>使用 fclose 关闭默认 <code>stdin</code>，<code>stdout</code> 或 <code>stderr</code> 将关闭 <code>FILE</code> 流对象 - 这将影响所有其他任务。</li>
<li>要更改新任务的默认 <code>stdin</code>，<code>stdout</code>，<code>stderr</code> 流，请在创建任务之前修改 <code>_GLOBAL_REENT - &gt; _ stdin(_stdout，_stderr)</code>。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/storage/vfs.html" target="_blank" rel="noopener">Virtual filesystem</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（十六）Over The Air Updates (OTA)</title>
    <url>/InfiniteYuanBlog/2018/08/29/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89Over%20The%20Air%20Updates%20(OTA)/</url>
    <content><![CDATA[<h1 id="Over-The-Air-Updates-OTA"><a href="#Over-The-Air-Updates-OTA" class="headerlink" title="Over The Air Updates (OTA)"></a>Over The Air Updates (OTA)</h1><h2 id="OTA-流程概述"><a href="#OTA-流程概述" class="headerlink" title="OTA 流程概述"></a>OTA 流程概述</h2><p>OTA 更新机制允许设备根据正常固件运行时收到的数据进行更新(例如,通过WiFi或蓝牙).</p>
<p>OTA 要求至少使用两个 “OTA app slot” 分区(即 <code>ota_0</code> 和 <code>ota_1</code>)和 “OTA Data Partition” 来配置设备的<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">分区表</a>.</p>
<p>OTA 操作功能将新的应用程序固件映像写入当前未用于启动的 OTA 应用程序位置. 验证映像后,将更新 OTA 数据分区以指定此映像应用于下次启动.</p>
<a id="more"></a>

<h2 id="OTA-数据分区"><a href="#OTA-数据分区" class="headerlink" title="OTA 数据分区"></a>OTA 数据分区</h2><p>OTA 数据分区 (type <code>data</code>, subtype <code>ota</code>) 必须包含在使用 OTA 功能的任何项目的<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">分区表</a>中.</p>
<p>对于出厂启动设置,OTA 数据分区不应包含任何数据(所有字节都擦除为 0xFF). 在这种情况下,esp-idf 软件引导加载程序将启动 factory 应用程序(如果它存在于分区表中). 如果分区表中不包含 factory 应用程序,则会启动第一个可用的 OTA 程序(通常为 <code>ota_0</code>).</p>
<p>在第一次 OTA 更新之后,更新 OTA 数据分区以指定下一个应该引导哪个 OTA 应用程序分区.</p>
<p>OTA 数据分区的大小为两个闪存扇区(0x2000 字节),以防止在写入时出现电源故障时出现问题. 扇区被独立擦除并用匹配数据写入,如果它们不同意,则使用计数器字段来确定最近写入哪个扇区.</p>
<h2 id="APP-回滚"><a href="#APP-回滚" class="headerlink" title="APP 回滚"></a>APP 回滚</h2><p>应用程序回滚的主要目的是在更新后使设备保持工作。此功能允许您回滚到以前的工作应用程序，以防新应用程序出现严重错误。启用回滚过程并且 OTA 更新提供应用程序的新版本时，可能会发生以下三种情况之一：</p>
<ul>
<li>应用程序正常，<code>esp_ota_mark_app_valid_cancel_rollback()</code> 使用状态 <code>ESP_OTA_IMG_VALID</code> 标记正在运行的应用程序。启动此应用程序没有任何限制。</li>
<li>应用程序存在严重错误，无法进行进一步的工作，需要回滚到先前的应用程序，<code>esp_ota_mark_app_invalid_rollback_and_reboot()</code> 将正在运行的应用程序标记为 <code>ESP_OTA_IMG_INVALID</code> 并重置。引导加载程序不会选择此应用程序进行引导，并将引导以前工作的应用程序。</li>
<li>如果设置了 <code>CONFIG_APP_ROLLBACK_ENABLE</code> 选项，并且在不调用任何函数的情况下发生重置，则会发生并回滚。</li>
</ul>
<blockquote>
<p>注意：状态不会写入应用程序的二进制映像，而是将其写入数据分区。该分区包含一个 <code>ota_seq</code> 计数器，该计数器是指向应用程序将从中进行引导的插槽（ota_0，ota_1，…）的指针。</p>
</blockquote>
<h2 id="APP-OTA-状态"><a href="#APP-OTA-状态" class="headerlink" title="APP OTA 状态"></a>APP OTA 状态</h2><p>状态控制选择启动应用程序的过程：</p>
<table>
<thead>
<tr>
<th align="center">States</th>
<th align="center">Restriction of selecting a boot app in bootloader</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ESP_OTA_IMG_VALID</td>
<td align="center">None restriction. Will be selected.</td>
</tr>
<tr>
<td align="center">ESP_OTA_IMG_UNDEFINED</td>
<td align="center">None restriction. Will be selected.</td>
</tr>
<tr>
<td align="center">ESP_OTA_IMG_INVALID</td>
<td align="center">Will not be selected.</td>
</tr>
<tr>
<td align="center">ESP_OTA_IMG_ABORTED</td>
<td align="center">Will not be selected.</td>
</tr>
<tr>
<td align="center">ESP_OTA_IMG_NEW</td>
<td align="center">If CONFIG_APP_ROLLBACK_ENABLE option is set it will be selected only once. In bootloader the state immediately changes to <code>ESP_OTA_IMG_PENDING_VERIFY</code>.</td>
</tr>
<tr>
<td align="center">ESP_OTA_IMG_PENDING_VERIFY</td>
<td align="center">If CONFIG_APP_ROLLBACK_ENABLE option is set it will not be selected and the state will change to <code>ESP_OTA_IMG_ABORTED</code>.</td>
</tr>
</tbody></table>
<p>如果未启用 <code>CONFIG_APP_ROLLBACK_ENABLE</code> 选项（默认情况下），则使用以下函数 <code>esp_ota_mark_app_valid_cancel_rollback()</code> 和 <code>esp_ota_mark_app_invalid_rollback_and_reboot()</code> 是可选的，并且不使用 <code>ESP_OTA_IMG_NEW</code> 和 <code>ESP_OTA_IMG_PENDING_VERIFY</code> 状态。</p>
<p>Kconfig 中的 <code>CONFIG_APP_ROLLBACK_ENABLE</code> 选项允许您跟踪新应用程序的首次引导。在这种情况下，应用程序必须通过调用 <code>esp_ota_mark_app_valid_cancel_rollback()</code> 函数来确认其可操作性，否则应用程序将在重新启动时回滚。它允许您在引导阶段控制应用程序的可操作性。因此，新应用程序只有一次尝试成功启动。</p>
<h2 id="回滚过程"><a href="#回滚过程" class="headerlink" title="回滚过程"></a>回滚过程</h2><p>启用 <code>CONFIG_APP_ROLLBACK_ENABLE</code> 选项时回滚过程的说明：</p>
<ul>
<li>成功下载的新应用程序和 <code>esp_ota_set_boot_partition()</code> 函数使此分区可引导并设置状态 <code>ESP_OTA_IMG_NEW</code>。此状态表示应用程序是新的，应监视其首次引导。</li>
<li>重启 <code>esp_restart()</code>。</li>
<li>引导加载程序检查 <code>ESP_OTA_IMG_PENDING_VERIFY</code> 状态（如果已设置），然后将写入 <code>ESP_OTA_IMG_ABORTED</code>。</li>
<li>引导加载程序选择要引导的新应用程序，以便状态不会设置为 <code>ESP_OTA_IMG_INVALID</code> 或 <code>ESP_OTA_IMG_ABORTED</code>。</li>
<li>引导加载程序检查所选应用程序的 <code>ESP_OTA_IMG_NEW</code> 状态（如果已设置），然后它将写入 <code>ESP_OTA_IMG_PENDING_VERIFY</code>。此状态意味着应用程序需要确认其可操作性，如果没有发生并且发生重新启动，此状态将被覆盖到 <code>ESP_OTA_IMG_ABORTED</code> （参见上文），此应用程序将无法再启动，即将返回到以前的工作申请。</li>
<li>一个新的应用程序已经开始，应该进行自我测试。</li>
<li>如果自检已成功完成，则必须调用函数 <code>esp_ota_mark_app_valid_cancel_rollback()</code>，因为应用程序正在等待可操作性的确认（<code>ESP_OTA_IMG_PENDING_VERIFY</code> 状态）。</li>
<li>如果自检失败，则调用 <code>esp_ota_mark_app_invalid_rollback_and_reboot()</code> 函数回滚到上一个工作应用程序，同时将无效应用程序设置为 <code>ESP_OTA_IMG_INVALID</code> 状态。</li>
<li>如果尚未确认应用程序，则状态仍为 <code>ESP_OTA_IMG_PENDING_VERIFY</code>，下次启动时将更改为 <code>ESP_OTA_IMG_ABORTED</code>。这将阻止重新启动此应用程序。将回滚到以前的工作应用程序。</li>
</ul>
<h2 id="意外重启"><a href="#意外重启" class="headerlink" title="意外重启"></a>意外重启</h2><p>如果在首次启动新应用程序时发生断电或意外崩溃，它将回滚应用程序。</p>
<p>建议：尽快执行自检程序，以防止因断电而导致的回滚。</p>
<p>只能回滚 <code>OTA</code> 分区。工厂分区未回滚。</p>
<h2 id="启动无效-中止的应用程序"><a href="#启动无效-中止的应用程序" class="headerlink" title="启动无效/中止的应用程序"></a>启动无效/中止的应用程序</h2><p>可以引导先前设置为 <code>ESP_OTA_IMG_INVALID</code> 或 <code>ESP_OTA_IMG_ABORTED</code> 的应用程序：</p>
<ul>
<li>获取最后一个无效的应用程序分区 <code>esp_ota_get_last_invalid_partition()</code>。</li>
<li>将收到的分区传递给 <code>esp_ota_set_boot_partition()</code>，这将更新 <code>otadata</code>。</li>
<li>重启 <code>esp_restart()</code>。引导加载程序将引导指定的应用程序。</li>
</ul>
<p>要确定在启动应用程序期间是否应运行自检，请调用 <code>esp_ota_get_state_partition()</code> 函数。如果结果为 <code>ESP_OTA_IMG_PENDING_VERIFY</code>，则需要进行自检并随后确认可操作性。</p>
<h2 id="设置状态"><a href="#设置状态" class="headerlink" title="设置状态"></a>设置状态</h2><p>关于状态设置的简要说明：</p>
<ul>
<li><code>ESP_OTA_IMG_VALID</code> 状态由 <code>esp_ota_mark_app_valid_cancel_rollback()</code> 函数设置。</li>
<li>如果未启用 <code>CONFIG_APP_ROLLBACK_ENABLE</code> 选项，则 <code>esp_ota_set_boot_partition()</code> 函数将设置 <code>ESP_OTA_IMG_UNDEFINED</code> 状态。</li>
<li>如果启用了 <code>CONFIG_APP_ROLLBACK_ENABLE</code> 选项，则 <code>esp_ota_set_boot_partition()</code> 函数将设置 <code>ESP_OTA_IMG_NEW</code> 状态。</li>
<li><code>ESP_OTA_IMG_INVALID</code> 状态由 <code>esp_ota_mark_app_invalid_rollback_and_reboot()</code> 函数设置。</li>
<li>如果没有确认应用程序可操作性并且重新启动（如果启用了 <code>CONFIG_APP_ROLLBACK_ENABLE</code> 选项），则设置 <code>ESP_OTA_IMG_ABORTED</code> 状态。</li>
<li>如果启用了 <code>CONFIG_APP_ROLLBACK_ENABLE</code> 选项并且所选应用具有 <code>ESP_OTA_IMG_NEW</code> 状态，则在引导加载程序中设置 <code>ESP_OTA_IMG_PENDING_VERIFY</code> 状态。</li>
</ul>
<h2 id="没有安全启动的安全-OTA-更新"><a href="#没有安全启动的安全-OTA-更新" class="headerlink" title="没有安全启动的安全 OTA 更新"></a>没有安全启动的安全 OTA 更新</h2><p>即使不启用硬件安全引导，也可以执行已签名的 OTA 更新的验证。为此，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html#signed-app-verify" target="_blank" rel="noopener">没有硬件安全启动的签名应用验证</a></p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul>
<li><a href="https://esp-idf.readthedocs.io/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">Partition Table documentation</a></li>
<li><a href="https://esp-idf.readthedocs.io/en/latest/api-reference/storage/spi_flash.html" target="_blank" rel="noopener">Lower-Level SPI Flash/Partition API</a></li>
<li><a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/esp_https_ota.html" target="_blank" rel="noopener">ESP HTTPS OTA</a></li>
</ul>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>OTA 固件更新工作流程的端到端示例: <a href="https://github.com/espressif/esp-idf/tree/51a4b4b/examples/system/ota" target="_blank" rel="noopener">system/ota</a>.</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/51a4b4b/components/app_update/include/esp_ota_ops.h" target="_blank" rel="noopener">app_update/include/esp_ota_ops.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/system/ota.html" target="_blank" rel="noopener">Over The Air Updates (OTA)</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（十四）Sigma-delta Modulation</title>
    <url>/InfiniteYuanBlog/2018/08/13/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89Sigma-delta%20Modulation/</url>
    <content><![CDATA[<h1 id="Sigma-delta-Modulation"><a href="#Sigma-delta-Modulation" class="headerlink" title="Sigma-delta Modulation"></a>Sigma-delta Modulation</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ESP32 有一个二阶 sigma-delta 调制模块。此驱动程序可配置 sigma-delta 模块的通道。</p>
<h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>八个独立的 sigma-delta 调制信道用 <code>sigmadelta_channel_t</code> 进行标识。每个通道都能够输出 sigma-delta 调制模块生成的二进制硬件信号。</p>
<p>应通过在 <code>sigmadelta_config_t</code> 中提供配置参数然后将此配置应用于 <code>sigmadelta_config()</code> 来设置所选通道。</p>
<p>另一种选择是调用各个函数，逐个配置所有必需参数：</p>
<ul>
<li>sigma-delta 调制模块的预分频器 - <code>sigmadelta_set_prescale()</code></li>
<li>输出信号的占空比 - <code>sigmadelta_set_duty()</code></li>
<li>输出调制信号的 GPIO 引脚 - <code>sigmadelta_set_pin()</code></li>
</ul>
<p><code>sigmadelta_set_duty()</code> 的 <code>duty</code> 参数的范围是 -128 到 127（八位有符号整数）。如果设置了零值，那么输出信号的占空比将为 50％，参见 <code>sigmadelta_set_duty()</code> 的描述。</p>
<a id="more"></a>

<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>Σ-Δ调制示例：<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/sigmadelta" target="_blank" rel="noopener">peripherals/sigmadelta</a>.</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/sigmadelta.h" target="_blank" rel="noopener">driver/include/driver/sigmadelta.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/sigmadelta.html" target="_blank" rel="noopener">Sigma-delta Modulation</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（十）Timer</title>
    <url>/InfiniteYuanBlog/2018/08/13/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89Timer/</url>
    <content><![CDATA[<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ESP32 芯片包含两个硬件定时器组。每组有两个通用硬件定时器。它们都是基于 16 位预分频器和 64 位自动重载功能的向上/向下计数器的 64 位通用定时器。</p>
<h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>以下各节介绍了配置操作定时器的典型步骤：</p>
<ul>
<li><a href="#定时器初始化">定时器初始化</a> - 应设置哪些参数以使定时器工作以及根据设置提供的具体功能。</li>
<li><a href="#定时器控制">定时器控制</a> - 如何读取定时器的值，暂停/启动定时器，以及如何操作。</li>
<li><a href="#警报">警报</a> - 设置和使用警报。</li>
<li><a href="#中断">中断</a> - 如何启用和使用中断。</li>
</ul>
<a id="more"></a>

<h3 id="定时器初始化"><a href="#定时器初始化" class="headerlink" title="定时器初始化"></a>定时器初始化</h3><p>使用 <code>timer_group_t</code> 标识 ESP32 的两个定时器组。使用 <code>timer_idx_t</code> 标识组中的各个定时器。每个定时器组都有两个定时器，总共提供四个定时器。</p>
<p>在启动定时器之前，应该通过调用 <code>timer_init()</code> 来初始化定时器。应该为此函数提供结构 <code>timer_config_t</code>，以定义定时器应如何工作。特别是以下定时器参数的设置：</p>
<ul>
<li><strong>分频器</strong>：定时器的计数器“滴答作响”的速度有多快。这取决于分频器的设置，它将用作输入的 80 MHz APB_CLK 时钟的除数。</li>
<li><strong>模式</strong>：<code>counter_dir</code> 决定了计数器递增或递减，通过从 <code>timer_count_dir_t</code> 中选择一个值来设置 <code>counter_dir</code> 。</li>
<li><strong>计数器启用</strong>：如果计数器已启用，则在调用 <code>timer_init()</code> 后它将立即开始递增/递减。通过从 <code>timer_start_t</code> 中选择一个值，使用 <code>counter_en</code> 设置此操作。</li>
<li><strong>报警启用</strong>：由 <code>alarm_en</code> 的设置决定。</li>
<li><strong>自动重新加载</strong>：计数器是否应在定时器的警报上自动重新加载特定的初始值，或者继续递增或递减。</li>
<li><strong>中断类型</strong>：定时器报警是否触发中断。设置 <code>timer_intr_mode_t</code> 中定义的值。</li>
</ul>
<p>要获取定时器设置的当前值，请使用函数 <code>timer_get_config()</code>。</p>
<h3 id="定时器控制"><a href="#定时器控制" class="headerlink" title="定时器控制"></a>定时器控制</h3><p>一旦配置并启用了定时器，它就已经“滴答作响”了。要检查它的当前值，请调用 <code>timer_get_counter_value()</code> 或 <code>timer_get_counter_time_sec()</code>。要将定时器设置为特定的起始值，请调用 <code>timer_set_counter_value()</code>。</p>
<p>可以通过调用 <code>timer_pause()</code> 随时暂停定时器。要再次启动它，请调用 <code>timer_start()</code>。</p>
<p>要更改定时器的运行方式，可以再次调用 <code>Timer_init()</code>，如 <a href="#定时器初始化">Timer Initialization</a> 部分所述。另一种选择是使用专用功能来更改个别设置：</p>
<ul>
<li><strong>分频器值</strong> - <code>timer_set_divider()</code>。注意：更改分频器时应暂停定时器以避免不可预测的结果。如果定时器已在运行，<code>timer_set_divider()</code> 将首先暂停定时器，更改分频器，最后再次启动定时器。</li>
<li><strong>模式</strong>(计数器是递增还是递减) - <code>timer_set_counter_mode()</code></li>
<li><strong>报警时自动重载计数器</strong> - <code>timer_set_auto_reload()</code></li>
</ul>
<h3 id="警报"><a href="#警报" class="headerlink" title="警报"></a>警报</h3><p>要设置警报，请调用函数 <code>timer_set_alarm_value()</code>，然后使用 <code>timer_set_alarm()</code> 启用它。当调用 <code>timer_init()</code> 时，也可以在定时器初始化阶段启用警报。</p>
<p>启用警报并且定时器达到警报值后，根据配置，可能会发生以下两种操作：</p>
<ul>
<li>如果先前已配置，将触发中断。请参见中断如何配置中断一节。</li>
<li>启用 <code>auto_reload</code> 后，将重新加载定时器的计数器以从特定的初始值开始计数。应使用 <code>timer_set_counter_value()</code> 预先设置要启动的值。</li>
</ul>
<blockquote>
<ul>
<li>如果设置了警报值并且定时器已经超过该值，则将立即触发警报。</li>
<li>触发后，警报将自动禁用，需要重新启动以再次触发。</li>
</ul>
</blockquote>
<p>要检查已设置的警报值，请调用 <code>timer_get_alarm_value()</code>。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>为特定定时器组和定时器注册中断处理程序是通过调用 <code>timer_isr_register()</code> 来完成的。</p>
<p>要为定时器组启用中断，请调用 <code>timer_group_intr_enable()</code>。要为特定定时器执行此操作，请调用 <code>timer_enable_intr()</code>。使用相应的函数 <code>timer_group_intr_disable()</code> 和 <code>timer_disable_intr()</code> 来禁用中断。</p>
<p>在 ISR 中处理中断时，需要明确清除中断。为此，请设置定义在 <a href="https://github.com/espressif/esp-idf/blob/30545f4/components/soc/esp32/include/soc/timer_group_struct.h" target="_blank" rel="noopener">soc/esp32/include/soc/timer_group_struct.h</a>里的 <code>TIMERGN.int_clr_timers.tM</code> 结构，其中 N 是定时器组号 [0,1]，M 是定时器号 [0,1]。例如，要清除定时器组 0 中定时器 1 的中断，请调用以下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIMERG0.int_clr_timers.t1 = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>请参阅下面的应用示例如何使用中断。</p>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>64 位硬件定时器示例：<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/timer_group" target="_blank" rel="noopener">peripherals/timer_group</a>.</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/30545f4/components/driver/include/driver/timer.h" target="_blank" rel="noopener">driver/include/driver/timer.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/timer.html" target="_blank" rel="noopener">Timer</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（四）ADC - Analog to Digital Converter</title>
    <url>/InfiniteYuanBlog/2018/08/11/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89ADC%20-%20Analog%20to%20Digital%20Converter/</url>
    <content><![CDATA[<h1 id="ADC-Analog-to-Digital-Converter"><a href="#ADC-Analog-to-Digital-Converter" class="headerlink" title="ADC - Analog to Digital Converter"></a>ADC - Analog to Digital Converter</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 集成了 2 个 12 位逐次逼近模数转换器 (SARADC),由 5 个专用转换器控制器管理.支持 18 个通道(模拟使能引脚)的测量. ADC 还可测量 vdd33 等内部信号.其中一些引脚可用于设计 1 个可编程增益放大器,用于测量微弱模拟信号.SAR ADC 使用的 5 个控制器均为专用控制器,其中 2 个支持高性能多通道扫描、2 个经过优化可支持 Deep-sleep 模式下的低功耗运行,另外 1 个专门用于 PWDET/ PKDET (功率检测和峰值监测).</p>
<a id="more"></a>

<p><img src="https://img-blog.csdn.net/20180824172548878?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图 1: SAR ADC 的概况"></p>
<center>图 1: SAR ADC 的概况</center>

<p>ADC 驱动程序 API 支持 ADC1(8 个通道,连接到 GPIO 32-39)和 ADC2(10 个通道,连接到 GPIO 0,2,4,12-15和 25-27). 但是,使用 ADC2 的应用程序存在一些限制:</p>
<ol>
<li>仅当 Wi-Fi 驱动程序未启动时,应用程序才能使用 ADC2,因为具有更高优先级的 Wi-Fi 驱动程序也使用 ADC.</li>
<li>某些 ADC2 引脚用作捆扎引脚(GPIO 0,2,15),因此无法自由使用. 例如,官方开发套件:</li>
</ol>
<ul>
<li><a href="https://esp-idf.readthedocs.io/en/latest/hw-reference/modules-and-boards.html#esp-modules-and-boards-esp32-devkitc" target="_blank" rel="noopener">ESP32 Core Board V2 / ESP32 DevKitC</a>:由于外部自动编程电路,无法使用 GPIO 0.</li>
<li><a href="https://esp-idf.readthedocs.io/en/latest/hw-reference/modules-and-boards.html#esp-modules-and-boards-esp-wrover-kit-v3" target="_blank" rel="noopener">ESP-WROVER-KIT V3</a>:由于外部连接用于不同目的,因此无法使用 GPIO 0,2,4 和 15.</li>
</ul>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul>
<li>采用 2 个 SAR ADC,可支持同时采样与转换</li>
<li>采用 5 个专用 ADC 控制器,可支持不同应用场景(比如,高性能、低功耗,或功率检测和峰值检测)</li>
<li>支持 18 个模拟输入管脚</li>
<li>1 个内部电压 vdd33 通道、2 个 pa_pkdet 通道(部分控制器支持)</li>
<li>可配置 12 位、11 位、10 位、9 位多种分辨率</li>
<li>支持 DMA(1 个控制器支持)</li>
<li>支持多通道扫描模式(2 个控制器支持)</li>
<li>支持 Deep-sleep 模式运行(1 个控制器支持)</li>
<li>支持 ULP 协处理器控制(2 个控制器支持)</li>
</ul>
<h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p><img src="https://img-blog.csdn.net/20180824181445719?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图 2: SAR ADC 的功能概况"></p>
<center>图 2: SAR ADC 的功能概况</center>

<p><img src="https://img-blog.csdn.net/20180824181614793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="表 1: SAR ADC 的信号输入"></p>
<center>表 1: SAR ADC 的信号输入</center>
ESP32 内置了 5 个专用 ADC 控制器: RTC ADC1 CTRL、 RTC ADC2 CTRL、 DIG ADC1 CTRL、 DIG ADC2 CTRL,
及 PWDET CTRL。各控制器的场景支持情况见表 2

<p><img src="https://img-blog.csdn.net/20180824184037450?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="表 2: ESP32 的 SAR ADC 控制器"></p>
<center>表 2: ESP32 的 SAR ADC 控制器</center>

<h2 id="配置和读取-ADC"><a href="#配置和读取-ADC" class="headerlink" title="配置和读取 ADC"></a>配置和读取 ADC</h2><p>在读取之前应配置 ADC.</p>
<ul>
<li>对于 ADC1,通过调用函数 <code>adc1_config_width()</code> 和 <code>adc1_config_channel_atten()</code> 来配置所需的精度和衰减.</li>
<li>对于 ADC2,通过 <code>adc2_config_channel_atten()</code> 配置衰减. 每次读取时都会配置 ADC2 的读取宽度.</li>
</ul>
<p>每个通道完成衰减配置,请参见 <code>adc1_channel_t</code> 和 <code>adc2_channel_t</code>,设置为上述功能的参数.</p>
<p>然后可以使用 <code>adc1_get_raw()</code> 和 <code>adc2_get_raw()</code> 读取 ADC 转换结果. 应将 ADC2 的读取宽度设置为 <code>adc2_get_raw()</code> 的参数,而不是配置函数中的参数.</p>
<blockquote>
<p>由于 ADC2 与具有更高优先级的 WIFI 模块共享,因此在 <code>esp_wifi_start()</code> 和 <code>esp_wifi_stop()</code> 之间,<code>adc2_get_raw()</code> 的读取操作将失败. 使用返回代码查看读数是否成功.</p>
</blockquote>
<p>也可以通过调用专用功能 <code>hall_sensor_read()</code>通过 ADC1 读取内部霍尔效应传感器. 请注意,即使霍尔传感器在 ESP32 内部,读取它也使用 ADC1 的通道 0 和 3(GPIO 36 和 39). 请勿将其他任何东西连接到这些引脚,也不要更改其配置. 否则可能会影响来自 sesnor 的低值信号的测量.</p>
<p>此 API 提供了配置 ADC1 以便从 ULP 读取的便捷方法. 为此,请调用函数 <code>adc1_ulp_enable()</code>,然后如上所述设置精度和衰减.</p>
<p>还有另一个特定功能 <code>adc2_vref_to_gpio()</code> 用于将内部参考电压路由到 GPIO 引脚. 它可以方便地校准 ADC 读数,这将在最小化噪声部分中讨论.</p>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>读取 ADC1 通道 0(GPIO 36)上的电压:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;driver/adc.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">    adc1_config_width(ADC_WIDTH_BIT_12);</span><br><span class="line">    adc1_config_channel_atten(ADC1_CHANNEL_0,ADC_ATTEN_DB_0);</span><br><span class="line">    <span class="keyword">int</span> val = adc1_get_raw(ADC1_CHANNEL_0);</span><br></pre></td></tr></table></figure>
<p>上例中的输入电压为 0 至 1.1V (衰减为 0 dB). 可以通过设置更高的衰减来扩展输入范围,请查看 <code>adc_atten_t</code>. esp-idf 中提供了使用 ADC 驱动程序的示例,包括校准(如下所述):<a href="https://github.com/espressif/esp-idf/tree/f9a4496/examples/peripherals/adc" target="_blank" rel="noopener">peripherals/adc</a></p>
<p>读取 ADC2 通道 7 (GPIO 27)的电压:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;driver/adc.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">int</span> read_raw;</span><br><span class="line">    adc2_config_channel_atten( ADC2_CHANNEL_7, ADC_ATTEN_0db );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">esp_err_t</span> r = adc2_get_raw( ADC2_CHANNEL_7, ADC_WIDTH_12Bit, &amp;read_raw);</span><br><span class="line">    <span class="keyword">if</span> ( r == ESP_OK ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, read_raw );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( r == ESP_ERR_TIMEOUT ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ADC2 used by Wi-Fi.\n"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于与 Wi-Fi 冲突,读数可能会失败,应该检查. esp-idf 中提供了使用 ADC2 驱动程序读取 DAC 输出的示例:<a href="https://github.com/espressif/esp-idf/tree/30545f4/examples/peripherals/adc2" target="_blank" rel="noopener">peripherals/adc2</a></p>
<p>读取内部霍尔效应传感器:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;driver/adc.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">    adc1_config_width(ADC_WIDTH_BIT_12);</span><br><span class="line">    <span class="keyword">int</span> val = hall_sensor_read();</span><br></pre></td></tr></table></figure>
<p>在这两个示例中读取的值是 12 位宽(范围 0-4095).</p>
<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><p>该参考包括三个组成部分:</p>
<ul>
<li><a href="https://esp-idf.readthedocs.io/en/latest/api-reference/peripherals/adc.html#adc-api-reference-adc-driver" target="_blank" rel="noopener">ADC driver</a></li>
<li><a href="https://esp-idf.readthedocs.io/en/latest/api-reference/peripherals/adc.html#adc-api-reference-adc-calibration" target="_blank" rel="noopener">ADC Calibration</a></li>
<li><a href="https://esp-idf.readthedocs.io/en/latest/api-reference/peripherals/adc.html#adc-api-reference-gpio-lookup-macros" target="_blank" rel="noopener">GPIO Lookup Macros</a></li>
</ul>
<h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/f9a4496/components/driver/include/driver/adc.h" target="_blank" rel="noopener">driver/include/driver/adc.h</a></li>
<li><a href="esp_adc_cal/include/esp_adc_cal.h">esp_adc_cal/include/esp_adc_cal.h</a></li>
<li><a href="https://github.com/espressif/esp-idf/blob/f9a4496/components/soc/esp32/include/soc/adc_channel.h" target="_blank" rel="noopener">soc/esp32/include/soc/adc_channel.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/adc.html" target="_blank" rel="noopener">ADC</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（一）关于 ESP-IDF 编程的一些说明</title>
    <url>/InfiniteYuanBlog/2018/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%B3%E4%BA%8E%20ESP-IDF%20%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="关于-ESP-IDF-编程的一些说明"><a href="#关于-ESP-IDF-编程的一些说明" class="headerlink" title="关于 ESP-IDF 编程的一些说明"></a>关于 ESP-IDF 编程的一些说明</h1><h2 id="应用启动流程"><a href="#应用启动流程" class="headerlink" title="应用启动流程"></a>应用启动流程</h2><p>本文档说明了在调用 ESP-IDF 应用程序的 <code>app_main</code> 函数之前发生的一些步骤.</p>
<p>启动过程如下：<br> <strong>1. 位于 ROM 中的第一阶段引导程序将第二阶段引导程序映像从 flash 0x1000 地址加载到 RAM( IRAM 和 DRAM ).<br> 2. 第二阶段引导程序从 flash 中加载分区表和主应用程序映像.主应用程序包含 RAM 段和通过 flash cache 映射的只读段.<br> 3. 主应用程序映像执行.此时,可以启动第二个 CPU 和 RTOS 调度器.</strong><br>以下各节将详细介绍此过程.</p>
<a id="more"></a>

<h2 id="第一阶段引导程序"><a href="#第一阶段引导程序" class="headerlink" title="第一阶段引导程序"></a>第一阶段引导程序</h2><p><strong>SoC 复位后,PRO CPU 会立即开始运行,执行复位向量代码,而 APP CPU 将保持复位状态.</strong> 在启动过程中, PRO CPU 会进行所有有关的初始化.APP CPU 复位状态在应用程序启动代码的 <code>call_start_cpu0</code> 函数中被取消.复位向量代码位于 ESP32 芯片掩模 ROM 中的 0x40000400 地址,并且无法修改.<br>复位向量调用的启动代码通过检查 <code>GPIO_STRAP_REG</code> 寄存器的引导引脚状态来确定引导模式.根据复位原因,有以下情况：</p>
<ol>
<li>从深度睡眠(<code>deep sleep</code>)模式复位：如果 <code>RTC_CNTL_STORE6_REG</code> 中的值非零,并且 <code>RTC_CNTL_STORE7_REG</code> 中的 RTC 存储器的 CRC 值有效,则使用 <code>RTC_CNTL_STORE6_REG</code> 作为入口地址并立即跳转到该地址.如果 <code>RTC_CNTL_STORE6_REG</code> 为零,或者 <code>RTC_CNTL_STORE7_REG</code> 包含无效的  CRC 值,或者通过 <code>RTC_CNTL_STORE6_REG</code> 调用的代码执行完毕,则继续启动,就像上电复位一样.注意：此时若要运行自定义的代码,需要提供深度睡眠存根机制.请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档.<ol start="2">
<li>对于上电复位,软件 SOC 复位和看门狗 SOC 复位：检查 <code>GPIO_STRAP_REG</code> 寄存器,是否要求 UART 或 SDIO 下载模式.如果是这种情况,配置 UART 或 SDIO,并等待下载代码.否则,继续启动,就好像是由于软件 CPU 复位.</li>
<li>对于软件 CPU 复位和看门狗 CPU 复位：根据 EFUSE 值配置 SPI flash,并尝试从 flash 中加载代码.在下面的段落中会更详细地描述了该步骤.如果从 flash 中加载代码失败,解压 BASIC 解释器到 RAM 中并启动它.请注意,发生这种情况时 RTC 看门狗仍然是开启的,因此除非解释器接收到任何输入,否则看门狗将在几百毫秒内复位 SOC,重复整个过程.如果解释器收到来自 UART 的任何输入,它将禁用看门狗.</li>
</ol>
</li>
</ol>
<p><strong>应用程序二进制映像从 flash 的 0x1000 地址开始加载.</strong> 闪存的第一个 4kB 扇区用于存储安全引导IV和应用程序映像的签名.有关详细信息,请查看安全启动文档.</p>
<h2 id="第二阶段引导程序"><a href="#第二阶段引导程序" class="headerlink" title="第二阶段引导程序"></a>第二阶段引导程序</h2><p>在 ESP-IDF 中,位于 flash 0x1000 地址的二进制映像是第二阶段引导程序. 第二阶段引导程序源代码可在 ESP-IDF 的 <code>components/bootloader</code> 目录中找到.请注意,第二阶段引导程序这样的安排并不是 ESP32 芯片唯一可行的安排.可以编写一个功能齐全的应用程序,当 flash 偏移到 0x1000 地址时可以工作,但这超出了本文档的范围.ESP-IDF 中使用第二阶段引导程序来增加 flash 布局的灵活性(使用分区表),并允许与闪存加密,安全引导和无线更新(OTA)相关的操作执行.</p>
<p><strong>当第一阶段引导程序完成校验并加载第二阶段引导程序时,它会跳转到在二进制映像头中找到的第二阶段引导程序的入口地址.</strong></p>
<p><strong>第二阶段引导程序读取在 0x8000 地址的分区表.</strong> 更多有关信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">分区表</a>文档.<strong>引导程序找到 factory 和 OTA 分区,并根据 OTA 信息分区中的数据决定引导哪个分区.</strong></p>
<p>对于所选分区,第二阶段引导程序将映射到 IRAM 和 DRAM 的数据和代码段拷贝到其加载地址.对于在 DROM 和 IROM 区域中具有加载地址的节,flash MMU 将提供正确的映射.请注意,第二阶段引导程序为 PRO 和 APP CPU 配置了 flash MMU,但它仅为 PRO CPU 启用 flash MMU.原因是第二阶段引导程序代码被加载到 APP CPU 缓存所使用的内存区域.为 APP CPU 启用缓存的任务将交给应用程序.加载代码并配置 flash MMU 后,第二阶段引导程序将跳转到二进制映像头中的应用程序入口地址.</p>
<p>目前,无法将应用程序定义的挂钩添加到引导程序以自定义应用程序分区的选择逻辑.例如,这可能需要根据 GPIO 的状态加载不同的应用程序映像.此类自定义功能将在未来添加到 ESP-IDF 中.目前,可以通过将 bootloader 组件拷贝到应用程序目录并在那里进行必要的更改来自定义引导程序.在这种情况下,ESP-IDF 构建系统将编译应用程序目录中的组件而不是 ESP-IDF 自身目录中的组件.</p>
<h2 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h2><p>ESP-IDF 应用程序入口地址是在 <code>components/esp32/cpu_start.c</code>中的<code>call_start_cpu0</code>函数.这个函数的两个主要功能是启用堆分配器并使 APP CPU 跳转到其入口地址<code>call_start_cpu1</code>.PRO CPU 上的代码设置 APP CPU 的入口地址、取消 APP CPU 复位,并等待全局标志被 APP CPU 上运行的代码设置,以表示 APP CPU 已经启动.这个函数执行后,PRO CPU 跳转到<code>start_cpu0</code>函数,APP CPU 跳转到<code>start_cpu1</code>函数.</p>
<p><code>start_cpu0</code>和<code>start_cpu1</code>都是弱函数,这意味着如果需要对初始化序列进行一些特定于应用程序的更改,则可以在应用程序中覆盖它们.<code>start_cpu0</code>默认启用或初始化 <code>menuconfig</code> 中选择的组件.请参阅<code>components/esp32/cpu_start.c</code>中此函数的源代码,以获取最新的执行步骤.请注意,在此阶段将调用应用程序中存在的任何 C ++ 全局构造函数.初始化完所有必要组件后,将创建主任务并启动 FreeRTOS 调度器.</p>
<p>当 PRO CPU 在 <code>start_cpu0</code>函数中进行初始化时,APP CPU 将在<code>start_cpu1</code>函数中等待调度器在 PRO CPU 上启动.在 PRO CPU 上启动调器器后,APP CPU 上的代码也会开启调度器.</p>
<p>主任务是运行 <code>app_main</code>函数. 可以在 <code>menuconfig</code> 中配置主任务堆栈大小和优先级. 应用程序可以将此任务用于特定应用程序的初始化,例如启动其他任务. 应用程序还可以将主任务用于事件循环和其他通用活动. 如果 <code>app_main</code> 函数返回,主任务会被删除.</p>
<h2 id="应用内存布局"><a href="#应用内存布局" class="headerlink" title="应用内存布局"></a>应用内存布局</h2><p>ESP32 芯片具有灵活的内存映射功能.本节将介绍  ESP-IDF 在默认情况下是如何使用这些功能的.<br>ESP-IDF 中的应用程序代码可以放入以下内存区域之一.</p>
<h3 id="IRAM-指令RAM"><a href="#IRAM-指令RAM" class="headerlink" title="IRAM(指令RAM)"></a>IRAM(指令RAM)</h3><p>ESP-IDF 为指令 RAM 分配内部 SRAM0 区域的一部分(在技术参考手册中定义).除了第一个 64 kB 块用于 PRO 和 APP CPU 高速缓存之外,该存储器范围的其余部分(即从 <code>0x40080000</code> 到 <code>0x400A0000</code> )用于存储需要从 RAM 中运行的应用程序部分.</p>
<p>使用链接描述文件将 ESP-IDF 的一些组件和 WiFi 协议栈的一些部分放入该区域.</p>
<p>如果需要将一些应用程序代码放入 IRAM,可以使用 <code>IRAM_ATTR</code> 定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;esp_attr.h&quot;</span><br><span class="line">void IRAM_ATTR gpio_isr_handler(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是部分应用可能或应该放在 IRAM 中的情况.</p>
<ul>
<li>如果在注册中断处理程序时使用<code>ESP_INTR_FLAG_IRAM</code>,则必须将中断处理程序放在 IRAM 中.在这种情况下,ISR 可能只调用放在 IRAM 中的函数或存在于 ROM 中的函数.注意：所有 FreeRTOS API 目前都放在 IRAM 中,因此可以安全地从中断处理程序中调用.如果将 ISR 放在 IRAM 中,则必须使用 <code>DRAM_ATTR</code> 将 ISR 使用的所有常量数据和从 ISR 调用的函数(包括但不限于 <code>const char</code> 数组)放在 DRAM 中.</li>
<li>可以将一些关键性的时序代码放在 IRAM 中以减少从闪存加载代码相关的损耗.ESP32 通过 32 kB 高速缓存从闪存中读取代码和数据.在某些情况下,将函数放入到 IRAM 中可以减少由高速缓存未命中引起的延迟.</li>
</ul>
<h3 id="IROM-从Flash执行的代码"><a href="#IROM-从Flash执行的代码" class="headerlink" title="IROM(从Flash执行的代码)"></a>IROM(从Flash执行的代码)</h3><p>如果函数未明确放入到 IRAM 或 RTC 内存中,则将其放置到闪存中.Flash 技术参考手册中介绍了 Flash MMU 用于允许代码从闪存执行的机制. ESP-IDF 从 0x400D0000 - 0x40400000 区域开始放置应该从闪存执行的代码.启动时,第二阶段引导加载程序初始化 Flash MMU 以将代码所在的 flash 中的位置映射到该区域的开头.使用 0x40070000 - 0x40080000 范围内的两个 32kB 块透明地缓存对该区域的访问.<br>请注意,使用 Window ABI CALLx 指令可能无法访问 0x40000000 - 0x40400000 区域外的代码,因此如果应用程序使用 0x40400000 - 0x40800000 或 0x40800000 - 0x40C00000 区域,需要特别小心. ESP-IDF 默认不使用这些区域.</p>
<h3 id="RTC-高速存储器"><a href="#RTC-高速存储器" class="headerlink" title="RTC 高速存储器"></a>RTC 高速存储器</h3><p>从深度睡眠模式唤醒后,将要运行的代码必须放入 RTC 存储器.请查看<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档中的详细说明.</p>
<h3 id="DRAM-数据-RAM"><a href="#DRAM-数据-RAM" class="headerlink" title="DRAM (数据 RAM)"></a>DRAM (数据 RAM)</h3><p>链接器将非常量静态数据和零初始化数据放入 256 kB 的 0x3FFB0000 - 0x3FFF0000 区域中.请注意,如果使用蓝牙堆栈,此区域将减少 64kB(通过将开始地址移至 0x3FFC0000).如果使用跟踪存储器,该区域的长度也会减少 16 kB 或 32kB.放置静态数据后,在此区域中的所有剩下的空间都将用于运行时堆.</p>
<p>常量数据也可以放入 DRAM 中,例如,如果它用在 ISR 中(参见上面 IRAM 部分的注释).为此,可以使用 DRAM_ATTR 定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DRAM_ATTR const char[] format_string &#x3D; &quot;%p %x&quot;;</span><br><span class="line">char buffer[64];</span><br><span class="line">sprintf(buffer, format_string, ptr, val);</span><br></pre></td></tr></table></figure>
<p>不必说,不建议在 ISR 中使用 printf 和其他输出功能.为了进行调试,从中断服务程序打印log时使用 <code>ESP_EARLY_LOGx</code> 宏.在这种情况下,必须确保将 TAG 和格式字符串都放入到 DRAM 中.</p>
<p><code>__NOINIT_ATTR</code>宏可以用作将数据放入<code>.noinit</code>部分的属性.放入此部分的值不会在启动时初始化,并在软件重新启动后保留其值.<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__NOINIT_ATTR uint32_t noinit_data;</span><br></pre></td></tr></table></figure>

<h3 id="DROM-存储在-Flash-中的数据"><a href="#DROM-存储在-Flash-中的数据" class="headerlink" title="DROM(存储在 Flash 中的数据)"></a>DROM(存储在 Flash 中的数据)</h3><p>默认情况下,链接器将常量数据放入到一个 4 MB 的区域中(0x3F400000 - 0x3F800000),该区域被用于通过 Flash MMU 和缓存访问外部闪存.但是对于文字常量不同,它们由编译器嵌入到应用程序代码中.</p>
<h3 id="RTC-低速存储器"><a href="#RTC-低速存储器" class="headerlink" title="RTC 低速存储器"></a>RTC 低速存储器</h3><p>从 RTC 存储器中运行的代码使用的全局和静态变量(即深度睡眠存根代码)必须放入到 RTC 慢速存储器中. 请查看<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档中的详细说明.</p>
<p><code>RTC_NOINIT_ATTR</code>宏可用于将数据放入到这种类型的内存中.放在此部分中的数据,在从深度睡眠中醒来后也会保持其值.<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTC_NOINIT_ATTR uint32_t rtc_noinit_data;</span><br></pre></td></tr></table></figure>

<h3 id="DMA-能力要求"><a href="#DMA-能力要求" class="headerlink" title="DMA 能力要求"></a>DMA 能力要求</h3><p>大多数 DMA 控制器(例如 SPI,sdmmc 等)都要求发送/接收缓冲区应放在 DRAM 中并进行字对齐.我们建议将 DMA 缓冲区放在静态变量中而不是堆栈中.使用<code>DMA_ATTR</code>宏声明全局/本地静态变量,如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DMA_ATTR uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;</span><br><span class="line"></span><br><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    DMA_ATTR static uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在堆栈中放置DMA缓冲区仍然是允许的,但必须记住：</p>
<ol>
<li>如果堆栈在 pSRAM 中,切勿尝试这样做.如果任务的堆栈放在 pSRAM 中,则必须执行<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/external-ram.html" target="_blank" rel="noopener">支持外部 RAM </a>文档(至少在 menuconfig 中启用 <code>SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY</code> 选项)中所述的几个步骤.确保你的任务不在 pSRAM 中.</li>
<li>在将变量放在适当的位置之前的函数中使用 <code>WORD_ALIGNED_ATTR</code> 宏,如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t stuff;</span><br><span class="line">    WORD_ALIGNED_ATTR uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;   &#x2F;&#x2F;or the buffer will be placed right after stuff.</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://esp-idf.readthedocs.io/en/latest/api-guides/general-notes.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（七）ESP32 Core Dump</title>
    <url>/InfiniteYuanBlog/2018/09/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%83%EF%BC%89ESP32%20Core%20Dump/</url>
    <content><![CDATA[<h1 id="ESP32-Core-Dump"><a href="#ESP32-Core-Dump" class="headerlink" title="ESP32 Core Dump"></a>ESP32 Core Dump</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-IDF 支持在不可恢复的软件错误上生成 Core Dump。这个技术可以对软件发生故障时的软件状态进行事后分析。在系统崩溃进入 Panic 状态时，根据配置打印一些信息并停止或重新启动。用户可以选择生成 Core Dump，以便稍后在 PC 上分析故障原因。Core Dump 包含软件发生故障时系统中所有任务的快照。快照包括任务控制块(TCB)和堆栈。因此。有可能找出什么任务，在什么指令(代码行)和该任务的什么调用堆栈导致崩溃。ESP-IDF 提供特殊脚本 <code>espcoredump.py</code>，以帮助用户检索和分析 Core Dump。此工具提供两个用于 Core Dump 分析的命令:</p>
<ul>
<li><code>info_corefile</code> - 打印崩溃的任务的寄存器，调用堆栈，系统中可用任务的列表，内存区域和存储在 Core Dump (TCB 和堆栈)中的内存内容。</li>
<li><code>dbg_corefile</code> - 创建 Core Dump ELF 文件并使用此文件运行 GDB 调试会话。用户可以手动检查内存，变量和任务状态。请注意，由于并非所有内存都保存在 Core Dump 中，因此只有堆栈上分配的变量值才有意义。</li>
</ul>
<a id="more"></a>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>有许多与 Core Dump 相关的配置选项，用户可以在应用程序的配置菜单中选择 (<code>make menuconfig</code>)。</p>
<ol>
<li>Core Dump 数据目标(Components -&gt; ESP32-specific config -&gt; Core dump destination):<ul>
<li>禁用 Core Dump 生成</li>
<li>将 Core Dump 保存到 Flash</li>
<li>将 Core Dump 打印到 UART</li>
</ul>
</li>
<li>核心转储中的最大任务快照数(Components -&gt; ESP32-specific config -&gt; Core dump -&gt; Maximum number of tasks)。</li>
<li>Core Dump 打印到 UART 之前的延迟时间(Components -&gt; ESP32-specific config -&gt; Core dump print to UART delay).。值以 ms 为单位。</li>
</ol>
<h2 id="将-Core-Dump-保存到-Flash"><a href="#将-Core-Dump-保存到-Flash" class="headerlink" title="将 Core Dump 保存到 Flash"></a>将 Core Dump 保存到 Flash</h2><p>选择此选项后，Core Dump 将保存到 Flash 上的特殊分区。当使用随 ESP-IDF 提供的默认分区表文件时，它会自动在 Flash 上分配必要的空间，但如果用户想要将自己的布局文件与 Core Dump 功能一起使用，则应为 Core Dump 定义单独的分区，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size</span><br><span class="line"># Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000</span><br><span class="line">factory,  app,  factory, 0x10000, 1M</span><br><span class="line">coredump, data, coredump,,        64K</span><br></pre></td></tr></table></figure>

<p>分区名称没有特殊要求。可以根据用户应用需求选择，但分区类型应为“数据”，子类型应为“coredump”。此外，在选择分区大小时请注意，Core Dump 数据结构会引入 20 字节的常量开销和 12 字节的每任务开销。此开销不包括每个任务的 TCB 和堆栈的大小，因此，partirion 大小应至少为 20 + max task stack number x(12 + TCB size + max task stack size) 字节。</p>
<p>从 Flash 分析 Core Dump 的通用命令示例是:<br><code>espcoredump.py -p &lt;/path/to/serial/port&gt; info_corefile &lt;/path/to/program/elf/file&gt;</code><br>或<br> <code>espcoredump.py -p &lt;/path/to/serial/port&gt; dbg_corefile &lt;/path/to/program/elf/file&gt;</code></p>
<h2 id="将-Core-Dump-打印到UART"><a href="#将-Core-Dump-打印到UART" class="headerlink" title="将 Core Dump 打印到UART"></a>将 Core Dump 打印到UART</h2><p>选择此选项时，在系统崩溃进入 Panic 状态时，将在 UART 上打印 <strong>base64 编码的 Core Dump</strong>。在这种情况下，用户应手动将 Core Dump 文本正文保存到某个文件，然后运行以下命令:<br><code>espcoredump.py info_corefile -t b64 -c &lt;/path/to/saved/base64/text&gt; &lt;/path/to/program/elf/file&gt;</code><br>或<br> <code>espcoredump.py dbg_corefile -t b64 -c &lt;/path/to/saved/base64/text&gt; &lt;/path/to/program/elf/file&gt;</code></p>
<p>Base64 编码的 Core Dump 体将位于以下页眉和页脚之间:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; CORE DUMP START &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&lt;body of base64-encoded core dump, save it to file on disk&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; CORE DUMP END &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>CORE DUMP START 和 CORE DUMP END 行不得包含在 Core Dump 文本文件中。</p>
<h2 id="Backtraces-中的-ROM-函数"><a href="#Backtraces-中的-ROM-函数" class="headerlink" title="Backtraces 中的 ROM 函数"></a>Backtraces 中的 ROM 函数</h2><p>可能的情况是，在崩溃时，一些任务或/和崩溃的任务本身在其调用堆栈中具有一个或多个 ROM 功能。由于 ROM 不是程序 ELF 的一部分，GDB 不可能解析这样的调用堆栈，因为它试图分析函数的序言来实现它。在这种情况下，调用堆栈打印将在第一个 ROM 函数中被错误消息打破。要解决此问题，您可以使用 Espressif 提供的 <a href="https://dl.espressif.com/dl/esp32_rom.elf" target="_blank" rel="noopener">ROM ELF</a> 并将其传递给 ‘espcoredump.py’。</p>
<h2 id="运行-‘espcoredump-py’"><a href="#运行-‘espcoredump-py’" class="headerlink" title="运行 ‘espcoredump.py’"></a>运行 ‘espcoredump.py’</h2><p>通用命令语法:</p>
<p><code>espcoredump.py [options] command [args]</code></p>
<p><code>Script Options:</code>    </p>
<ul>
<li>–chip,-c {auto,esp32}. Target chip type. Supported values are auto and esp32.</li>
<li>–port,-p PORT. Serial port device.</li>
<li>–baud,-b BAUD. Serial port baud rate used when flashing/reading.</li>
</ul>
<p><code>Commands:</code>    </p>
<ul>
<li>info_corefile. Retrieve core dump and print useful info.</li>
<li>dbg_corefile. Retrieve core dump and start GDB session with it.</li>
</ul>
<p><code>Command Arguments:</code></p>
<ul>
<li>–gdb,-g GDB. Path to gdb to use for data retrieval.</li>
<li>–core,-c CORE. Path to core dump file to use (if skipped core dump will be read from flash).</li>
<li>–core-format,-t CORE_FORMAT. Specifies that file passed with “-c” is an ELF (“elf”), dumped raw binary (“raw”) or base64-encoded (“b64”) format.</li>
<li>–off,-o OFF. Ofsset of coredump partition in flash (type “make partition_table” to see it).</li>
<li>–save-core,-s SAVE_CORE. Save core to file. Othwerwise temporary core file will be deleted. Ignored with “-c”.</li>
<li>–rom-elf,-r ROM_ELF. Path to ROM ELF file to use (if skipped “esp32_rom.elf” is used).</li>
<li>–print-mem,-m Print memory dump. Used only with “info_corefile”.</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/core_dump.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（三）分区表</title>
    <url>/InfiniteYuanBlog/2018/08/29/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>单个 ESP32 的 flash 可以包含多个应用程序,以及许多不同类型的数据(校准数据,文件系统,参数存储等). 因此,分区表被下载到 flash 中的 0x8000 地址(默认偏移量).</p>
<p>分区表长度为 0xC00 字节(最多 95 个分区表条目). 在表数据之后附加 MD5 校验和. 如果分区表由于安全引导而签名,则签名将附加在分区表之后.</p>
<p>分区表中的每个条目都有一个 <code>name</code> (label),<code>type</code>(app,data 或其他),<code>subtype</code>以及加载分区的 flash 中的 <code>offset</code> (偏移量).</p>
<p>使用分区表的最简单方法是 <code>make menuconfig</code> 并选择一个简单的预定义分区表:</p>
<ul>
<li>“Single factory app, no OTA”</li>
<li>“Factory app, two OTA definitions”</li>
</ul>
<p>在这两种情况下,<code>factory</code> 应用程序下载到 0x10000 地址. 如果您 <code>make partition_table</code>,那么它将打印分区表的摘要.</p>
<a id="more"></a>

<h2 id="内置分区表"><a href="#内置分区表" class="headerlink" title="内置分区表"></a>内置分区表</h2><p>以下是 <code>Single factory app, no OTA</code> 的分区表配置信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Espressif ESP32 Partition Table</span><br><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  app,  factory, 0x10000, 1M,</span><br></pre></td></tr></table></figure>
<ul>
<li>flash 中的 0x10000(64KB) 偏移量被标记为 <code>factory</code> 应用程序. 默认情况下,引导加载程序将运行此应用程序.</li>
<li>在分区表中还定义了两个用于存储 NVS 库分区和 PHY 初始化数据的数据区域.</li>
</ul>
<p>以下是 <code>Factory app, two OTA definitions</code> 的分区表配置信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Espressif ESP32 Partition Table</span><br><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x4000,</span><br><span class="line">otadata,  data, ota,     0xd000,  0x2000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  0,    0,       0x10000, 1M,</span><br><span class="line">ota_0,    0,    ota_0,  0x110000, 1M,</span><br><span class="line">ota_1,    0,    ota_1,  0x210000, 1M,</span><br></pre></td></tr></table></figure>
<ul>
<li>现在有三个应用程序分区定义.</li>
<li>这三种 <code>Type</code> 都设置为 <code>app</code>,但在 0x10000 位置的 <code>factory</code> 应用程序和后面的两个 <code>OTA</code> 应用程序的子类型有所不同.</li>
<li>还有一个新的 <code>ota data</code> 区域,用于保存 OTA 更新的数据. 引导加载程序会查询此数据,以便了解要执行的应用程序. 如果 <code>ota data</code> 为空,它将执行 <code>factory</code> 应用程序.</li>
</ul>
<h2 id="创建自定义分区表"><a href="#创建自定义分区表" class="headerlink" title="创建自定义分区表"></a>创建自定义分区表</h2><p>如果在 menuconfig 中选择 “Custom partition table CSV”,还应该输入要用于分区表的 CSV 文件的名称(在项目目录中). CSV 文件中有将要用于分区表配置的任意数量的定义.</p>
<p>CSV 格式与上面摘要中打印的格式相同. 但是,CSV 中并非所有字段都是必需的. 例如,以下是 OTA 分区表的“输入” CSV:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Custom partition table</span><br><span class="line"># Name,   Type, SubType, Offset, Size, Flags</span><br><span class="line">nvs,      data, nvs,     ,       0x4000,</span><br><span class="line">otadata,  data, ota,     ,       0x2000,</span><br><span class="line">phy_init, data, phy,     ,       0x1000,</span><br><span class="line">factory,  app,  factory, ,       1M,</span><br><span class="line">ota_0,    app,  ota_0,   ,       1M,</span><br><span class="line">ota_1,    app,  ota_1,   ,       1M,</span><br></pre></td></tr></table></figure>
<ul>
<li>字段之间的空格被忽略,任何以＃(注释)开头的行也是如此.</li>
<li>CSV 文件中的每个非注释行都是分区定义.</li>
<li>每个分区的 “Offset” 字段为空. <code>gen_esp32part.py</code> 工具填充每个空白偏移量,从分区表开始并确保每个分区正确对齐.</li>
</ul>
<h3 id="名字字段"><a href="#名字字段" class="headerlink" title="名字字段"></a>名字字段</h3><p>名称字段可以是任何有意义的名称. 这对 ESP32 来说并不重要. 超过 16 个字符的名称将被截取.</p>
<h3 id="类型字段"><a href="#类型字段" class="headerlink" title="类型字段"></a>类型字段</h3><p>分区类型字段可以指定为 app(0) 或 data(1). 或者它可以是数字 0-254(或十六进制 0x00-0xFE). 类型 0x00-0x3F 保留用于 esp-idf 核心功能.</p>
<p>如果您的应用程序需要存储数据,请在 0x40-0xFE 范围内添加自定义分区类型.</p>
<p>引导加载程序忽略 app(0) 和 data(1) 以外的任何分区类型.</p>
<h3 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a>子类型</h3><p>8 位子类型字段特定于给定的分区类型.</p>
<p>esp-idf 当前仅指定 “app” 和 “data” 分区类型的子类型字段的含义.</p>
<h3 id="App-子类型"><a href="#App-子类型" class="headerlink" title="App 子类型"></a>App 子类型</h3><p>当 type 为 “app” 时,子类型字段可以指定为 factory(0),ota_0(0x10)… ota_15(0x1F) 或 test(0x20).</p>
<ul>
<li>factory(0) 是默认的应用程序分区. 引导加载程序将执行工厂应用程序,除非它看到类型为 data/ota 的分区,在这种情况下,它会读取此分区以确定要引导的 OTA 映像.<ul>
<li>OTA 永远不会更新 <code>factory</code> 分区.</li>
<li>如果要保留 OTA 项目中的闪存使用率,可以删除 <code>factory</code> 分区并改为使用 ota_0.</li>
</ul>
</li>
<li>ota_0(0x10)… ota_15(0x1F) 是 OTA app 区域. 有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html" target="_blank" rel="noopener">OTA文档</a>,然后使用 OTA 数据分区配置引导加载程序应引导的应用程序. 如果使用 OTA,则应用程序应至少具有两个 OTA 应用程序槽(<code>ota_0</code>＆<code>ota_1</code>). 有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html" target="_blank" rel="noopener">OTA文档</a>.</li>
<li>test(0x2) 是 <code>factory</code> 测试程序的保留子类型. esp-idf 引导程序当前不支持它.</li>
</ul>
<h3 id="数据子类型"><a href="#数据子类型" class="headerlink" title="数据子类型"></a>数据子类型</h3><p>当 type 为 “data” 时,子类型字段可以指定为 ota(0),phy(1),nvs(2).</p>
<ul>
<li>ota(0) 是<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html#ota-data-partition" target="_blank" rel="noopener">OTA数据分区</a>,它存储有关当前所选 OTA 应用程序的信息.此分区的大小应为 0x2000 字节.有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html#ota-data-partition" target="_blank" rel="noopener">OTA文档</a>.</li>
<li>phy(1) 用于存储 PHY 初始化数据.这允许 PHY 到每个设备被配置,而不是在固件.<ul>
<li>在默认配置中,不使用 phy 分区,并且 PHY 初始化数据被编译到 app 本身.因此,可以从分区表中删除此分区以节省空间.</li>
<li>要从此分区加载 PHY 数据,请运行 <code>make menuconfig</code> 并启用 <code>CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</code> 选项.您还需要使用 <code>phy init</code> 数据刷新(flash)设备,因为 esp-idf 构建系统不会自动执行此操作.</li>
</ul>
</li>
<li>nvs(2) 用于<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/storage/nvs_flash.html" target="_blank" rel="noopener">非易失性存储(NVS)API</a>.<ul>
<li>NVS 用于存储每个设备 PHY 校准数据(与初始化数据不同).</li>
<li>如果使用<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/wifi/esp_wifi.html" target="_blank" rel="noopener">esp_wifi_set_storage(WIFI_STORAGE_FLASH)</a>初始化功能,则 NVS 用于存储 WiFi 数据.</li>
<li>NVS API 还可用于其他应用程序数据.</li>
<li>强烈建议您在项目中包含至少 0x3000 字节的 NVS 分区.</li>
<li>如果使用 NVS API 存储大量数据,请将 NVS 分区默认的 0x6000 字节大小增加.</li>
</ul>
</li>
</ul>
<p>其他数据子类型保留用于将来的 esp-idf 用途.</p>
<h3 id="偏移量-amp-大小"><a href="#偏移量-amp-大小" class="headerlink" title="偏移量 &amp; 大小"></a>偏移量 &amp; 大小</h3><p>具有空白偏移的分区将在前一个分区之后开始,或者第一个分区是在分区表之后开始.</p>
<p>应用程序分区必须处于与 0x10000(64K) 对齐的偏移量. 如果将偏移字段留空,工具将自动对齐分区. 如果为应用程序分区指定未对齐的偏移量,该工具将返回错误.</p>
<p>大小和偏移量可以指定为十进制数,带前缀 0x 的十六进制数,或大小乘数 K 或 M(1024 和 1024 * 1024 字节).</p>
<p>如果希望分区表中的分区与表本身的任何起始偏移量(<code>CONFIG_PARTITION_TABLE_OFFSET</code>)一起使用,请将所有分区的偏移字段(在 CSV 文件中)留空. 类似地,如果更改分区表偏移,则要注意所有空白分区偏移可能会更改为匹配,并且任何固定偏移现在可能与分区表冲突(导致错误).</p>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>目前仅支持一个加密的标志. 如果此字段设置为加密,则在启用 Flash 加密时将对此分区进行加密.</p>
<p>(请注意,无论是否设置此标志,应用程序类型分区都将始终加密.)</p>
<h2 id="生成二进制分区表"><a href="#生成二进制分区表" class="headerlink" title="生成二进制分区表"></a>生成二进制分区表</h2><p>下载到 ESP32 的分区表是二进制格式,而不是 CSV 格式. 工具 <code>partition_table/gen_esp32part.py</code> 用于在 CSV 和二进制格式之间进行转换.</p>
<p>如果在 <code>make menuconfig</code> 中配置分区表 CSV 名称,然后生成 <code>partition_table</code>,则此转换将在构建过程中完成.</p>
<p>要手动将 CSV 转换为二进制:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python gen_esp32part.py input_partitions.csv binary_partitions.bin</span><br></pre></td></tr></table></figure>
<p>要将二进制格式转换回 CSV:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python gen_esp32part.py binary_partitions.bin input_partitions.csv</span><br></pre></td></tr></table></figure>
<p>在 stdout 上显示二进制分区表的内容(这是生成 <code>make partition_table</code> 时显示的摘要的方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python gen_esp32part.py binary_partitions.bin</span><br></pre></td></tr></table></figure>

<h3 id="MD5-校验和"><a href="#MD5-校验和" class="headerlink" title="MD5 校验和"></a>MD5 校验和</h3><p>分区表的二进制格式包含基于分区表计算的 MD5 校验和. 此校验和用于在引导期间检查分区表的完整性.</p>
<p>可以通过 <code>gen_esp32part.py</code> 的 <code>--disable-md5sum</code> 选项或 <code>CONFIG_PARTITION_TABLE_MD5</code> 选项禁用 MD5 校验和生成. 例如,当使用传统引导加载程序无法处理 MD5 校验和且引导失败并且错误消息无效幻数 0xebeb 时,这很有用.</p>
<h2 id="烧录分区表"><a href="#烧录分区表" class="headerlink" title="烧录分区表"></a>烧录分区表</h2><ul>
<li><code>make partition_table-flash</code>:将使用 `esptool.py 下载分区表.</li>
<li><code>make flash</code>:会下载所有固件,包括分区表.</li>
</ul>
<p>手动下载命令也会打印在 <code>make partition_table</code> 中.</p>
<p>请注意,更新分区表不会擦除已根据旧分区表存储的数据. 您可以使用 <code>make erase_flash</code> (或 <code>esptool.py erase_flash</code>)来擦除整个闪存内容.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（九）ESP-IDF FreeRTOS SMP Changes</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B9%9D%EF%BC%89ESP-IDF%20FreeRTOS%20SMP%20Changes/</url>
    <content><![CDATA[<h1 id="ESP-IDF-FreeRTOS-SMP-Changes"><a href="#ESP-IDF-FreeRTOS-SMP-Changes" class="headerlink" title="ESP-IDF FreeRTOS SMP Changes"></a>ESP-IDF FreeRTOS SMP Changes</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>vanilla FreeRTOS 是设计运行在单核上. 但 ESP32 是双核的,包含 Protocol CPU (称为 <strong>CPU 0</strong> 或<strong>PRO_CPU</strong>)和 Application CPU (称为 <strong>CPU 1</strong> 或 <strong>APP_CPU</strong>). 这两个核实际上是相同的,并且共享相同的内存. 这允许任务在两个核之间交替运行.</p>
<p>ESP-IDF FreeRTOS 是 vanilla FreeRTOS 的修改版本,支持对称多处理 (SMP). ESP-IDF FreeRTOS 基于 FreeRTOS v8.2.0 的 Xtensa 端口. 本指南概述了 vanilla FreeRTOS 和 ESP-IDF FreeRTOS 之间的主要区别. 可以通过 <a href="http://www.freertos.org/a00106.html" target="_blank" rel="noopener">http://www.freertos.org/a00106.html</a> 找到 vanilla FreeRTOS 的 API 参考.</p>
<p>有关 ESP-IDF FreeRTOS 独有功能的信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/freertos_additions.html" target="_blank" rel="noopener">ESP-IDF FreeRTOS 附加功能</a>.</p>
<p><a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7">反向移植特性</a>:虽然 ESP-IDF FreeRTOS 基于 FreeRTOS v8.2.0 的 Xtensa 端口,但许多 FreeRTOS v9.0.0 功能已被移植到 ESP-IDF.</p>
<p><a href="#%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA">任务和任务创建</a>:使用 <code>xTaskCreatePinnedToCore()</code> 或 <code>xTaskCreateStaticPinnedToCore()</code> 在 ESP-IDF FreeRTOS 中创建任务.这两个函数的最后一个参数是 xCoreID.此参数指定任务运行在那个核上.  <strong>PRO_CPU</strong> 为 0, <strong>APP_CPU</strong> 为 1,或者 tskNO_AFFINITY 允许任务在两者上运行.</p>
<p>循环调度:ESP-IDF FreeRTOS 调度器将在 Ready 状态下具有相同优先级的多个任务之间实施循环调度时跳过任务.要避免此行为,请确保这些任务进入阻塞状态,或者分布在更广泛的优先级中.</p>
<p>挂起调度器:在 ESP-IDF 中挂起调度器 FreeRTOS 只会影响调用核上的调度器.换句话说,在 <strong>PRO_CPU</strong> 上调用 <code>vTaskSuspendAll()</code> 不会阻止 <strong>APP_CPU</strong> 进行调度,反之亦然.使用临界区或信号量代替同时访问保护.</p>
<p><a href="#%E6%BB%B4%E7%AD%94%E4%B8%AD%E6%96%AD%E5%90%8C%E6%AD%A5">滴答中断同步</a>:<strong>PRO_CPU</strong> 和 <strong>APP_CPU</strong> 的滴答中断不同步. 不要期望使用 <code>vTaskDelay()</code> 或 <code>vTaskDelayUntil()</code> 作为在两个核之间同步任务执行的准确方法. 使用计数信号量,因为它们的上下文切换不会因抢占而与滴答中断相关联.</p>
<p><a href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E7%A6%81%E7%94%A8%E4%B8%AD%E6%96%AD">临界区和禁用中断</a>:在 ESP-IDF FreeRTOS 中,临界区是使用互斥锁实现的.进入临界区涉及获取互斥锁,然后禁用调度器和调用核的中断.然而,另一个核不受影响.如果另一个核尝试使用相同的互斥锁,它将自旋直到调用核通过退出临界区释放互斥锁.</p>
<p><a href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97">浮点运算</a>:ESP32 支持单精度浮点运算 (<code>float</code>) 的硬件加速.然而,硬件加速的使用导致 ESP-IDF FreeRTOS 中的一些行为限制.因此,如果没有这样做,使用 float 的任务将自动固定到核.此外, float 不能用于中断服务程序.</p>
<p><a href="#%E4%BB%BB%E5%8A%A1%E5%88%A0%E9%99%A4">任务删除</a>:任务删除行为已从 FreeRTOS v9.0.0 反向移植并修改为 SMP 兼容.调用 <code>vTaskDelete()</code> 时,将立即释放任务内存,以删除当前未运行且未固定到其他核的任务.否则,释放任务存储器仍将被委托给空闲任务.</p>
<p><a href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%8C%87%E9%92%88%E5%92%8C%E5%88%A0%E9%99%A4%E5%9B%9E%E8%B0%83">线程本地存储指针和删除回调</a>:ESP-IDF FreeRTOS 已经反向移植了线程本地存储指针 (TLSP) 功能.但是,添加了删除回调的额外功能.在删除任务期间会自动调用删除回调,并用于释放 TLSP 指向的内存.调用 <code>vTaskSetThreadLocalStoragePointerAndDelCallback()</code> 来设置 TLSP 和删除回调.</p>
<p><a href="%E9%85%8D%E7%BD%AE-esp-idf-freertos">配置 ESP-IDF FreeRTOS</a>:可以使用 <code>make meunconfig</code> 配置 ESP-IDF FreeRTOS 的几个方面,例如在 Unicore 模式下运行 ESP-IDF,或配置每个任务将具有的线程本地存储指针的数量.</p>
<a id="more"></a>

<h2 id="反向移植特性"><a href="#反向移植特性" class="headerlink" title="反向移植特性"></a>反向移植特性</h2><p>以下功能已从 FreeRTOS v9.0.0 反向移植到 ESP-IDF.</p>
<h3 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h3><p>此特性已从 FreeRTOS v9.0.0 反向移植到 ESP-IDF. 必须在 menuconfig 中启用 <code>CONFIG_SUPPORT_STATIC_ALLOCATION</code> 选项才能使静态分配功能可用. 启用后,可以调用以下函数…</p>
<ul>
<li><code>xTaskCreateStatic()</code> (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li>
<li><code>xQueueCreateStatic</code></li>
<li><code>xSemaphoreCreateBinaryStatic</code></li>
<li><code>xSemaphoreCreateCountingStatic</code></li>
<li><code>xSemaphoreCreateMutexStatic</code></li>
<li><code>xSemaphoreCreateRecursiveMutexStatic</code></li>
<li><code>xTimerCreateStatic()</code> (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li>
<li><code>xEventGroupCreateStatic()</code></li>
</ul>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul>
<li><code>vTaskSetThreadLocalStoragePointer()</code>  (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li>
<li><code>pvTaskGetThreadLocalStoragePointer()</code>  (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li>
<li><code>vTimerSetTimerID()</code></li>
<li><code>xTimerGetPeriod()</code></li>
<li><code>xTimerGetExpiryTime()</code></li>
<li><code>pcQueueGetName()</code></li>
<li><code>uxSemaphoreGetCount</code></li>
</ul>
<h3 id="反向移植记录"><a href="#反向移植记录" class="headerlink" title="反向移植记录"></a>反向移植记录</h3><ol>
<li><code>xTaskCreateStatic()</code> 以与 <code>xTaskCreate()</code> 类似的方式与 SMP 兼容(请参阅<a href="#%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA">任务和任务创建</a>). 因此也可以调用 <code>xTaskCreateStaticPinnedToCore()</code>.</li>
<li>尽管 vanilla FreeRTOS 允许静态分配 Timer 功能的守护进程任务,但守护进程任务总是在 ESP-IDF 中动态分配. 因此,在 ESP-IDF FreeRTOS 中使用静态分配的计时器时,不需要定义 <code>vApplicationGetTimerTaskMemory</code>.</li>
<li>在 ESP-IDF FreeRTOS 中修改了线程本地存储指针功能,以包括删除回调(请参阅<a href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%8C%87%E9%92%88%E5%92%8C%E5%88%A0%E9%99%A4%E5%9B%9E%E8%B0%83">线程本地存储指针和删除回调</a>). 因此,也可以调用函数 <code>vTaskSetThreadLocalStoragePointerAndDelCallback()</code>.</li>
</ol>
<h2 id="任务和任务创建"><a href="#任务和任务创建" class="headerlink" title="任务和任务创建"></a>任务和任务创建</h2><p>ESP-IDF FreeRTOS 中的任务设计为在特定核上运行,因此通过将 <code>PinnedToCore</code> 附加到 vanilla FreeRTOS 中的任务创建功能的名称,ESP-IDF FreeRTOS 中添加了两个新的任务创建功能. <code>xTaskCreate()</code> 和 <code>xTaskCreateStatic()</code> 的 vanilla FreeRTOS 函数导致在 ESP-IDF FreeRTOS 中添加了 <code>xTaskCreatePinnedToCore()</code> 和 <code>xTaskCreateStaticPinnedToCore()</code> (参见<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7">反向移植特性</a>).</p>
<p>有关更多详细信息,请参阅 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/freertos/task.c" target="_blank" rel="noopener">freertos/task.c</a></p>
<p>除了称为 <code>xCoreID</code> 的额外参数外,ESP-IDF FreeRTOS 任务创建功能几乎与它们的vanilla对应物相同. 此参数指定应在其上运行任务的核,并且可以是以下值之一.</p>
<ul>
<li><code>0</code> 将任务固定在 <strong>PRO_CPU</strong> 上运行</li>
<li><code>1</code> 将任务固定在 <strong>APP_CPU</strong> 上运行</li>
<li><code>tskNO_AFFINITY</code>允许在两个 CPU 上运行任务</li>
</ul>
<p>例如,<code>xTaskCreatePinnedToCore(tsk_callback,“APP_CPU Task”,1000,NULL,10,NULL,1)</code> 创建优先级为 10 的任务,该堆栈大小为 1000 字节运行在 <strong>APP_CPU</strong> 上. 应该注意的是,vanilla FreeRTOS 中的 <code>uxStackDepth</code> 参数根据字数指定任务的堆栈深度,而 ESP-IDF FreeRTOS 以字节的形式指定堆栈深度.</p>
<p>请注意,vanilla FreeRTOS函数 <code>xTaskCreate()</code> 和 <code>xTaskCreateStatic()</code> 已在 ESP-IDF FreeRTOS 中定义为内联函数,它们分别使用 tskNO_AFFINITY 作为 xCoreID 值调用 <code>xTaskCreatePinnedToCore()</code> 和 <code>xTaskCreateStaticPinnedToCore()</code>.</p>
<p>ESP-IDF 中的每个任务控制块 (TCB) 将 <code>xCoreID</code> 存储为成员. 因此,当每个核调用调度器选择要运行的任务时,<code>xCoreID</code> 成员将允许调度器确定是否允许让任务在调用调度器的核上运行.</p>
<h2 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h2><p>vanilla FreeRTOS 在 <code>vTaskSwitchContext()</code> 函数中实现调度. 此函数负责从处于就绪状态的任务列表中选择要执行的最高优先级任务,称为就绪任务列表(将在下一节中介绍). 在 ESP-IDF FreeRTOS 中,每个核将独立调用 <code>vTaskSwitchContext()</code>以从两个核之间共享的就绪任务列表中选择要运行的任务. vanilla 和 ESP-IDF FreeRTOS 之间的调度行为存在一些差异,例如 循环调度调度,调度程序暂停和滴答中断同步的差异.</p>
<h3 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h3><p>鉴于 Ready 状态和优先级相同的多个任务,vanilla FreeRTOS 在每个任务之间实现循环调度. 这将导致每次调用调度程序时轮流运行这些任务(例如每个滴答中断). 另一方面,当循环调度具有相同优先级的多个 Ready 状态任务时,ESP-IDF FreeRTOS 调度器可以跳过任务.</p>
<p>循环调度期间跳过任务的问题源于在 FreeRTOS 中实现就绪任务列表的方式. 在 vanilla FreeRTOS 中,<code>pxReadyTasksList</code> 用于存储处于 Ready 状态的任务列表. 该列表实现为长度为 <code>configMAX_PRIORITIES</code> 的数组,其中数组的每个元素都是链表. 每个链表都是 <code>List_t</code> 类型,并包含处于 Ready 状态的相同优先级任务的 TCB. 下图说明了 <code>pxReadyTasksList</code> 结构.</p>
<p><img src="https://img-blog.csdn.net/20180902140458206?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="pxReadyTasksList"><br> <center> Illustration of FreeRTOS Ready Task List Data Structure</center></p>
<p>每个链表还包含一个 <code>pxIndex</code>,它指向查询列表时返回的最后一个 TCB. 该索引允许 <code>vTaskSwitchContext()</code> 在 <code>pxIndex</code> 之后立即开始遍历 TCB 上的列表,从而在相同优先级的任务之间实现循环调度.</p>
<p>在 ESP-IDF FreeRTOS 中,就绪任务列表在核之间共享,因此 <code>pxReadyTasksList</code> 将包含固定到不同核的任务. 当核调用调度程序时,它能够查看列表中每个 TCB 的 <code>xCoreID</code> 成员,以确定是否允许在调用调度程序的核上运行该任务. ESP-IDF FreeRTOS <code>pxReadyTasksList</code> 如下图所示.</p>
<p><img src="https://img-blog.csdn.net/20180902140927284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Illustration of FreeRTOS Ready Task List Data Structure in ESP-IDF"><br> <center> Illustration of FreeRTOS Ready Task List Data Structure in ESP-IDF </center> </p>
<p>因此,当 <strong>PRO_CPU</strong> 调用调度程序时,它只会将任务视为蓝色或紫色. 而当 <strong>APP_CPU</strong> 调用调度程序时,它只会考虑橙色或紫色的任务.</p>
<p>虽然每个 TCB 在 ESP-IDF FreeRTOS 中都有一个 <code>xCoreID</code>,但每个优先级的链表只有一个 <code>pxIndex</code>. 因此,当从特定核调用调度程序并遍历链接列表时,它将跳过固定到另一个核的所有 TCB,并将 <code>pxIndex</code> 指向所选任务. 如果另一个核接着调用调度程序,它将在 <code>pxIndex</code> 之后立即遍历从 TCB 开始的链表. 因此,<strong>在当前调度程序调用中不会考虑从由其他核先前调用调度程序跳过的 TCB</strong>. 下图说明了此问题.</p>
<p><img src="https://img-blog.csdn.net/20180902141125129?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Illustration of pxIndex behavior in ESP-IDF FreeRTOS"><br> <center>Illustration of pxIndex behavior in ESP-IDF FreeRTOS </center></p>
<p>参考上面的图示,假设优先级 9 是最高优先级,并且优先级9中的任何任务都不会被阻塞,因此将始终处于运行或就绪状态.</p>
<ol>
<li><strong>PRO_CPU</strong> 调用调度程序并选择要运行的任务 A,因此将 <code>pxIndex</code> 移动到指向任务 A.</li>
<li><strong>APP_CPU</strong> 调用调度程序并在作为任务 B 的 <code>pxIndex</code> 之后开始遍历任务.但是没有选择任务 B 运行,因为它没有固定到 <strong>APP_CPU</strong> 因此它被跳过并且选择了任务 C.  <code>pxIndex</code> 现在指向任务 C.</li>
<li><strong>PRO_CPU</strong> 调用调度程序并开始从任务 D 开始遍历.它跳过任务 D 并选择任务 E 运行并将 <code>pxIndex</code> 指向任务 E.请注意,任务 B 未被遍历,因为最后一次 <strong>APP_CPU</strong> 调用调度程序时它被跳过遍历清单.</li>
<li>如果 <strong>APP_CPU</strong> 再次调用调度程序,则会发生与任务 D 相同的情况,因为 <code>pxIndex</code> 现在指向任务E</li>
</ol>
<p>任务跳过问题的一个解决方案是确保每个任务都进入阻塞状态,以便从就绪任务列表中删除它们.另一种解决方案是跨多个优先级分配任务,以便不给予给定优先级多个固定到不同核的任务.</p>
<h3 id="挂起调度器"><a href="#挂起调度器" class="headerlink" title="挂起调度器"></a>挂起调度器</h3><p>在 vanilla FreeRTOS 中,通过 <code>vTaskSuspendAll()</code> 挂起调度程序将阻止 <code>vTaskSwitchContext</code> 从上下文切换调用,直到调度程序已使用 <code>xTaskResumeAll()</code> 恢复.但是仍然允许为 ISR 提供服务.因此,在恢复调度程序之前,将不会执行由当前正在运行的任务或 ISRS 导致的任务状态的任何更改. vanilla FreeRTOS 中的调度程序暂停是一种常见的保护方法,可以同时访问任务之间共享的数据,同时仍允许对 ISR 进行服务.</p>
<p>在 ESP-IDF FreeRTOS 中,<code>xTaskResumeAll()</code> 只会阻止调用 <code>vTaskSwitchContext()</code> 来切换调用挂起的核上下文.因此,如果 <strong>PRO_CPU</strong> 调用 <code>vTaskSuspendAll()</code>, <strong>APP_CPU</strong> 仍然可以切换上下文.如果数据在固定到不同核的任务之间共享,则调度程序暂停不是防止同时访问的有效方法.在保护 ESP-IDF FreeRTOS 中的共享资源时,请考虑使用关键部分(禁用中断)或信号量(不禁用中断).</p>
<p>通常,最好使用其他 RTOS 原语(如互斥信号量)来防止任务之间共享的数据,而不是 <code>vTaskSuspendAll()</code>.</p>
<h3 id="滴答中断同步"><a href="#滴答中断同步" class="headerlink" title="滴答中断同步"></a>滴答中断同步</h3><p>在 ESP-IDF FreeRTOS 中,由于来自每个核的调度程序调用是独立的,因此在相同的滴答计数上取消阻塞的不同核上的任务可能不会在完全相同的时间运行,并且每个核的滴答中断是不同步的.</p>
<p>在 vanilla FreeRTOS 中,滴答中断触发对 <code>xTaskIncrementTick()</code> 的调用,该调用负责增加滴答计数器,检查调用 <code>vTaskDelay()</code> 的任务是否已经完成延迟时间,并将这些任务从 Delayed Task List 移动​​到 Ready Task 名单.如果需要上下文切换,则滴答中断将调用调度程序.</p>
<p>在 ESP-IDF FreeRTOS 中,由于 <strong>PRO_CPU</strong> 负责增加共享滴答计数,因此参考 <strong>PRO_CPU</strong> 上的滴答中断来解除延迟任务的阻塞.但是,每个核的滴答中断可能不会同步(频率相同但异相),因此当 <strong>PRO_CPU</strong> 收到滴答中断时, <strong>APP_CPU</strong> 可能尚未收到它.因此,如果相同优先级的多个任务在相同的滴答计数上被解除阻塞,则固定到 <strong>PRO_CPU</strong> 的任务将立即运行,而固定到 <strong>APP_CPU</strong> 的任务必须等到 <strong>APP_CPU</strong> 收到其不同步滴答中断.收到滴答中断后, <strong>APP_CPU</strong> 将调用上下文切换,最后将上下文切换到新解锁的任务.</p>
<p>因此,不应将任务延迟用作 ESP-IDF FreeRTOS 中任务之间的同步方法.相反,请考虑使用计数信号量同时取消阻止多个任务.</p>
<h2 id="临界区和禁用中断"><a href="#临界区和禁用中断" class="headerlink" title="临界区和禁用中断"></a>临界区和禁用中断</h2><p>Vanilla FreeRTOS 在 <code>vTaskEnterCritical</code> 中实现了关键部分,它们禁用调度程序并调用 <code>portDISABLE_INTERRUPTS</code>.这可以防止在关键部分中进行上下文切换和ISR服务.因此,关键部分被用作防止 vanilla FreeRTOS 同时访问的有效保护方法.</p>
<p>另一方面, ESP32 没有内核的硬件方法来禁用彼此的中断.调用 <code>portDISABLE_INTERRUPTS()</code> 对其他内核的中断没有影响.因此,禁用中断不是防止同时访问共享数据的有效保护方法,因为即使当前内核已禁用其自身的中断,它也会使其他内核可以自由访问数据.</p>
<p>因此, ESP-IDF FreeRTOS 使用互斥锁实现关键部分,进入或退出关键部分的调用必须提供与需要访问保护的共享资源相关联的互斥锁.当进入 ESP-IDF FreeRTOS 中的关键部分时,调用内核将禁用其调度程序和中断,类似于 vanilla FreeRTOS 实现.但是,调用核也将使用互斥锁,而另一个核在关键部分不受影响.如果另一个核尝试使用相同的互斥锁,它将旋转直到释放互斥锁.因此,关键部分的 ESP-IDF FreeRTOS 实现允许核具有对共享资源的受保护访问,而不会禁用其他核.另一个核只有在尝试同时访问同一资源时才会受到影响.</p>
<p>ESP-IDF FreeRTOS 关键部分功能已经修改如下……</p>
<ul>
<li><code>taskENTER_CRITICAL(mux)</code>,<code>taskENTER_CRITICAL_ISR(mux)</code>,<code>portENTER_CRITICAL(mux)</code>,<code>portENTER_CRITICAL_ISR(mux)</code> 都是宏定义来调用 <code>vTaskEnterCritical()</code></li>
<li><code>taskEXIT_CRITICAL(mux)</code>,<code>taskEXIT_CRITICAL_ISR(mux)</code>,<code>portEXIT_CRITICAL(mux)</code>,<code>portEXIT_CRITICAL_ISR(mux)</code> 都是宏定义来调用 <code>vTaskExitCritical()</code></li>
</ul>
<p>有关更多详细信息,请参阅 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/freertos/include/freertos/portmacro.h" target="_blank" rel="noopener">freertos/include/freertos/portmacro.h</a> 和 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/freertos/task.c" target="_blank" rel="noopener">freertos/task.c</a></p>
<p>应该注意的是,当修改 vanilla FreeRTOS 代码与 ESP-IDF FreeRTOS 兼容时,修改关键部分的类型是微不足道的,因为它们都被定义为调用相同的函数.只要在进入和退出时提供相同的互斥锁,呼叫类型就无关紧要了.</p>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><p>ESP32 通过连接到每个内核的浮点单元 (FPU,也称为协处理器)支持单精度浮点运算 (<code>float</code>) 的硬件加速.使用 FPU 对 ESP-IDF FreeRTOS 施加了一些行为限制.</p>
<p>ESP-IDF FreeRTOS 为 FPU 实现了延迟上下文切换.换句话说,当发生上下文切换时,不会立即保存核心 FPU 寄存器的状态.因此,利用 <code>float</code> 的任务必须在创建时固定到特定的核心.如果没有, ESP-IDF FreeRTOS 会自动将有问题的任务固定到任务首次使用 <code>float</code> 任务的任何核心上.同样由于惰性上下文切换,中断服务例程也必须不使用 <code>float</code>.</p>
<p>ESP32 不支持双精度浮点运算 (<code>double</code>) 的硬件加速.相反, <code>double</code> 是通过软件实现的,因此关于 <code>float</code> 的行为限制不适用于 <code>double</code>.请注意,由于缺少硬件加速,与 <code>float</code> 相比,双重操作可能会消耗更多的 CPU 时间.</p>
<h2 id="任务删除"><a href="#任务删除" class="headerlink" title="任务删除"></a>任务删除</h2><p>在 v9.0.0 之前删除 FreeRTOS 任务将任务内存的释放完全委托给空闲任务. 目前,如果正在删除的任务当前没有运行或没有固定到另一个核心(相对于核心 <code>vTaskDelete()</code> 被调用),任务内存的释放将立即发生(在 <code>vTaskDelete()</code> 内). 如果满足相同的条件,TLSP删除回调也将立即运行.</p>
<p>但是,调用 <code>vTaskDelete()</code> 来删除当前正在运行或固定到另一个核心的任务仍将导致释放被委派给空闲任务的内存.</p>
<h2 id="线程本地存储指针和删除回调"><a href="#线程本地存储指针和删除回调" class="headerlink" title="线程本地存储指针和删除回调"></a>线程本地存储指针和删除回调</h2><p>线程本地存储指针 (TLSP) 是直接存储在 TCB 中的指针. TLSP 允许每个任务拥有自己唯一的数据结构指针集.但是, vanilla FreeRTOS 中的任务删除行为不会自动释放 TLSP 指向的内存.因此,如果在删除任务之前用户未明确释放 TLSP 指向的内存,则会发生内存泄漏.</p>
<p>ESP-IDF FreeRTOS 提供了 Deletion Callbacks 的附加功能.删除任务删除期间自动调用回调以释放 TLSP 指向的内存.每个 TLSP 都可以拥有自己的 Deletion Callback.请注意,由于 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/freertos-smp.html#task-deletion" target="_blank" rel="noopener">Task Deletion</a> 行为,可能存在在空闲任务的上下文中调用 Deletion Callbacks 的实例.因此,删除回调不应该试图阻止,并且关键部分应该尽可能短,以最小化优先级倒置.</p>
<p>删除回调的类型为 <code>void(* TlsDeleteCallbackFunction_t)(int,void *)</code>,其中第一个参数是关联 TLSP 的索引号,第二个参数是 TLSP 本身.</p>
<p>通过调用 <code>vTaskSetThreadLocalStoragePointerAndDelCallback()</code> 将删除回调与 TLSP 一起设置.调用 vanilla FreeRTOS 函数 <code>vTaskSetThreadLocalStoragePointer()</code> 只会将 TLSP 关联的 Deletion Callback 设置为 NULL,这意味着在删除任务期间不会为该 TLSP 调用回调.如果删除回调为 NULL,则用户应在删除任务之前手动释放相关 TLSP 指向的内存,以避免内存泄漏.</p>
<p>menuconfig 中的 <code>CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS</code> 可用于配置TCB将具有的 TLSP 和删除回调数.</p>
<p>有关更多详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/freertos.html" target="_blank" rel="noopener">FreeRTOS API 参考</a>.</p>
<h2 id="配置-ESP-IDF-FreeRTOS"><a href="#配置-ESP-IDF-FreeRTOS" class="headerlink" title="配置 ESP-IDF FreeRTOS"></a>配置 ESP-IDF FreeRTOS</h2><p>可以使用 <code>Component_Config/FreeRTOS</code> 下的 <code>make menuconfig</code> 配置 ESP-IDF FreeRTOS. 以下部分重点介绍了一些 ESP-IDF FreeRTOS 配置选项.有关 ESP-IDF FreeRTOS 配置的完整列表,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/kconfig.html" target="_blank" rel="noopener">FreeRTOS</a></p>
<p><code>CONFIG_FREERTOS_UNICORE</code> 将仅在 <strong>PRO_CPU</strong> 上运行 ESP-IDF FreeRTOS.请注意,这不等于运行 vanilla FreeRTOS.将修改 ESP-IDF 中多个组件的行为,例如 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/esp32/cpu_start.c" target="_blank" rel="noopener">esp32/cpu_start.c</a>.有关在单核上运行 ESP-IDF FreeRTOS 的效果的更多详细信息,请在 ESP-IDF 组件中搜索 <code>CONFIG_FREERTOS_UNICORE</code> 的出现.</p>
<p><code>CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS</code> 将定义每个任务在 ESP-IDF FreeRTOS 中将具有的线程本地存储指针的数量.</p>
<p><code>CONFIG_SUPPORT_STATIC_ALLOCATION</code> 将在 ESP-IDF FreeRTOS 中启用 <code>xTaskCreateStaticPinnedToCore()</code> 的反向移植功能</p>
<p><code>CONFIG_FREERTOS_ASSERT_ON_UNTESTED_FUNCTION</code> 将触发 ESP-IDF FreeRTOS 中特定功能的暂停,这些功能尚未在 SMP 上下文中进行全面测试.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/freertos-smp.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（二）构建系统</title>
    <url>/InfiniteYuanBlog/2018/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h1><p>本文档解释了 Espressif 物联网开发框架构建系统和“组件”的概念.</p>
<p>如果您想知道如何组织新的 <code>ESP-IDF</code> 项目,请阅读本文档.</p>
<p>我们建议使用 <a href="https://github.com/espressif/esp-idf-template" target="_blank" rel="noopener">esp-idf-template</a> 项目作为项目的起点.</p>
<a id="more"></a>

<h2 id="使用构建系统"><a href="#使用构建系统" class="headerlink" title="使用构建系统"></a>使用构建系统</h2><p>esp-idf 中的 <code>README</code> 文件有如何使用构建系统构建项目的说明.</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>一个 <code>ESP-IDF</code> 项目可以看作是多个组件的组合.例如,对于显示当前湿度的网络服务器,可能有:</p>
<ul>
<li>ESP32 基础库( libc,rom bindings 等)</li>
<li>WiFi 驱动</li>
<li>TCP / IP 协议堆栈</li>
<li>FreeRTOS 操作系统</li>
<li>Web 服务器</li>
<li>湿度传感器驱动</li>
<li>主程序</li>
</ul>
<p><code>ESP-IDF</code> 使这些组件结构更清晰并具有可配置性.为此,在编译项目时,构建环境将查找 <code>ESP-IDF</code> 目录、项目目录和(可选)其他自定义组件目录中的所有组件.之后,它允许用户使用基于文本的菜单系统去自定义每个组件来配置 <code>ESP-IDF</code> 项目.在配置完项目中的组件之后,构建程序将编译项目.</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>“项目”是一个目录,其中包含构建单个 “app” (可执行文件)所需的文件和配置,以及其他附加文件,如:分区表,数据/文件系统分区和引导程序.</li>
<li>“项目配置”保存在项目根目录中的 <code>sdkconfig</code>  文件中.通过 <code>make menuconfig</code> 修改此文件以自定义项目配置.单个项目只包含一个项目配置.</li>
<li>“app” 是由 esp-idf 构建的可执行文件.单个项目通常会构建两个应用程序 - 一个“项目应用程序”(主要可执行文件,即您的自定义固件)和一个“引导程序”(启动项目应用程序的初始引导程序).</li>
<li>“组件”是独立代码的模块化部分,它们被编译成静态库(.a文件)并链接到应用程序.有些是由 esp-idf 本身提供的,有些则可能来自其他地方.</li>
</ul>
<p>有些东西不是项目的一部分:</p>
<ul>
<li>“ESP-IDF” 不是该项目的一部分.相反,它是独立的,并通过 <code>IDF_PATH</code> 环境变量链接到项目,该变量保存 <code>esp-idf</code> 目录的路径.这允许 IDF 框架与您的项目分离.</li>
<li>用于编译的工具链不是项目的一部分.工具链应安装在系统命令行 <code>PATH</code> 中,或者工具链的路径设置为项目配置中编译器前缀的一部分.</li>
</ul>
<h3 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h3><p>一个示例项目目录结构可能如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- myProject&#x2F;</span><br><span class="line">            - Makefile</span><br><span class="line">            - sdkconfig</span><br><span class="line">            - components&#x2F; - component1&#x2F; - component.mk</span><br><span class="line">                                        - Kconfig</span><br><span class="line">                                        - src1.c</span><br><span class="line">                          - component2&#x2F; - component.mk</span><br><span class="line">                                        - Kconfig</span><br><span class="line">                                        - src1.c</span><br><span class="line">                                        - include&#x2F; - component2.h</span><br><span class="line">            - main&#x2F;       - src1.c</span><br><span class="line">                          - src2.c</span><br><span class="line">                          - component.mk</span><br><span class="line"></span><br><span class="line">            - build&#x2F;</span><br></pre></td></tr></table></figure>
<p>“myProject” 示例包含以下元素:</p>
<ul>
<li>顶层项目 Makefile .此 Makefile 设置 <code>PROJECT_NAME</code> 变量,并(可选)定义项目范围的 make 变量.它包括核心的 <code>$(IDF_PATH)/make/project.mk</code> Makefile 文件,它实现了 <code>ESP-IDF</code> 构建系统的其余部分.</li>
<li>“sdkconfig” 项目配置文件.当 “make menuconfig” 运行时,将创建/更新此文件,并保存项目中所有组件的配置(包括 esp-idf 本身).“sdkconfig” 文件可能会也可能不会添加到项目的源代码管理系统中.</li>
<li>可选的 “components” 目录包含属于项目一部分的组件.项目不必包含此类自定义组件,但它可用于构造可重用代码或包括不属于 ESP-IDF 的第三方组件.</li>
<li>“main” 目录是一个特殊的“伪组件(pseudo-component)”,它包含项目本身的源代码.“main” 是默认名称,Makefile 变量<code>COMPONENT_DIRS</code>包含此组件,但您可以修改此变量(或设置 <code>EXTRA_COMPONENT_DIRS</code>)以查找其他位置的组件.</li>
<li>“build” 目录是项目编译时创建的,包含项目编译时产生的文件.运行 make 后,该目录被创建,并包含临时目标文件和库以及最终的二进制输出文件 <code>bin</code>.此目录通常不会添加到源代码管理中,也不会随项目源代码一起发布.</li>
</ul>
<p>组件目录包含一个组件 makefile 文件 - <code>component.mk</code>.这可能包含变量定义,以控制组件的构建过程,以及它与整个项目的集成.有关更多详细信息,请参阅[组件Makefile](#组件 Makefile).</p>
<p>每个组件还可以包括一个 <code>Kconfig</code> 文件,用于定义通过项目配置设置的组件配置选项.某些组件还可能包含 <code>Kconfig.projbuild</code> 和 <code>Makefile.projbuild</code> 文件,这些文件是用于覆盖项目部分的特殊文件.</p>
<h3 id="项目-Makefile"><a href="#项目-Makefile" class="headerlink" title="项目 Makefile"></a>项目 Makefile</h3><p>每个项目都有一个 Makefile,其中包含整个项目的构建配置.默认情况下,项目 Makefile 可以非常小.</p>
<h4 id="最小示例-Makefile"><a href="#最小示例-Makefile" class="headerlink" title="最小示例 Makefile"></a>最小示例 Makefile</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROJECT_NAME :&#x3D; myProject</span><br><span class="line"></span><br><span class="line">include $(IDF_PATH)&#x2F;make&#x2F;project.mk</span><br></pre></td></tr></table></figure>

<h4 id="强制项目变量"><a href="#强制项目变量" class="headerlink" title="强制项目变量"></a>强制项目变量</h4><ul>
<li>PROJECT_NAME:项目名称.二进制输出文件将使用此名称 - 即 myProject.bin, myProject.elf.</li>
</ul>
<h4 id="可选项目变量"><a href="#可选项目变量" class="headerlink" title="可选项目变量"></a>可选项目变量</h4><p>这些变量都有默认值,并可以被自定义操作覆盖.查看 <code>make/project.mk</code> 以获取所有实现细节.</p>
<ul>
<li><code>PROJECT_PATH</code>:顶级项目目录.默认为包含 Makefile 的目录.许多其他项目变量都基于此变量.项目路径不能包含空格.</li>
<li><code>BUILD_DIR_BASE</code>:所有 objects/libraries/binaries 文件的构建输出目录.默认为<code>$(PROJECT_PATH)/build</code>.</li>
<li><code>COMPONENT_DIRS</code>:搜索组件的目录.默认为<code>$(IDF_PATH)/components</code>( idf 组件),<code>$(PROJECT_PATH)/components</code>(项目组件),<code>$(PROJECT_PATH)/main</code> 和 <code>EXTRA_COMPONENT_DIRS</code> (其他组件).如果您不想在这些位置搜索组件,请覆盖此变量.</li>
<li><code>EXTRA_COMPONENT_DIRS</code>:用于搜索组件的其他目录的可选列表.</li>
<li><code>COMPONENTS</code>:要构建到项目中的组件名称列表.默认为<code>COMPONENT_DIRS</code>目录中的所有组件.</li>
<li><code>EXCLUDE_COMPONENTS</code>:在构建过程中要排除的组件名称的可选列表.请注意,这会减少构建时间,但不会减少二进制大小.</li>
<li><code>TEST_EXCLUDE_COMPONENTS</code>:在单元测试的构建过程中要排除的可选组件名称列表.</li>
</ul>
<p>这些 Makefile 变量中的任何路径都应该是绝对路径.您可以使用<code>$(PROJECT_PATH)/ xxx</code>,<code>$(IDF_PATH)/ xxx</code>转换相对路径,或使用 Make 函数<code>$(abspath xxx)</code>.</p>
<p>这些都变量应该在 Makefile 中的 <code>include $(IDF_PATH)/make/project.mk</code> 行之前设置.</p>
<h3 id="组件-Makefile"><a href="#组件-Makefile" class="headerlink" title="组件 Makefile"></a>组件 Makefile</h3><p>每个项目都包含一个或多个组件,这些组件可以是 esp-idf 的一部分,也可以从其他组件目录添加.</p>
<p>组件是包含 <code>component.mk</code> 文件的任何目录.</p>
<h3 id="搜索组件"><a href="#搜索组件" class="headerlink" title="搜索组件"></a>搜索组件</h3><p>在<code>COMPONENT_DIRS</code>中的目录列表中搜索项目的组件.此列表中的目录可以是组件本身(即它们包含 <code>component.mk</code> 文件),也可以是子目录为组件的顶级目录(包含组件的目录).</p>
<p>运行 <code>make list-components</code> 后,会输出这些变量,这可以帮助调试组件目录是否被找到.</p>
<h4 id="具有相同名称的多个组件"><a href="#具有相同名称的多个组件" class="headerlink" title="具有相同名称的多个组件"></a>具有相同名称的多个组件</h4><p>当 esp-idf 找到所有要编译的组件时,它将按照 <code>COMPONENT_DIRS</code> 指定的顺序执行此操作; 默认情况下,首先是 idf 组件,第二个是项目组件,最后是 <code>EXTRA_COMPONENT_DIRS</code> 中的组件.如果这些目录中的两个或多个包含具有相同名称的组件子目录,则使用搜索的最后一个位置中的组件.例如,这允许通过简单地将组件从 esp-idf 组件目录复制到项目组件树然后在那里修改它来覆盖具有修改版本的 esp-idf 组件.如果以这种方式使用,esp-idf 目录本身可以保持不变.</p>
<h4 id="最小组件-Makefile"><a href="#最小组件-Makefile" class="headerlink" title="最小组件 Makefile"></a>最小组件 Makefile</h4><p>最小的 <code>component.mk</code> 文件是一个空文件.如果文件为空,则设置默认组件行为:</p>
<ul>
<li>与 makefile 在相同的目录中的所有源文件(<code>*.c</code>,<code>*.cpp</code>,<code>*.cc</code>,<code>*.S</code>)将被编译到组件库中</li>
<li>子目录 “include” 将被添加到所有其他组件的全局 include 搜索路径中.</li>
<li>组件库将链接到项目应用程序中.</li>
</ul>
<p>有关更完整的示例组件 makefile,请参阅[示例组件 makefile](#示例组件 Makefile).</p>
<p>请注意,空的 <code>component.mk</code> 文件(调用默认组件构建行为)和没有 <code>component.mk</code> 文件(这意味着不会发生默认组件构建行为)之间存在差异.组件可能没有 <code>component.mk</code> 文件,如果它只包含影响项目配置或构建过程的其他文件.</p>
<h4 id="预设组件变量"><a href="#预设组件变量" class="headerlink" title="预设组件变量"></a>预设组件变量</h4><p>以下特定组件的变量可在<code>component.mk</code>中使用,但不应修改:</p>
<ul>
<li><code>COMPONENT_PATH</code>:组件目录.计算包含 <code>component.mk</code> 的目录的绝对路径.组件路径不能包含空格.</li>
<li><code>COMPONENT_NAME</code>:组件的名称.默认为组件目录的名称.</li>
<li><code>COMPONENT_BUILD_DIR</code>:组件构建目录.计算 <code>$(BUILD_DIR_BASE)</code> 中要构建此组件源文件的目录的绝对路径.每次构建组件时,这也是当前工作目录,因此 make 等目标中的相对路径都是相对于此目录.</li>
<li><code>COMPONENT_LIBRARY</code>:将为此组件构建的静态库文件的名称(相对于组件构建目录).默认为 <code>$(COMPONENT_NAME).a</code>.</li>
</ul>
<p>以下变量在项目级别设置,但会导出在组件构建中使用:</p>
<ul>
<li><code>PROJECT_NAME</code>:项目名称,在项目 Makefile 中设置</li>
<li><code>PROJECT_PATH</code>:包含项目 Makefile 的项目目录的绝对路径.</li>
<li><code>COMPONENTS</code>:此构建中包含的所有组件的名称.</li>
<li><code>CONFIG_ *</code>:项目配置中的每个值都有一个 make 中可用的对应变量.所有名称都以 <code>CONFIG_</code> 开头.</li>
<li><code>CC</code>,<code>LD</code>,<code>AR</code>,<code>OBJCOPY</code>:gcc xtensa 交叉工具链中每个工具的完整路径.</li>
<li><code>HOSTCC</code>,<code>HOSTLD</code>,<code>HOSTAR</code>:来自主机本机工具链的每个工具的全名.</li>
<li><code>IDF_VER</code>:ESP-IDF 版本,使用 git 命令 <code>git describe</code> 从 <code>$(IDF_PATH)/version.txt</code> 文件(如果存在)中检索.这里推荐的格式是单独的一行指定主要 IDF 发布版本,例如标记版本的 <code>v2.0</code> 或任意提交的 <code>v2.0-275-g0efaa4f</code>.应用程序可以通过调用 <code>esp_get_idf_version()</code> 来使用它.</li>
<li><code>PROJECT_VER</code>: 项目版本<ul>
<li>如果 <code>PROJECT_VER</code> 变量在项目 Makefile 文件中设置，则将使用其值。</li>
<li>否则，如果 <code>$PROJECT_PATH/version.txt</code> 存在，其内容将用作 <code>PROJECT_VER</code>。</li>
<li>否则，如果项目位于 Git 存储库中，则将使用git describe的输出。</li>
<li>否则，<code>PROJECT_VER</code> 将为“1”。</li>
</ul>
</li>
</ul>
<p>如果您修改 <code>component.mk</code> 中的任何这些变量,那么这不会阻止构建其他组件,但它可能使您的组件难以构建或者调试.</p>
<h4 id="可选项目范围的组件变量"><a href="#可选项目范围的组件变量" class="headerlink" title="可选项目范围的组件变量"></a>可选项目范围的组件变量</h4><p>可以在 <code>component.mk</code> 中设置以下变量来控制整个项目中的构建设置:</p>
<ul>
<li><code>COMPONENT_ADD_INCLUDEDIRS</code>:相对于组件目录的路径,将添加到项目中所有组件的 “include” 搜索路径.如果未被覆盖,则默认<code>include</code>.如果仅需要编译此特定组件的 “include” 目录,请将其添加到 <code>COMPONENT_PRIV_INCLUDEDIRS</code></li>
<li><code>COMPONENT_ADD_LDFLAGS</code>:为 LDFLAGS 添加链接器参数以用于应用程序可执行文件.默认为 <code>-l$(COMPONENT_NAME)</code>.如果将预编译库添加到此目录,请将它们添加为绝对路径 <code>-e$(COMPONENT_PATH)/libwhatever.a</code></li>
<li><code>COMPONENT_DEPENDS</code>:应在此组件之前编译的组件名称的可选列表.对于链接时依赖性,这不是必需的,因为所有组件”include”目录始终可用.如果一个组件生成一个”include”文件,然后您想要包含在另一个组件中,则这是必要的.大多数组件不需要设置此变量.</li>
<li><code>COMPONENT_ADD_LINKER_DEPS</code>:相对组件路径的文件的可选列表，如果它们发生更改，应触发 ELF 文件的重新链接。 通常用于链接描述文件和二进制库。大多数组件不需要设置此变量。</li>
</ul>
<p>以下变量仅适用于属于 esp-idf 本身的组件:</p>
<ul>
<li><code>COMPONENT_SUBMODULES</code>:组件使用的 git 子模块路径(相对于 COMPONENT_PATH)的可选列表.这些将由构建过程检查(并在必要时初始化).如果组件位于 IDF_PATH 目录之外,则忽略此变量.</li>
</ul>
<h4 id="可选特定的组件变量"><a href="#可选特定的组件变量" class="headerlink" title="可选特定的组件变量"></a>可选特定的组件变量</h4><p>可以在<code>component.mk</code>中设置以下变量来控制该组件的构建:</p>
<ul>
<li><code>COMPONENT_PRIV_INCLUDEDIRS</code>:目录路径,必须相对于组件目录,该组件目录将仅添加到此组件源文件的”include”搜索路径中.</li>
<li><code>COMPONENT_EXTRA_INCLUDES</code>:编译组件源文件时使用的任何额外包含路径.这些将以’-I’为前缀,并按原样传递给编译器.与<code>COMPONENT_PRIV_INCLUDEDIRS</code>变量类似,但这些路径不会相对于组件目录进行扩展.</li>
<li><code>COMPONENT_SRCDIRS</code>:目录路径,必须相对于组件目录,将用以搜索源文件(<code>* .cpp</code>,<code>* .c</code>,<code>* .S</code>).默认为’.’,即组件目录本身.覆盖它以指定包含源文件的不同目录列表.</li>
<li><code>COMPONENT_OBJS</code>:要编译的对象文件.默认值是<code>COMPONENT_SRCDIRS</code>中找到的每个源文件的 a.o 文件.覆盖此列表允许您排除<code>COMPONENT_SRCDIRS</code>中的源文件,否则将被编译.请参阅指定源文件</li>
<li><code>COMPONENT_EXTRA_CLEAN</code>:相对于组件构建目录的路径,使用<code>component.mk</code>文件中的自定义make规则生成的任何文件,以及作为make clean的一部分需要删除的文件.有关示例,请参阅<a href="#_428">源代码生成</a>.</li>
<li><code>COMPONENT_OWNBUILDTARGET</code>＆<code>COMPONENT_OWNCLEANTARGET</code>:这些目标允许您完全覆盖组件的默认构建行为.有关详细信息,请参阅[完全覆盖组件 Makefile](#完全覆盖组件 Makefile).</li>
<li><code>COMPONENT_CONFIG_ONLY</code>:如果设置,则此标志指示组件根本不生成任何内置输出(即未构建 <code>COMPONENT_LIBRARY</code>),并忽略大多数其他组件变量.此标志用于 IDF 内部组件,其中仅包含 KConfig.projbuild 和/或 Makefile.projbuild 文件以配置项目,但没有源文件.</li>
<li><code>CFLAGS</code>:传递给 C 编译器的标志.根据项目设置定义一组默认 <code>CFLAGS</code>.可以通过 <code>CFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li>
<li><code>CPPFLAGS</code>:传递给 C 预处理器的标志(用于. c , .cpp 和 .S 文件).根据项目设置定义一组默认的 <code>CPPFLAGS</code>.可以通过 <code>CPPFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li>
<li><code>CXXFLAGS</code>:传递给 C++ 编译器的标志.根据项目设置定义一组默认的 <code>CXXFLAGS</code>.可以通过 <code>CXXFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li>
</ul>
<p>要将编译标志应用于单个源文件,可以将变量覆盖添加为目标,即:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apps&#x2F;dhcpserver.o: CFLAGS +&#x3D; -Wno-unused-variable</span><br></pre></td></tr></table></figure>

<h3 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h3><p>每个组件还可以有一个 Kconfig 文件,与 <code>component.mk</code> 在同一目录下.Kconfig 中包含要添加到此组件的 “make menuconfig” 的配置设置.</p>
<p>运行 menuconfig 时,可在 “Component Settings” 菜单下找到这些设置.</p>
<p>要创建组件 KConfig 文件,最简单的方法是使用 esp-idf 中的 KConfig 文件做修改.</p>
<p>有关示例,请参阅<a href="#添加条件配置">添加条件配置</a>.</p>
<h3 id="示例：添加二进制库、组件配置文件-Kconfig"><a href="#示例：添加二进制库、组件配置文件-Kconfig" class="headerlink" title="示例：添加二进制库、组件配置文件 Kconfig"></a>示例：添加二进制库、组件配置文件 Kconfig</h3><p><img src="https://img-blog.csdnimg.cn/20190131111141734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Component Makefile</span><br><span class="line">#</span><br><span class="line">ifdef CONFIG_BT_ENABLED</span><br><span class="line"></span><br><span class="line">COMPONENT_SRCDIRS :&#x3D; .</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_INCLUDEDIRS :&#x3D; include</span><br><span class="line"></span><br><span class="line"># add pre-compiled libraries</span><br><span class="line">LIBS :&#x3D; btdm_app</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_LDFLAGS     :&#x3D; -lbt -L $(COMPONENT_PATH)&#x2F;lib \</span><br><span class="line">                           $(addprefix -l,$(LIBS))</span><br><span class="line"></span><br><span class="line"># re-link program if BT binary libs change</span><br><span class="line">COMPONENT_ADD_LINKER_DEPS :&#x3D; $(patsubst %,$(COMPONENT_PATH)&#x2F;lib&#x2F;lib%.a,$(LIBS))</span><br><span class="line"></span><br><span class="line">COMPONENT_SUBMODULES +&#x3D; lib</span><br><span class="line"></span><br><span class="line">ifeq ($(GCC_NOT_5_2_0), 1)</span><br><span class="line"># TODO: annotate fallthroughs in Bluedroid code with comments</span><br><span class="line">CFLAGS +&#x3D; -Wno-implicit-fallthrough</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifdef CONFIG_BLUEDROID_ENABLED</span><br><span class="line"></span><br><span class="line">COMPONENT_PRIV_INCLUDEDIRS +&#x3D;   bluedroid&#x2F;bta&#x2F;include                   \</span><br><span class="line">                                bluedroid&#x2F;bta&#x2F;ar&#x2F;include</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_INCLUDEDIRS +&#x3D;    bluedroid&#x2F;api&#x2F;include&#x2F;api</span><br><span class="line"></span><br><span class="line">COMPONENT_SRCDIRS +&#x3D;    bluedroid&#x2F;bta&#x2F;dm                      \</span><br><span class="line">                        bluedroid&#x2F;bta&#x2F;gatt </span><br><span class="line"></span><br><span class="line">ifeq ($(GCC_NOT_5_2_0), 1)</span><br><span class="line">bluedroid&#x2F;bta&#x2F;sdp&#x2F;bta_sdp_act.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;btc&#x2F;core&#x2F;btc_config.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;stack&#x2F;btm&#x2F;btm_sec.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;stack&#x2F;smp&#x2F;smp_keys.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<h3 id="预处理器定义"><a href="#预处理器定义" class="headerlink" title="预处理器定义"></a>预处理器定义</h3><p>ESP-IDF 构建系统在命令行上添加以下 C 预处理器定义:</p>
<ul>
<li><code>ESP_PLATFORM</code> - 可用于检测在 ESP-IDF 内发生的构建.</li>
<li><code>IDF_VER</code> - ESP-IDF 版本,有关详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/build-system.html#preset-component-variables" target="_blank" rel="noopener">预设组件变量</a>.</li>
<li><code>PROJECT_VER</code>：项目版本，有关详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/build-system.html#preset-component-variables" target="_blank" rel="noopener">预设组件变量</a>.</li>
<li><code>PROJECT_NAME</code>：项目名称，在项目 Makefile 中设置.</li>
</ul>
<h3 id="构建过程内部"><a href="#构建过程内部" class="headerlink" title="构建过程内部"></a>构建过程内部</h3><h4 id="顶级-Project-Makefile"><a href="#顶级-Project-Makefile" class="headerlink" title="顶级:Project Makefile"></a>顶级:Project Makefile</h4><ul>
<li>“make” 总是从项目目录和项目 makefile 运行,通常名为 Makefile.</li>
<li>项目 makefile 设置 <code>PROJECT_NAME</code>,并可选择自定义其他可选项目变量</li>
<li>项目 makefile 包含 <code>$(IDF_PATH)/make/project.mk</code>,其中包含项目级的 Make 逻辑.</li>
<li><code>project.mk</code> 填写默认的项目级 make 变量,并包含项目配置中的 make 变量.如果生成的包含项目配置的 makefile 已过期,则会重新生成(通过 <code>project_config.mk</code> 中的 targets),然后 make 进程从顶部重新开始.</li>
<li><code>project.mk</code> 根据默认组件目录或可选项目变量中设置的自定义组件列表构建需要要构建的组件列表.</li>
<li>每个组件都可以设置一些<a href="#可选项目范围的组件变量">可选项目范围的组件变量</a>.这些包含在 <code>component_project_vars.mk</code> 生成的 makefile 中 - 每个组件有一个.这些生成的 makefile 包含在 <code>project.mk</code>中.如果有任何缺失或过时,它们将被重新生成(通过对组件 makefile 的递归调用),然后 make 进程从顶部重新开始.</li>
<li>组件中的 Makefile.projbuild 文件包含在 make 进程中,以添加额外的目标或配置.</li>
<li>默认情况下,项目 makefile 还为每个组件生成顶级构建和清理目标,并设置 app 和 clean 目标以调用这些子目标.</li>
<li>为了编译每个组件,对组件 makefile 执行递归 make.</li>
</ul>
<p>为了更好地理解项目构建过程,请通读 <code>project.mk</code> 文件本身.</p>
<h4 id="第二级-组件Makefile"><a href="#第二级-组件Makefile" class="headerlink" title="第二级:组件Makefile"></a>第二级:组件Makefile</h4><ul>
<li>每次调用组件 makefile 都是通过 <code>$(IDF_PATH)/make/component_wrapper.mk</code> 包装器 makefile 进行的.</li>
<li>此组件包装器包含所有组件 <code>Makefile.componentbuild</code> 文件,使这些文件中的任何配方,变量等可用于每个组件.</li>
<li>调用<code>component_wrapper.mk</code>时将当前目录设置为组件构建目录,并将<code>COMPONENT_MAKEFILE</code>变量设置为<code>component.mk</code>的绝对路径.</li>
<li><code>component_wrapper.mk</code>为所有组件变量设置默认值,然后包括可以覆盖或修改这些变量的component.mk文件.</li>
<li>如果未定义 <code>COMPONENT_OWNBUILDTARGET</code> 和 <code>COMPONENT_OWNCLEANTARGET</code>,则会为组件的源文件和必备组件 <code>COMPONENT_LIBRARY</code> 静态库文件创建缺省构建和清除目标.</li>
<li><code>component_project_vars.mk</code> 文件在 <code>component_wrapper.mk</code> 中有自己的目标,如果由于组件 makefile 或项目配置的更改而需要重建此文件,则从 <code>project.mk</code> 进行评估.</li>
</ul>
<p>为了更好地理解组件制作过程,请通读 <code>component_wrapper.mk</code> 文件和 esp-idf 中包含的一些 <code>component.mk</code> 文件.</p>
<h3 id="以非交互方式运行"><a href="#以非交互方式运行" class="headerlink" title="以非交互方式运行"></a>以非交互方式运行</h3><p>在不希望交互式提示的情况下运行 <code>make</code> 时(例如:在 IDE 或自动构建系统中)将 <code>BATCH_BUILD = 1</code> 附加到 make 参数(或将其设置为环境变量).</p>
<p>设置 <code>BATCH_BUILD</code> 意味着以下内容:</p>
<ul>
<li>详细输出(与 <code>V = 1</code> 相同,见下文).如果您不想要详细输出,设置 <code>V = 0</code>.</li>
<li>如果项目配置缺少新配置项(来自新组件或 esp-idf 更新),则项目使用默认值,而不是提示用户输入每个项目.</li>
<li>如果构建系统需要调用<code>menuconfig</code>,则会打印错误并且构建失败.</li>
</ul>
<h3 id="高级-Make-用法"><a href="#高级-Make-用法" class="headerlink" title="高级 Make 用法"></a>高级 Make 用法</h3><ul>
<li><code>make app</code>，<code>make bootloader</code>，<code>make partition table</code> 可用于仅根据需要从项目中构建 <code>app</code>，<code>bootloader</code> 或 <code>partition table</code>。</li>
<li><code>make erase_flash</code> 和 <code>make erase_ota</code> 将分别使用 <code>esptool.py</code> 从 Flash 中擦除整个 Flash 和 OTA 分区选择配置。</li>
<li><code>make size</code> 打印有关应用程序的一些大小信息。<code>make size-components</code> 和 <code>make size-files</code> 是类似的目标，分别打印更详细的每个组件或每个源文件信息。</li>
</ul>
<h3 id="调试-Make-Process"><a href="#调试-Make-Process" class="headerlink" title="调试 Make Process"></a>调试 Make Process</h3><p>调试 esp-idf 构建系统的一些技巧:</p>
<ul>
<li>将 <code>V = 1</code> 附加到 make 参数(或将其设置为环境变量)将使 make 回显所有已执行的命令,以及为 sub-make 输入的每个目录.</li>
<li>运行 <code>make -w</code> 将导致 make 在为 sub-make 输入时回显每个目录 - 与 <code>V = 1</code> 相同但不回显所有命令.</li>
<li>运行 <code>make --trace</code> (可能除了上述参数之一)将打印出构建时的每个目标,以及导致它构建的依赖项.</li>
<li>运行 <code>make -p</code> 会打印每个 makefile 中每个生成的目标的(非常详细的)摘要.</li>
</ul>
<p>有关更多调试技巧和一般制作信息,请参阅 GNU制作手册.</p>
<h4 id="警告未定义的变量"><a href="#警告未定义的变量" class="headerlink" title="警告未定义的变量"></a>警告未定义的变量</h4><p>默认情况下,如果引用了未定义的变量(如<code>$(DOES_NOT_EXIST)</code>),构建过程将打印警告.这对于查找变量名称中的错误非常有用.</p>
<p>如果您不想要此行为,可以在 SDK 工具配置下的 menuconfig 顶级菜单中禁用它.</p>
<p>请注意,如果在 Makefile 中使用<code>ifdef</code>或<code>ifndef</code>,则此选项不会触发警告.</p>
<h3 id="覆盖项目的部分内容"><a href="#覆盖项目的部分内容" class="headerlink" title="覆盖项目的部分内容"></a>覆盖项目的部分内容</h3><h4 id="Makefile-projbuild"><a href="#Makefile-projbuild" class="headerlink" title="Makefile.projbuild"></a>Makefile.projbuild</h4><p>对于具有必须在顶级项目 make pass 中进行求值的构建要求的组件,可以在组件目录中创建名为 <code>Makefile.projbuild</code> 的文件.在计算 <code>project.mk</code> 时会包含此 makefile.</p>
<p>例如,如果您的组件需要为整个项目添加 CFLAGS (不仅仅是为了自己的源文件),那么您可以在 Makefile.projbuild 中设置 <code>CFLAGS +=</code>.</p>
<p><code>Makefile.projbuild</code> 文件在 esp-idf 中大量使用,用于定义项目范围的构建功能,例如 <code>esptool.py</code> 命令行参数和 <code>bootloader</code> “特殊应用程序”.</p>
<p>请注意,<code>Makefile.projbuild</code> 对于最常见的组件使用不是必需的 - 例如向项目添加 include 目录,或者将 LDFLAGS 添加到最终链接步骤.可以通过 <code>component.mk</code> 文件本身自定义这些值.有关详细信息,请参阅<a href="#可选项目范围的组件变量">可选项目范围的组件变量</a>.</p>
<p>在此文件中设置变量或目标时要小心.由于这些值包含在顶级项目 makefile 中,因此它们可以影响或破坏所有组件的功能！</p>
<h4 id="KConfig-projbuild"><a href="#KConfig-projbuild" class="headerlink" title="KConfig.projbuild"></a>KConfig.projbuild</h4><p>这相当于 <code>Makefile.projbuild</code> 的组件配置 KConfig 文件.如果要在 menuconfig 的顶层包含配置选项,而不是在 “Component Configuration” 子菜单中,则可以在 <code>component.mk</code> 文件旁边的 KConfig.projbuild 文件中定义这些选项.</p>
<p>在此文件中添加配置值时要小心,因为它们将包含在整个项目配置中.在可能的情况下,通常最好为组件配置创建 KConfig 文件.</p>
<h4 id="Makefile-componentbuild"><a href="#Makefile-componentbuild" class="headerlink" title="Makefile.componentbuild"></a>Makefile.componentbuild</h4><p>对于组件例如,包括从其他文件生成源文件的工具,必须能够将配置,宏或变量定义添加到每个组件的组件构建过程中.这是通过在组件目录中包含 Makefile.componentbuild 来完成的.在包含组件的 component.mk 之前,此文件会包含在 component_wrapper.mk 中.与 Makefile.projbuild 类似,请注意这些文件:因为它们包含在每个组件构建中,所以只有在编译完全不同的组件时才会出现 Makefile.componentbuild 错误.</p>
<h4 id="仅配置组件"><a href="#仅配置组件" class="headerlink" title="仅配置组件"></a>仅配置组件</h4><p>一些不包含源文件的特殊组件,只有 <code>Kconfig.projbuild</code> 和 <code>Makefile.projbuild</code>,可以在 component.mk 文件中设置标志 <code>COMPONENT_CONFIG_ONLY</code>.如果设置了此标志,则忽略大多数其他组件变量,并且不会为组件运行构建步骤.</p>
<h3 id="示例组件-Makefile"><a href="#示例组件-Makefile" class="headerlink" title="示例组件 Makefile"></a>示例组件 Makefile</h3><p>因为构建环境试图设置大多数时间都能工作的合理默认值,所以 component.mk 可能非常小甚至是空的(请参阅<a href="#最小组件Makefile">最小组件 Makefile</a>).但是,某些功能通常需要覆盖组件变量.</p>
<p>以下是<code>component.mk</code> makefile 的一些更高级的示例:</p>
<h4 id="添加源文件目录"><a href="#添加源文件目录" class="headerlink" title="添加源文件目录"></a>添加源文件目录</h4><p>默认情况下,将忽略子目录.如果您的项目在子目录而不是组件的根目录中有源文件,那么您可以通过设置<code>COMPONENT_SRCDIRS</code> 告诉构建系统:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_SRCDIRS:&#x3D; src1 src2</span><br></pre></td></tr></table></figure>
<p>这将编译 src1/ 和 src2/ 子目录中的所有源文件.</p>
<h4 id="指定源文件"><a href="#指定源文件" class="headerlink" title="指定源文件"></a>指定源文件</h4><p>标准 component.mk 逻辑将源目录中的所有 .S 和 .c 文件添加为无条件编译的源.通过将 <code>COMPONENT_OBJS</code> 变量手动设置为需要生成的对象的名称,可以绕过该逻辑并对要编译的对象进行硬编码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_OBJS :&#x3D; file1.o file2.o thing&#x2F;filea.o thing&#x2F;fileb.o anotherthing&#x2F;main.o</span><br><span class="line">COMPONENT_SRCDIRS :&#x3D; . thing anotherthing</span><br></pre></td></tr></table></figure>
<p>请注意,还必须设置 <code>COMPONENT_SRCDIRS</code>.</p>
<h4 id="添加条件配置"><a href="#添加条件配置" class="headerlink" title="添加条件配置"></a>添加条件配置</h4><p>配置系统可有条件地编译某些文件,具体取决于 <code>make menuconfig</code> 中选择的选项.为此, ESP-IDF 具有 <code>compile_only_if</code> 和 <code>compile_only_if_not</code> 宏:</p>
<p><code>Kconfig</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config FOO_ENABLE_BAR</span><br><span class="line">    bool &quot;Enable the BAR feature.&quot;</span><br><span class="line">    help</span><br><span class="line">        This enables the BAR feature of the FOO component.</span><br></pre></td></tr></table></figure>
<p><code>component.mk</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(call compile_only_if,$(CONFIG_FOO_ENABLE_BAR),bar.o)</span><br></pre></td></tr></table></figure>
<p>从示例中可以看出,<code>compile_only_if</code> 宏将条件和目标文件列表作为参数.如果条件为真(在这种情况下:如果在 menuconfig 中启用了 BAR 功能),将始终编译目标文件(在本例中为 bar.o).相反的情况也是如此:如果条件不成立, bar.o 将永远不会被编译.<code>compile_only_if_not</code> 执行相反的操作:如果条件为false则编译,如果条件为 true 则不编译.</p>
<p>这也可用于选择或删除一种实现,如下所示:</p>
<p><code>Kconfig</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config ENABLE_LCD_OUTPUT</span><br><span class="line">    bool &quot;Enable LCD output.&quot;</span><br><span class="line">    help</span><br><span class="line">        Select this if your board has a LCD.</span><br><span class="line"></span><br><span class="line">config ENABLE_LCD_CONSOLE</span><br><span class="line">    bool &quot;Output console text to LCD&quot;</span><br><span class="line">    depends on ENABLE_LCD_OUTPUT</span><br><span class="line">    help</span><br><span class="line">        Select this to output debugging output to the lcd</span><br><span class="line"></span><br><span class="line">config ENABLE_LCD_PLOT</span><br><span class="line">    bool &quot;Output temperature plots to LCD&quot;</span><br><span class="line">    depends on ENABLE_LCD_OUTPUT</span><br><span class="line">    help</span><br><span class="line">        Select this to output temperature plots</span><br></pre></td></tr></table></figure>

<p>component.mk:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># If LCD is enabled, compile interface to it, otherwise compile dummy interface</span><br><span class="line">$(call compile_only_if,$(CONFIG_ENABLE_LCD_OUTPUT),lcd-real.o lcd-spi.o)</span><br><span class="line">$(call compile_only_if_not,$(CONFIG_ENABLE_LCD_OUTPUT),lcd-dummy.o)</span><br><span class="line"></span><br><span class="line">#We need font if either console or plot is enabled</span><br><span class="line">$(call compile_only_if,$(or $(CONFIG_ENABLE_LCD_CONSOLE),$(CONFIG_ENABLE_LCD_PLOT)), font.o)</span><br></pre></td></tr></table></figure>
<p>请注意使用 Make ‘or’ 功能来包含字体文件.其他替换函数,如 ‘and’ 以及 ‘if’ 也适用于此处.也可以使用不来自 menuconfig 的变量: ESP-IDF 使用默认的构建配置来判断一个空的变量或只包含空格为false,而其中包含任何非空格的变量为true.</p>
<p>(注意:本文档的旧版本建议有条件地将目标文件名添加到 <code>COMPONENT_OBJS</code>.虽然这仍然可行,但只有当组件的所有目标文件都明确命名时才会起作用,并且不会通过 <code>make clear</code> 中的取消选择的目标文件通过.)</p>
<h4 id="源代码生成"><a href="#源代码生成" class="headerlink" title="源代码生成"></a>源代码生成</h4><p>某些组件将出现源文件未随组件本身提供但必须从另一个文件生成的情况.假设我们的组件有一个头文件,该文件由 BMP 文件的转换后的二进制数据组成,使用名为 bmp2h 的假设工具进行转换.然后将头文件包含在名为 graphics_lib.c 的 C 源文件中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_EXTRA_CLEAN :&#x3D; logo.h</span><br><span class="line"></span><br><span class="line">graphics_lib.o: logo.h</span><br><span class="line"></span><br><span class="line">logo.h: $(COMPONENT_PATH)&#x2F;logo.bmp</span><br><span class="line">    bmp2h -i $^ -o $@</span><br></pre></td></tr></table></figure>
<p>在此示例中,将在当前目录(构建目录)中生成 <code>graphics_lib.o</code> 和 <code>logo.h</code>,而 logo.bmp 随组件一起提供并位于组件路径下.因为 logo.h 是一个生成的文件,所以当调用 make clean 时需要清理它,这就是为什么它被添加到 <code>COMPONENT_EXTRA_CLEAN</code> 变量中.</p>
<h4 id="Cosmetic-Improvements"><a href="#Cosmetic-Improvements" class="headerlink" title="Cosmetic Improvements"></a>Cosmetic Improvements</h4><p>因为 logo.h 是一个生成的文件,所以当调用 make clean 时需要清理它,这就是为什么它被添加到 <code>COMPONENT_EXTRA_CLEAN</code> 变量中.</p>
<p>将 logo.h 添加到 <code>graphics_lib.o</code> 依赖项会导致在编译 <code>graphics_lib.c</code> 之前生成它.</p>
<p>如果另一个组件中的源文件包含 <code>logo.h</code>,则必须将此组件的名称添加到另一个组件的 <code>COMPONENT_DEPENDS</code> 列表中,以确保组件按顺序构建.</p>
<h4 id="嵌入二进制数据"><a href="#嵌入二进制数据" class="headerlink" title="嵌入二进制数据"></a>嵌入二进制数据</h4><p>有时您有一个文件,包含组件需要使用的二进制数据或文本数据 - 但您不希望将文件重新格式化为 C 文件.</p>
<p>您可以在 component.mk 中设置变量 <code>COMPONENT_EMBED_FILES</code>,以这种方式给出要嵌入的文件的名称:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_EMBED_FILES:&#x3D; server_root_cert.der</span><br></pre></td></tr></table></figure>
<p>或者,如果文件是字符串,则可以使用变量 <code>COMPONENT_EMBED_TXTFILES</code>.这将把文本文件的内容嵌入为以 null 结尾的字符串:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_EMBED_TXTFILES:&#x3D; server_root_cert.pem</span><br></pre></td></tr></table></figure>
<p>文件的内容将被添加到 flash 中的 .rodata 部分,并通过符号名称提供,如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern const uint8_t server_root_cert_pem_start [] asm(“_ binary_server_root_cert_pem_start”);</span><br><span class="line">extern const uint8_t server_root_cert_pem_end [] asm(“_ binary_server_root_cert_pem_end”);</span><br></pre></td></tr></table></figure>
<p>名称是根据文件的全名生成的,如 <code>COMPONENT_EMBED_FILES</code> 中所示.字符 <code>/</code>,<code>.</code>等用下划线代替.符号名称中的 <code>_binary</code> 前缀由 <code>objcopy</code> 添加,对于文本和二进制文件都是相同的.</p>
<p>有关使用此技术的示例,请参阅<a href="https://github.com/espressif/esp-idf/tree/be81d2c/examples/protocols/https_request" target="_blank" rel="noopener">protocols/https_request</a>-证书文件内容在编译时从文本 .pem 文件加载.</p>
<h3 id="完全覆盖组件-Makefile"><a href="#完全覆盖组件-Makefile" class="headerlink" title="完全覆盖组件 Makefile"></a>完全覆盖组件 Makefile</h3><p>显然,在某些情况下,所有这些不足以满足某个组件,例如,当组件基本上是另一个第三方组件的包装器时,该第三方组件最初不打算在此构建系统下编译.在这种情况下,可以通过设置 <code>COMPONENT_OWNBUILDTARGET</code> 和可能的 <code>COMPONENT_OWNCLEANTARGET</code> 并在 <code>component.mk</code> 目标中定义名为 <code>build</code> 和 <code>clean</code> 的自己的目标来完全放弃 esp-idf 构建系统.构建目标可以执行任何操作,只要它为项目生成过程创建 $(COMPONENT_LIBRARY) 以链接到应用程序二进制文件.</p>
<p>(实际上,即使这不是必需的-如果重写 <code>COMPONENT_ADD_LDFLAGS</code> 变量,则组件可以指示链接器链接其他二进制文件.)</p>
<h3 id="自定义-sdkconfig-默认值"><a href="#自定义-sdkconfig-默认值" class="headerlink" title="自定义 sdkconfig 默认值"></a>自定义 sdkconfig 默认值</h3><p>例如,您不希望指定完整 sdkconfig 配置的项目或其他项目,但您确实希望覆盖 esp-idf 默认值中的某些键值,则可以在项目目录中创建文件 <code>sdkconfig.defaults</code>.运行 <code>make defconfig</code> 或从头创建新配置时将使用此文件.</p>
<p>要覆盖此文件的名称,请设置 <code>SDKCONFIG_DEFAULTS</code> 环境变量.</p>
<h3 id="保存-flash-参数"><a href="#保存-flash-参数" class="headerlink" title="保存 flash 参数"></a>保存 flash 参数</h3><p>在某些情况下,我们希望在没有 IDF 的情况下烧写目标板.对于这种情况,我们希望保存构建的二进制文件, <code>esptool.py</code> 和 <code>esptool write_flash</code> 参数.编写脚本以保存二进制文件和 <code>esptool.py</code> 很简单.我们可以使用命令 <code>make print_flash_cmd</code>,它会打印 flash 参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader &#x2F; bootloader.bin 0x10000 example_app.bin 0x8000 partition_table_unit_test_app.bin</span><br></pre></td></tr></table></figure>
<p>然后使用 flash 参数作为 <code>esptool write_flash</code> 参数的 arguemnts:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python esptool.py --chip esp32 --port &#x2F; dev &#x2F; ttyUSB0 --baud 921600 - before default_reset - after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader &#x2F; bootloader.bin 0x10000 example_app .bin 0x8000 partition_table_unit_test_app.bin</span><br></pre></td></tr></table></figure>

<h2 id="构建-Bootloader"><a href="#构建-Bootloader" class="headerlink" title="构建 Bootloader"></a>构建 Bootloader</h2><p>引导程序默认构建为 “make all” 的一部分,或者可以通过 “make bootloader-clean” 独立构建.还有 “make bootloader-list-components” 来查看引导加载程序构建中包含的组件.</p>
<p>IDF <code>components/bootloader</code> 中的组件是特殊的,因为第二阶段引导加载程序是主项目的单独.ELF和.BIN文件.但是,它与主项目共享其配置和构建目录.</p>
<p>这是通过在 <code>components/bootloader/subproject</code> 下添加子项目来完成的.这个子项目有自己的 Makefile,但它希望通过 <code>components/bootloader/Makefile.projectbuild</code> 文件中的一些粘合剂从项目自己的 Makefile 中调用.有关详细信息,请参阅这些文件</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（五）严重错误</title>
    <url>/InfiniteYuanBlog/2018/09/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%A5%E9%87%8D%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在某些情况下,程序的执行,没有按照定义的方式持续执行.在 ESP-IDF 中,这些情况包括:</p>
<ul>
<li>CPU 异常:Illegal Instruction, Load/Store Alignment Error, Load/Store Prohibited error, Double Exception.(非法指令,加载/存储对齐错误,加载/存储禁止错误,双重异常)</li>
<li>系统级别检查和安全措施:<ul>
<li>Interrupt watchdog timeout 中断看门狗超时</li>
<li>Task watchdog timeout  任务监视程序超时(如果设置了 <code>CONFIG_TASK_WDT_PANIC</code>,则仅 fatal)</li>
<li>Cache access error 缓存访问错误</li>
<li>Brownout detection event 掉电检测事件</li>
<li>Stack overflow 堆栈溢出</li>
<li>Stack smashing protection check 堆栈粉碎保护检查</li>
<li>Heap integrity check 堆完整性检查</li>
</ul>
</li>
<li>Failed assertions 断言失败,通过 <code>assert</code> ,<code>configASSERT</code> 和类似的宏.</li>
</ul>
<p>本指南介绍了 ESP-IDF 中用于处理这些错误的过程,并提供了有关错误故障排除的建议.</p>
<a id="more"></a>

<h2 id="Panic-处理"><a href="#Panic-处理" class="headerlink" title="Panic 处理"></a>Panic 处理</h2><p>概述中列出的每个错误原因都将由 Panic 处理程序处理.</p>
<p>Panic 处理程序将首先将错误原因打印到控制台. 对于 CPU 异常,消息类似于:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Guru Meditation Error: Core 0 panic&#39;ed (IllegalInstruction). Exception was unhandled.</span><br></pre></td></tr></table></figure>

<p>对于某些系统级别检查(中断监视程序,缓存访问错误),该消息将类似于:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Guru Meditation Error: Core 0 panic&#39;ed (Cache disabled but cached memory region accessed)</span><br></pre></td></tr></table></figure>

<p>在所有情况下,错误原因将打印在括号中. 有关可能的错误原因列表,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html#guru-meditation-errors" target="_blank" rel="noopener">Guru Meditation Errors</a>.</p>
<p>可以使用 <code>CONFIG_ESP32_PANIC</code> 配置选项设置 Panic 处理程序的后续行为. 可用选项包括:</p>
<ul>
<li><p>打印寄存器并重新启动(<code>CONFIG_ESP32_PANIC_PRINT_REBOOT</code>) - 默认选项.<br> 这将在异常点打印寄存器值,打印回溯,然后重新启动芯片.</p>
</li>
<li><p>打印寄存器并暂停(<code>CONFIG_ESP32_PANIC_PRINT_HALT</code>)<br> 与上述选项类似,但暂停而不是重新启动. 重启程序需要外部重置.</p>
</li>
<li><p>无提示重启(<code>CONFIG_ESP32_PANIC_SILENT_REBOOT</code>)<br> 不要打印寄存器或回溯,立即重启芯片.</p>
</li>
<li><p>调用 GDB 存根(<code>CONFIG_ESP32_PANIC_GDBSTUB</code>)<br>  启动 GDB 服务器,它可以通过控制台 UART 端口与 GDB 通信. 有关详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html#gdb-stub" target="_blank" rel="noopener">GDB 存根</a>.</p>
</li>
</ul>
<p>Panic 处理程序的行为受另外两个配置选项的影响.</p>
<ul>
<li>如果启用了 <code>CONFIG_ESP32_DEBUG_OCDAWARE</code> (这是默认设置),则 Panic 处理程序将检测 JTAG 调试器是否已连接. 如果是,则执行将暂停,控制权将传递给调试器. 在这种情况下,寄存器和回溯不会转储到控制台,并且不使用 GDBStub/Core Dump 功能.</li>
<li>如果启用了核心转储功能(<code>CONFIG_ESP32_ENABLE_COREDUMP_TO_FLASH</code> 或 <code>CONFIG_ESP32_ENABLE_COREDUMP_TO_UART</code> 选项),则系统状态(任务堆栈和寄存器)将被转储到 Flash 或 UART,以供以后分析.</li>
</ul>
<p>下图说明了 Panic 处理程序的行为:</p>
<p><img src="https://img-blog.csdn.net/20180901140838695?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Panic 处理程序流程图"></p>
<h2 id="寄存器转储和回溯"><a href="#寄存器转储和回溯" class="headerlink" title="寄存器转储和回溯"></a>寄存器转储和回溯</h2><p>除非启用了 <code>CONFIG_ESP32_PANIC_SILENT_REBOOT</code> 选项,否则 Panic 处理程序会将一些 CPU 寄存器和回溯打印到控制台:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Core 0 register dump:</span><br><span class="line">PC      : 0x400e14ed  PS      : 0x00060030  A0      : 0x800d0805  A1      : 0x3ffb5030</span><br><span class="line">A2      : 0x00000000  A3      : 0x00000001  A4      : 0x00000001  A5      : 0x3ffb50dc</span><br><span class="line">A6      : 0x00000000  A7      : 0x00000001  A8      : 0x00000000  A9      : 0x3ffb5000</span><br><span class="line">A10     : 0x00000000  A11     : 0x3ffb2bac  A12     : 0x40082d1c  A13     : 0x06ff1ff8</span><br><span class="line">A14     : 0x3ffb7078  A15     : 0x00000000  SAR     : 0x00000014  EXCCAUSE: 0x0000001d</span><br><span class="line">EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0xffffffff</span><br><span class="line"></span><br><span class="line">Backtrace: 0x400e14ed:0x3ffb5030 0x400d0802:0x3ffb5050</span><br></pre></td></tr></table></figure>

<p>打印的寄存器值是异常帧中的寄存器值,即 CPU 异常或其他严重错误发生时的值.</p>
<p>如果由于 <code>abort()</code> 调用而执行了 Panic 处理程序,则不会打印寄存器转储.</p>
<p>在某些情况下,例如中断看门狗超时, Panic 处理程序可能会打印额外的 CPU 寄存器 (EPC1-EPC4) 以及在另一个 CPU 上运行的代码的寄存器/回溯.</p>
<p>Backtrace 行包含 PC:SP 对,其中 PC 是程序计数器,SP 是堆栈指针,用于当前任务的每个堆栈帧. 如果在 ISR 内发生严重错误,则回溯可能包括来自被中断的任务和来自 ISR 的 PC:SP 对.</p>
<p>如果使用 IDF Monitor,程序计数器值将转换为代码位置(函数名称,文件名和行号),输出将与其他行进行注释:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Core 0 register dump:</span><br><span class="line">PC      : 0x400e14ed  PS      : 0x00060030  A0      : 0x800d0805  A1      : 0x3ffb5030</span><br><span class="line">0x400e14ed: app_main at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.cpp:36</span><br><span class="line"></span><br><span class="line">A2      : 0x00000000  A3      : 0x00000001  A4      : 0x00000001  A5      : 0x3ffb50dc</span><br><span class="line">A6      : 0x00000000  A7      : 0x00000001  A8      : 0x00000000  A9      : 0x3ffb5000</span><br><span class="line">A10     : 0x00000000  A11     : 0x3ffb2bac  A12     : 0x40082d1c  A13     : 0x06ff1ff8</span><br><span class="line">0x40082d1c: _calloc_r at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;esp-idf&#x2F;components&#x2F;newlib&#x2F;syscalls.c:51</span><br><span class="line"></span><br><span class="line">A14     : 0x3ffb7078  A15     : 0x00000000  SAR     : 0x00000014  EXCCAUSE: 0x0000001d</span><br><span class="line">EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0xffffffff</span><br><span class="line"></span><br><span class="line">Backtrace: 0x400e14ed:0x3ffb5030 0x400d0802:0x3ffb5050</span><br><span class="line">0x400e14ed: app_main at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.cpp:36</span><br><span class="line"></span><br><span class="line">0x400d0802: main_task at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;esp-idf&#x2F;components&#x2F;esp32&#x2F;cpu_start.c:470</span><br></pre></td></tr></table></figure>

<p>要查找发生严重错误的位置,请查看“Backtrace”的下一行. 严重错误位置是顶行,后续行显示调用堆栈.</p>
<h2 id="GDB-存根"><a href="#GDB-存根" class="headerlink" title="GDB 存根"></a>GDB 存根</h2><p>如果启用了 <code>CONFIG_ESP32_PANIC_GDBSTUB</code> 选项,则发生严重错误时, Panic 处理程序不会重置芯片. 相反,它将启动 GDB 远程协议服务器,通常称为 GDB Stub. 发生这种情况时,可以指示主机上运行的 GDB 实例连接到 ESP32 UART 端口.</p>
<p>如果使用 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/idf-monitor.html" target="_blank" rel="noopener">IDF Monitor</a>,则在 UART 上检测到 GDB Stub 提示时会自动启动 GDB. 输出看起来像这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entering gdb stub now.</span><br><span class="line">$T0b#e6GNU gdb (crosstool-NG crosstool-ng-1.22.0-80-gff1f415) 7.10</span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;--host&#x3D;x86_64-build_apple-darwin16.3.0 --target&#x3D;xtensa-esp32-elf&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;bugs&#x2F;&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;documentation&#x2F;&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;build&#x2F;example.elf...done.</span><br><span class="line">Remote debugging using &#x2F;dev&#x2F;cu.usbserial-31301</span><br><span class="line">0x400e1b41 in app_main ()</span><br><span class="line">    at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.cpp:36</span><br><span class="line">36      *((int*) 0) &#x3D; 0;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>GDB 提示可用于检查 CPU 寄存器,本地和静态变量以及内存中的任意位置. 无法设置断点,更改 PC 或继续执行. 要重置程序,请退出 GDB 并执行外部重置:IDF Monitor 中的 <code>Ctrl-T Ctrl-R</code>,或使用开发板上的外部重置按钮.</p>
<h2 id="Guru-Meditation-错误"><a href="#Guru-Meditation-错误" class="headerlink" title="Guru Meditation 错误"></a>Guru Meditation 错误</h2><p>本节解释了不同错误原因的含义,打印在 <code>Guru Meditation Error:Core panic&#39;ed message</code> 之后的括号中.</p>
<blockquote>
<p>有关“Guru Meditation”的历史渊源,请参阅 <a href="https://en.wikipedia.org/wiki/Guru_Meditation" target="_blank" rel="noopener">Wikipedia 文章</a>.</p>
</blockquote>
<h3 id="IllegalInstruction-非法指令"><a href="#IllegalInstruction-非法指令" class="headerlink" title="IllegalInstruction (非法指令)"></a>IllegalInstruction (非法指令)</h3><p>该 CPU 异常表示执行的指令不是有效指令. 此错误的最常见原因有:</p>
<ul>
<li>FreeRTOS 任务功能已经返回. 在 FreeRTOS 中,如果任务函数需要终止,它应该调用 vTaskDelete() 函数并删除它自己,而不是返回.</li>
<li>无法从 SPI Flash 加载下一条指令. 这种情况通常发生在:<ul>
<li>应用程序已将 SPI Flash 引脚重新配置为其他功能(GPIO,UART 等). 有关 SPI Flash 引脚的详细信息,请参阅硬件设计指南和芯片或模块的数据表.</li>
<li>某些外部设备意外连接到 SPI Flash 引脚,干扰了 ESP32 和 SPI Flash 之间的通信.</li>
</ul>
</li>
</ul>
<h3 id="InstrFetchProhibited-禁止指令加载"><a href="#InstrFetchProhibited-禁止指令加载" class="headerlink" title="InstrFetchProhibited (禁止指令加载)"></a>InstrFetchProhibited (禁止指令加载)</h3><p>此 CPU 异常表示 CPU 无法加载指令,因为指令的地址不属于指令 RAM 或 ROM 中的有效区域.</p>
<p>通常这意味着尝试调用函数指针,该指针不指向有效代码. PC (程序计数器)寄存器可用作指示器:它将为零或将包含垃圾值(不是 0x4xxxxxxx).</p>
<h3 id="LoadProhibited-StoreProhibited-禁止加载，禁止存储"><a href="#LoadProhibited-StoreProhibited-禁止加载，禁止存储" class="headerlink" title="LoadProhibited,StoreProhibited(禁止加载，禁止存储)"></a>LoadProhibited,StoreProhibited(禁止加载，禁止存储)</h3><p>当应用程序尝试读取或写入无效的内存位置时,会发生此 CPU 异常. 写入/读取的地址可在寄存器转储中的 <code>EXCVADDR</code> 寄存器中找到. 如果此地址为零,则通常表示应用程序尝试取消引用 NULL 指针. 如果此地址接近于零,则通常意味着应用程序尝试访问结构的成员,但指向该结构的指针为 NULL. 如果该地址是别的(垃圾值,不在 <code>0x3fxxxxxx</code> - <code>0x6xxxxxxx</code> 范围内),则可能意味着用于访问数据的指针未初始化或已损坏.</p>
<h3 id="IntegerDivideByZero-除以-0"><a href="#IntegerDivideByZero-除以-0" class="headerlink" title="IntegerDivideByZero(除以 0)"></a>IntegerDivideByZero(除以 0)</h3><p>应用程序尝试将整数除以零.</p>
<h3 id="LoadStoreAlignment-对齐方式不对"><a href="#LoadStoreAlignment-对齐方式不对" class="headerlink" title="LoadStoreAlignment(对齐方式不对)"></a>LoadStoreAlignment(对齐方式不对)</h3><p>应用程序尝试读取或写入内存位置,并且地址对齐与加载/存储大小不匹配. 例如,32 位加载只能从 4 字节对齐的地址完成,而 16 位加载只能从 2 字节的对齐地址完成.</p>
<h3 id="LoadStoreError-加载-存储错误"><a href="#LoadStoreError-加载-存储错误" class="headerlink" title="LoadStoreError(加载/存储错误)"></a>LoadStoreError(加载/存储错误)</h3><p>应用程序尝试从仅支持 32 位加载/存储的内存区域进行 8 位或 16 位加载/存储. 例如,取消引用指向内存存储器的 <code>char *</code> 指针将导致这样的错误.</p>
<h3 id="Unhandled-debug-exception-堆栈错误"><a href="#Unhandled-debug-exception-堆栈错误" class="headerlink" title="Unhandled debug exception(堆栈错误)"></a>Unhandled debug exception(堆栈错误)</h3><p>通常会出现以下消息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Debug exception reason: Stack canary watchpoint triggered (task_name)</span><br></pre></td></tr></table></figure>

<p>此错误表示应用程序已写入 <code>task_name</code> 任务堆栈的末尾. 请注意,并非每个堆栈溢出都可以保证触发此错误. 任务可能会在堆栈 <code>canary</code> 位置之外写入堆栈,在这种情况下,不会触发观察点.</p>
<h3 id="Interrupt-wdt-timeout-on-CPU0-CPU1-看门狗超时"><a href="#Interrupt-wdt-timeout-on-CPU0-CPU1-看门狗超时" class="headerlink" title="Interrupt wdt timeout on CPU0 / CPU1(看门狗超时)"></a>Interrupt wdt timeout on CPU0 / CPU1(看门狗超时)</h3><p>表示发生了中断看门狗超时. 有关详细信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/wdts.html" target="_blank" rel="noopener">看门狗</a>.</p>
<h3 id="Cache-disabled-but-cached-memory-region-accessed-Cache-禁止"><a href="#Cache-disabled-but-cached-memory-region-accessed-Cache-禁止" class="headerlink" title="Cache disabled but cached memory region accessed(Cache 禁止)"></a>Cache disabled but cached memory region accessed(Cache 禁止)</h3><p>在某些情况下,ESP-IDF 将暂时禁止通过高速缓存访问外部 SPI Flash 和 SPI RAM. 例如,spi_flash API 用于读取/写入/擦除/mmap SPI Flash 区域. 在这些情况下,任务被挂起,并且未注册 <code>ESP_INTR_FLAG_IRAM</code> 的中断处理程序被禁用. 确保使用此标志注册的任何中断处理程序都具有 IRAM/DRAM 中的所有代码和数据. 有关更多详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/spi_flash.html#iram-safe-interrupt-handlers" target="_blank" rel="noopener">SPI Flash API 文档</a>.</p>
<h2 id="其他严重错误"><a href="#其他严重错误" class="headerlink" title="其他严重错误"></a>其他严重错误</h2><h3 id="Brownout-欠压"><a href="#Brownout-欠压" class="headerlink" title="Brownout(欠压)"></a>Brownout(欠压)</h3><p>ESP32 有一个内置的掉电检测器,默认启用. 如果电源电压低于安全水平,掉电检测器可以触发系统复位. 可以使用 <code>CONFIG_BROWNOUT_DET</code> 和 <code>CONFIG_BROWNOUT_DET_LVL_SEL</code> 选项配置掉电检测器. 当掉电检测器触发时,将打印以下消息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Brownout detector was triggered</span><br></pre></td></tr></table></figure>

<p>打印消息后,芯片将复位.</p>
<p>请注意,如果电源电压快速下降,则控制台上只能看到部分消息.</p>
<h3 id="Corrupt-Heap"><a href="#Corrupt-Heap" class="headerlink" title="Corrupt Heap"></a>Corrupt Heap</h3><p>ESP-IDF 堆实现包含许多堆结构的运行时检查. 可以在 menuconfig 中启用其他检查(“Heap Stisoning”). 如果其中一项检查失败,将打印类似于以下内容的消息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CORRUPT HEAP: Bad tail at 0x3ffe270a. Expected 0xbaad5678 got 0xbaac5678</span><br><span class="line">assertion &quot;head !&#x3D; NULL&quot; failed: file &quot;&#x2F;Users&#x2F;user&#x2F;esp&#x2F;esp-idf&#x2F;components&#x2F;heap&#x2F;multi_heap_poisoning.c&quot;, line 201, function: multi_heap_free</span><br><span class="line">abort() was called at PC 0x400dca43 on core 0</span><br></pre></td></tr></table></figure>

<p>有关详细信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/heap_debug.html" target="_blank" rel="noopener">堆内存调试文档</a>.</p>
<h3 id="Stack-Smashing"><a href="#Stack-Smashing" class="headerlink" title="Stack Smashing"></a>Stack Smashing</h3><p>可以使用 <code>CONFIG_STACK_CHECK_MODE</code> 选项在 ESP-IDF 中启用 Stack Smashing 保护(基于 GCC  <code>-fstack-protector *</code> 标志). 如果检测到 Stack Smashing,将打印类似于以下内容的消息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack smashing protect failure!</span><br><span class="line"></span><br><span class="line">abort() was called at PC 0x400d2138 on core 0</span><br><span class="line"></span><br><span class="line">Backtrace: 0x4008e6c0:0x3ffc1780 0x4008e8b7:0x3ffc17a0 0x400d2138:0x3ffc17c0 0x400e79d5:0x3ffc17e0 0x400e79a7:0x3ffc1840 0x400e79df:0x3ffc18a0 0x400e2235:0x3ffc18c0 0x400e1916:0x3ffc18f0 0x400e19cd:0x3ffc1910 0x400e1a11:0x3ffc1930 0x400e1bb2:0x3ffc1950 0x400d2c44:0x3ffc1a80</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>回溯应该指向 Stack Smashing 发生的函数. 检查功能代码以获得对本地阵列的无限制访问.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（八）Flash 加密</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%AB%EF%BC%89Flash%20%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="Flash-加密"><a href="#Flash-加密" class="headerlink" title="Flash 加密"></a>Flash 加密</h1><p>Flash 加密功能用于加密 ESP32 连接的 SPI  Flash 的内容。启用 Flash 加密后，通过物理方式读取 SPI Flash 的内容不足以恢复大多数 Flash 内容。</p>
<p>Flash 加密与安全启动功能是分离的，您可以使用 Flash 加密而无需启用<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html" target="_blank" rel="noopener">安全启动</a>。但是，我们建议将这两种功能一起用于安全的环境。在没有安全启动的情况下，需要执行其他配置以确保 Flash 加密的有效性。有关更多详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-without-secure-boot" target="_blank" rel="noopener">使用无安全启动的 Flash 加密</a>.</p>
<blockquote>
<p>启用闪存加密会限制您进一步更新 ESP32 的选项。请务必阅读本文档(包括 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-limitations" target="_blank" rel="noopener">Flash 加密限制</a>)并了解启用闪存加密的含义。</p>
</blockquote>
<a id="more"></a>

<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><ul>
<li><p>使用带有 256 位密钥的 AES 加密闪存的内容。闪存加密密钥存储在芯片内部的 efuse 中，并且(默认情况下)受软件访问保护。</p>
</li>
<li><p>通过 ESP32 的闪存缓存映射功能，Flash 访问是透明的 - 映射到地址空间的任何闪存区域在读取时都将被透明地解密。</p>
</li>
<li><p>通过使用明文数据烧录 ESP32 来应用加密，并且(如果启用了加密)引导加载程序会在首次启动时对数据进行加密。</p>
</li>
<li><p>并非所有闪存都是加密的。以下类型的闪存数据已加密:</p>
<ul>
<li><p>引导程序</p>
</li>
<li><p>安全启动引导加载程序摘要(如果启用了安全启动)</p>
</li>
<li><p>分区表</p>
</li>
<li><p>所有 “app” 类型分区</p>
</li>
<li><p>分区表中标有 “encrypted” 标志的任何分区</p>
<p> 可能希望一些数据分区保持未加密以便于访问，或者使用对于数据被加密时无效的闪存友好更新算法。由于 NVS 库与闪存加密不直接兼容，因此无法加密用于非易失性存储的 NVS 分区。有关更多详细信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html#nvs-encryption" target="_blank" rel="noopener">NVS 加密</a>。</p>
</li>
</ul>
</li>
<li><p>闪存加密密钥存储在 ESP32 芯片内部的 efuse 密钥块 1 中。默认情况下，此密钥具有读写保护功能，因此软件无法访问或更改密钥。</p>
</li>
<li><p>默认情况下，Efuse Block 1 编码方案为 “None”，并且在该块中存储 256 位密钥。在某些 ESP32 上，编码方案设置为 3/4 编码 (CODING_SCHEME efuse 的值为 1)，并且必须在该块中存储 192 位密钥。有关详细信息，请参见 《ESP32 技术参考手册》第 20.3.1.3 节 “系统参数 coding_scheme”。在所有情况下，算法都在 256 位密钥上运行，通过重复一些位（<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-algorithm" target="_blank" rel="noopener">具体细节</a>）来扩展  192 位密钥。当 <code>esptool.py</code> 连接到芯片或 <code>espefuse.py summary</code> 输出时，编码方案显示在 Features 行中。</p>
</li>
<li><p>闪存加密算法是 AES-256，其中密钥是“调整”的，每个 32 字节闪存块的偏移地址。这意味着每个 32 字节块(两个连续的 16 字节 AES 块)使用从闪存加密密钥派生的唯一密钥进行加密。</p>
</li>
<li><p>虽然芯片上运行的软件可以透明地解密闪存内容，但默认情况下，当启用闪存加密时，UART 引导加载程序无法解密(或加密)数据。</p>
</li>
<li><p>如果可以启用闪存加密，则编写<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#using-encrypted-flash" target="_blank" rel="noopener">使用加密闪存</a>的代码时，编程人员必须采取一定的预防措施。</p>
</li>
</ul>
<h2 id="2-Flash-加密初始化"><a href="#2-Flash-加密初始化" class="headerlink" title="2 Flash 加密初始化"></a>2 Flash 加密初始化</h2><p>这是默认(推荐) Flash 加密初始化过程。可以为开发或其他目的自定义此过程，有关详细信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-advanced-features" target="_blank" rel="noopener">Flash 加密高级功能</a>。</p>
<blockquote>
<p>在首次启动时启用闪存加密后，硬件通过串行重新闪存最多允许3次后续闪存烧录。必须遵循特殊过程(在<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#updating-encrypted-flash-serial" target="_blank" rel="noopener">串口烧录</a>中记录)才能执行这些更新。</p>
</blockquote>
<ul>
<li>如果启用了安全启动，则使用纯文本数据进行物理重新刷新需要“可重新映射”的安全启动摘要(请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-and-secure-boot" target="_blank" rel="noopener">Flash 加密和安全启动</a>)。</li>
<li>OTA 更新可用于更新 Flash 内容，而不计入此限制。</li>
<li>在开发中启用闪存加密时，请使用预生成的闪存加密密钥，以允许使用预加密数据进行无限次重新闪存。</li>
</ul>
<p>启用闪存加密的过程:</p>
<ul>
<li>必须在启用闪存加密支持的情况下编译引导加载程序。在 <code>make menuconfig</code> 中，导航到“安全功能”，然后选择“是”以“启动时启用闪存加密”。</li>
<li>如果同时启用安全启动，最好同时选择这些选项。首先阅读<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html" target="_blank" rel="noopener">安全启动</a>文档。</li>
<li>正常构建并刷新引导加载程序，分区表和工厂应用程序映像。这些分区最初写入未加密的闪存。</li>
</ul>
<blockquote>
<p>启用安全启动和闪存加密时，引导加载程序应用程序二进制 <code>bootloader.bin</code> 可能会变得太大。请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html#secure-boot-bootloader-size" target="_blank" rel="noopener">Bootloader 大小</a>。</p>
</blockquote>
<ul>
<li>首次启动时，引导加载程序会看到 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 设置为 0 (出厂默认值)，因此它使用硬件随机数生成器生成闪存加密密钥。该密钥存储在efuse中。密钥是读写保护，以防止进一步的软件访问。</li>
<li>然后，引导加载程序就地对所有加密分区进行加密。就地加密可能需要一些时间(对于大型分区，最多需要一分钟.)</li>
</ul>
<blockquote>
<p>第一次启动加密通道运行时，请勿中断ESP32的电源。如果电源中断，闪存内容将被破坏，并且需要再次使用未加密的数据烧录。像这样的重新烧录不会计入烧录限制。</p>
</blockquote>
<ul>
<li>烧录完成后。在 UART 引导加载程序运行时，激活(默认情况下)以禁用加密的闪存访问。有关高级详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#uart-bootloader-encryption" target="_blank" rel="noopener">启用 UART Bootloader 加密/解密</a>。</li>
<li><code>FLASH_CRYPT_CONFIG efuse</code> 也会被烧制到最大值(0xF)，以最大化闪存算法中调整的关键位数。有关高级详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#setting-flash-crypt-config" target="_blank" rel="noopener">设置 FLASH_CRYPT_CONFIG</a>。</li>
<li>最后，<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 以初始值 1 进行刻录。这个 efuse 激活透明闪存加密层，并限制后续重新刷新的次数。有关 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 的详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#updating-encrypted-flash" target="_blank" rel="noopener">更新加密的 Flash</a> 部分。</li>
<li>引导加载程序重置自身以重新加密的闪存重新引导。</li>
</ul>
<h2 id="3-使用加密的-Flash"><a href="#3-使用加密的-Flash" class="headerlink" title="3 使用加密的 Flash"></a>3 使用加密的 Flash</h2><p>ESP32 应用程序代码可以通过调用 <code>esp_flash_encryption_enabled()</code> 来检查当前是否启用了闪存加密。</p>
<p>启用闪存加密后，从代码访问闪存内容时需要注意一些事项。</p>
<h3 id="3-1-Flash-加密的范围"><a href="#3-1-Flash-加密的范围" class="headerlink" title="3.1 Flash 加密的范围"></a>3.1 Flash 加密的范围</h3><p>只要将 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 设置为设置了奇数位的值，就会透明地解密通过 MMU 的闪存缓存访问的所有闪存内容。这包括:</p>
<ul>
<li>Flash 中的可执行应用程序代码 (IROM)。</li>
<li>存储在闪存 (DROM) 中的所有只读数据。</li>
<li>通过 <code>esp_spi_flash_mmap()</code> 访问的任何数据。</li>
<li>ROM 引导加载程序读取软件引导加载程序映像。</li>
</ul>
<blockquote>
<p>MMU Flash 缓存无条件地解密所有数据。在闪存中未加密存储的数据将通过闪存缓存“透明地解密”，并且看起来像随机垃圾这样的软件。</p>
</blockquote>
<h3 id="3-2-读取加密的-Flash"><a href="#3-2-读取加密的-Flash" class="headerlink" title="3.2 读取加密的 Flash"></a>3.2 读取加密的 Flash</h3><p>要在不使用闪存缓存 MMU 映射的情况下读取数据，我们建议使用分区读取函数 <code>esp_partition_read()</code>。使用此功能时，只有从加密分区读取数据时才会解密数据。其他分区将以未加密方式读取。通过这种方式，软件可以以相同的方式访问加密和非加密的闪存。</p>
<p>通过其他 SPI 读取 APIs 读取的数据不会被解密:</p>
<ul>
<li>通过 <code>esp_spi_flash_read()</code> 读取的数据不会被解密</li>
<li>通过 ROM 函数 <code>SPIRead()</code> 读取的数据不会被解密 (esp-idf 应用程序不支持此功能)</li>
<li>使用非易失性存储 (NVS) API 存储的数据始终存储并读取解密。</li>
</ul>
<h3 id="3-3-写加密的-Flash"><a href="#3-3-写加密的-Flash" class="headerlink" title="3.3 写加密的 Flash"></a>3.3 写加密的 Flash</h3><p>在可能的情况下，我们建议使用分区写入函数 <code>esp_partition_write</code>。使用此功能时，只有在写入加密分区时才会加密数据。数据将被写入未加密的其他分区。通过这种方式，软件可以以相同的方式访问加密和非加密的闪存.</p>
<p>当 <code>write_encrypted</code> 参数设置为 true 时，<code>esp_spi_flash_write</code> 函数将写入数据。否则，数据将以未加密的方式写入.</p>
<p>ROM 函数 <code>esp_rom_spiflash_write_encrypted</code> 将加密数据写入闪存，ROM 函数 <code>SPIWrite</code> 将未加密写入闪存。(esp-idf 应用程序不支持这些功能).</p>
<p>未加密数据的最小写入大小为 4 个字节(对齐为 4 个字节)。由于数据是以块为单位加密的，因此加密数据的最小写入大小为 16 字节(对齐为16字节).</p>
<h2 id="4-更像加密的-Flash"><a href="#4-更像加密的-Flash" class="headerlink" title="4 更像加密的 Flash"></a>4 更像加密的 Flash</h2><h3 id="4-1-OTA-更新"><a href="#4-1-OTA-更新" class="headerlink" title="4.1 OTA 更新"></a>4.1 OTA 更新</h3><p>只要使用 <code>esp_partition_write</code> 函数，对加密分区的 OTA 更新将自动加密写入.</p>
<h3 id="4-2-串口烧录"><a href="#4-2-串口烧录" class="headerlink" title="4.2 串口烧录"></a>4.2 串口烧录</h3><p><code>FLASH_CRYPT_CNT efuse</code> 允许通过串口烧录(或其他物理方法)使用新的明文数据更新闪存，最多 3 次.</p>
<p>该过程涉及烧录明文数据，然后碰撞 <code>FLASH_CRYPT_CNT efuse</code> 的值，这会导致引导加载程序重新加密此数据.</p>
<h4 id="4-2-1-限制更新"><a href="#4-2-1-限制更新" class="headerlink" title="4.2.1 限制更新"></a>4.2.1 限制更新</h4><p>这种类型只有 4 个明文串行更新周期，包括初始加密闪存.</p>
<p>禁用第四次加密后，<code>FLASH_CRYPT_CNT efuse</code> 的最大值为 0xFF，永久禁用加密.</p>
<p>通过预生成的 Flash 加密密钥使用 OTA 更新或重新刷新可以超过此限制.</p>
<h4 id="4-2-2-串口烧录的注意事项"><a href="#4-2-2-串口烧录的注意事项" class="headerlink" title="4.2.2 串口烧录的注意事项"></a>4.2.2 串口烧录的注意事项</h4><ul>
<li>通过串口重新烧录时，重新刷新最初用明文数据写入的每个分区(包括 bootloader)。可以跳过不是“当前选择的” OTA 分区的应用程序分区(除非在那里找到明文应用程序映像，否则不会重新加密这些分区.)但是，标有“加密”标志的任何分区都将无条件地重新分区。加密，意味着任何已加密的数据将被加密两次并被破坏.<ul>
<li>使用 <code>make flash</code> 应烧录所有需要闪存的分区.</li>
</ul>
</li>
<li>如果启用了安全启动，则除非您使用“可重新启动”选项进行安全启动，否则无法通过串口重新刷新纯文本数据。请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-and-secure-boot" target="_blank" rel="noopener">Flash加密和安全启动</a>.</li>
</ul>
<h3 id="4-3-串口重新烧录程序"><a href="#4-3-串口重新烧录程序" class="headerlink" title="4.3 串口重新烧录程序"></a>4.3 串口重新烧录程序</h3><ul>
<li>正常的构建应用程序.</li>
<li>正常的使用明文数据刷新设备 (make flash 或 esptool.py 命令.)闪存所有先前加密的分区，包括引导加载程序(参见上一节).</li>
<li>此时，设备将无法启动(消息为 flash read err，1000)，因为它希望看到加密的引导加载程序，但引导加载程序是纯文本.</li>
<li>通过运行命令 <code>espefuse.py burn_efuse FLASH_CRYPT_CNT</code> 来刻录 <code>FLASH_CRYPT_CNT efuse</code>。 <code>espefuse.py</code> 会自动将位数递增 1，从而禁用加密.</li>
<li>重置设备，它将重新加密明文分区，然后再次刻录 <code>FLASH_CRYPT_CNT efuse</code> 以重新启用加密.</li>
</ul>
<h4 id="4-3-1-禁用串口更新"><a href="#4-3-1-禁用串口更新" class="headerlink" title="4.3.1 禁用串口更新"></a>4.3.1 禁用串口更新</h4><p>要防止通过串口进行进一步的明文更新，请在启用闪存加密后(即首次启动完成后)使用 <code>espefuse.py</code> 写保护 <code>FLASH_CRYPT_CNT efuse</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espefuse.py --port PORT write_protect_efuse FLASH_CRYPT_CNT</span><br></pre></td></tr></table></figure>

<p>这可以防止进一步修改以禁用或重新启用闪存加密.</p>
<h3 id="4-4-通过预生成的-Flash-加密密钥重新烧录"><a href="#4-4-通过预生成的-Flash-加密密钥重新烧录" class="headerlink" title="4.4 通过预生成的 Flash 加密密钥重新烧录"></a>4.4 通过预生成的 Flash 加密密钥重新烧录</h3><p>可以在主机上预生成闪存加密密钥，并将其刻录到 ESP32 的 efuse 密钥块中。这允许数据在主机上预加密并烧录到 ESP32，而无需明文闪存更新.</p>
<p>这对于开发很有用，因为它消除了 4 次刷新限制。它还允许在启用安全启动的情况下重新刷新应用程序，因为每次都不需要重新启动引导加载程序.</p>
<blockquote>
<p>此方法仅用于协助开发，而不用于生产设备。如果为生产预生成闪存加密，请确保密钥是从高质量的随机数源生成的，并且不要跨多个设备共享相同的闪存加密密钥.</p>
</blockquote>
<h4 id="4-4-1-预生成-Flash-加密密钥"><a href="#4-4-1-预生成-Flash-加密密钥" class="headerlink" title="4.4.1 预生成 Flash 加密密钥"></a>4.4.1 预生成 Flash 加密密钥</h4><p>Flash 加密密钥是 32 字节的随机数据。您可以使用 <code>espsecure.py</code> 生成随机密钥:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure>

<p>(这些数据的随机性仅与操作系统一样好，而且是Python安装的随机数据源.)</p>
<p>或者，如果您使用安全启动并具有安全启动签名密钥，则可以生成安全启动专用签名密钥的确定性SHA-256摘要，并将其用作闪存加密密钥:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espsecure.py digest_private_key --keyfile secure_boot_signing_key.pem my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure>

<p>(如果为安全启动启用可重新映射模式，则使用相同的 32 个字节作为安全启动摘要键.)</p>
<p>以这种方式从安全启动签名密钥生成闪存加密密钥意味着您只需要存储一个密钥文件。然而，该方法根本不适用于生产设备.</p>
<h4 id="4-4-2-刻录-Flash-加密密钥"><a href="#4-4-2-刻录-Flash-加密密钥" class="headerlink" title="4.4.2 刻录 Flash 加密密钥"></a>4.4.2 刻录 Flash 加密密钥</h4><p>生成闪存加密密钥后，需要将其刻录到 ESP32 的 efuse 密钥块。这必须在首次加密启动之前完成，否则 ESP32 将生成软件无法访问或修改的随机密钥.</p>
<p>要将密钥刻录到设备(仅限一次):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espefuse.py --port PORT burn_key flash_encryption my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure>

<h4 id="4-4-3-带有预生成密钥的第一次烧录"><a href="#4-4-3-带有预生成密钥的第一次烧录" class="headerlink" title="4.4.3 带有预生成密钥的第一次烧录"></a>4.4.3 带有预生成密钥的第一次烧录</h4><p>烧录密钥后，按照与默认 Flash 加密初始化相同的步骤操作，并为第一次启动时刷新纯文本图像。引导加载程序将使用预先烧制的密钥启用闪存加密并加密所有分区.</p>
<h4 id="4-4-4-使用预生成密钥重新烧录"><a href="#4-4-4-使用预生成密钥重新烧录" class="headerlink" title="4.4.4 使用预生成密钥重新烧录"></a>4.4.4 使用预生成密钥重新烧录</h4><p>在首次启动时启用加密后，重新烧录加密镜像需要额外的手动步骤。这是我们预先加密我们希望在闪存中更新的数据的地方.</p>
<p>假设这是用于刷新明文数据的常规命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esptool.py --port &#x2F;dev&#x2F;ttyUSB0 --baud 115200 write_flash 0x10000 build&#x2F;my-app.bin</span><br></pre></td></tr></table></figure>

<p>二进制应用程序映像 build/my-app.bin 写入偏移量 0x10000。此文件名和偏移量需要用于加密数据，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espsecure.py encrypt_flash_data --keyfile my_flash_encryption_key.bin --address 0x10000 -o build&#x2F;my-app-encrypted.bin build&#x2F;my-app.bin</span><br></pre></td></tr></table></figure>

<p>此示例命令将使用提供的密钥加密 my-app.bin，并生成加密文件 my-app-encrypted.bin。确保 address 参数与计划闪存二进制文件的地址匹配.</p>
<p>然后，使用esptool.py刷新加密的二进制文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esptool.py --port &#x2F;dev&#x2F;ttyUSB0 --baud 115200 write_flash 0x10000 build&#x2F;my-app-encrypted.bin</span><br></pre></td></tr></table></figure>

<p>不需要进一步的步骤或 efuse 操作，因为我们闪存时数据已经加密.</p>
<h2 id="5-禁用-Flash-加密"><a href="#5-禁用-Flash-加密" class="headerlink" title="5 禁用 Flash 加密"></a>5 禁用 Flash 加密</h2><p>如果由于某种原因意外启用了闪存加密，则下一次明文数据闪存将使ESP32软化(设备将连续重启，打印错误闪存读错误， 1000).</p>
<p>您可以通过编写 <code>FLASH_CRYPT_CNT efuse</code> 再次禁用闪存加密:</p>
<ul>
<li>首先，运行 <code>make menuconfig</code> 并取消选中“安全功能”下的“启用闪存加密启动”.</li>
<li>退出 <code>menuconfig</code> 并保存新配置.</li>
<li>再次运行 <code>make menuconfig</code> 并仔细检查你是否真的禁用了这个选项！ 如果启用此选项，则引导加载程序将在引导时立即重新启用加密.</li>
<li>运行 <code>make flash</code> 以构建并刷新新的引导加载程序和应用程序，而不启用闪存加密.</li>
<li>运行 <code>espefuse.py</code> (在 components/esptool_py/esptool 中)以禁用 <code>FLASH_CRYPT_CNT efuse</code>)::</li>
</ul>
<p>重置 ESP32 并禁用闪存加密，引导加载程序将正常启动.</p>
<h2 id="6-Flash-加密的局限性"><a href="#6-Flash-加密的局限性" class="headerlink" title="6 Flash 加密的局限性"></a>6 Flash 加密的局限性</h2><p>Flash 加密可防止加密闪存的明文读出，从而保护固件免受未经授权的读取和修改.了解闪存加密系统的局限性非常重要:</p>
<ul>
<li>Flash 加密仅与密钥一样强大.因此，我们建议在首次启动时在设备上生成密钥(默认行为).如果在设备外生成密钥(请参阅通过预生成的 Flash 加密密钥重新刷新)，请确保遵循正确的步骤.</li>
<li>并非所有数据都是加密存储的.如果在闪存上存储数据，请检查您使用的方法(库，API 等)是否支持闪存加密.</li>
<li>Flash 加密不会阻止攻击者理解闪存的高级布局.这是因为相同的 AES 密钥用于每对相邻的 16 字节 AES 块.当这些相邻的 16 字节块包含相同的内容(例如空或填充区域)时，这些块将加密以产生匹配的加密块对.这可能允许攻击者在加密设备之间进行高级别比较(即判断两个设备是否可能运行相同的固件版本).</li>
<li>出于同样的原因，攻击者总能知道一对相邻的 16 字节块 (32 字节对齐)何时包含相同的内容.如果将敏感数据存储在闪存中，请记住这一点，设计闪存存储器，以免发生这种情况(使用计数器字节或每 16 字节一些其他不相同的值就足够了).</li>
</ul>
<h2 id="7-Flash-加密和安全启动"><a href="#7-Flash-加密和安全启动" class="headerlink" title="7 Flash 加密和安全启动"></a>7 Flash 加密和安全启动</h2><p>建议一起使用闪存加密和安全启动。但是，如果启用了安全启动，则重新刷新设备会有其他限制:</p>
<ul>
<li>OTA 更新不受限制(前提是新应用程序使用安全启动签名密钥正确签名).</li>
<li>只有选择了 Reflashable Secure Boot 模式并且预先生成安全启动密钥并将其刻录到 ESP32 (参见安全启动文档)，才能进行明文串口烧录更新。在此配置中， make bootloader 将生成预先消化的引导加载程序和安全引导摘要文件，以便在偏移量 0x0 处烧录。当遵循明文串行重新刷新步骤时，必须在烧录其他明文数据之前重新刷新该文件.</li>
<li>如果未重新启动引导加载程序，仍可以通过预生成的 Flash 加密密钥重新刷新。重新刷新引导加载程序需要在安全引导配置中启用相同的 Reflashable 选项.</li>
</ul>
<h2 id="8-使用没有安全启动的-Flash-加密"><a href="#8-使用没有安全启动的-Flash-加密" class="headerlink" title="8 使用没有安全启动的 Flash 加密"></a>8 使用没有安全启动的 Flash 加密</h2><p>如果在没有安全启动的情况下使用闪存加密，则可以使用串行重新烧录加载未经授权的代码。有关详细信息，请参阅串行烧录 然后，这个未授权的代码可以读取所有加密的分区(以解密的形式)，使闪存加密无效。这可以通过写保护 <code>FLASH_CRYPT_CNT efuse</code> 来避免，从而禁止串口重新烧录。FLASH_CRYPT_CNT可以使用命令对efuse进行写保护:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espefuse.py --port PORT write_protect_efuse FLASH_CRYPT_CNT</span><br></pre></td></tr></table></figure>

<p>或者，应用程序可以在其启动过程中调用 <code>esp_flash_write_protect_crypt_cnt()</code>.</p>
<h2 id="9-Flash-加密高级功能"><a href="#9-Flash-加密高级功能" class="headerlink" title="9 Flash 加密高级功能"></a>9 Flash 加密高级功能</h2><p>以下信息对于高级使用闪存加密非常有用:</p>
<h3 id="9-1-加密分区标志"><a href="#9-1-加密分区标志" class="headerlink" title="9.1 加密分区标志"></a>9.1 加密分区标志</h3><p>某些分区默认是加密的。否则，可以将任何分区标记为需要加密:</p>
<p>在分区表描述 CSV 文件中，有一个标志字段.</p>
<p>通常留空，如果在此字段中写入 “encrypted” ，则分区将在分区表中标记为已加密，此处写入的数据将被视为已加密(与应用程序分区相同):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000</span><br><span class="line">factory,  app,  factory, 0x10000, 1M</span><br><span class="line">secret_data, 0x40, 0x01, 0x20000, 256K, encrypted</span><br></pre></td></tr></table></figure>

<ul>
<li>默认分区表都不包含任何加密数据分区.</li>
<li>没有必要将 “app” 分区标记为已加密，它们始终被视为已加密.</li>
<li>如果未启用闪存加密，则“加密”标志不执行任何操作.</li>
<li>如果您希望保护此数据不受物理访问读取或修改的影响，则可以将 phy_init 数据标记为可选的phy分区.</li>
<li>无法将 nvs 分区标记为已加密.</li>
</ul>
<h3 id="9-2-启用-UART-Bootloader-加密-解密"><a href="#9-2-启用-UART-Bootloader-加密-解密" class="headerlink" title="9.2 启用 UART Bootloader 加密/解密"></a>9.2 启用 UART Bootloader 加密/解密</h3><p>默认情况下，首次启动时，闪存加密过程将刻录 <code>DISABLE_DL_ENCRYPT</code> ， <code>DISABLE_DL_DECRYPT</code> 和 <code>DISABLE_DL_CACHE</code> :</p>
<p>在 UART 引导加载程序引导模式下运行时， <code>DISABLE_DL_ENCRYPT</code> 禁用闪存加密操作.<br> <code>DISABLE_DL_DECRYPT</code> 在 UART 引导加载程序模式下运行时禁用透明闪存解密，即使 <code>FLASH_CRYPT_CNT efuse</code> 设置为在正常操作中启用它也是如此.<br>在 UART 引导加载程序模式下运行时， <code>DISABLE_DL_CACHE</code> 禁用整个 MMU 闪存缓存.<br>可以仅刻录其中一些 efuses，并在第一次引导之前对其余部分进行写保护(使用未设置值 0)，以便保留它们。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espefuse.py --port PORT burn_efuse DISABLE_DL_DECRYPT</span><br><span class="line">espefuse.py --port PORT write_protect_efuse DISABLE_DL_ENCRYPT</span><br></pre></td></tr></table></figure>

<p>(注意，这些 efuse 中的所有 3 个都是通过一个写保护位禁用的，因此写保护将保护所有这些保护位.因此，在写保护之前必须设置任何位.)</p>
<blockquote>
<p>由于 esptool.py 不支持写入或读取加密闪存，因此写保护这些 efuse 以保持它们不被设置目前不是非常有用.</p>
</blockquote>
<blockquote>
<p>如果未设置 <code>DISABLE_DL_DECRYPT(0)</code>， 这有效地使闪存加密无效，因为具有物理访问权限的攻击者可以使用UART引导加载程序模式(使用自定义存根代码)来读取闪存内容.</p>
</blockquote>
<h3 id="9-3-设置-FLASH-CRYPT-CONFIG"><a href="#9-3-设置-FLASH-CRYPT-CONFIG" class="headerlink" title="9.3 设置 FLASH_CRYPT_CONFIG"></a>9.3 设置 <code>FLASH_CRYPT_CONFIG</code></h3><p><code>FLASH_CRYPT_CONFIG efuse</code> 确定闪存加密密钥中用块偏移“调整”的位数。有关详细信息，请参阅 Flash 加密算法.</p>
<p>引导加载程序的首次引导始终将此值设置为最大 0xF.</p>
<p>可以手动编写这些 efuse， 并在首次启动之前写保护，以便选择不同的调整值。不建议这样做.</p>
<p>强烈建议在值为零时永远不要写保护 <code>FLASH_CRYPT_CONFIG</code>。如果此 efuse 设置为零，则不会调整闪存加密密钥中的任何位，并且闪存加密算法等同于 AES ECB 模式.</p>
<h2 id="10-技术细节"><a href="#10-技术细节" class="headerlink" title="10 技术细节"></a>10 技术细节</h2><p>以下部分提供有关闪存加密操作的一些参考信息.</p>
<h3 id="10-1-FLASH-CRYPT-CNT-efuse"><a href="#10-1-FLASH-CRYPT-CNT-efuse" class="headerlink" title="10.1 FLASH_CRYPT_CNT efuse"></a>10.1 <code>FLASH_CRYPT_CNT efuse</code></h3><p><code>FLASH_CRYPT_CNT</code> 是一个 8 位 efuse 字段，用于控制闪存加密。Flash 加密根据此 efuse 中设置为 “1” 的位数启用或禁用:</p>
<ul>
<li>设置偶数位 (0,2,4,6,8) 时:禁用闪存加密，无法解密任何加密数据.<ul>
<li>如果引导加载程序是使用“启动时启用闪存加密”构建的，那么它将看到这种情况并立即重新加密闪存，无论它何时找到未加密的数据.完成后，它会将 efuse 中的另一位设置为 “1”，这意味着现在设置了奇数个位.<ul>
<li>在第一次纯文本引导时，位计数具有全新值 0，并且引导加载程序在加密后将其更改为位计数 1 (值 0x01).</li>
<li>在下一次明文闪存更新后，将位计数手动更新为 2 (值 0x03).重新加密引导加载程序后，将 efuse 位计数更改为 3 (值 0x07).</li>
<li>在下一个明文闪存之后，将位计数手动更新为 4 (值 0x0F).重新加密引导加载程序后，将 efuse 位计数更改为 5 (值 0x1F).</li>
<li>在最后的明文闪存之后，位计数被手动更新为 6 (值 0x3F).重新加密引导加载程序后，将 efuse 位计数更改为7 (值 0x7F).</li>
</ul>
</li>
</ul>
</li>
<li>设置奇数位 (1,3,5,7) 时:启用透明读取加密闪存.</li>
<li>设置完所有 8 位后(efuse 值 0xFF):禁用透明读取加密闪存，永久无法访问任何加密数据。Bootloader 通常会检测到这种情况并停止.为避免使用此状态加载未经授权的代码，必须使用安全引导或 <code>FLASH_CRYPT_CNT efuse</code> 必须写保护.</li>
</ul>
<h3 id="10-2-Flash-加密算法"><a href="#10-2-Flash-加密算法" class="headerlink" title="10.2 Flash 加密算法"></a>10.2 Flash 加密算法</h3><ul>
<li><p>AES-256 以 16 字节数据块运行.闪存加密引擎以 32 字节块，两个串联的 AES 块加密和解密数据.</p>
</li>
<li><p>AES 算法在闪存加密中反转使用，因此闪存加密“加密”操作是 AES 解密，“解密”操作是AES加密.这是出于性能原因，并未改变算法的有效性.</p>
</li>
<li><p>主闪存加密密钥存储在 efuse(BLOCK1) 中，默认情况下不受进一步写入或软件读取的影响.</p>
</li>
<li><p>每个 32 字节块(两个相邻的 16 字节 AES 块)使用唯一密钥加密.密钥源自efuse中的主闪存加密密钥，与闪存中该块的偏移量进行异或(“键调整”).</p>
</li>
<li><p>具体的调整取决于 <code>FLASH_CRYPT_CONFIG efuse</code> 的设置.这是一个 4 位 efuse， 其中每个位都能对特定范围的关键位进行异或运算:</p>
<ul>
<li>位 1， 该值的 0-66 位被异或.</li>
<li>位 2， 该值的 67-131 位被异或.</li>
<li>位 3， 该值的 132-194 被异或.</li>
<li>位 4， 该值的 195-256 位被异或.<br>建议始终保留 <code>FLASH_CRYPT_CONFIG</code> 以设置默认值 0xF，以便所有关键位与块偏移进行异或.有关详细信息，请参阅设置 <code>FLASH_CRYPT_CONFIG</code>.</li>
</ul>
</li>
<li><p>块偏移的高 19 位(第 5 位到第 23 位)与主闪存加密密钥进行异或.选择此范围有两个原因:最大闪存大小为 16MB(24 位)，每个块为 32 字节，因此最低有效 5 位 始终为零.</p>
</li>
<li><p>从 19 个块偏移位中的每一个到闪存加密密钥的 256 位存在特定映射，以确定哪个位与哪个位进行异或.请参阅 espsecure.py 源代码中的变量 <code>_FLASH_ENCRYPTION_TWEAK_PATTERN</code> 以获取完整的映射.</p>
</li>
<li><p>要查看 Python 中实现的完整闪存加密算法，请参阅 espsecure.py 源代码中的 <code>_flash_encryption_operation()</code> 函数.</p>
</li>
</ul>
<h2 id="11-参考资料"><a href="#11-参考资料" class="headerlink" title="11 参考资料"></a>11 参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（六）深度睡眠唤醒存根</title>
    <url>/InfiniteYuanBlog/2018/09/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E7%9D%A1%E7%9C%A0%E5%94%A4%E9%86%92%E5%AD%98%E6%A0%B9/</url>
    <content><![CDATA[<h1 id="深度睡眠唤醒存根"><a href="#深度睡眠唤醒存根" class="headerlink" title="深度睡眠唤醒存根"></a>深度睡眠唤醒存根</h1><p>ESP32 支持在深度睡眠时运行“深度睡眠唤醒存根”。芯片唤醒后立即运行此功能 - 在任何正常初始化，引导加载程序或 ESP-IDF 代码运行之前。唤醒存根运行后，SoC 可以返回休眠状态或继续正常启动 ESP-IDF。</p>
<p>深度睡眠唤醒存根代码被加载到“RTC 快速存储器”中，它使用的任何数据也必须加载到 RTC 存储器中。RTC 存储区域在深度睡眠期间保持其内容。</p>
<a id="more"></a>

<h2 id="唤醒存根规则"><a href="#唤醒存根规则" class="headerlink" title="唤醒存根规则"></a>唤醒存根规则</h2><p>必须仔细编写唤醒存根代码:</p>
<ul>
<li>由于 SoC 刚刚从睡眠状态中醒来，大多数外设都处于复位状态。SPI Flash 未映射。</li>
<li>唤醒存根代码只能调用 ROM 中或加载到 RTC 快速存储器中实现的功能(见下文)。</li>
<li>唤醒存根代码只能访问 RTC 存储器中加载的数据。所有其他 RAM 将无法使用并具有随机内容。唤醒存根可以使用其他 RAM 进行临时存储，但是当 SoC 重新进入休眠状态或启动 ESP-IDF 时,内容将被覆盖。</li>
<li>RTC 内存必须包含存根使用的任何只读数据(.rodata)。</li>
<li>每当 SoC 重新启动时，RTC 存储器中的数据都会被初始化，除非从深度睡眠中唤醒。从深度睡眠中醒来时，保持睡眠前存在的值。</li>
<li>唤醒存根代码是 esp-idf 应用程序的一部分。在 esp-idf 的正常运行期间，函数可以调用唤醒存根函数或访问 RTC 存储器。就好像这些是应用程序的常规部分。</li>
</ul>
<h2 id="实现存根"><a href="#实现存根" class="headerlink" title="实现存根"></a>实现存根</h2><p>esp-idf 中的唤醒存根的函数 <code>esp_wake_deep_sleep()</code>。只要 SoC 从深度睡眠中唤醒，该函数就会运行。esp-idf 中提供了此函数的默认版本，但默认函数是弱链接的，因此如果您的应用程序包含名为 <code>esp_wake_deep_sleep()</code> 的函数，那么这将覆盖这个默认版本。</p>
<p>如果提供自定义唤醒存根，它首先要做的就是调用 <code>esp_default_wake_deep_sleep()</code>。</p>
<p>没有必要在您的应用程序中实现 <code>esp_wake_deep_sleep()</code> 以使用深度睡眠。只有你想在唤醒时立即有特殊行为才有必要。</p>
<p>如果要在运行时在不同的深度睡眠存根之间进行交换，也可以通过调用 <code>esp_set_deep_sleep_wake_stub()</code> 函数来执行此操作。如果仅使用默认的 <code>esp_wake_deep_sleep()</code> 函数，则不需要这样做。</p>
<p>所有这些函数都在 components/esp32 下的 <code>esp_deepsleep.h</code> 头文件中声明。</p>
<h2 id="将代码加载到-RTC-内存中"><a href="#将代码加载到-RTC-内存中" class="headerlink" title="将代码加载到 RTC 内存中"></a>将代码加载到 RTC 内存中</h2><p>唤醒存根代码必须驻留在 RTC 快速存储器中。这可以通过两种方式之一完成。</p>
<p>第一种方法是使用 <code>RTC_IRAM_ATTR</code> 属性将函数放入 RTC 内存:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RTC_IRAM_ATTR esp_wake_deep_sleep(void) &#123;</span><br><span class="line">    esp_default_wake_deep_sleep();</span><br><span class="line">    &#x2F;&#x2F; Add additional functionality here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法是将函数放入名称以 <code>rtc_wake_stub</code> 开头的任何源文件中。文件名 <code>rtc_wake_stub *</code> 中其内容将通过链接器自动放入 <code>RTC</code> 存储器中。</p>
<p>对于非常简短的代码，或者对于要混合“普通”和 “RTC” 代码的源文件，第一种方法更简单。当你想为 <code>RTC</code> 内存编写更长的代码时，第二种方法更简单。</p>
<h2 id="将数据加载到-RTC-内存中"><a href="#将数据加载到-RTC-内存中" class="headerlink" title="将数据加载到 RTC 内存中"></a>将数据加载到 RTC 内存中</h2><p>存根代码使用的数据必须驻留在 <code>RTC</code> 慢速存储器中。ULP 也使用该存储器。</p>
<p>可以通过以下两种方式之一来指定此数据:</p>
<p>第一种方法是使用 <code>RTC_DATA_ATTR</code> 和 <code>RTC_RODATA_ATTR</code> 来指定应加载到 RTC 慢速内存中的任何数据(可写或只读，相应):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTC_DATA_ATTR int wake_count;</span><br><span class="line"></span><br><span class="line">void RTC_IRAM_ATTR esp_wake_deep_sleep(void) &#123;</span><br><span class="line">    esp_default_wake_deep_sleep();</span><br><span class="line">    static RTC_RODATA_ATTR const char fmt_str[] &#x3D; &quot;Wake count %d\n&quot;;</span><br><span class="line">    ets_printf(fmt_str, wake_count++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过名为 <code>CONFIG_ESP32_RTCDATA_IN_FAST_MEM</code> 的 menuconfig 选项配置放置此数据的 RTC 存储区。此选项允许为 ULP 程序保留较慢的存储区域，一旦启用，标记为 <code>RTC_DATA_ATTR</code> 和 <code>RTC_RODATA_ATTR</code> 的数据将被放置在 RTC 快速存储器段中，否则将转至 RTC 慢速存储器（默认选项）。此选项取决于 <code>CONFIG_FREERTOS_UNICORE</code>，因为 RTC 快速存储器只能由 PRO_CPU 访问。</p>
<p>类似的属性 <code>RTC_FAST_ATTR</code> 和 <code>RTC_SLOW_ATTR</code> 用于指定将数据分别强制放入 <code>RTC_FAST</code> 和 <code>RTC_SLOW</code> 存储器。<code>PRO_CPU</code> 仅允许对标记为 <code>RTC_FAST_ATTR</code> 的数据进行访问，并且用户有责任确保它。</p>
<p>不幸的是，以这种方式使用的任何字符串常量必须声明为数组并用 <code>RTC_RODATA_ATTR</code> 标记，如上例所示。</p>
<p>第二种方法是将数据放入名称以 <code>rtc_wake_stub</code> 开头的任何源文件中。</p>
<p>例如，<code>rtc_wake_stub_counter.c</code> 中的等效示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int wake_count;</span><br><span class="line"></span><br><span class="line">void RTC_IRAM_ATTR esp_wake_deep_sleep(void) &#123;</span><br><span class="line">    esp_default_wake_deep_sleep();</span><br><span class="line">    ets_printf(&quot;Wake count %d\n&quot;, wake_count++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您需要使用字符串或编写其他更复杂的代码，第二种方法是更好的选择。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十一）高级中断</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E9%AB%98%E7%BA%A7%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h1 id="高级中断"><a href="#高级中断" class="headerlink" title="高级中断"></a>高级中断</h1><p>Xtensa 架构支持 32 个中断,分为 8 个级别,以及各种异常. 在 ESP32 上,中断复用器允许使用<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/intr_alloc.html" target="_blank" rel="noopener">中断分配器</a>将大多数中断源路由到这些中断. 通常,中断将以 C 语言写入,但 ESP-IDF 也允许在汇编中写入高级中断,从而允许非常低的中断延迟.</p>
<a id="more"></a>

<h2 id="中断级别"><a href="#中断级别" class="headerlink" title="中断级别"></a>中断级别</h2><table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">标识</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">N/A</td>
<td align="center">异常和0级中断. 由 ESP-IDF 处理</td>
</tr>
<tr>
<td align="center">2-3</td>
<td align="center">N/A</td>
<td align="center">中级中断. 由 ESP-IDF 处理</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">xt_highint4</td>
<td align="center">通常由 ESP-IDF 调试逻辑使用</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">xt_highint4</td>
<td align="center">随意使用</td>
</tr>
<tr>
<td align="center">NMI</td>
<td align="center">xt_nmi</td>
<td align="center">随意使用</td>
</tr>
<tr>
<td align="center">dbg</td>
<td align="center">xt_debugexception</td>
<td align="center">调试异常. 被称为例如 BREAK 指令.</td>
</tr>
</tbody></table>
<p>使用这些标识是通过创建一个程序集文件(后缀 .S)并定义命名符号来完成的,如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    .section .iram1,&quot;ax&quot;</span><br><span class="line">    .global     xt_highint5</span><br><span class="line">    .type       xt_highint5,@function</span><br><span class="line">    .align      4</span><br><span class="line">xt_highint5:</span><br><span class="line">    ... your code here</span><br><span class="line">    rsr     a0, EXCSAVE_5</span><br><span class="line">    rfi     5</span><br></pre></td></tr></table></figure>

<p>有关实际示例,请参阅 <code>components/esp32/panic_highint_hdl.S</code> 文件; Panic 处理程序中断在那里实现.</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>不要从高级别中断调用 C 代码; 因为这些中断仍然在关键部分运行,这可能会导致崩溃. (恐慌处理程序中断会调用正常的C代码,但这没关系,因为之后无意返回正常的代码流.)</p>
</li>
<li><p>确保汇编代码被链接.如果中断处理程序符号是代码中其余代码使用的唯一符号,则链接器将采用默认的ISR,而不是将程序集文件链接到最终项目. 要解决此问题,请在汇编文件中定义符号,如下所示：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     .global ld_include_my_isr_file</span><br><span class="line">ld_include_my_isr_file:</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>(此符号在此处称为 <code>ld_include_my_isr_file</code>,但可以具有未在其他任何位置定义的任意名称.)然后,在 <code>component.mk</code> 中,将此文件作为未解析的符号添加到 ld 命令行参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_ADD_LDFLAGS :&#x3D; -u ld_include_my_isr_file</span><br></pre></td></tr></table></figure>

<p>这应该导致链接器始终包含定义 <code>ld_include_my_isr_file</code> 的文件,从而导致始终链接 ISR.</p>
<ul>
<li>可以使用 <code>esp_intr_alloc</code> 和相关函数路由和处理高级中断. 但是,<code>esp_intr_alloc</code> 的处理程序和处理程序参数必须为 NULL.</li>
<li>理论上,中等优先级中断也可以这种方式处理. 目前, ESP-IDF 不支持这一点.</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/hlinterrupts.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十三）外部 RAM</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%A4%96%E9%83%A8%20RAM/</url>
    <content><![CDATA[<h1 id="外部-RAM"><a href="#外部-RAM" class="headerlink" title="外部 RAM"></a>外部 RAM</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ESP32 有几百 KiB 的内部 RAM，与 ESP32 的其余部分位于同一个芯片上。 出于某些目的，这是不够的，因此ESP32还能够使用高达 4MB 的外部 SPI RAM 存储器作为存储器。 外部存储器包含在存储器映射中，并且在某些限制内，可以与内部数据 RAM 相同的方式使用。</p>
<a id="more"></a>

<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>ESP32 支持与 SPI Flash 芯片并联的SPI（P）SRAM。 虽然 ESP32 能够支持多种类型的 RAM 芯片，但 ESP32 SDK 目前仅支持 ESP-PSRAM32 芯片。</p>
<p>ESP-PSRAM32 芯片是 1.8V 器件，只能与 1.8V 闪存器件并联使用。 确保在启动时将 MTDI 引脚设置为高信号电平，或者将 ESP32 中的保险丝编程为始终使用 1.8V 的 VDD_SIO 电平。 不这样做有损坏 PSRAM 和/或 Flash 芯片的风险。</p>
<p><strong>要将 ESP-PSRAM 芯片连接到 ESP32D0W *，请连接以下信号：</strong></p>
<ul>
<li>PSRAM /CE (pin 1) - ESP32 GPIO 16</li>
<li>PSRAM SO (pin 2) - flash DO</li>
<li>PSRAM SIO[2] (pin 3) - flash WP</li>
<li>PSRAM SI (pin 5) - flash DI</li>
<li>PSRAM SCLK (pin 6) - ESP32 GPIO 17</li>
<li>PSRAM SIO[3] (pin 7) - flash HOLD</li>
<li>PSRAM Vcc (pin 8) - ESP32 VCC_SDIO</li>
</ul>
<p>ESP32D2W * 芯片的连接是 TBD。</p>
<blockquote>
<p>Espressif 销售 ESP-WROVER 模块，该模块包含 ESP32,1.8V Flash 和集成在模块中的 ESP-PSRAM32，可以包含在最终产品 PCB 中。</p>
</blockquote>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p><strong>ESP-IDF 完全支持将外部存储器集成到您的应用程序中。 ESP-IDF 可以配置为以多种方式处理外部 RAM：</strong></p>
<ul>
<li>只初始化 RAM。 这允许应用程序通过解除指向外部 RAM 存储器区域（0x3F800000 及以上）的指针来手动放置数据。</li>
<li>初始化 RAM 并将其添加到功能分配器。 这允许程序使用 <code>heap_caps_malloc（size，MALLOC_CAP_SPIRAM）</code> 专门分配一块外部 RAM。 可以使用此内存，然后使用正常的 <code>free（）</code> 调用释放。</li>
<li>初始化 RAM，将其添加到功能分配器，并将内存添加到可由 <code>malloc（）</code> 返回的 RAM 池中。 这允许任何应用程序使用外部 RAM 而无需重写代码以使用 <code>heap_caps_malloc</code>。</li>
</ul>
<p>可以从 menuconfig 菜单中选择所有这些选项。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p><strong>使用外部 RAM 有一些限制：</strong></p>
<ul>
<li>禁用闪存缓存时（例如，因为正在写闪存），外部 RAM 也变得无法访问;对它的任何读取或写入都将导致非法的缓存访问异常。这也是 ESP-IDF 永远不会在外部 RAM 中分配任务堆栈的原因。</li>
<li>外部 RAM 不能用作存储 DMA 事务描述符的位置，也不能用作 DMA 传输的读取或写入缓冲区。必须使用 <code>heap_caps_malloc（size，MALLOC_CAP_DMA）</code> 分配将与 DMA 结合使用的任何缓冲区（并且可以使用标准的 <code>free（）</code> 调用释放。）</li>
<li>外部 RAM 使用与外部闪存相同的缓存区域。这意味着外部 RAM 中经常访问的变量几乎可以像内部 RAM 一样快速地读取和修改。但是，当访问大块数据（&gt;32K）时，缓存可能不足，速度将回落到外部 RAM 的访问速度。此外，访问大块数据可以“推出”缓存的闪存，可能会使代码执行速度变慢。</li>
<li>外部 RAM 不能用作任务堆栈内存;因此，<code>xTaskCreate</code> 和类似函数将始终为堆栈和任务 TCB 分配内部存储器，而 <code>xTaskCreateStatic</code> 类型函数将检查传递的缓冲区是否是内部的。但是，对于不以任何方式直接或间接调用 ROM 中的代码的任务， menuconfig 选项 <code>CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY</code> 将消除 <code>xTaskCreateStatic</code> 中的检查，从而允许外部 RAM 中的任务堆栈。但是，不建议使用此方法。</li>
</ul>
<p>因为有一些对内部存储器有特定需求的情况，但也可以使用 <code>malloc（）</code> 来耗尽内部存储器，因此有一个专门为无法从外部存储器中解析的请求而保留的池;分配任务堆栈，DMA 缓冲区和在禁用缓存时仍可访问的内存从此池中提取。此池的大小可在 menuconfig 中配置。</p>
<h2 id="芯片版本"><a href="#芯片版本" class="headerlink" title="芯片版本"></a>芯片版本</h2><p>ESP32 的某些修订存在一些问题，这些问题会对外部 RAM 的使用产生影响。 这些内容记录在 ESP32 ECO 文档中。 特别是， ESP-IDF 以下列方式处理提到的错误：</p>
<h3 id="ESP32-rev-v0"><a href="#ESP32-rev-v0" class="headerlink" title="ESP32 rev v0"></a>ESP32 rev v0</h3><p>ESP-IDF 没有针对此版本硅片中的错误的解决方法，它不能用于将外部 PSRAM 映射到 ESP32s 主存储器映射中。</p>
<h3 id="ESP32-rev-v1"><a href="#ESP32-rev-v1" class="headerlink" title="ESP32 rev v1"></a>ESP32 rev v1</h3><p>当某些机器指令序列在外部存储器位置 （ESP32 ECO 3.2） 上运行时，此芯片版本中的错误会带来危险。 为了解决这个问题，编译 ESP-IDF 的 gcc 编译器已经扩展了一个标志： -mfix-esp32-psram-cache-issue。 将此标志传递给命令行上的 gcc，编译器可以解决这些序列，并只输出可以安全执行的代码。</p>
<p>在 ESP-IDF 中，当您选择 <code>CONFIG_SPIRAM_CACHE_WORKAROUND</code> 时，将启用此标志。 ESP-IDF 还采取其他措施确保不使用 PSRAM 访问和违规指令集的组合：它链接到使用 gcc 标志重新编译的 Newlib 版本，不使用某些 ROM 函数并为 WiFi 分配静态内存叠加。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/external-ram.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十二）Bootloader (引导加载程序)</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89Bootloader%20(%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F)/</url>
    <content><![CDATA[<h1 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h1><p>引导加载程序执行以下功能：</p>
<ol>
<li>内部模块的最初初始配置;</li>
<li>根据分区表和 ota_data(如果有),选择要引导的应用程序分区;</li>
<li>将此映像加载到  RAM(IRAM 和 DRAM) 并将管理传输到它.</li>
</ol>
<p>引导加载程序位于 Flash 中的地址 0x1000.</p>
<a id="more"></a>

<h2 id="恢复出厂设置"><a href="#恢复出厂设置" class="headerlink" title="恢复出厂设置"></a>恢复出厂设置</h2><p>用户可以编写基本工作固件并将其加载到 factory 分区.接下来,通过 OTA(无线)更新固件.更新的固件将加载到 OTA 应用程序分区位置,并更新 OTA 数据分区以从此分区引导.如果您希望能够回滚到出厂固件并清除设置,则需要设置 <code>CONFIG_BOOTLOADER_FACTORY_RESET</code>.恢复出厂设置机制允许将设备重置为 factory 设置：</p>
<ul>
<li>清除一个或多个数据分区.</li>
<li>从 “factory” 分区启动.</li>
</ul>
<p><code>CONFIG_BOOTLOADER_DATA_FACTORY_RESET</code> 允许客户选择在执行恢复出厂设置时将擦除哪些数据分区.可以通过逗号分隔的可选空格指定分区的名称以便于阅读. (像这样：“nvs,phy_init,nvs_custom,……”).确保分区表中指定的名称和此处的名称相同.此处无法指定 “app” 类型的分区.</p>
<p><code>CONFIG_BOOTLOADER_OTA_DATA_ERASE</code> - 设备将在恢复出厂设置后从 “factory” 分区启动. OTA 数据分区将被清除.</p>
<p><code>CONFIG_BOOTLOADER_NUM_PIN_FACTORY_RESET</code> - 用于恢复出厂设置的 GPIO 输入数用于触发恢复出厂设置,此 GPIO 必须在复位时拉低以触发此操作.</p>
<p><code>CONFIG_BOOTLOADER_HOLD_TIME_GPIO</code> - 这是 GPIO 保持复位/测试模式的时间(默认为 5 秒).复位后,GPIO 必须在此段时间内保持低电平,然后才能执行恢复出厂设置或测试分区引导(如果适用).</p>
<p>分区表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,   Size, Flags</span><br><span class="line"># Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild</span><br><span class="line">nvs,      data, nvs,     0x9000,   0x4000</span><br><span class="line">otadata,  data, ota,     0xd000,   0x2000</span><br><span class="line">phy_init, data, phy,     0xf000,   0x1000</span><br><span class="line">factory,  0,    0,       0x10000,  1M</span><br><span class="line">test,     0,    test,    ,         512K</span><br><span class="line">ota_0,    0,    ota_0,   ,         512K</span><br><span class="line">ota_1,    0,    ota_1,   ,         512K</span><br></pre></td></tr></table></figure>

<h2 id="从-TEST-固件启动"><a href="#从-TEST-固件启动" class="headerlink" title="从 TEST 固件启动"></a>从 TEST 固件启动</h2><p>用户可以编写一个特殊的固件用于生产中的测试,并根据需要运行它. 分区表还需要一个专用分区用于此测试固件(请参阅分区表). 要触发测试应用,您需要设置 <code>CONFIG_BOOTLOADER_APP_TEST</code>.</p>
<p><code>CONFIG_BOOTLOADER_NUM_PIN_APP_TEST</code> - 引导TEST 分区的 GPIO 输入的编号. 选定的 GPIO 将配置为启用内部上拉的输入. 要触发测试应用程序,必须在复位时将此 GPIO 拉低. 停用 GPIO 输入并重启设备后,旧应用程序将启动(工厂或任何 OTA 位置的应用程序).</p>
<p><code>CONFIG_BOOTLOADER_HOLD_TIME_GPIO</code> - 这是 GPIO 的复位/测试模式保持时间(默认为 5 秒). 复位后,GPIO 必须在此段时间内保持低电平,然后才能执行恢复出厂设置或测试分区引导(如果适用).</p>
<h2 id="自定义引导加载程序"><a href="#自定义引导加载程序" class="headerlink" title="自定义引导加载程序"></a>自定义引导加载程序</h2><p>当前的引导加载程序实现允许客户覆盖它. 为此,您必须复制文件夹 <code>/esp-idf/components/bootloader</code>,然后编辑 <code>/your_project/components/bootloader/subproject/main/bootloader_main.c</code>. 在引导加载程序空间中,您无法使用其他组件的驱动程序和函数. 如有必要,则应将所需功能放在文件夹引导程序中(请注意,这会增加其大小). 有必要监视其大小,因为内存中可能存在覆盖层,导致损坏. 目前,引导加载程序仅限于地址 0x8000 的分区表.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/bootloader.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十五）ESP-MESH</title>
    <url>/InfiniteYuanBlog/2019/02/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89ESP-MESH/</url>
    <content><![CDATA[<h1 id="ESP-MESH"><a href="#ESP-MESH" class="headerlink" title="ESP-MESH"></a>ESP-MESH</h1><p>本指南提供有关 ESP-MESH 协议的信息。有关 API 使用的更多信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/network/esp_mesh.html" target="_blank" rel="noopener">MESH API 参考</a>。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-MESH 是一种基于 Wi-Fi 协议构建的网络协议。ESP-MESH 允许在大的物理区域（室内和室外）上分布的多个设备（以下称为节点）在单个 WLAN（无线局域网）下互连。ESP-MESH 具有自组织和自我修复功能，意味着网络可以自主构建和维护。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://img-blog.csdnimg.cn/20190201111240103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="传统的 Wi-Fi 网络架构"><br>传统的 Wi-Fi 网络是一点对多点网络，其中称为接入点（AP）的单个中心节点直接连接到所有其他节点（station）。AP 负责仲裁和转发节点之间的传输。一些 AP 还通过路由器中继与外部 IP 网络的传输。传统的 Wi-Fi 网络由于要求每个站必须在一定范围内以直接与 AP 连接而具有有限覆盖区域的缺点。此外，传统的 Wi-Fi 网络易于过载，因为网络中允许的最大站数受到 AP 容量的限制。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201113539338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>ESP-MESH 与传统的 Wi-Fi 网络的不同之处在于节点不需要连接到中心节点。相反，允许节点与相邻节点连接。节点相互负责传递彼此的传输。这允许 ESP-MESH 网络具有更大的覆盖区域，因为节点仍然可以实现互连而无需在中心节点的范围内。同样，ESP-MESH 也不易受到过载的影响，因为网络上允许的节点数量不再受单个中心节点的限制。</p>
<a id="more"></a>

<h2 id="ESP-MESH概念"><a href="#ESP-MESH概念" class="headerlink" title="ESP-MESH概念"></a>ESP-MESH概念</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>节点</td>
<td>任何属于或可以属于 ESP-MESH 网络的设备</td>
</tr>
<tr>
<td>根节点</td>
<td>网络中的顶级节点</td>
</tr>
<tr>
<td>子节点</td>
<td>当节点 X 连接到另一节点 Y 时，节点 X 是子节点，其中连接使节点 X 比根节点更远离节点 Y（就连接数而言）。</td>
</tr>
<tr>
<td>父节点</td>
<td>子节点的相反概念</td>
</tr>
<tr>
<td>子孙节点</td>
<td>通过从父节点到子节点重复进行都可以访问的任何节点（例：父-&gt;子-&gt;子孙）</td>
</tr>
<tr>
<td>同级节点</td>
<td>共享同一父节点的节点</td>
</tr>
<tr>
<td>连接</td>
<td>AP 与站之间的传统 Wi-Fi 关联。ESP-MESH 中的节点将使用其工作站接口与另一个节点的 SoftAP 接口关联，从而形成连接。连接过程包括 Wi-Fi 中的认证和关联过程。</td>
</tr>
<tr>
<td>上游连接</td>
<td>从节点到其父节点的连接</td>
</tr>
<tr>
<td>下游连接</td>
<td>从节点到其子节点之一的连接</td>
</tr>
<tr>
<td>无线跳数</td>
<td>源节点和目标节点之间的路径部分，对应于单个无线连接。遍历单个连接的数据包称为单跳，而遍历多个连接称为多跳。</td>
</tr>
<tr>
<td>子网</td>
<td>一个子网是 ESP-MESH 网络的细分，它由一个节点及其所有后代节点组成。因此，根节点的子网由 ESP-MESH 网络中的所有节点组成。</td>
</tr>
<tr>
<td>MAC 地址</td>
<td>媒体访问控制地址，用于唯一标识 ESP-MESH 网络中的每个节点或路由器。</td>
</tr>
<tr>
<td>DS</td>
<td>分配系统（外部 IP 网络）</td>
</tr>
</tbody></table>
<h3 id="树状网络拓扑结构"><a href="#树状网络拓扑结构" class="headerlink" title="树状网络拓扑结构"></a>树状网络拓扑结构</h3><p>ESP-MESH 基于 Wi-Fi 协议构建，可以被视为将许多单独的 Wi-Fi 网络组合到单个 WLAN 中的网络协议。在 Wi-Fi 中，Station 在任何时候都限于与 AP（上游连接）的单个连接，而 AP 可以同时连接到多个 Station（下游连接）。然而，ESP-MESH 允许节点同时充当 Station 和 AP。因此，ESP-MESH 中的节点可以使用其 SoftAP 接口具有多个下游连接，同时使用其 Station 接口具有单个上游连接。这就是具有由多个层组成的父子层次结构的树状网络拓扑结构。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201114600123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 树状网络拓扑结构"><br>ESP-MESH 是多跳网络，意味着节点可以通过一个或多个无线“跳跃”将数据包发送到网络中的其他节点。因此，ESP-MESH 中的节点不仅传输自己的数据包，还同时用作其他节点的中继。如果物理层上的任何两个节点之间存在路径（通过一个或多个无线跳），则 ESP-MESH 网络内的 <strong>任何两个节点（节点对）</strong> 都可以进行通信。</p>
<blockquote>
<p>ESP-MESH 网络中的大小（节点总数）取决于网络中允许的最大层数，以及每个节点可以拥有的最大下游连接数。可以通过配置这两个变量限制网络的大小。</p>
</blockquote>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p><img src="https://img-blog.csdnimg.cn/20190201115649174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 节点类型"><br><strong>根节点：</strong> 根节点是网络中的顶级节点，并且是 ESP-MESH 网络和外部 IP 网络之间的唯一接口。 根节点连接到传统的 Wi-Fi 路由器，并将数据包中继到外部 IP 网络或从中继到 ESP-MESH 网络内的节点。 ESP-MESH 网络中只能有一个根节点，根节点的上游连接只可能与路由器连接。参考上图，节点 A 是网络的根节点。</p>
<p><strong>叶节点：</strong> 叶节点是不允许具有任何子节点（没有下游连接）的节点。因此，叶子节点只能发送或接收自己的数据包，但不能转发其他节点的数据包。如果节点位于网络的最大允许层上，则将其指定为叶节点。这可以防止节点形成任何下游连接，从而确保网络不会添加额外的层。由于需要为任何下游连接提供 SoftAP 接口，因此一些没有 SoftAP 接口（仅限 Station）的节点也将被指定为叶节点。参考上图，节点 L/M/N 位于网络最大允许层上，因此已被指定为叶节点。</p>
<p><strong>中间父节点：</strong> 既不是根节点也不是叶节点的连接节点是中间父节点。中间父节点必须具有单个上游连接（单个父节点），但可以具有零到多个下游连接（零到多个子节点）。因此，中间父节点可以发送和接收数据包，但也可以转发从其上游和下游连接发送的数据包。参考上图，节点 B 到 J 是中间父节点。没有下游连接的中间父节点（例如节点 E/F/G/I/J）不等同于叶节点，因为它们在将来仍然允许形成下游连接。</p>
<p><strong>空闲节点：</strong> 尚未加入网络的节点被指定为空闲节点。空闲节点将尝试与中间父节点形成上游连接，或尝试在正确的情况下成为根节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>）。参考上图，节点 K 和 O 是空闲节点。</p>
<h3 id="信标帧-Beacon-帧-和-RSSI-阈值"><a href="#信标帧-Beacon-帧-和-RSSI-阈值" class="headerlink" title="信标帧(Beacon 帧)和 RSSI 阈值"></a>信标帧(Beacon 帧)和 RSSI 阈值</h3><p>ESP-MESH 中能够形成下游连接（即具有 SoftAP 接口）的每个节点将<strong>周期性地发送 Wi-Fi 信标帧</strong>。节点使用信标帧来允许其他节点检测其存在并知道其状态。空闲节点将监听信标帧以生成潜在父节点的列表，空闲节点将与其中一个形成上游连接。<strong>ESP-MESH 使用信标帧中的供应商信息（Vendor IE）元素来存储（传输）元数据</strong>，例如：</p>
<ul>
<li>节点类型（根节点，中间父节点，叶节点，空闲节点）</li>
<li>当前节点层</li>
<li>网络中允许的最大层数</li>
<li>当前子节点数</li>
<li>要接受的最大下游连接数</li>
</ul>
<p>潜在上游连接的信号强度由潜在父节点的信标帧的 RSSI（接收信号强度指示）表示。为了防止节点形成弱上游连接，ESP-MESH 为信标帧实现了 RSSI 阈值机制。如果节点检测到 RSSI 低于预先配置的阈值的信标帧，则在形成上游连接时将忽略发送该信标帧的节点。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201120120285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="RSSI 阈值的影响"><br>上图中的面板 A 展示了 RSSI 阈值如何影响空闲节点具有的候选父节点的数量。</p>
<p>上图中的面板 B 展示了 RF 屏蔽对象如何降低潜在父节点的 RSSI。由于 RF 屏蔽对象，节点 X 的 RSSI 高于阈值的区域显着减小。这导致空闲节点忽略节点 X，即使节点 X 在物理上相邻。由于更强的 RSSI，空闲节点将改为与物理上远的节点Y形成上游连接。</p>
<blockquote>
<p>节点在技术上仍然接收 MAC 层上的所有信标帧。RSSI 阈值是 ESP-MESH 功能，它只是过滤掉所有接收到的低于预先配置阈值的信号帧。</p>
</blockquote>
<h3 id="首选父节点"><a href="#首选父节点" class="headerlink" title="首选父节点"></a>首选父节点</h3><p>当空闲节点具有多个候选父节点（潜在父节点）时，空闲节点将与首选父节点形成上游连接。<strong>首选父节点基于以下标准确定</strong>：</p>
<ul>
<li>候选父节点位于哪个层</li>
<li>候选父节点当前具有的下游连接（子节点）的数量</li>
</ul>
<p>首选父节点的选择将始终优先考虑网络最浅层（包括根节点）上的候选父节点。这有助于在形成上游连接时最小化ESP-MESH网络中的层总数。例如，给定第二层节点和第三层节点，第二层节点将始终是首选的。</p>
<p>如果在同一层内存在多个候选父节点，则具有最少子节点的候选父节点将是首选的。该标准具有平衡同一层的节点之间的下游连接数的效果。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201140919219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="首选父节点"><br>上图中的面板 A 展示了在给定五个候选父节点 B/C/D/E/F 的情况下空闲节点 G 如何选择首选父节点的示例。最浅层上的节点是首选的，因此节点 B/C 优先选择做为父节点，因为它们是第二层节点，而节点 D/E/F 在第三层上。选择节点 C 作为首选父节点，因为与节点 B 相比，它具有更少的下游连接（更少的子节点）。</p>
<p>上图中的面板 B 展示了根节点在空闲节点 G 的范围内的情况。换句话说，当节点 G 接收时，根节点的信标帧高于 RSSI 阈值。根节点始终是最浅节点，因此，在 ESP-MESH网络中，给定多个候选父节点时，根节点总是首选的父节点。</p>
<blockquote>
<p>用户还可以定义自己的算法以选择首选父节点，或强制节点仅与特定父节点连接（请参阅<a href="https://github.com/espressif/esp-idf/tree/2790d4a/examples/mesh/manual_networking" target="_blank" rel="noopener">手动 MESH 网络示例</a>）。</p>
</blockquote>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>ESP-MESH 网络中的每个节点将单独维护自己的路由表，用于将 ESP-MESH 数据包（请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#esp-mesh-packet" target="_blank" rel="noopener">ESP-MESH 数据包</a>）正确路由到正确目标节点。特定节点的路由表将包括特定节点的子网内所有节点的 MAC 地址（包括特定节点本身的 MAC 地址）。每个路由表在内部划分为多个子表，每个子表对应于每个子节点的子网。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201142029243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH路由表示例"><br>使用上面的图作为示例，节点 B 的路由表将包括节点 B 到 I 的 MAC 地址（即，等同于节点 B 的子网）。节点 B 的路由表在内部划分为两个子表，包含节点 C 到 F 和节点 G 到 I（即分别等同于节点 C 和 G 的子网）。</p>
<p><strong>ESP-MESH 利用路由表来确定是否应根据以下规则向上游或下游转发 ESP-MESH 数据包。</strong></p>
<ol>
<li>如果数据包的目标 MAC 地址在当前节点的路由表中并且不是当前节点，请选择包含目标 MAC 地址的子表，并将数据包下游转发到与子表对应的子节点。</li>
<li>如果目标 MAC 地址不在当前节点的路由表中，则将数据包上游转发到当前节点的父节点。重复执行此操作将导致数据包到达根节点，其中路由表应包含网络中的所有节点。</li>
</ol>
<blockquote>
<p>用户可以调用 <code>esp_mesh_get_routing_table()</code> 来获取节点的路由表，或者调用 <code>esp_mesh_get_routing_table_size()</code> 来获取节点的路由表的大小。<br><code>esp_mesh_get_subnet_nodes_list()</code> 可用于获取特定子节点的相应子表。同样，<code>esp_mesh_get_subnet_nodes_num()</code> 可用于获取子表的大小。</p>
</blockquote>
<h2 id="构建-ESP-MESH-网络"><a href="#构建-ESP-MESH-网络" class="headerlink" title="构建 ESP-MESH 网络"></a>构建 ESP-MESH 网络</h2><h3 id="一般过程"><a href="#一般过程" class="headerlink" title="一般过程"></a>一般过程</h3><blockquote>
<p>在 ESP-MESH 网络构建过程开始之前，配置的某些部分必须在网络中的每个节点上保持一致（请参阅 <code>mesh_cfg_t</code>）。每个节点必须配置相同的 Mesh 网络 ID，路由器配置和 SoftAP 配置。</p>
</blockquote>
<p>ESP-MESH 网络构建过程涉及根节点选择，然后逐层形成下游连接，直到所有节点都加入网络。网络的确切布局可以取决于诸如根节点选择，父节点选择和异步上电复位等因素。但是，ESP-MESH 网络构建过程可以概括为以下步骤：</p>
<p><img src="https://img-blog.csdnimg.cn/2019020114281399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 网络构建过程"></p>
<ol>
<li><p>根节点选择</p>
<p><strong>根节点可以在配置期间指定</strong>（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#user-designated-root-node" target="_blank" rel="noopener">用户指定的根节点部分</a>），或者<strong>根据每个节点和路由器之间的信号强度动态选择</strong>（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>）。选择后，根节点将与路由器连接并开始允许形成下游连接。参考上图，节点 A 被选择为根节点，因此节点 A 与路由器形成上游连接。</p>
</li>
<li><p>第二层形成</p>
<p>一旦根节点连接到路由器，根节点范围内的空闲节点将开始与根节点连接，从而形成网络的第二层。连接后，第二层节点成为中间父节点（假设允许的最大层数 &gt; 2），因此形成下一层。参考上图，节点 B 到 D 在根节点的范围内。因此，节点 B 到 D 与根节点形成上游连接，并成为中间父节点。</p>
</li>
<li><p>形成剩余层</p>
<p>剩余的空闲节点将与范围内的中间父节点连接，从而在网络中形成新层。连接后，空闲节点将成为中间父节点或叶节点，具体取决于网络允许的最大层数。重复该步骤，直到网络中不再有空闲节点或者直到达到网络的最大允许层为止。参考上图，节点 E/F/G 分别与节点 B/C/D 连接，并成为中间父节点本身。</p>
</li>
<li><p>限制树深度</p>
<p>为防止网络超出允许的最大层数，最大层上的节点一旦连接就会自动成为叶子节点。这防止任何其他空闲节点与叶节点连接，从而防止形成新的层形式。但是，如果空闲节点没有其他可能的父节点，它将无限期地保持空闲状态。参考上图，网络的最大允许层数设置为 4。因此，当节点 H 连接时，它成为叶节点以防止形成任何下游连接。</p>
</li>
</ol>
<h3 id="自动根节点选择"><a href="#自动根节点选择" class="headerlink" title="自动根节点选择"></a>自动根节点选择</h3><p><strong>根节点的自动选择涉及所有空闲节点之间基于其与路由器的信号强度的选举过程。每个空闲节点将通过 Wi-Fi 信标帧发送其 MAC 地址和路由器 RSSI 值</strong>。MAC 地址用于唯一地标识网络中的每个节点，而路由器 RSSI 用于指示节点参考路由器的信号强度。</p>
<p>然后，<strong>每个节点将同时扫描来自其他空闲节点的信标帧</strong>。<strong>如果节点检测到具有更强路由器 RSSI 的信标帧，则该节点将开始发送该信标帧的内容</strong>（即，对具有更强路由器 RSSI 的节点进行投票）。<strong>传输和扫描的过程将重复预先配置的最小迭代次数</strong>（默认为 10 次迭代），<strong>这将导致具有最强路由器 RSSI 的信标帧在整个网络中传播</strong>。</p>
<p>在所有迭代之后，每个节点将单独检查其投票百分比（投票数/参与选举的节点数）以确定它是否应该成为根节点。<strong>如果节点的投票百分比大于预配置的阈值（默认为 90％），则该节点将成为根节点</strong>。</p>
<p>下图演示了在自动选择根节点时如何构建 ESP-MESH 网络。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201144333598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="根节点选择示例"></p>
<ol>
<li>在上电复位时，每个节点开始发送由其自己的 MAC 地址和路由器 RSSI 组成的信标帧。</li>
<li>在多次传输和扫描迭代中，具有最强路由器 RSSI 的信标帧在整个网络中传播。节点 C 具有最强的路由器RSSI（-10db），因此其信标帧在整个网络中传播。参与选举的所有节点都对节点 C 进行投票，从而给节点 C 一个 100％ 的投票百分比。因此，节点 C 成为根节点并与路由器连接。</li>
<li>一旦节点 C 与路由器连接，节点 A/B/D/E 就与节点 C 连接，因为它是首选的父节点（即最浅节点）。节点 A/B/D/E 构成网络的第二层。</li>
<li>节点 F 和 G 分别与节点 D 和 E 连接，网络构建过程完成。</li>
</ol>
<blockquote>
<p>可以使用 <code>esp_mesh_set_attempts（）</code> 配置选举过程的最小迭代次数。用户应该基于网络内的节点数量来调整迭代次数（即，网络越大，所需的扫描迭代次数越多）。</p>
</blockquote>
<blockquote>
<p>也可以使用 <code>esp_mesh_set_vote_percentage()</code> 配置投票百分比阈值。设置低投票百分比阈值可导致两个或更多节点成为同一 ESP-MESH 网络内的根节点，从而导致建立多个网络。如果是这种情况，ESP-MESH 具有自主解决根节点冲突的内部机制。多个根节点的网络将组合成具有单个根节点的单个网络。但是，根节点冲突，其中两个或多个根节点具有相同的路由器 SSID 但不处理不同的路由器 BSSID。</p>
</blockquote>
<h3 id="用户指定根节点"><a href="#用户指定根节点" class="headerlink" title="用户指定根节点"></a>用户指定根节点</h3><p><strong>根节点也可以由用户指定，这将使指定的根节点直接与路由器连接并放弃选举过程。当指定根节点时，网络中的所有其他节点也必须放弃选举过程以防止发生根节点冲突。</strong> 下图演示了当用户指定根节点时如何构建 ESP-MESH 网络。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201145101139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="指定根节点示例（根节点= A，最大层数= 4）"></p>
<ol>
<li>节点 A 被用户指定为根节点，因此直接与路由器连接。所有其他节点放弃选举过程。</li>
<li>节点 C/D 连接节点 A 作为其首选父节点。两个节点构成网络的第二层。</li>
<li>同样，节点 B/E 与节点 C 连接，节点 F 与节点 D 连接。节点 B/E/F 构成网络的第三层。</li>
<li>节点 G 与节点 E 连接，形成网络的第四层。但是，此网络中允许的最大层数配置为 4，因此节点 G 成为叶节点以防止形成任何新层。</li>
</ol>
<blockquote>
<p>在指定根节点时，根节点应调用 <code>esp_mesh_set_parent()</code> 以直接与路由器连接。同样，所有其他节点应调用 <code>esp_mesh_fix_root()</code> 以放弃选举过程。</p>
</blockquote>
<h3 id="父节点选择"><a href="#父节点选择" class="headerlink" title="父节点选择"></a>父节点选择</h3><p>默认情况下，ESP-MESH 是自组织的，这意味着每个节点将自动选择与哪个潜在父节点形成上游连接。自主选择的父节点称为首选父节点。用于选择首选父节点的标准旨在减少 ESP-MESH 网络中的层数，并平衡潜在父节点之间的下游连接数（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#preferred-parent-node" target="_blank" rel="noopener">首选父节点</a>）。</p>
<p>但是，ESP-MESH 还允许用户禁用自组织行为，这将允许用户定义自己的父节点选择标准，或配置节点以具有指定的父节点（请参阅<a href="https://github.com/espressif/esp-idf/tree/2790d4a/examples/mesh/manual_networking" target="_blank" rel="noopener">手动 MESH 网络示例</a>）。</p>
<h3 id="异步上电复位"><a href="#异步上电复位" class="headerlink" title="异步上电复位"></a>异步上电复位</h3><p>ESP-MESH 网络建设可能受节点上电顺序的影响。如果网络中的某些节点异步上电（即相隔几分钟），则网络的最终结构可能与所有节点同步通电的理想情况不同。上电延迟的节点将遵循以下规则：</p>
<p>规则1：如果网络中已存在根节点，则延迟节点将不会尝试选择新的根节点，即使它与路由器具有更强的 RSSI。通过连接首选父节点，延迟节点将像任何其他空闲节点一样加入网络。如果延迟节点是指定的根节点，则网络中的所有其他节点将保持空闲，直到延迟节点通电。</p>
<p>规则2：如果延迟节点形成上游连接并成为中间父节点，则它也可以成为其他节点的新首选父节点（即，是较浅的节点）。这将导致其他节点切换其上游连接以与延迟节点连接（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#parent-node-switching" target="_blank" rel="noopener">父节点切换</a>）。</p>
<p>规则3：如果空闲节点具有在通电时被延迟的指定父节点，则空闲节点将不会在没有其指定的父节点的情况下尝试形成任何上游连接。空闲节点将无限期地保持空闲，直到其指定的父节点上电为止。</p>
<p>以下示例演示了异步上电对网络构建的影响。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201150942611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="基于异步电源的网络构建示例"></p>
<ol>
<li>节点 A/C/D/F/G/H 同步上电，通过广播其 MAC 地址和路由器 RSSI 开始根节点选举过程。节点 A 被选为根节点，因为它具有最强的 RSSI。</li>
<li>一旦节点 A 成为根节点，其余节点就开始逐层形成具有其首选选父节点的上游连接。结果是一个有五层的网络。</li>
<li>节点 B/E 在上电时被延迟但是没有尝试成为根节点，即使它们具有比节点 A 更强的路由器 RSSI（-20db 和 -10db）。相反，两个延迟节点形成与其首选父节点的上游连接。节点 A 和 C 分别。连接后，两个节点 B/E 都成为中间父节点。</li>
<li>节点 D/G 切换它们的上游连接，因为节点 B 是新的首选父节点，因为它位于较浅的层（第二层节点）上。由于切换，所得到的网络具有三层而不是原始的五层。</li>
</ol>
<p>同步上电：如果所有节点同步上电，节点 E 将成为根节点，因为它具有最强的路由器 RSSI（-10db）。与在异步通电条件下形成的网络相比，这将导致显着不同的网络布局。但是，如果用户手动切换根节点，仍然可以达到同步开机网络布局（请参阅 <code>esp_mesh_waive_root()</code> ）。</p>
<blockquote>
<p>由异步上电引起的父节点选择的差异在 ESP-MESH 中在某种程度上被自动校正（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#parent-node-switching" target="_blank" rel="noopener">父节点切换</a>）</p>
</blockquote>
<h3 id="环路避免，检测和处理"><a href="#环路避免，检测和处理" class="headerlink" title="环路避免，检测和处理"></a>环路避免，检测和处理</h3><p>环路是特定节点与其后代节点之一（特定节点的子网内的节点）形成上游连接的情况。这导致圆形连接路径，从而破坏树状网络拓扑结构。ESP-MESH 通过排除在选择节点的路由表中已存在的节点（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#routing-tables" target="_blank" rel="noopener">路由表</a>）来防止在父节点选择期间产生环路，从而防止特定节点尝试连接到其子网内的任何节点。</p>
<p>在发生环路的情况下，ESP-MESH利用路径验证机制和能量传输机制来检测环路发生。导致环路的上游连接的父节点将通知子节点环路并启动断开连接。</p>
<h2 id="管理网络"><a href="#管理网络" class="headerlink" title="管理网络"></a>管理网络</h2><p>ESP-MESH 是一个自我修复网络，意味着它可以检测并纠正网络路由中的故障。当具有一个或多个子节点的父节点发生故障或父节点与其子节点之间的连接变得不稳定时，会发生故障。ESP-MESH 中的子节点将自动选择新的父节点并与其形成上游连接以维持网络互连。ESP-MESH 可以处理根节点故障和中间父节点故障。</p>
<h3 id="根节点故障"><a href="#根节点故障" class="headerlink" title="根节点故障"></a>根节点故障</h3><p><strong>如果根节点发生故障，与其连接的节点（第二层节点）将立即检测到根节点的故障。第二层节点最初将尝试与根节点重新连接。但是，在多次尝试失败后，第二层节点将初始化新一轮的根节点选举。具有最强路由器 RSSI 的第二层节点将被选为新的根节点，而剩余的第二层节点将与新的根节点（或相邻的父节点，如果不在范围内）形成上游连接。</strong></p>
<p>如果根节点和多个下游层同时发生故障（例如，根节点，第二层和第三层），仍然起作用的最浅层将初始化根节点选举。以下示例说明了从根节点分解的自我修复示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201153541569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="从根节点故障中自我修复"></p>
<ol>
<li>节点 C 是网络的根节点。节点 A/B/D/E 是连接到节点 C 的第二层节点。</li>
<li>节点 C 发生故障。在多次尝试重新连接失败后，第二层节点通过广播其路由器 RSSI 开始选举过程。节点 B 具有最强的路由器 RSSI。</li>
<li>节点 B 被选为根节点并开始接受下游连接。剩余的第二层节点 A/D/E 形成与节点 B 的上游连接，因此网络被修复并且可以继续正常操作。</li>
</ol>
<blockquote>
<p>如果指定的根节点发生故障，则其余节点将不会自主地尝试选择新的根节点，因为在使用指定的根节点时将永远不会尝试选举过程。</p>
</blockquote>
<h3 id="中间父节点故障"><a href="#中间父节点故障" class="headerlink" title="中间父节点故障"></a>中间父节点故障</h3><p><strong>如果中间父节点发生故障，则断开连接的子节点将首先尝试与父节点重新连接。在多次尝试重新连接失败后，每个子节点将开始扫描潜在的父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#beacon-frames-rssi-thresholding" target="_blank" rel="noopener">信标帧和 RSSI 阈值</a>）。</strong></p>
<p>如果其他可能的父节点可用，则每个子节点将单独选择新的首选父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#preferred-parent-node" target="_blank" rel="noopener">首选父节点</a>）并与其形成上游连接。如果特定子节点没有其他潜在父节点，则它将无限期保持空闲状态。</p>
<p>下图说明了从中间父节点分解的自我修复的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201153956675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="从中间父节点故障中自我修复"></p>
<ol>
<li>网络的以下分支由节点 A 到 G 组成。</li>
<li>节点 C 发生故障。 节点 F/G 检测到故障并尝试与节点 C 重新连接。多次尝试重新连接失败后，节点 F/G 开始选择新的首选父节点。</li>
<li>节点 G 超出任何其他父节点的范围，因此暂时保持空闲。节点 F 在节点 B/E 的范围内，但是节点 B 被选择，因为它是较浅的节点。节点 F 在与节点 B 连接之后成为中间父节点，因此节点 G 可以与节点 F 连接。网络被修复，但是网络路由已经受到影响并且添加了额外的层。</li>
</ol>
<blockquote>
<p>如果子节点具有指定的父节点，则子节点将不会尝试连接新的父节点。子节点将无限期保持空闲状态。</p>
</blockquote>
<h3 id="根节点切换"><a href="#根节点切换" class="headerlink" title="根节点切换"></a>根节点切换</h3><p><strong>除非根节点发生故障，否则 ESP-MESH 不会自动切换根节点。即使根节点的路由器 RSSI 降级到断开点，根节点也将保持不变</strong>。根节点切换是明确开始新选举的行为，使得具有更强路由器 RSSI 的节点将被选为新的根节点。这可以是适应降低根节点性能的有用方法。</p>
<p><strong>要触发根节点切换，当前根节点必须显式调用 <code>esp_mesh_waive_root()</code> 以触发新选举</strong>。当前根节点将发信号通知网络内的所有节点开始发送和扫描信标帧（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>），同时保持连接到网络（即，不空闲）。如果另一个节点收到的选票多于当前根节点，则将启动根节点切换。否则，根节点将保持不变。</p>
<p>新选择的根节点向当前根节点发送切换请求，该当前根节点将以确认响应，表示两个节点都准备切换。一旦收到确认，新选出的根节点将与其父节点断开连接，并迅速与路由器形成上游连接，从而成为网络的新根节点。先前的根节点将断开与路由器的连接，同时保持其所有下游连接并进入空闲状态。然后，先前的根节点将开始扫描潜在的父节点并选择首选父节点。</p>
<p>下图说明了根节点切换的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201160040642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="根节点切换示例"></p>
<ol>
<li>节点 C 是当前的根节点，但路由器的信号强度降低（-85db）。节点 C 触发新的选举，并且所有节点在仍然连接的同时开始发送和扫描信标帧。</li>
<li>经过多轮传输和扫描后，节点 B 被选为新的根节点。节点 B 向节点 C 发送切换请求，节点 C 以确认响应。</li>
<li>节点 B 与其父节点断开连接，并与路由器连接，成为网络新的根节点。节点 C 与路由器断开连接，进入空闲状态，并开始扫描并选择新的首选父节点。节点 C 在整个过程中维护其所有下游连接。</li>
<li>节点 C 选择节点 B 作为其首选父节点，形成上游连接，并成为第二层节点。交换根节点后网络布局类似，因为节点 C 仍保持相同的子网。但是，由于交换根节点，节点 C 的子网中的每个节点都被放置了一层。如果任何节点由于根节点切换而具有新的优选父节点，则父节点切换可以随后调整网络布局。</li>
</ol>
<blockquote>
<p>根节点切换必须要求选举，因此仅在使用自组织 ESP-MESH 网络时才支持。换句话说，如果使用指定的根节点，则不能发生根节点切换。</p>
</blockquote>
<h3 id="父节点切换"><a href="#父节点切换" class="headerlink" title="父节点切换"></a>父节点切换</h3><p><strong>父节点切换需要子节点将其上游连接切换到较浅层的另一个父节点。父节点切换自动发生，这意味着如果较浅层的潜在父节点变得可用（即，由于<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#asynchronous-power-on-reset" target="_blank" rel="noopener">异步上电复位</a>），子节点将自动改变其上游连接。</strong></p>
<p>所有潜在的父节点周期性地发送信标帧（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#beacon-frames-rssi-thresholding" target="_blank" rel="noopener">信标帧和 RSSI 阈值</a>），允许子节点扫描较浅的父节点的可用性。由于父节点切换，自组织的 ESP-MESH 网络可以动态调整其网络布局，以确保每个连接具有良好的 RSSI 并且网络中的层数最小化。</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="ESP-MESH数据包"><a href="#ESP-MESH数据包" class="headerlink" title="ESP-MESH数据包"></a>ESP-MESH数据包</h3><p>ESP-MESH 网络数据传输使用 ESP-MESH 数据包。ESP-MESH 数据包完全包含在 Wi-Fi 数据帧的帧体内。ESP-MESH 网络中的多跳数据传输将涉及通过不同的 Wi-Fi 数据帧在每个无线跳上承载的单个 ESP-MESH 数据包。</p>
<p>下图显示了 ESP-MESH 数据包的结构及其与 Wi-Fi 数据帧的关系。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201162512352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 数据包"><br>ESP-MESH 数据包的包头包含源节点和目标节点的 MAC 地址。选项字段包含与特殊类型的 ESP-MESH 数据包有关的信息，例如组传输或源自外部 IP 网络的数据包（请参阅 <code>MESH_OPT_SEND_GROUP</code> 和 <code>MESH_OPT_RECV_DS_ADDR</code>）。</p>
<p>ESP-MESH 数据包的有效负载包含实际的应用程序数据。此数据可以是原始二进制数据，也可以在应用程序层协议（如 HTTP，MQTT 和 JSON）下编码（请参阅 <code>mesh_proto_t</code>）。</p>
<blockquote>
<p>将 ESP-MESH 数据包发送到外部 IP 网络时，包头的目标地址字段将包含目标服务器的 IP 地址和端口，而不是节点的 MAC 地址（请参阅 <code>mesh_addr_t</code>）。此外，根节点将处理输出 TCP/IP 数据包的形成。</p>
</blockquote>
<h3 id="组控制和多播"><a href="#组控制和多播" class="headerlink" title="组控制和多播"></a>组控制和多播</h3><p>多播是一种允许将单个 ESP-MESH 数据包同时传输到网络中的多个节点的功能。ESP-MESH 中的多播可以通过指定目标节点列表或指定预先配置的节点组来实现。两种多播方法都是通过 <code>esp_mesh_send()</code> 调用的。</p>
<p>要通过指定目标节点列表进行多播，用户必须首先将 ESP-MESH 数据包的目标地址设置为多播组地址（01:00:5E:xx:xx:xx）。这表示 ESP-MESH 数据包是具有一组地址的多播数据包，并且该地址应从头选项中获取。然后，用户必须将目标节点的 MAC 地址列为选项（请参阅 <code>mesh_opt_t</code> 和 <code>MESH_OPT_SEND_GROUP</code>）。这种多播方法不需要事先设置，但可能产生大量开销数据，因为每个目标节点的 MAC 地址必须列在数据包包头的选项字段中。</p>
<p>按组进行多播允许将 ESP-MESH 数据包传输到预先配置的节点组。每个组由唯一 ID 标识，并且可以通过 <code>esp_mesh_set_group_id()</code> 将节点放入组中。对组进行组播涉及将 ESP-MESH 数据包中的目的地址设置为目标组 ID。此外，必须设置 <code>MESH_DATA_GROUP</code> 标志。使用组进行多播会产生较少的开销，但需要先前将节点添加到组中。</p>
<blockquote>
<p>在多播期间，网络中的所有节点仍然在 MAC 层上接收 ESP-MESH 数据包。但是，未包含在 MAC 地址列表或目标组中的节点将简单地过滤掉该数据包。</p>
</blockquote>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播是一种允许单个 ESP-MESH 数据包同时传输到网络中所有节点的功能。每个节点基本上将广播包转发到其所有上游和下游连接，使得广播包尽可能快地在整个网络中传播。但是，ESP-MESH 利用以下方法避免在广播期间浪费带宽。</p>
<ol>
<li>当中间父节点从其父节点接收广播包时，它将广播包转发到其每个子节点，同时为其自身存储广播包的副本。</li>
<li>当中间父节点是广播的源节点时，它将向上游发送广播包到父节点并且向下游发送广播包到每个子节点。</li>
<li>当中间父节点从其子节点之一接收广播包时，它将广播包转发到其父节点及其剩余的每个子节点，同时为其自身存储广播包的副本。</li>
<li>当叶节点是广播的源节点时，它将直接将数据包传输到其父节点。</li>
<li>当根节点是广播的源节点时，根节点将数据包传输到其所有子节点。</li>
<li>当根节点从其子节点之一接收广播包时，它将广播包转发到其剩余的每个子节点，同时为其自身存储广播包的副本。</li>
<li>当节点接收到源地址与其自己的 MAC 地址匹配的广播包时，该节点将丢弃该广播包。</li>
<li>当中间父节点从其父节点接收到最初从其子节点之一发送的广播包时，它将丢弃广播包。</li>
</ol>
<h3 id="上游流量控制"><a href="#上游流量控制" class="headerlink" title="上游流量控制"></a>上游流量控制</h3><p>ESP-MESH 依靠父节点来控制其直接子节点的上游数据流。为了防止父节点的消息缓冲区由于上游传输的过载而溢出，父节点将为其每个子节点分配用于上游传输的配额，称为接收窗口。<strong>每个子节点必须在允许向上游传输之前申请接收窗口。</strong> 可以动态调整接收窗口的大小。从子节点到父节点的上游传输包括以下步骤：</p>
<ol>
<li>在每次传输之前，子节点向其父节点发送窗口请求。窗口请求由序列号组成，该序列号对应于待传输的子节点的数据包。</li>
<li>父节点接收窗口请求，并将序列号与子节点发送的先前数据包的序列号进行比较。该比较用于计算发送回子节点的接收窗口的大小。</li>
<li>子节点根据父节点指定的窗口大小发送数据包。如果子节点耗尽其接收窗口，则必须通过在允许继续发送之前发送请求来获得另一个接收窗口。</li>
</ol>
<blockquote>
<p>ESP-MESH 不支持任何下游流量控制。</p>
</blockquote>
<blockquote>
<p>由于父节点切换，在上游传输期间可能发生数据包丢失。</p>
</blockquote>
<p>由于根节点充当外部 IP 网络的唯一接口，因此下游节点了解根节点与外部 IP 网络的连接状态至关重要。如果不这样做，可能会导致节点在与 IP 网络断开连接时尝试将数据上行传递到根节点。这导致不必要的传输和数据包丢失。ESP-MESH 通过提供一种机制来解决此问题，该机制基于根节点和外部 IP 网络之间的连接状态来稳定传出数据的吞吐量。根节点可以通过调用 <code>esp_mesh_post_toDS_state()</code> 将其外部 IP 网络连接状态广播到所有其他节点。</p>
<h3 id="双向数据流"><a href="#双向数据流" class="headerlink" title="双向数据流"></a>双向数据流</h3><p>下图说明了 ESP-MESH 双向数据流中涉及的各种网络层。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201165440991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 双向数据流"><br>由于使用了<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#routing-tables" target="_blank" rel="noopener">路由表</a>，ESP-MESH 能够完全在网状层上处理包转发。仅当根节点向/从外部 IP 网络发送/接收数据包时，才需要 TCP/IP 层。</p>
<h2 id="信道切换"><a href="#信道切换" class="headerlink" title="信道切换"></a>信道切换</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在传统的 Wi-Fi 网络中，信道是预定的频率范围。在基本服务集（BSS）中，服务 AP 及其连接的 Station 必须在相同信道（1 至 14）上发送信标。在同一信道上运行的物理上相邻的 BSS（基本服务集）可能会导致干扰并降低性能。</p>
<p>为了使 BSS 适应不断变化的物理层条件并保持性能，Wi-Fi 包含用于网络信道切换的机制。网络信道切换是尝试将 BSS 移动到新的操作信道，同时在此过程中最小化对 BSS 的干扰。然而，应该认识到，在将所有 Station 移动到新的操作信道时，信道切换可能是不成功的。</p>
<p>在 Wi-Fi 网络中，AP 触发网络信道切换，目的是使 AP 和所有连接的 Station 同步切换到新信道。通过在 AP 的周期性发送的信标帧内嵌入信道切换公告（CSA）元素来实现网络信道切换。CSA 元素用于向所有连接的站点通告关于即将到来的网络信道切换，并且将被包括在多个信标帧中直到切换发生。</p>
<p>CSA 元素包含关于新信道号和信道切换计数的信息，其指示在网络信道切换发生之前剩余的信标帧间隔（TBTT）的数量。因此，每个信标帧递减信道切换计数，并允许连接的 Station 将其信道切换与 AP 同步。</p>
<h3 id="ESP-MESH-网络信道切换"><a href="#ESP-MESH-网络信道切换" class="headerlink" title="ESP-MESH 网络信道切换"></a>ESP-MESH 网络信道切换</h3><p>ESP-MESH 网络信道切换还利用包含 CSA 元素的信标帧。然而，作为多跳网络使得 ESP-MESH 中的切换过程更复杂，因为信标帧可能无法到达网络内的所有节点（即，在单跳中）。因此，ESP-MESH 网络依靠节点转发 CSA 元素，以便它在整个网络中传播。</p>
<p>当具有一个或多个子节点的中间父节点接收到包含 CSA 的信标帧时，该节点将通过将该元素包括在其下一个发送的信标帧中（即，具有相同的新信道号和信道切换计数）来转发 CSA 元素。鉴于 ESP-MESH 网络内的所有节点都接收相同的 CSA，节点可以使用信道切换计数来同步其信道切换，尽管由于 CSA 元素转发而导致短的延迟。</p>
<p>ESP-MESH 网络信道切换可以由路由器或根节点触发。</p>
<h3 id="根节点触发"><a href="#根节点触发" class="headerlink" title="根节点触发"></a>根节点触发</h3><p>只有当 ESP-MESH 网络未连接到路由器时，才会发生根节点触发的信道切换。通过调用 <code>esp_mesh_switch_channel()</code>，根节点将设置初始信道切换计数值并开始在其信标帧中包含 CSA 元素。然后，每个 CSA 元素由第二层节点接收，并在它们自己的信标帧中向下游转发。</p>
<h3 id="路由器触发"><a href="#路由器触发" class="headerlink" title="路由器触发"></a>路由器触发</h3><p>当 ESP-MESH 网络连接到路由器时，整个网络必须使用与路由器相同的信道。因此，当根节点连接到路由器时，将不允许根节点触发通道切换。</p>
<p>当根节点从路由器接收包含 CSA 元素的信标帧时，根节点将 CSA 元素中的信道切换计数值设置为自定义值，然后通过信标帧向下游转发。它还将相对于自定义值递减后续 CSA 元素的通道切换计数。此自定义值可以基于诸如网络层数，当前节点数等因素。</p>
<p>将信道切换计数值设置为自定义值是由于 ESP-MESH 网络及其路由器可能具有不同且变化的信标间隔。因此，路由器提供的信道切换计数值与 ESP-MESH 网络无关。通过使用自定义值，ESP-MESH 网络中的节点能够相对于 ESP-MESH 网络的信标间隔同步切换信道。但是，这也会导致 ESP-MESH 网络的信道切换与路由器及其连接站的信道切换不同步。</p>
<h3 id="网络信道切换的影响"><a href="#网络信道切换的影响" class="headerlink" title="网络信道切换的影响"></a>网络信道切换的影响</h3><ul>
<li>由于 ESP-MESH 网络信道切换与路由器的信道切换不同步，ESP-MESH 网络和路由器之间将存在临时信道差异。<ul>
<li>ESP-MESH 网络的信道切换时间取决于 ESP-MESH 网络的信标间隔和根节点的自定义信道切换计数值。</li>
<li>通道差异可防止在 ESP-MESH 网络切换期间根节点与路由器之间的任何数据交换。</li>
<li>在 ESP-MESH 网络中，根节点和中间父节点将请求其连接的子节点停止传输，直到通过将 CSA 元素中的信道切换模式字段设置为 1 来进行信道切换。</li>
<li>频繁路由器触发的网络信道切换会降低 ESP-MESH 网络的性能。请注意，这可能是由 ESP-MESH 网络本身引起的（例如，由于与 ESP-MESH 网络的无线媒体争用）。如果是这种情况，用户应禁用路由器上的自动信道切换，并使用指定的信道。</li>
</ul>
</li>
<li>当存在临时信道差异时，根节点在技术上保持与路由器的连接。<ul>
<li>在根节点未能通过固定数量的路由器信标间隔从路由器接收任何信标帧或探测响应之后发生断开连接。</li>
<li>断开连接后，根节点将自动重新扫描所有通道以查找是否存在路由器。</li>
</ul>
</li>
<li>如果根节点无法接收任何路由器的 CSA 信标帧（例如，由于路由器给出的切换时间短），路由器将在没有 ESP-MESH 网络知识的情况下切换信道。<ul>
<li>路由器切换通道后，根节点将无法再接收路由器的信标帧和探测响应，并在固定数量的信标间隔后导致断开连接。</li>
<li>断开连接后，根节点将重新扫描路由器的所有通道。</li>
<li>根节点将在整个过程中维护下游连接。</li>
</ul>
</li>
</ul>
<blockquote>
<p>尽管 ESP-MESH 网络信道切换旨在将网络内的所有节点移动到新的操作信道，但应该认识到信道切换可能不能成功地移动所有节点（例如，由于诸如节点故障的原因）。</p>
</blockquote>
<h3 id="通道和路由器切换配置"><a href="#通道和路由器切换配置" class="headerlink" title="通道和路由器切换配置"></a>通道和路由器切换配置</h3><p>ESP-MESH 允许通过配置启用/禁用自主通道切换。同样，也可以通过配置启用/禁用自主路由器切换（即，当根节点自主连接到另一个路由器时）。自主信道切换和路由器切换取决于以下配置参数和运行时条件。</p>
<p><strong>允许通道切换：</strong> 此参数通过 <code>mesh_cfg_t</code> 结构的 <code>allow_channel_switch</code> 字段设置，并允许 ESP-MESH 网络在设置时动态切换通道。</p>
<p><strong>预设信道：</strong> 通过将 <code>mesh_cfg_t</code> 结构的信道字段设置为所需的信道号，ESP-MESH 网络可以拥有预设信道。如果未设置此字段，则会覆盖 <code>allow_channel_switch</code> 参数，以便始终允许通道切换。</p>
<p><strong>允许路由器切换：</strong> 此参数通过 <code>mesh_router_t</code> 的 <code>allow_router_switch</code> 字段设置，并允许 ESP-MESH 在设置时动态切换到其他路由器。</p>
<p><strong>预设路由器BSSID：</strong> ESP-MESH 网络可以通过将 <code>mesh_router_t</code> 结构的 <code>bssid</code> 字段设置为所需路由器的 BSSID 来具有预设路由器。如果未设置此字段，则会覆盖 <code>allow_router_switch</code> 参数，以便始终允许路由器切换。</p>
<p><strong>根节点存在：</strong> 根节点的存在还会影响是允许还是允许通道或路由器切换。</p>
<p>下表说明了参数/条件的不同组合如何影响是否允许信道切换和/或路由器切换。请注意，X 表示参数的“不关心”。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201171947753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>可以基于多个指标评估 ESP-MESH 网络的性能，例如：</p>
<p><strong>网络构建时间：</strong> 从头开始构建 ESP-MESH 网络所需的时间。</p>
<p><strong>恢复时间：</strong> 网络检测节点故障所需的时间，并执行适当的操作来修复网络（例如生成新的根节点或形成新的连接）。</p>
<p><strong>每跳延迟：</strong> 通过一个无线跳数据传输的延迟。换句话说，将数据包从父节点传输到子节点所花费的时间，反之亦然。</p>
<p><strong>网络节点容量：</strong> ESP-MESH 网络可以同时支持的节点总数。<strong>此数字由节点可接受的最大下游连接数和网络中允许的最大层数确定。</strong></p>
<p>下表列出了 ESP-MESH 网络的常见性能数据。但是，用户应注意，基于网络配置和操作环境的安装之间的性能数字可能会有很大差异。</p>
<blockquote>
<p>使用以下测试条件产生上述性能数据。</p>
<ul>
<li>测试设备数量：100</li>
<li>要接受的最大下游连接数：6</li>
<li>最大允许层数：6</li>
</ul>
</blockquote>
<blockquote>
<p>吞吐量取决于数据包错误率和跳数。</p>
</blockquote>
<blockquote>
<p>根节点访问外部IP网络的吞吐量直接受 ESP-MESH 网络中节点数量和路由器带宽的影响。</p>
</blockquote>
<h2 id="进一步说明"><a href="#进一步说明" class="headerlink" title="进一步说明"></a>进一步说明</h2><ul>
<li>数据传输使用 Wi-Fi WPA2-PSK 加密</li>
<li>网状网络 IE 使用 AES 加密</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十六）ESP-MESH 编程指南</title>
    <url>/InfiniteYuanBlog/2019/03/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89ESP-MESH%20%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="ESP-MESH-编程指南"><a href="#ESP-MESH-编程指南" class="headerlink" title="ESP-MESH 编程指南"></a>ESP-MESH 编程指南</h1><p>这是 ESP-MESH 的编程指南，包括 API 参考和编码示例。本指南分为以下几部分：</p>
<ul>
<li>ESP-MESH 编程模型</li>
<li>编写 ESP-MESH 应用程序</li>
<li>自组织网络</li>
<li>应用实例</li>
<li>API 参考</li>
</ul>
<p>有关 ESP-MESH 协议的文档，请参阅 <a href="https://mp.csdn.net/postedit/86743079" target="_blank" rel="noopener">ESP-MESH API 指南</a>。</p>
<a id="more"></a>

<h2 id="ESP-MESH-编程模型"><a href="#ESP-MESH-编程模型" class="headerlink" title="ESP-MESH 编程模型"></a>ESP-MESH 编程模型</h2><h3 id="软件栈"><a href="#软件栈" class="headerlink" title="软件栈"></a>软件栈</h3><p>ESP-MESH 软件栈构建在 Wi-Fi 驱动/FreeRTOS 之上，并且在某些情况下可以使用 LwIP 栈（即根节点）。下图说明了 ESP-MESH 软件栈。<br><img src="https://img-blog.csdnimg.cn/2019030215595528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 软件栈"></p>
<h3 id="系统事件"><a href="#系统事件" class="headerlink" title="系统事件"></a>系统事件</h3><p>应用程序通过 ESP-MESH 事件与 ESP-MESH 交互。由于 ESP-MESH 构建在 Wi-Fi 栈的顶部，因此应用程序也可以通过 Wi-Fi 事件任务与 Wi-Fi 驱动交互。下图说明了 ESP-MESH 应用程序中各种系统事件的接口。<br><img src="https://img-blog.csdnimg.cn/20190302162721734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 系统事件"><br><code>mesh_event_id_t</code> 定义所有可能的  ESP-MESH 系统事件，并且可以指示诸如父/子的连接/断开之类的事件。在可以使用 ESP-MESH 系统事件之前，应用程序必须通过 <code>esp_mesh_set_config()</code> 注册 Mesh 事件回调。 回调用于从 ESP-MESH 栈以及 LwIP 栈接收事件，并且应包含与应用程序相关的每个事件的处理程序。</p>
<p>系统事件的典型用例包括使用诸如 <code>MESH_EVENT_PARENT_CONNECTED</code> 和 <code>MESH_EVENT_CHILD_CONNECTED</code> 之类的事件来指示节点何时可以分别开始上游和下游传输数据。 同样，<code>MESH_EVENT_ROOT_GOT_IP</code> 和 <code>MESH_EVENT_ROOT_LOST_IP</code> 可用于指示根节点何时能够和不能将数据传输到外部 IP 网络。</p>
<blockquote>
<p>在自组织模式下使用 ESP-MESH 时，用户必须确保不会调用 Wi-Fi API。这是因为自组织模式将在内部进行 Wi-Fi API 调用以连接/断开/扫描等。来自应用程序的任何 Wi-Fi 调用（包括来自回调函数和 Wi-Fi 事件处理程序的调用）可能干扰 ESP-MESH 的自组织行为。因此，在调用 <code>esp_mesh_start()</code> 之后，并且在调用 <code>esp_mesh_stop()</code> 之前，用户不应该调用 Wi-Fi API。</p>
</blockquote>
<h3 id="LwIP-amp-ESP-MESH"><a href="#LwIP-amp-ESP-MESH" class="headerlink" title="LwIP &amp; ESP-MESH"></a>LwIP &amp; ESP-MESH</h3><p><strong>应用程序可以直接访问 ESP-MESH 栈，而无需通过 LwIP 栈。仅根节点需要 LwIP 栈向/从外部 IP 网络发送/接收数据。</strong> 但是，由于每个节点都可能成为根节点（由于自动根节点选择），每个节点仍必须初始化 LwIP 栈。</p>
<p><strong>每个节点都需要通过调用 <code>tcpip_adapter_init()</code> 来初始化 LwIP 栈。为了防止非根节点访问 LwIP 栈，应用程序应在 LwIP 栈初始化后停止以下服务</strong>：</p>
<ul>
<li>SoftAP 接口上的 DHCP 服务器服务。</li>
<li>Station 接口上的 DHCP 客户端服务。</li>
</ul>
<p>以下代码段演示了如何为 ESP-MESH 应用程序初始化 LwIP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*  tcpip initialization *&#x2F;</span><br><span class="line">tcpip_adapter_init();</span><br><span class="line">&#x2F;*</span><br><span class="line"> * for mesh</span><br><span class="line"> * stop DHCP server on softAP interface by default</span><br><span class="line"> * stop DHCP client on station interface by default</span><br><span class="line"> *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA));</span><br><span class="line">&#x2F;* do not specify system event callback, use NULL instead. *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_event_loop_init(NULL, NULL));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ESP-MESH 要求根节点与路由器连接。因此，如果节点成为根节点，则相应的处理程序必须启动 DHCP 客户端服务并立即获取 IP 地址。这样做将允许其他节点开始向/从外部 IP 网络发送/接收分组。但是，如果使用静态 IP 设置，则不需要此步骤。</p>
</blockquote>
<h2 id="编写-ESP-MESH-应用程序"><a href="#编写-ESP-MESH-应用程序" class="headerlink" title="编写 ESP-MESH 应用程序"></a>编写 ESP-MESH 应用程序</h2><p><strong>启动 ESP-MESH 的先决条件是初始化 LwIP 和 Wi-Fi。</strong> 以下代码片段演示了初始化 ESP-MESH 之前必要的先决条件步骤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpip_adapter_init();</span><br><span class="line">&#x2F;*</span><br><span class="line"> * for mesh</span><br><span class="line"> * stop DHCP server on softAP interface by default</span><br><span class="line"> * stop DHCP client on station interface by default</span><br><span class="line"> *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA));</span><br><span class="line">&#x2F;* do not specify system event callback, use NULL instead. *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_event_loop_init(NULL, NULL));</span><br><span class="line"></span><br><span class="line">&#x2F;*  Wi-Fi initialization *&#x2F;</span><br><span class="line">wifi_init_config_t config &#x3D; WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_init(&amp;config));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_start());</span><br></pre></td></tr></table></figure>

<p>初始化 LwIP 和 Wi-Fi 后，启动和运行 ESP-MESH 网络的过程可归纳为以下三个步骤：</p>
<ul>
<li>初始化 Mesh</li>
<li>配置 ESP-MESH 网络</li>
<li>启动 Mesh</li>
</ul>
<h3 id="初始化-Mesh"><a href="#初始化-Mesh" class="headerlink" title="初始化 Mesh"></a>初始化 Mesh</h3><p>以下代码段演示了如何初始化 ESP-MESH</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*  mesh initialization *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_init());</span><br></pre></td></tr></table></figure>

<h3 id="配置-ESP-MESH-网络"><a href="#配置-ESP-MESH-网络" class="headerlink" title="配置 ESP-MESH 网络"></a>配置 ESP-MESH 网络</h3><p><strong>ESP-MESH 通过 <code>esp_mesh_set_config()</code> 配置，它使用 <code>mesh_cfg_t</code> 结构接收其参数。</strong> 该结构包含用于配置 ESP-MESH 的以下参数：</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Channel</td>
<td>Range from 1 to 14</td>
</tr>
<tr>
<td>Event Callback</td>
<td>Callback for Mesh Events, see mesh_event_cb_t</td>
</tr>
<tr>
<td>Mesh ID</td>
<td>ID of ESP-MESH Network, see mesh_addr_t</td>
</tr>
<tr>
<td>Router</td>
<td>Router Configuration, see mesh_router_t</td>
</tr>
<tr>
<td>Mesh AP</td>
<td>Mesh AP Configuration, see mesh_ap_cfg_t</td>
</tr>
<tr>
<td>Crypto Functions</td>
<td>Crypto Functions for Mesh IE, see mesh_crypto_funcs_t</td>
</tr>
</tbody></table>
<p>以下代码段演示了如何配置 ESP-MESH。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Enable the Mesh IE encryption by default *&#x2F;</span><br><span class="line">mesh_cfg_t cfg &#x3D; MESH_INIT_CONFIG_DEFAULT();</span><br><span class="line">&#x2F;* mesh ID *&#x2F;</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.mesh_id, MESH_ID, 6);</span><br><span class="line">&#x2F;* mesh event callback *&#x2F;</span><br><span class="line">cfg.event_cb &#x3D; &amp;mesh_event_handler;</span><br><span class="line">&#x2F;* channel (must match the router&#39;s channel) *&#x2F;</span><br><span class="line">cfg.channel &#x3D; CONFIG_MESH_CHANNEL;</span><br><span class="line">&#x2F;* router *&#x2F;</span><br><span class="line">cfg.router.ssid_len &#x3D; strlen(CONFIG_MESH_ROUTER_SSID);</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len);</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.router.password, CONFIG_MESH_ROUTER_PASSWD,</span><br><span class="line">       strlen(CONFIG_MESH_ROUTER_PASSWD));</span><br><span class="line">&#x2F;* mesh softAP *&#x2F;</span><br><span class="line">cfg.mesh_ap.max_connection &#x3D; CONFIG_MESH_AP_CONNECTIONS;</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD,</span><br><span class="line">       strlen(CONFIG_MESH_AP_PASSWD));</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_set_config(&amp;cfg));</span><br></pre></td></tr></table></figure>

<h3 id="启动-Mesh"><a href="#启动-Mesh" class="headerlink" title="启动 Mesh"></a>启动 Mesh</h3><p>以下代码段演示了如何启动 ESP-MESH。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* mesh start *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_start());</span><br></pre></td></tr></table></figure>

<p><strong>启动 ESP-MESH 后，应用程序应检查 ESP-MESH 事件以确定它何时连接到网络。连接后，应用程序可以使用 <code>esp_mesh_send()</code> 和 <code>esp_mesh_recv()</code> 通过 ESP-MESH 网络开始发送和接收数据包。</strong></p>
<h2 id="自组织网络"><a href="#自组织网络" class="headerlink" title="自组织网络"></a>自组织网络</h2><p>自组织网络是 ESP-MESH 的一项功能，节点可以自动扫描/选择/连接/重新连接到其他节点和路由器。此功能允许 ESP-MESH 网络通过使网络对动态网络拓扑和条件具有鲁棒性来实现高度自治。启用自组织网络后，ESP-MESH 网络中的节点无需自主执行以下操作：</p>
<ul>
<li>选择或选择根节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-building-a-network" target="_blank" rel="noopener">构建网络</a>中的自动根节点选择）</li>
<li>选择首选父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-building-a-network" target="_blank" rel="noopener">构建网络</a>中的父节点选择）</li>
<li>检测到断开连接时自动重新连接（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-managing-a-network" target="_blank" rel="noopener">管理网络</a>中的中间父节点故障）</li>
</ul>
<p>启用自组织网络后，ESP-MESH 栈将在内部调用 Wi-Fi 驱动程序 API。因此，应用层不应对 Wi-Fi 驱动程序 API 进行任何调用，同时启用自组织网络，否则可能会干扰 ESP-MESH。</p>
<h3 id="切换自组织网络"><a href="#切换自组织网络" class="headerlink" title="切换自组织网络"></a>切换自组织网络</h3><p>应用程序在运行时通过调用 <code>esp_mesh_set_self_organized()</code> 函数可以启用或禁用自组织网络。该函数具有以下两个参数：</p>
<ul>
<li><code>bool enable</code> 指定是启用还是禁用自组织网络。</li>
<li><code>bool select_parent</code> 指定在启用自组织网络时是否应选择新的父节点。根据节点类型和节点的当前状态，选择新父级具有不同的效果。禁用自组织网络时，此参数未使用。</li>
</ul>
<h3 id="禁用自组织网络"><a href="#禁用自组织网络" class="headerlink" title="禁用自组织网络"></a>禁用自组织网络</h3><p>以下代码段演示了如何禁用自组织网络。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Disable self organized networking</span><br><span class="line">esp_mesh_set_self_organized(false, false);</span><br></pre></td></tr></table></figure>

<p>当禁用自组织网络时，ESP-MESH 将尝试维持节点当前的 Wi-Fi 状态。</p>
<ul>
<li>如果节点先前已连接到其他节点，则它将保持连接状态。</li>
<li>如果节点先前已断开连接并且正在扫描父节点或路由器，则它将停止扫描。</li>
<li>如果节点先前尝试重新连接到父节点或路由器，它将停止重新连接。</li>
</ul>
<h3 id="启用自组织网络"><a href="#启用自组织网络" class="headerlink" title="启用自组织网络"></a>启用自组织网络</h3><p>在启用自组织网络时，ESP-MESH 将尝试维持节点当前的 Wi-Fi 状态。但是，根据节点类型以及是否选择了新父节点，节点的 Wi-Fi 状态可能会发生变化。下表显示了启用自组织网络的效果。</p>
<p><img src="https://img-blog.csdnimg.cn/20190302173636709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以下代码演示了如何启用自组织网络。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Enable self organized networking and select a new parent</span><br><span class="line">esp_mesh_set_self_organized(true, true);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Enable self organized networking and manually reconnect</span><br><span class="line">esp_mesh_set_self_organized(true, false);</span><br><span class="line">esp_mesh_connect();</span><br></pre></td></tr></table></figure>

<h3 id="调用-Wi-Fi-驱动程序-API"><a href="#调用-Wi-Fi-驱动程序-API" class="headerlink" title="调用 Wi-Fi 驱动程序 API"></a>调用 Wi-Fi 驱动程序 API</h3><p>应用程序可能希望在使用 ESP-MESH 时直接调用 Wi-Fi 驱动程序 API 的情况。例如，应用程序可能想要手动扫描相邻的 AP。但是，<strong>在应用程序调用任何 Wi-Fi 驱动程序 API 之前，必须禁用自组织网络。</strong> 这将阻止 ESP-MESH 栈尝试调用任何 Wi-Fi 驱动程序 API ，ESP-MESH 栈的这些调用可能干扰应用程序的调用。</p>
<p>因此，<strong>应该在调用 <code>esp_mesh_set_self_organized()</code> 进行禁用和启用自组织网络之间放置对 Wi-Fi 驱动程序 API 的调用。</strong> 以下代码段演示了应用程序在使用 ESP-MESH 时如何安全地调用 <code>esp_wifi_scan_start()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Disable self organized networking</span><br><span class="line">esp_mesh_set_self_organized(0, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Stop any scans already in progress</span><br><span class="line">esp_wifi_scan_stop();</span><br><span class="line">&#x2F;&#x2F;Manually start scan. Will automatically stop when run to completion</span><br><span class="line">esp_wifi_scan_start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Process scan results</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if still connected</span><br><span class="line">esp_mesh_set_self_organized(1, 0);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if non-root and disconnected</span><br><span class="line">esp_mesh_set_self_organized(1, 1);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if root and disconnected</span><br><span class="line">esp_mesh_set_self_organized(1, 0);  &#x2F;&#x2F;Don&#39;t select new parent</span><br><span class="line">esp_mesh_connect();                 &#x2F;&#x2F;Manually reconnect to router</span><br></pre></td></tr></table></figure>

<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>ESP-IDF 包含这些 ESP-MESH 示例项目：</p>
<p><a href="https://github.com/espressif/esp-idf/tree/ebdcbe8c6/examples/mesh/internal_communication" target="_blank" rel="noopener">内部通信示例</a>演示了如何设置 ESP-MESH 网络并让根节点向网络中的每个节点发送数据包。</p>
<p><a href="https://github.com/espressif/esp-idf/tree/ebdcbe8c6/examples/mesh/manual_networking" target="_blank" rel="noopener">手动网络示例</a>演示了如何在没有自组织功能的情况下使用 ESP-MESH。此示例显示如何对节点进行编程以手动扫描潜在父节点列表，并根据自定义条件选择父节点。</p>
<h2 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul>
<li>esp32/include/esp_mesh.h</li>
</ul>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ul>
<li>esp_err_tesp_mesh_init(void)</li>
<li>esp_err_tesp_mesh_deinit(void)</li>
<li>esp_err_tesp_mesh_start(void)</li>
<li>esp_err_tesp_mesh_stop(void)</li>
<li>esp_err_tesp_mesh_send(constmesh_addr_t *to, constmesh_data_t *data, int flag, constmesh_opt_topt[], int opt_count)</li>
<li>esp_err_tesp_mesh_recv(mesh_addr_t *from, mesh_data_t *data, int timeout_ms, int *flag, mesh_opt_topt[], int opt_count)</li>
<li>esp_err_tesp_mesh_recv_toDS(mesh_addr_t *from, mesh_addr_t *to, mesh_data_t *data, int timeout_ms, int *flag, mesh_opt_topt[], int opt_count)</li>
<li>esp_err_tesp_mesh_set_config(constmesh_cfg_t *config)</li>
<li>esp_err_tesp_mesh_get_config(mesh_cfg_t *config)</li>
<li>esp_err_tesp_mesh_set_router(constmesh_router_t *router)</li>
<li>esp_err_tesp_mesh_get_router(mesh_router_t *router)</li>
<li>esp_err_tesp_mesh_set_id(constmesh_addr_t *id)</li>
<li>esp_err_tesp_mesh_get_id(mesh_addr_t *id)</li>
<li>esp_err_tesp_mesh_set_type(mesh_type_ttype)</li>
<li>mesh_type_tesp_mesh_get_type(void)</li>
<li>esp_err_tesp_mesh_set_max_layer(int max_layer)</li>
<li>int esp_mesh_get_max_layer(void)</li>
<li>esp_err_tesp_mesh_set_ap_password(const uint8_t *pwd, int len)</li>
<li>esp_err_tesp_mesh_set_ap_authmode(wifi_auth_mode_tauthmode)</li>
<li>wifi_auth_mode_tesp_mesh_get_ap_authmode(void)</li>
<li>esp_err_tesp_mesh_set_ap_connections(int connections)</li>
<li>int esp_mesh_get_ap_connections(void)</li>
<li>int esp_mesh_get_layer(void)</li>
<li>esp_err_tesp_mesh_get_parent_bssid(mesh_addr_t *bssid)</li>
<li>bool esp_mesh_is_root(void)</li>
<li>esp_err_tesp_mesh_set_self_organized(bool enable, bool select_parent)</li>
<li>bool esp_mesh_get_self_organized(void)</li>
<li>esp_err_tesp_mesh_waive_root(constmesh_vote_t *vote, int reason)</li>
<li>esp_err_tesp_mesh_set_vote_percentage(float percentage)</li>
<li>float esp_mesh_get_vote_percentage(void)</li>
<li>esp_err_tesp_mesh_set_ap_assoc_expire(int seconds)</li>
<li>int esp_mesh_get_ap_assoc_expire(void)</li>
<li>int esp_mesh_get_total_node_num(void)</li>
<li>int esp_mesh_get_routing_table_size(void)</li>
<li>esp_err_tesp_mesh_get_routing_table(mesh_addr_t *mac, int len, int *size)</li>
<li>esp_err_tesp_mesh_post_toDS_state(bool reachable)</li>
<li>esp_err_tesp_mesh_get_tx_pending(mesh_tx_pending_t *pending)</li>
<li>esp_err_tesp_mesh_get_rx_pending(mesh_rx_pending_t *pending)</li>
<li>int esp_mesh_available_txupQ_num(constmesh_addr_t *addr, uint32_t *xseqno_in)</li>
<li>esp_err_tesp_mesh_set_xon_qsize(int qsize)</li>
<li>int esp_mesh_get_xon_qsize(void)</li>
<li>esp_err_tesp_mesh_allow_root_conflicts(bool allowed)</li>
<li>bool esp_mesh_is_root_conflicts_allowed(void)</li>
<li>esp_err_tesp_mesh_set_group_id(constmesh_addr_t *addr, int num)</li>
<li>esp_err_tesp_mesh_delete_group_id(constmesh_addr_t *addr, int num)</li>
<li>int esp_mesh_get_group_num(void)</li>
<li>esp_err_tesp_mesh_get_group_list(mesh_addr_t *addr, int num)</li>
<li>bool esp_mesh_is_my_group(constmesh_addr_t *addr)</li>
<li>esp_err_tesp_mesh_set_capacity_num(int num)</li>
<li>int esp_mesh_get_capacity_num(void)</li>
<li>esp_err_tesp_mesh_set_ie_crypto_funcs(const mesh_crypto_funcs_t *crypto_funcs)</li>
<li>esp_err_tesp_mesh_set_ie_crypto_key(const char *key, int len)</li>
<li>esp_err_tesp_mesh_get_ie_crypto_key(char *key, int len)</li>
<li>esp_err_tesp_mesh_set_root_healing_delay(int delay_ms)</li>
<li>int esp_mesh_get_root_healing_delay(void)</li>
<li>esp_err_tesp_mesh_set_event_cb(constmesh_event_cb_tevent_cb)</li>
<li>esp_err_tesp_mesh_fix_root(bool enable)</li>
<li>bool esp_mesh_is_root_fixed(void)</li>
<li>esp_err_tesp_mesh_set_parent(constwifi_config_t *parent, constmesh_addr_t *parent_mesh_id, mesh_type_tmy_type, int my_layer)</li>
<li>esp_err_tesp_mesh_scan_get_ap_ie_len(int *len)</li>
<li>esp_err_tesp_mesh_scan_get_ap_record(wifi_ap_record_t *ap_record, void *buffer)</li>
<li>esp_err_tesp_mesh_flush_upstream_packets(void)</li>
<li>esp_err_tesp_mesh_get_subnet_nodes_num(constmesh_addr_t *child_mac, int *nodes_num)</li>
<li>esp_err_tesp_mesh_get_subnet_nodes_list(constmesh_addr_t *child_mac, mesh_addr_t *nodes, int nodes_num)</li>
<li>esp_err_tesp_mesh_disconnect(void)</li>
<li>esp_err_tesp_mesh_connect(void)</li>
<li>esp_err_tesp_mesh_flush_scan_result(void)</li>
<li>esp_err_tesp_mesh_switch_channel(const uint8_t *new_bssid, int csa_newchan, int csa_count)</li>
<li>esp_err_tesp_mesh_get_router_bssid(uint8_t *router_bssid)</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/network/esp_mesh.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十四）RF 校准</title>
    <url>/InfiniteYuanBlog/2018/12/09/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89RF%20%E6%A0%A1%E5%87%86/</url>
    <content><![CDATA[<h1 id="RF-校准"><a href="#RF-校准" class="headerlink" title="RF 校准"></a>RF 校准</h1><p>ESP32 在 RF 初始化期间支持三种 RF 校准方法：</p>
<ol>
<li>部分校准</li>
<li>完全校准</li>
<li>没有校准</li>
</ol>
<a id="more"></a>

<h2 id="部分校准"><a href="#部分校准" class="headerlink" title="部分校准"></a>部分校准</h2><p>在 RF 初始化期间，默认情况下使用部分校准方法进行 RF 校准。 它基于存储在 NVS 中的完整校准数据完成。 要使用此方法，请到 <code>menuconfig</code> 并启用 <code>CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE</code>。</p>
<h2 id="完全校准"><a href="#完全校准" class="headerlink" title="完全校准"></a>完全校准</h2><p>在以下条件下触发完全校准：</p>
<ol>
<li>NVS  不存在。</li>
<li>用于存储校准数据的  NVS  分区被擦除。</li>
<li>硬件 MAC  地址已更改。</li>
<li>PHY 库版本已更改。</li>
<li>从 NVS 分区加载的 RF 校准数据被破坏。</li>
</ol>
<p>需要大约  100 ms, 比部分校准用的时间多。如果启动持续时间不重要，建议使用完整的校准方法。要切换到完整校准方法，请转到 <code>menuconfig</code> 并禁用 <code>CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE</code>。如果使用 RF 校准的默认方法，有两种方法可以添加触发完全校准功能作为最后的补救措施。</p>
<ol>
<li>如果您不介意删除存储在  NVS  分区中的所有数据，请擦除 NVS 分区。</li>
<li>在基于某些条件（例如，在某些诊断模式中提供的选项）初始化 WiFi  和 BT/BLE 之前调用 <code>esp_phy_erase_cal_data_in_nvs（）</code>。在这种情况下，仅擦除 NVS 分区的 phy 命名空间。</li>
</ol>
<h2 id="没有校准"><a href="#没有校准" class="headerlink" title="没有校准"></a>没有校准</h2><p>ESP32 从深度睡眠中醒来时，不会使用校准方法。</p>
<h2 id="PHY-初始化数据"><a href="#PHY-初始化数据" class="headerlink" title="PHY 初始化数据"></a>PHY 初始化数据</h2><p>PHY 初始化数据用于 RF 校准。 有两种方法可以获得 PHY 初始化数据。</p>
<ol>
<li>一个是默认的初始化数据，它位于头文件 <code>components/esp32/phy_init_data.h</code> 中。 它在编译后嵌入到应用程序二进制文件中，然后存储到只读存储器（DROM）中。 要使用默认初始化数据，请到 <code>menuconfig</code> 并禁用 <code>CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</code>。</li>
<li>另一种是存储在分区中的初始化数据。 使用自定义分区表时，请确保包含 PHY 数据分区（类型：数据，子类型：phy）。 使用默认分区表，这是自动完成的。 如果初始化数据存储在分区中，则必须在那里闪存，否则将发生运行时错误。 要切换到存储在分区中的初始化数据，请到 <code>menuconfig</code> 并启用 <code>CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</code>。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/RF_calibration.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十）线程局部存储</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>线程局部存储 (TLS) 是一种机制,通过该机制分配变量,使每个现存线程有一个变量实例. ESP-IDF 提供了三种利用这些变量的方法:</p>
<p><a href="#freertos-%E5%8E%9F%E7%94%9F-api">FreeRTOS 原生 API</a>: ESP-IDF FreeRTOS 原生 API.<br><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-api">多线程 API</a>:ESP-IDF 的多线程 API.<br><a href="#c11-%E6%A0%87%E5%87%86">C11 标准</a>:C11 标准引入了特殊关键字来将变量声明为线程局部.</p>
<a id="more"></a>

<h2 id="FreeRTOS-原生-API"><a href="#FreeRTOS-原生-API" class="headerlink" title="FreeRTOS 原生 API"></a>FreeRTOS 原生 API</h2><p>ESP-IDF FreeRTOS 提供以下 AP I来管理线程局部变量:</p>
<ul>
<li>vTaskSetThreadLocalStoragePointer()</li>
<li>pvTaskGetThreadLocalStoragePointer()</li>
<li>vTaskSetThreadLocalStoragePointerAndDelCallback()</li>
</ul>
<p>在这种情况下,可分配的最大变量数受 <code>configNUM_THREAD_LOCAL_STORAGE_POINTERS</code> 宏的限制. 变量保存在任务控制块 (TCB) 中,并通过索引访问. 请注意,索引 0 保留用于 ESP-IDF 内部使用. 使用该 API,用户可以分配任意大小的线程局部变量,并将它们分配给任意数量的任务. 不同的任务可以有不同的 TLS 变量集. 如果变量的大小超过 4 个字节,则用户负责为其分配/释放内存. 变量的释放由 FreeRTOS 在删除任务时启动,但用户必须提供函数(回调)才能进行适当的清理.</p>
<h2 id="多线程-API"><a href="#多线程-API" class="headerlink" title="多线程 API"></a>多线程 API</h2><p>ESP-IDF提供以下 多线程 API 来管理线程局部变量:</p>
<ul>
<li>pthread_key_create()</li>
<li>pthread_key_delete()</li>
<li>pthread_getspecific()</li>
<li>pthread_setspecific()</li>
</ul>
<p>此 API 具有上述 API 的所有优点,但消除了一些限制. 变量的数量仅受堆上可用内存大小的限制. 由于动态特性,与原生 API 相比,此 API 引入了额外的性能开销.</p>
<h2 id="C11-标准"><a href="#C11-标准" class="headerlink" title="C11 标准"></a>C11 标准</h2><p>ESP-IDF FreeRTOS 支持根据 C11 标准的线程局部变量(使用 <code>__thread</code> 关键字指定的变量). 有关此 GCC 功能的详细信息,请参阅<a href="https://gcc.gnu.org/onlinedocs/gcc-5.5.0/gcc/Thread-Local.html#Thread-Local" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-5.5.0/gcc/Thread-Local.html#Thread-Local</a>. 这种变量的存储在任务堆栈上分配. 请注意,程序中所有此类变量的区域将分配到系统中每个任务的堆栈上,即使该任务根本不使用此类变量也是如此. 例如, ESP-IDF 系统任务(如 <code>ipc</code>, <code>timer</code> 任务等)也将分配额外的堆栈空间. 因此应谨慎使用此功能. 有一个权衡: C11 线程局部变量在编程中非常方便,只需使用几个 Xtensa 指令即可访问,但这个好处与系统中所有任务的额外堆栈使用成本有关. 由于变量的静态性质,系统中的所有任务都具有相同的 C11 线程局部变量集.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/thread-local-storage.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（四）错误处理</title>
    <url>/InfiniteYuanBlog/2018/09/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>识别和处理运行时错误对于开发健壮的应用程序非常重要. ESP-IDF 中可能存在多种运行时错误:</p>
<ul>
<li>可恢复的错误:<ul>
<li>函数通过返回值表示的错误(错误代码)</li>
<li>使用 throw 关键字抛出的 C++ 异常</li>
</ul>
</li>
<li>不可恢复(严重)错误:<ul>
<li>断言失败(使用断言宏和等效方法)和 abort() 调用.</li>
<li>CPU 异常:access to protected regions of memory, illegal instruction(访问受保护的内存区域,非法指令)等.</li>
<li>系统级别检查:watchdog timeout, cache access error, stack overflow, stack smashing, heap corruption(监视程序超时,缓存访问错误,堆栈溢出,堆栈粉碎,堆损坏)等.</li>
</ul>
</li>
</ul>
<p>本指南介绍了与可恢复错误相关的 ESP-IDF 错误处理机制,并提供了一些常见的错误处理模式.</p>
<p>有关诊断不可恢复错误的说明,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误</a>.</p>
<a id="more"></a>

<h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><p>大多数特定的 ESP-IDF 函数使用 <code>esp_err_t</code> 类型来返回错误代码. <code>esp_err_t</code> 是带符号的整数类型. <code>ESP_OK</code> 代码表示成功(无错误),定义为零.</p>
<p>各种 ESP-IDF 头文件使用预处理器定义来定义可能的错误代码. 通常这些定义以 <code>ESP_ERR_</code> 前缀开头. 通用错误的常见错误代码(内存不足,超时,无效参数等)在 <code>esp_err.h</code> 文件中定义. ESP-IDF 中的各种组件可以为特定情况定义附加的错误代码.</p>
<p>有关错误代码的完整列表,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/error-codes.html" target="_blank" rel="noopener">错误代码参考</a>.</p>
<h2 id="将错误代码转换为错误消息"><a href="#将错误代码转换为错误消息" class="headerlink" title="将错误代码转换为错误消息"></a>将错误代码转换为错误消息</h2><p>对于 ESP-IDF 组件中定义的每个错误代码,可以使用 <code>esp_err_to_name()</code> 或 <code>esp_err_to_name_r()</code> 函数将 <code>esp_err_t</code> 值转换为错误代码名称. 例如,将 <code>0x101</code> 传递给 <code>esp_err_to_name()</code> 将返回 “ESP_ERR_NO_MEM” 字符串. 可以在日志输出中使用此类字符串,以便更容易理解发生了哪个错误.</p>
<p>此外,如果未找到匹配的 <code>ESP_ERR_</code> 值,<code>esp_err_to_name_r()</code> 函数将尝试将错误代码解释为<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html" target="_blank" rel="noopener">标准 POSIX 错误代码</a>. 这是使用 <code>strerror_r</code> 函数完成的. POSIX 错误代码(例如 <code>ENOENT</code>,<code>ENOMEM</code>)在 <code>errno.h</code> 中定义,通常从 <code>errno</code> 变量获得. 在 ESP-IDF 中,这个变量是线程本地的:多个 FreeRTOS 任务都有自己的 <code>errno</code> 副本. 设置 <code>errno</code> 的函数仅修改它们运行的任务的值.</p>
<p>默认情况下启用此功能,但可以禁用此功能以减少应用程序二进制文件大小. 请参阅 <code>CONFIG_ESP_ERR_TO_NAME_LOOKUP</code>. 禁用此功能后,仍会定义 <code>esp_err_to_name()</code> 和 <code>esp_err_to_name_r()</code> ,并且可以调用它. 在这种情况下,<code>esp_err_to_name()</code> 将返回<code>UNKNOWN ERROR</code>,并且 <code>esp_err_to_name_r()</code> 将返回 <code>Unknown error 0xXXXX(YYYYY)</code> ,其中<code>0xXXXX</code> 和 <code>YYYYY</code> 分别是错误代码的十六进制和十进制表示.</p>
<h2 id="ESP-ERROR-CHECK-宏"><a href="#ESP-ERROR-CHECK-宏" class="headerlink" title="ESP_ERROR_CHECK 宏"></a><code>ESP_ERROR_CHECK</code> 宏</h2><p><code>ESP_ERROR_CHECK()</code> 宏与 <code>assert</code> 的用途相似,只是它检查 <code>esp_err_t</code> 值而不是 <code>bool</code> 条件. 如果 <code>ESP_ERROR_CHECK()</code> 的参数不等于 <code>ESP_OK</code> ,则在控制台上打印错误消息,并调用 <code>abort()</code>.</p>
<p>错误消息通常如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESP_ERROR_CHECK failed: esp_err_t 0x107 (ESP_ERR_TIMEOUT) at 0x400d1fdf</span><br><span class="line"></span><br><span class="line">file: &quot;&#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.c&quot; line 20</span><br><span class="line">func: app_main</span><br><span class="line">expression: sdmmc_card_init(host, &amp;card)</span><br><span class="line"></span><br><span class="line">Backtrace: 0x40086e7c:0x3ffb4ff0 0x40087328:0x3ffb5010 0x400d1fdf:0x3ffb5030 0x400d0816:0x3ffb5050</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/idf-monitor.html" target="_blank" rel="noopener">IDF monitor</a>,则回溯中的地址将转换为文件名和行号.</p>
</blockquote>
<ul>
<li>第一行提到错误代码为十六进制值,以及源代码中用于此错误的标识符. 后者取决于设置的 <code>CONFIG_ESP_ERR_TO_NAME_LOOKUP</code> 选项. 打印出错误的程序中的地址也被打印出来.</li>
<li>后续行显示程序中调用 <code>ESP_ERROR_CHECK()</code> 宏的位置,以及作为参数传递给宏的表达式.</li>
<li>最后,打印回溯. 这是所有错误 <code>panic</code> 处理程序输出的公共部分. 有关回溯的更多信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误 Fatal Errors</a>.</li>
</ul>
<h2 id="错误处理模式"><a href="#错误处理模式" class="headerlink" title="错误处理模式"></a>错误处理模式</h2><ol>
<li><p>尝试恢复. 根据具体情况,这可能意味着在一段时间后重试呼叫,或尝试取消初始化驱动程序并重新初始化,或使用带外机制修复错误条件(例如重置外部外围设备) 这没有回应).</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esp_err_t err;</span><br><span class="line">do &#123;</span><br><span class="line">    err &#x3D; sdio_slave_send_queue(addr, len, arg, timeout);</span><br><span class="line">    &#x2F;&#x2F; keep retrying while the sending queue is full</span><br><span class="line">&#125; while (err &#x3D;&#x3D; ESP_ERR_TIMEOUT);</span><br><span class="line">if (err !&#x3D; ESP_OK) &#123;</span><br><span class="line">    &#x2F;&#x2F; handle other errors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将错误传播给调用者. 在某些中间件组件中,这意味着函数必须以相同的错误代码退出,从而确保回滚任何资源分配.</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	sdmmc_card_t* card &#x3D; calloc(1, sizeof(sdmmc_card_t));</span><br><span class="line">if (card &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    return ESP_ERR_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line">esp_err_t err &#x3D; sdmmc_card_init(host, &amp;card);</span><br><span class="line">if (err !&#x3D; ESP_OK) &#123;</span><br><span class="line">    &#x2F;&#x2F; Clean up</span><br><span class="line">    free(card);</span><br><span class="line">    &#x2F;&#x2F; Propagate the error to the upper layer (e.g. to notify the user).</span><br><span class="line">    &#x2F;&#x2F; Alternatively, application can define and return custom error code.</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换为不可恢复的错误,例如使用 <code>ESP_ERROR_CHECK</code>. 有关详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/error-handling.html#esp-error-check-macro" target="_blank" rel="noopener"><code>ESP_ERROR_CHECK</code> 宏</a>部分.</p>
<p>在出现错误的情况下终止应用程序通常是中间件组件的不良行为,但有时在应用程序级别可以接受.</p>
<p>许多 ESP-IDF 示例使用 <code>ESP_ERROR_CHECK</code> 来处理来自各种API的错误. 这不是应用程序的最佳实践,并且可以使示例代码更简洁.</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESP_ERROR_CHECK(spi_bus_initialize(host, bus_config, dma_chan));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="C-异常"><a href="#C-异常" class="headerlink" title="C++ 异常"></a>C++ 异常</h2><p>默认情况下禁用对 ESP-IDF 中的 C++ 异常的支持,但可以使用 <code>CONFIG_CXX_EXCEPTIONS</code> 选项启用.</p>
<p>启用异常处理通常会将应用程序二进制大小增加几KB. 此外,可能需要为异常紧急池预留一定量的 RAM. 如果无法从堆中分配异常对象,则将使用此池中的内存. 可以使用 <code>CONFIG_CXX_EXCEPTIONS_EMG_POOL_SIZE</code> 变量设置应急池中的内存量.</p>
<p>如果抛出异常,但没有 <code>catch</code> 块,程序将被 <code>abort</code> 函数终止,并且将打印 <code>backtrace</code>. 有关回溯的更多信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误</a>.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/error-handling.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（一）ESP32  移植开源图形库 uGFX</title>
    <url>/InfiniteYuanBlog/2018/01/10/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89ESP32%20%20%E7%A7%BB%E6%A4%8D%E5%BC%80%E6%BA%90%E5%9B%BE%E5%BD%A2%E5%BA%93%20uGFX/</url>
    <content><![CDATA[<h1 id="ESP32-移植开源图形库-ugfx"><a href="#ESP32-移植开源图形库-ugfx" class="headerlink" title="ESP32 移植开源图形库 ugfx"></a>ESP32 移植开源图形库 ugfx</h1><p>ESP32 移植 uGFX 的源码：<a href="https://github.com/InfiniteYuan/esp32-ugfx-gui" target="_blank" rel="noopener">GitHub 源码地址</a><br>欢迎 Star ～</p>
<h2 id="源码工程分析"><a href="#源码工程分析" class="headerlink" title="源码工程分析"></a>源码工程分析</h2><ol>
<li>/3rdparty 这里面包含第三方相关的功能代码</li>
<li>/boards 一些公用开发板的使用资料</li>
<li>/demos 例子应用</li>
<li>/docs 帮助文档</li>
<li>/drivers 底层驱动代码</li>
<li>/src 公共源码</li>
<li>/tools 相关工具</li>
</ol>
<a id="more"></a>

<h2 id="移植过程"><a href="#移植过程" class="headerlink" title="移植过程"></a>移植过程</h2><p>在移植之前，你需要配置 esp32-iot-solution 的环境，可参考： <a href="https://esp-idf.readthedocs.io/en/latest/get-started/index.html" target="_blank" rel="noopener"> ESP-IDF Programming Guide </a></p>
<ul>
<li>从 ugfx 官网下载源码：<a href="https://community.ugfx.io/index.php?/files/" target="_blank" rel="noopener">官网下载链接</a></li>
<li>在工程下单独建立一个 ugfx 文件夹，并在下面新建一个 include 文件夹（其中放入你需要包含的头文件）</li>
<li>拷贝配置头文件 gfxconf.h 和 gfx.h 到 include 文件夹</li>
<li>拷贝源码文件 /src 到 ugfx 文件夹下</li>
<li>添加驱动芯片的驱动文件到 ugfx 文件夹下（例如，你使用的 LCD 屏驱动和 touch 驱动，在 drives 中可以找到一些模板）</li>
<li>增加自己的板级文件 board_SSD1306.c</li>
<li>实现相关缺少函数，相关函数可以在 drivers 的驱动模板中看到。你需要选择性的实现一些函数，另一些函数使用默认的即可。</li>
</ul>
<p>这是我的工程结构，其中实现了：LCD(ST7789)、touch(XPT2046)<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTEwMTgxNzM5NjM3?x-oss-process=image/format,png" alt="这是我的工程结构"><br>在下面的两节，我将介绍我在移植 ugfx 中的部分过程，可供参考</p>
<h2 id="移植-LCD-驱动"><a href="#移植-LCD-驱动" class="headerlink" title="移植 LCD 驱动"></a>移植 LCD 驱动</h2><ul>
<li>由于 ugfx 官方未提供 st7789 的驱动模板，在这里我们使用 drivers/gdisp/ST7735 中的驱动模板，将其拷贝到我们的 ugfx 文件夹下，并从 ST7565 中拷贝一个头文件 board_ST7565_template.h，共需添加五个文件。</li>
<li>接着我们实现一些函数，例如 init_board、post_init_board、setpin_reset、acquire_bus、release_bus、write_cmd、write_data;这些都在 board_ST7565_template.h 中有默认定义，我们需要根据我们的工程情况修改实现方法</li>
<li>我们还需要对文件中的相关宏定义作修改</li>
</ul>
<h2 id="移植-touch-驱动"><a href="#移植-touch-驱动" class="headerlink" title="移植 touch 驱动"></a>移植 touch 驱动</h2><ul>
<li>在移植完上面的 lcd 驱动，相信你已经找到感觉，我们可以直接中 drivers/ginput/ 中拷贝 ads7843 下的文件到 ugfx 文件夹下，接着和移植 lcd 是类似的操作</li>
<li>实现函数，例如：getpin_pressed、read_value、init_board，在实现 aquire_bus、release_bus 的时候，可能编译器会报函数重定义的错，这个时候，我们需要查看是否头文件引用错误等</li>
</ul>
<h2 id="编译、运行"><a href="#编译、运行" class="headerlink" title="编译、运行"></a>编译、运行</h2><p>还需要根据 iot-solution 的规则拷贝 component.mk  到我们的工程文件夹下（参考上图），接着我们可以编译运行，其中会遇到很多文件包含错误，我们需要耐心的一个个去解决；在完成之后我们就可以使用了。</p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（七）LittlevGL PC Simulator 配置</title>
    <url>/InfiniteYuanBlog/2018/08/09/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89LittlevGL%20PC%20Simulator%20%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="LittlevGL-PC-Simulator-配置"><a href="#LittlevGL-PC-Simulator-配置" class="headerlink" title="LittlevGL PC Simulator 配置"></a>LittlevGL PC Simulator 配置</h1><p>视频教程：<a href="http://tuinghe.com/videos/how-to-run-littlev-graphics-library-in-pc-simulator-linux-q5n615u5m54674n4s5d6w5.html" target="_blank" rel="noopener">How to Run Littlev Graphics Library in PC Simulator (Linux)</a></p>
<h2 id="PC-simulator"><a href="#PC-simulator" class="headerlink" title="PC simulator"></a>PC simulator</h2><p>You can try out the Littlev Graphics Library using only your PC without any development board. Write a code, run it on the PC and see the result on the monitor. It is cross-platform: Windows, Linux and OSX is also supported!</p>
<ul>
<li>Needs only few minutes setup</li>
<li>Costs $0. No PCB cost and no pay for any software</li>
<li>A TFT display is simulated and shown on the monitor of your PC</li>
<li>The touch pad is replaced by your mouse</li>
<li>The written code is portable, you can simply copy it when using an embedded hardware</li>
</ul>
<a id="more"></a>

<h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><h3>Install Eclipse CDT</h3>

<p>Eclipse CDT is C/C++ IDE. You can use other IDEs as well but in this tutorial the configuration for Eclipse CDT is shown.<br>Eclipse is a Java based software therefore be sure Jave Runtime Environment is installed on your system.<br>On linux: sudo apt-get install default-jre<br>You can download Eclipse’s CDT from: <a href="https://eclipse.org/cdt/" target="_blank" rel="noopener">https://eclipse.org/cdt/</a>. Start the nstaller and choose <em>Eclipse CDT</em> from the list</p>
<h3>Install SDL 2</h3>

<p>The PC simulator uses the <a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">SDL 2</a> cross platform library to simulate a TFT display and a touch pad.</p>
<h5>Linux</h5>

<p>On Linux you can easily install SDL2 using a terminal:</p>
<ol>
<li>Find the current version of SDL2: <code>apt-cache search libsdl2</code> (e.g. libsdl2-2.0-0)</li>
<li>Install SDL2: <code>sudo apt-get install libsdl2-2.0-0</code> (replace with the found version)</li>
<li>Install SDL2 developement package: <code>sudo apt-get install libsdl2-dev</code></li>
<li>If build essentials are not installed yet: <code>sudo apt-get install build-essential</code></li>
</ol>
<h5>Windows</h5>

<p>If you are using Windows firstly you need to install MinGW (<a href="http://mingw-w64.org/doku.php/download" target="_blank" rel="noopener">64 bit version</a>). After it do the following steps to add SDL2:</p>
<ol>
<li>Download the development libraries of SDL. Go to <a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">https://www.libsdl.org/download-2.0.php</a> and download Development Libraries: SDL2-devel-2.0.5-mingw.tar.gz</li>
<li>Uncompress the file and go to x86_64-w64-mingw32 directory (for 64 bit MinGW) or to i686-w64-mingw32 (for 32 bit MinGW)</li>
<li>Copy …_mingw32/include/SDL2 folder to C:/MinGW/…/x86_64-w64-mingw32/include</li>
<li>Copy …_mingw32/lib/ content to C:/MinGW/…/x86_64-w64-mingw32/lib</li>
<li>Copy …_mingw32/bin/SDL2.dll to {eclipse_worksapce}/pc_simulator/Debug/. Do it later when Eclipse is installed.</li>
</ol>
<blockquote>
<p>Note: If you will use Microsoft Visual Studio instead of Eclipse then you don’t have to install MinGW.</p>
</blockquote>
<h5>OSX</h5>

<p>On OSX you can easily install SDL2 with brew: <code>brew install sdl2</code></p>
<p>If something is not worging I suggest <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/index.php" target="_blank" rel="noopener">this tutoria</a>l to get statered with SDL</p>
<h2 id="Pre-configured-project"><a href="#Pre-configured-project" class="headerlink" title="Pre-configured project"></a>Pre-configured project</h2><p>A pre-configured graphics library project (based on the lates release) is always available in PC simulator project. You can find it on <a href="https://github.com/littlevgl/proj_pc" target="_blank" rel="noopener">GitHub</a> or on the <a href="https://littlevgl.com/download" target="_blank" rel="noopener">Download</a> page. The project is configured for Eclipse CDT.</p>
<p>##Add the pre-configured project to Eclipse CDT<br>Run Eclipse CDT. It will show a dialogue about the <strong>workspace path</strong>. Before accepting it check that path and copy (and unzip) the downloaded pre-configured project there. Now you can accept the workspace path. Of course you can modify this path but in that case copy the projct to the that location.</p>
<p>Close the start up window and go to <strong>File-&gt;Import</strong> and choose <strong>General-&gt;Existing project into Workspace</strong>.<br><strong>Browse the root directory</strong> of the project and click <strong>Finish</strong></p>
<p>On <strong>Windows</strong> you have to do two additional things:</p>
<ul>
<li>Copy the <strong>SDL2.dll</strong> into the project’s Debug folder</li>
<li>Righ click on the project -&gt; Project properties -&gt; C/C++ Build -&gt; Settings -&gt; Libraries -&gt; Add … and add mingw32 above SDLmain and SDL. (The order is important: mingw32, SDLmain, SDL)</li>
</ul>
<h2 id="Compile-and-Run"><a href="#Compile-and-Run" class="headerlink" title="Compile and Run"></a>Compile and Run</h2><p>Now you are ready to run the Littlev Graphics Library on your PC. Click on the Hammer Icon on the top menu bar to Build the project. If you have done everything right you will not get any errors. Note that on some systems additional steps might be required to “see” SDL 2 from Eclipse but in most of cases the configurtions in the downloaded project is enough.</p>
<p>After a success build click on the Play button on the top menu bar to run the project. Now a window should appear in the middle of your screen</p>
<p>Now everything is ready to use the Littlev Graphics Library in the practice or begin the developement on your PC.</p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（三）ESP32  连接 AWS IOT</title>
    <url>/InfiniteYuanBlog/2018/01/12/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89ESP32%20%20%E8%BF%9E%E6%8E%A5%20AWS%20IOT/</url>
    <content><![CDATA[<h1 id="ESP32-AWS-IOT-发布-订阅-示例"><a href="#ESP32-AWS-IOT-发布-订阅-示例" class="headerlink" title="ESP32 AWS IOT 发布/订阅 示例"></a>ESP32 AWS IOT 发布/订阅 示例</h1><p>首先提供源码吧：<a href="https://github.com/InfiniteYuan/esp32-aws-iot" target="_blank" rel="noopener">GitHub源码地址</a><br>这是一个适用于 ESP-IDF 中<a href="https://github.com/aws/aws-iot-device-sdk-embedded-C" target="_blank" rel="noopener">AWS IoT C SDK</a> 的 “subscribe_publish”示例。</p>
<a id="more"></a>

<h1 id="AWS-IOT-配置"><a href="#AWS-IOT-配置" class="headerlink" title="AWS IOT 配置"></a>AWS IOT 配置</h1><p>在运行工程前，我们需要正确配置 AWS IOT ：</p>
<ul>
<li><p>正确配置 esp-iot-solution 和 示例工程</p>
<ul>
<li>拉取最新的 esp-iot-solution</li>
<li>保证能够正确编译一个工程</li>
</ul>
</li>
<li><p>正确配置 AWS 事物模块：事物、证书、策略</p>
<ul>
<li><p>我们可以根据<a href="https://docs.aws.amazon.com/zh_cn/iot/latest/developerguide/iot-console-signin.html" target="_blank" rel="noopener">AWS IoT Developer Guide</a>，从<code>登录 AWS IOT 控制台</code> 这一步，一直配置到 <code>配置您的设备</code>这步，之后再进行下面的配置</p>
</li>
<li><p>安装私钥和证书</p>
<p>  添加 <code>*.pem.key</code> 和 <code>*.pem.crt</code> 文件到 <code>main/cert</code> 目录中，并重命名为<code>private.pem.key</code>和<code>certificate.pem.crt</code>。</p>
</li>
<li><p>设置 AWS 端点主机名</p>
<p>  您的 AWS IOT 帐户具有唯一终端主机名。要找到它，请打开 AWS IOT 控制台，然后单击左下方的“设置”按钮。端点主机名显示在此页面的“自定义端点”标题下。</p>
<p>  之后我们在电脑终端运行<code>make menuconfig</code>并进入<code>component config</code>-&gt;<code>Amazon Web Service IoT Config</code>-&gt;<code>AWS IoT MQTT Hostname</code>，在这里我们输入上一步找到的主机名。</p>
</li>
<li><p>设置客户端 ID</p>
<p>  在电脑终端中运行<code>make menuconfig</code>，在<code>example configuration</code>下，设置 <code>AWS IOT Client ID</code>的值</p>
</li>
<li><p>本地验证证书是否配置正确 </p>
<p>当 ESP32 连接到 AWS IoT 时，根 CA 证书提供信任根。我们已经在文件 <code>main/certs/aws-root-ca.pem</code> 中提供了根 CA 证书（采用 PEM 格式）。</p>
<p>如果要本地验证此根 CA 证书未更改，可以对 AWS MQTT 主机运行以下命令：</p>
<p>运行 <code>openssl s_client -showcerts -connect hostname:8883 &lt; /dev/null</code> 命令去验证证书是否正确</p>
<p>（将主机名替换为您的 AWS MQTT 端点主机。）根 CA 证书是打印的证书列表中的最后一个证书。 您可以复制粘贴它来代替现有的 <code>aws-root-ca.pem</code> 文件。</p>
</li>
</ul>
</li>
<li><p>正确配置 ESP32 网络连接</p>
<p>  在电脑终端运行 <code>make menuconfig</code> 命令，在 <code>Example Configuration</code> 目录中配置 <code>WiFi SSID</code> 和 <code>WiFi Password</code></p>
</li>
</ul>
<h1 id="监视来自设备的数据"><a href="#监视来自设备的数据" class="headerlink" title="监视来自设备的数据"></a>监视来自设备的数据</h1><p>下载完这个工程之后，程序会自动连接 AWS 并开始订阅/发布数据。</p>
<p>这个工程会发布数据到<code>test_topic/node1</code>主题，在 AWS 中提供了一个用于测试订阅/发布数据的接口：</p>
<ul>
<li>在 AWS IOT 控制里，点击右上角的“MQTT Client”。</li>
<li>点击“Generate Client ID去生成一个随机 ID。</li>
<li>点击”Connect”</li>
</ul>
<p>在连接成功后，我们可以订阅 ESP32 发布的数据：</p>
<ul>
<li>点击”Subscribe to Topic”</li>
<li>在”Subscription Topic”中输入<code>test_topic/node1</code></li>
<li>点击”Subscribe”</li>
</ul>
<p>我们可以看到正在运行的示例中发布的 MQTT 数据。</p>
<p>发布数据返回到设备：</p>
<ul>
<li>点击”Publish to Topic”</li>
<li>在”Publish Topic”中输入<code>test_topic/node2</code></li>
<li>在有效负载字段中输入消息</li>
<li>点击“Publish”</li>
</ul>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（九）使用 VS Code 快速开发 ESP32</title>
    <url>/InfiniteYuanBlog/2018/12/17/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BD%BF%E7%94%A8%20VS%20Code%20%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%20ESP32/</url>
    <content><![CDATA[<h1 id="使用-VS-Code-快速开发-ESP32"><a href="#使用-VS-Code-快速开发-ESP32" class="headerlink" title="使用 VS Code 快速开发 ESP32"></a>使用 VS Code 快速开发 ESP32</h1><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><ul>
<li>根据<a href="https://blog.csdn.net/qq_27114397/article/details/79078449" target="_blank" rel="noopener">官方文档</a>进行 <code>esp-idf</code> 开发环境搭建</li>
<li>安装 <a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">VS Code</a> </li>
</ul>
<h2 id="在-VS-Code-中进行开发"><a href="#在-VS-Code-中进行开发" class="headerlink" title="在 VS Code 中进行开发"></a>在 VS Code 中进行开发</h2><ul>
<li>将 <code>esp-idf</code> 中的模板工程 <a href="https://github.com/espressif/esp-idf/tree/master/examples/get-started/hello_world" target="_blank" rel="noopener">hello_world</a> 在 VS Code 中打开</li>
<li>在 VS Code 中开发项目</li>
</ul>
<a id="more"></a>

<h2 id="VS-Code-任务、快捷键配置"><a href="#VS-Code-任务、快捷键配置" class="headerlink" title="VS Code 任务、快捷键配置"></a>VS Code 任务、快捷键配置</h2><h3 id="任务配置"><a href="#任务配置" class="headerlink" title="任务配置"></a>任务配置</h3><ul>
<li>按下 <code>Ctrl+Shift+P</code></li>
<li>输入、选择 <code>Tasks: Configure Task</code>(任务：配置任务)</li>
<li>使用模板创建 <code>tasks.json</code> 文件</li>
<li>选择 <code>others</code></li>
<li>可使用下面的的任务配置模板（实现：快捷编译、下载、擦除 flash、清除编译、打开 monitor、menuconfig）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="string">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"build app"</span>, <span class="comment">// f5</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make -j8"</span>,</span><br><span class="line">            <span class="string">"group"</span>: &#123;</span><br><span class="line">                <span class="string">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="string">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"flash app"</span>, <span class="comment">// f6</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make -j8 flash"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"monitor"</span>, <span class="comment">// f7</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make monitor"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"clean app"</span>, <span class="comment">// f8</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make clean"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"erase flash"</span>, <span class="comment">// f9</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make erase_flash"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"menuconfig"</span>, <span class="comment">// f10</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make menuconfig"</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细配置过程：<img src="https://img-blog.csdnimg.cn/20181217181209238.gif" alt="详细配置过程"></p>
<h3 id="快捷键配置"><a href="#快捷键配置" class="headerlink" title="快捷键配置"></a>快捷键配置</h3><p>接下来我们给这些编译命令增加快捷键。</p>
<ul>
<li>按下：<code>Ctrl+Shift+P</code></li>
<li>输入、选择 <code>Preferences: Open Keyboard Shortcuts(JSON)</code> (首选项:打开键盘快捷方式)</li>
<li>高级自定义请打开和编辑 <code>keybindings.json</code></li>
<li>填充参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Override key bindings by placing them into your key bindings file.</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f5"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"build app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f6"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"flash app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f7"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"monitor"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f8"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"clean app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f9"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"erase flash"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f10"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"menuconfig"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这样我们就可通过快捷键进行编译、下载等</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>执行的命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>F5</td>
<td><code>make -j8</code></td>
<td>编译</td>
</tr>
<tr>
<td>F6</td>
<td><code>make -j8 flash</code></td>
<td>编译、下载</td>
</tr>
<tr>
<td>F7</td>
<td><code>make monitor</code></td>
<td>监视器</td>
</tr>
<tr>
<td>F8</td>
<td><code>make clean</code></td>
<td>清除编译</td>
</tr>
<tr>
<td>F9</td>
<td><code>make erase_flash</code></td>
<td>擦除 flash</td>
</tr>
<tr>
<td>F10</td>
<td><code>make menuconfig</code></td>
<td>打开 menuconfig</td>
</tr>
</tbody></table>
<blockquote>
<p>NOTE: 这些命令都应该在工程的 <code>main</code> 目录下的文件中执行，例如： 在 VS Code 中打开了 hello_world 工程中 main 目录下的 <code>hello_world_main.c</code> 文件，可以按快捷键 <code>F6</code> 进行编译、下载。暂不支持在其他目录下进行。</p>
</blockquote>
<p>详细配置过程：<br><img src="https://img-blog.csdnimg.cn/20181217182915118.gif" alt="详细配置过程"></p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（二）OLED ssd1306 apds9960 手势控制</title>
    <url>/InfiniteYuanBlog/2018/01/12/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89OLED%20ssd1306%20apds9960%20%E6%89%8B%E5%8A%BF%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="ESP32-OLED-Demo"><a href="#ESP32-OLED-Demo" class="headerlink" title="ESP32 OLED Demo"></a>ESP32 OLED Demo</h1><p>源码地址：<a href="https://github.com/InfiniteYuan/esp32_oled_gestrue" target="_blank" rel="noopener">GitHub 源码地址</a></p>
<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><p>ESP32 OLED demo 实现了以下功能：</p>
<ul>
<li>温湿度数据采集</li>
<li>网络更新实时时间</li>
<li>OLED 分页显示温湿度、实时时间</li>
<li>手势/触摸传感器控制 OLED 显示页面上下翻页</li>
<li>通过触摸传感器手动进入低功耗模式</li>
</ul>
<a id="more"></a>

<p>下图为 ESP32 OLED Demo 的硬件实物图：<br>    <br><br>   <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTEyMTIxNzU2MjAx?x-oss-process=image/format,png" alt="硬件实物图"></p>
<hr>
<h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><p>该 DEMO 使用 ESP32_Button_Module_V2 作为开发板，包含以下元件：</p>
<ul>
<li>接近/环境光线传感器 (APDS9960)</li>
<li>OLED 显示屏 (SSD1306)</li>
<li>温度、湿度传感器 (HTS221)</li>
<li>两个触摸传感器按钮</li>
</ul>
<p>完整硬件原理图：<a href="https://github.com/InfiniteYuan1/esp32_oled_gestrue/blob/master/ESP32_BUTTON_MODULE_V2_20170720A.pdf" target="_blank" rel="noopener">ESP32_BUTTON_MODULE_V2.pdf</a></p>
<p>显示屏、传感器电源开关控制原理图：<br>    <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTEyMTIyMjQ4MjA1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>VDD33 为 LDO VOUT 3.3V 端，做为 ESP32、外设、 flash 电源；VDD33_PeriP 为显示屏、温湿度传感器、手势传感器电源。三极管 SI2301 用做电源开关，控制 VDD33_PeriP 端电压。默认情况下三极管 gate 端保持高电平，电源开关关闭，通过控制 Power_ON 保持低电平以打开电源开关。</p>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>我们使用了以下方法实现了 ESP32 OLED demo：</p>
<ul>
<li>使用 esp-iot-solution 开发工具包</li>
<li>基于 FreeRTOS 实时操作系统，多任务处理</li>
<li>SNTP 协议获取实时时间</li>
<li>通过触摸传感器进入低功耗模式</li>
<li>通过触摸传感器唤醒设备</li>
</ul>
<hr>
<h2 id="低功耗模式说明"><a href="#低功耗模式说明" class="headerlink" title="低功耗模式说明"></a>低功耗模式说明</h2><h3 id="低功耗模式硬件设计"><a href="#低功耗模式硬件设计" class="headerlink" title="低功耗模式硬件设计"></a>低功耗模式硬件设计</h3><p>我们使用了以下方法使设备在低功耗模式下的功耗达到最低。</p>
<ul>
<li>控制显示屏、温湿度传感器、手势传感器的电源开关</li>
<li>选用低功耗 LDO, 静态电流约为 1 μA</li>
<li>对触摸传感器进行功耗管理</li>
</ul>
<h3 id="触摸传感器工作周期"><a href="#触摸传感器工作周期" class="headerlink" title="触摸传感器工作周期"></a>触摸传感器工作周期</h3><p>触摸传感器在工作时，会有两种状态：sleep、measurement，两种状态循环交替进行。在正常的工作模式下我们把 sleep 时间设置得比较短，在进入低功耗模式后，我们把 sleep 时间设置得相对较长，以尽可能地降低功耗。</p>
<p>在进入低功耗模式前调用 <code>touch_pad_set_meas_time(uint16_t sleep_cycle, uint16_t meas_cycle)</code> 接口调整触摸传感器的 sleep 与 measure 时间。</p>
<p>参数说明：</p>
<ul>
<li><p><code>sleep_cycle</code>：<code>sleep_cycle</code> 决定了两次测量的间隔时间，间隔时间 t_sleep = sleep_cycle / (RTC_SLOW_CLK frequency)。</p>
<p>  可以使用 <code>rtc_clk_slow_freq_get_hz()</code> 接口获取 <code>RTC_SLOW_CLK</code> frequency 值。</p>
</li>
<li><p><code>meas_cycle</code>：<code>meas_cycle</code> 决定了测量时间，测量时间 t_meas = meas_cycle / 8M，最大测量时间为 0xffff / 8 M = 8.19 ms。</p>
</li>
</ul>
<h3 id="低功耗模式使用"><a href="#低功耗模式使用" class="headerlink" title="低功耗模式使用"></a>低功耗模式使用</h3><p>长按触摸传感器按钮进入低功耗模式，在低功耗模式下，触摸传感器采样频率会降至最低，所以从低功耗模式下唤醒同样需要稍长时间地触摸传感器按钮。低功耗模式下电流采样如下：</p>
<ul>
<li>低功耗模式下 LDO VOUT 3.3V 端的电流采样图如下 (包含 ESP32、显示屏、传感器消耗的电流) ：  <br>
  ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTEyMTIyMzE0OTQ1?x-oss-process=image/format,png)

</li>
</ul>
<blockquote>
<p>注：在低功耗模式下 LDO VOUT 3.3V 端的平均电流约为 30 μA， 最大电流约为 1.6 mA， 处在波峰时， 触摸传感器位于 measurement 状态。<br><br></p>
</blockquote>
<ul>
<li>低功耗模式下 LDO VIN 5V 端的电流采样图如下 (包含 ESP32、显示屏、传感器、LDO 消耗的电流) ：  <br>
  ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTEyMTIyMzI2Nzg1?x-oss-process=image/format,png)

</li>
</ul>
<blockquote>
<p>注：在低功耗模式下 LDO VIN 5V 端的平均电流约为 45 μA，最大电流约为 2.1 mA。</p>
</blockquote>
<h2 id="OLED-Demo-编译与运行"><a href="#OLED-Demo-编译与运行" class="headerlink" title="OLED Demo 编译与运行"></a>OLED Demo 编译与运行</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>首先需要确保你的电脑上已经安装好 ESP32 工具链，工具链安装请参考 ESP-IDF 中的 <a href="https://github.com/espressif/esp-idf/blob/master/README.md" target="_blank" rel="noopener">README.md</a>。</p>
<h3 id="获取-IoT-Solution-项目代码"><a href="#获取-IoT-Solution-项目代码" class="headerlink" title="获取 IoT Solution 项目代码"></a>获取 IoT Solution 项目代码</h3><p>执行指令，下载 iot-solution 项目仓库：</p>
<ul>
<li><p>可以直接递归获取仓库代码，这样将会自动初始化需要的所有子模块：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-iot-solution.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以手动进行初始化子模块，先运行以下指令：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-iot-solution.git</span><br></pre></td></tr></table></figure>

<ul>
<li><p>然后切换到项目根目录执行以下指令, 下载本项目依赖的一些其它子模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h3><p>子模块代码下载完成后就可以对 Iot Solution 工程中的  oled_screen_module 进行编译和运行。切换到 <code>esp-iot-solution/examples/oled\_screen\_module</code> 目录下，然后进行下列步骤。</p>
<ul>
<li>串口参数设置</li>
</ul>
<p>执行以下指令进行编译配置，如串口号和串口下载速度可以在 <code>Serial flasher config</code> 这一菜单选项中进行配置（如果不需配置, 可跳过这一步）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd YOUR_IOT_SOLUTION_PATH&#x2F;examples&#x2F;oled_screen_module</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>编译，烧写与运行</li>
</ul>
<p>执行下面指令，编译 oled_screen_module，以下命令中的 flash 是下载命令，monitor 表示开启系统打印，可根据实际情况选择添加。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make flash monitor</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：下载程序时，如果无法自动开始下载，可以尝试手动进入下载模式。下载固件完成后，按开发板上的 reset 键重新运行程序，可以查看串口打印。</p>
</blockquote>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（五）XPT2046 触摸</title>
    <url>/InfiniteYuanBlog/2018/01/16/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89XPT2046%20%E8%A7%A6%E6%91%B8/</url>
    <content><![CDATA[<h1 id="ESP32-Touch-TFT"><a href="#ESP32-Touch-TFT" class="headerlink" title="ESP32 Touch TFT"></a>ESP32 Touch TFT</h1><p>GitHub地址：<a href="https://github.com/InfiniteYuan/esp32-touchTFT" target="_blank" rel="noopener">工程源码</a><br>该工程时使用了 lcd、xpt2046、esp32 实现了触摸屏基础功能</p>
<a id="more"></a>

<h1 id="编译、运行"><a href="#编译、运行" class="headerlink" title="编译、运行"></a>编译、运行</h1><p>请参考 esp-idf 的工程配置与运行</p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（八）ESP32 MP3 播放器</title>
    <url>/InfiniteYuanBlog/2018/11/20/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89ESP32%20MP3%20%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<h1 id="ESP32-MP3-播放器"><a href="#ESP32-MP3-播放器" class="headerlink" title="ESP32 MP3 播放器"></a>ESP32 MP3 播放器</h1><p>源码地址：<a href="https://github.com/InfiniteYuan/esp32-MP3" target="_blank" rel="noopener">GitHub</a></p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>开发框架：<a href="https://github.com/espressif/esp-idf" target="_blank" rel="noopener">ESP-IDF</a>、<a href="https://github.com/espressif/esp-adf" target="_blank" rel="noopener">ESP-ADF</a><br>Embedded GUI: <a href="https://github.com/littlevgl/lvgl" target="_blank" rel="noopener">LittlevGL</a></p>
<a id="more"></a>

<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>ESP-IDF:<a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/index.html" target="_blank" rel="noopener">搭建步骤</a></li>
<li>ESP-ADF:<a href="https://docs.espressif.com/projects/esp-adf/en/latest/get-started/index.html#setup-esp-idf" target="_blank" rel="noopener">搭建步骤</a></li>
</ul>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><ul>
<li>克隆仓库</li>
<li>进入 esp32-MP3 目录</li>
<li><code>make -j8 flash</code> 编译下载</li>
</ul>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><ul>
<li><a href="https://twitter.com/InfiniteYuan/status/1063739310275350528" target="_blank" rel="noopener">Twitter Video</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（六）移植开源图形库 LittlevGL</title>
    <url>/InfiniteYuanBlog/2018/08/08/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E7%A7%BB%E6%A4%8D%E5%BC%80%E6%BA%90%E5%9B%BE%E5%BD%A2%E5%BA%93%20LittlevGL/</url>
    <content><![CDATA[<h1 id="ESP32-移植开源图形库-LittlevGL"><a href="#ESP32-移植开源图形库-LittlevGL" class="headerlink" title="ESP32 移植开源图形库 LittlevGL"></a>ESP32 移植开源图形库 LittlevGL</h1><p>ESP32 移植 LittlevGL 的源码：<a href="https://github.com/InfiniteYuan/esp32-lvgl-gui" target="_blank" rel="noopener">GitHub 源码地址</a><br>欢迎 Star ～</p>
<h2 id="LittlevGL-介绍"><a href="#LittlevGL-介绍" class="headerlink" title="LittlevGL 介绍"></a>LittlevGL 介绍</h2><blockquote>
<p>littlevGL is a free and open-source graphics library providing everything you need to create embedded GUI with easy-to-use graphical elements, beautiful visual effects and low memory footprint.<br><a href="https://littlevgl.com/" target="_blank" rel="noopener">LittlevGL 官网链接</a><br><a href="https://littlevgl.com/porting" target="_blank" rel="noopener">LittlevGL 移植教程</a><br><a href="https://littlevgl.com/basics" target="_blank" rel="noopener">LittlevGL 官方文档</a><br><a href="https://github.com/littlevgl/lvgl" target="_blank" rel="noopener">LittlevGL GitHub链接</a></p>
</blockquote>
<a id="more"></a>

<h4>关键特性：</h4>

<ul>
<li>Powerful building blocks buttons, charts, lists, sliders, images etc</li>
<li>Advanced graphics with animations, anti-aliasing, opacity, smooth scrolling</li>
<li>Various input devices touch pad, mouse, keyboard, encoder, buttons etc</li>
<li>Multi language support with UTF-8 decoding</li>
<li>Fully customizable graphical elements</li>
<li>Hardware independent to use with any microcontroller or display</li>
<li>Scalable to operate with few memory (50 kB Flash, 10 kB RAM)</li>
<li>OS, External memory and GPU supported but not required</li>
<li>Single frame buffer operation even with advances graphical effects</li>
<li>Written in C for maximal compatibility</li>
<li>Simulator to develop on PC without embedded hardware</li>
<li>Tutorials, examples, themes for rapid development</li>
<li>Documentation and API references online</li>
</ul>
<h2 id="移植过程"><a href="#移植过程" class="headerlink" title="移植过程"></a>移植过程</h2><ol>
<li>在工程目录下新建一个 components 目录，放入 LittlevGL 源码</li>
<li>在 components 目录下新建一个 include 目录，放入 lv_conf.h 文件，由 LittlevGL 源码目录中的 lv_conf_templ.h文件而来</li>
<li>在 components 目录下新建一个  component.mk  文件，将 LittlevGL 相关源码添加到组件的 <code>COMPONENT_SRCDIRS</code>、<code>COMPONENT_ADD_INCLUDEDIRS</code>和<code>COMPONENT_PRIV_INCLUDEDIRS</code>目录变量中</li>
<li>之后在程序中使用了～，可根据 <a href="https://github.com/littlevgl/lv_examples/blob/master/lv_tutorial/0_porting/lv_tutorial_porting.c" target="_blank" rel="noopener">LittlevGL Tutorial</a> 在自己的主程序中实现</li>
</ol>
<h4>大致初始化流程：</h4>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Initialize LittlevGL</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line">lv_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Tick interface</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"><span class="comment">/* Initialize a Timer for 1 ms period and</span></span><br><span class="line"><span class="comment"> * in its interrupt call</span></span><br><span class="line"><span class="comment"> * lv_tick_inc(1); */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Display interface</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"><span class="keyword">lv_disp_drv_t</span> disp_drv;                         <span class="comment">/*Descriptor of a display driver*/</span></span><br><span class="line">lv_disp_drv_init(&amp;disp_drv);                    <span class="comment">/*Basic initialization*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Set up the functions to access to your display*/</span></span><br><span class="line">disp_drv.disp_flush = ex_disp_flush;            <span class="comment">/*Used in buffered mode (LV_VDB_SIZE != 0  in lv_conf.h)*/</span></span><br><span class="line"></span><br><span class="line">disp_drv.disp_fill = ex_disp_fill;              <span class="comment">/*Used in unbuffered mode (LV_VDB_SIZE == 0  in lv_conf.h)*/</span></span><br><span class="line">disp_drv.disp_map = ex_disp_map;                <span class="comment">/*Used in unbuffered mode (LV_VDB_SIZE == 0  in lv_conf.h)*/</span></span><br><span class="line"><span class="comment">/*Finally register the driver*/</span></span><br><span class="line">lv_disp_drv_register(&amp;disp_drv);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment"> * Input device interface</span></span><br><span class="line"><span class="comment"> *************************/</span></span><br><span class="line"><span class="comment">/*Add a touchpad in the example*/</span></span><br><span class="line"><span class="comment">/*touchpad_init();*/</span>                            <span class="comment">/*Initialize your touchpad*/</span></span><br><span class="line"><span class="keyword">lv_indev_drv_t</span> indev_drv;                       <span class="comment">/*Descriptor of an input device driver*/</span></span><br><span class="line">lv_indev_drv_init(&amp;indev_drv);                  <span class="comment">/*Basic initialization*/</span></span><br><span class="line">indev_drv.type = LV_INDEV_TYPE_POINTER;         <span class="comment">/*The touchpad is pointer type device*/</span></span><br><span class="line">indev_drv.<span class="built_in">read</span> = ex_tp_read;                    <span class="comment">/*Library ready your touchpad via this function*/</span></span><br><span class="line">lv_indev_drv_register(&amp;indev_drv);              <span class="comment">/*Finally register the driver*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************</span></span><br><span class="line"><span class="comment"> * Run the task handler of LittlevGL</span></span><br><span class="line"><span class="comment"> *************************************/</span></span><br><span class="line"><span class="comment">/* Periodically call this function.</span></span><br><span class="line"><span class="comment"> * The timing is not critical but should be between 1..10 ms */</span></span><br><span class="line">lv_task_handler();</span><br><span class="line"><span class="comment">/*delay_ms(5)*/</span></span><br></pre></td></tr></table></figure>

<h4>需要实现的函数：</h4>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Display interface</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"> <span class="comment">/*Write the internal buffer (VDB) to the display. 'lv_flush_ready()' has to be called when finished*/</span></span><br><span class="line"> <span class="keyword">void</span> (*disp_flush)(<span class="keyword">int32_t</span> x1, <span class="keyword">int32_t</span> y1, <span class="keyword">int32_t</span> x2, <span class="keyword">int32_t</span> y2, <span class="keyword">const</span> <span class="keyword">lv_color_t</span> * color_p);</span><br><span class="line"> <span class="comment">/*Fill an area with a color on the display*/</span></span><br><span class="line"> <span class="keyword">void</span> (*disp_fill)(<span class="keyword">int32_t</span> x1, <span class="keyword">int32_t</span> y1, <span class="keyword">int32_t</span> x2, <span class="keyword">int32_t</span> y2, <span class="keyword">lv_color_t</span> color);</span><br><span class="line"> <span class="comment">/*Write pixel map (e.g. image) to the display*/</span></span><br><span class="line"> <span class="keyword">void</span> (*disp_map)(<span class="keyword">int32_t</span> x1, <span class="keyword">int32_t</span> y1, <span class="keyword">int32_t</span> x2, <span class="keyword">int32_t</span> y2, <span class="keyword">const</span> <span class="keyword">lv_color_t</span> * color_p);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment"> * Input device interface</span></span><br><span class="line"><span class="comment"> *************************/</span></span><br><span class="line"> <span class="keyword">bool</span> (*<span class="built_in">read</span>)(<span class="keyword">lv_indev_data_t</span> *data);        <span class="comment">/*Function pointer to read data. Return 'true' if there is still data to be read (buffered)*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>在实现 <code>disp_flush</code> 函数时，在函数末尾需要调用 LittlevGL 提供的 <code>lv_flush_ready</code> 函数<br>上述的这些函数可以自行实现，函数体保持一致即可</p>
</blockquote>
<p>欢迎关注本人 <a href="https://github.com/InfiniteYuan" target="_blank" rel="noopener">GitHub</a> ，更新 ESP32 相关开源库</p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十一）使用 ESP32 做为 WebServer</title>
    <url>/InfiniteYuanBlog/2019/04/28/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32%20%E5%81%9A%E4%B8%BA%20WebServer/</url>
    <content><![CDATA[<h1 id="使用-ESP32-做为-WebServer"><a href="#使用-ESP32-做为-WebServer" class="headerlink" title="使用 ESP32 做为 WebServer"></a>使用 ESP32 做为 WebServer</h1><p>在某些场景，我们可能需要在手机上或者其他移动终端访问 ESP32 的数据，这个时候我们需要在手机上展示 ESP32 设备的相关信息，这个时候可以用 APP 在手机上展示数据，或者在手机浏览器中打开存储在 ESP32 上的网页。或者其他的方式。</p>
<p>这篇文章我们将介绍第二种方式。在 ESP32 上存储网页文件，将 ESP32 做为一个简单的 WebServer。</p>
<p>工作流程：(第一种方式)</p>
<ol>
<li>首先通过 gzip 将 HTML 文件压缩为 <code>.gz</code> 文件</li>
<li>使用 filetoarray 工具将 <code>.gz</code> 文件转为头文件</li>
<li>在 ESP32 程序中将头文件中的数组发送出去</li>
</ol>
<p>工作流程：(第二种方式)</p>
<ol>
<li>首先通过 gzip 将 HTML 文件压缩为 <code>.gz</code> 文件</li>
<li>使用 ESP32 构建系统中的<a href="https://blog.csdn.net/qq_27114397/article/details/81152448#_449" target="_blank" rel="noopener">嵌入二进制数据</a>的方式，将其添加到 Flash 中的 <code>.rodata</code> 部分</li>
<li>在 ESP32 程序中将 Flash 中的数组发送出去</li>
</ol>
<a id="more"></a>

<h2 id="filetoarray-工具"><a href="#filetoarray-工具" class="headerlink" title="filetoarray 工具"></a>filetoarray 工具</h2><p>使用这个工具将 <code>.gz</code> 文件转换为包含十六进制数组和其长度的头文件。</p>
<p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span>;</span><br><span class="line">    <span class="keyword">long</span> flen;</span><br><span class="line">    <span class="keyword">char</span> *fname;</span><br><span class="line">    <span class="keyword">char</span> pname[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( argc == <span class="number">2</span> ) &#123;</span><br><span class="line">        fname = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(pname, fname);</span><br><span class="line">        <span class="keyword">char</span> *dot = <span class="built_in">strchr</span>(pname, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">while</span> (dot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *dot = <span class="string">'_'</span>;</span><br><span class="line">            dot = <span class="built_in">strchr</span>(pname, <span class="string">'.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Filename not supplied\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(fname, <span class="string">"rb"</span>);</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    flen = ftell(fp);</span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buffer</span> = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((flen + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    fread(<span class="built_in">buffer</span>, flen, <span class="number">1</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n//File: %s, Size: %lu\n"</span>, fname, flen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"#define %s_len %lu\n"</span>, pname, flen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const uint8_t %s[] PROGMEM = &#123;\n"</span>, pname);</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; flen; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 0x%02X"</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="built_in">buffer</span>[i]));</span><br><span class="line">        <span class="keyword">if</span> (i &lt; (flen - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">16</span>) == <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n&#125;;\n\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">buffer</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML-文件到头文件"><a href="#HTML-文件到头文件" class="headerlink" title="HTML 文件到头文件"></a>HTML 文件到头文件</h2><p>使用方式：</p>
<ol>
<li>使用 gzip 将 HTML 文件转换为 <code>.gz</code> 文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gzip index.html</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译 <code>filetoarray.c</code> 源文件，生成可执行文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc filetoarray.c -o filetoarray</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 filetoarray 将  <code>.gz</code> 文件转为头文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./filetoarray index.html.gz &gt; index.h</span><br></pre></td></tr></table></figure>

<h2 id="HTML-文件到-Flash"><a href="#HTML-文件到-Flash" class="headerlink" title="HTML 文件到 Flash"></a>HTML 文件到 Flash</h2><p>使用方式：</p>
<ol>
<li>使用 gzip 将 HTML 文件转换为 <code>.gz</code> 文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gzip index.html</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在工程 <code>main</code> 目录下的 <code>component.mk</code> 中添加</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COMPONENT_EMBED_FILES := www/index.html.gz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在工程源码中这样使用</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_start[] <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_start"</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_end[]   <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_end"</span>);</span><br><span class="line"><span class="keyword">size_t</span> index_html_gz_len = index_html_gz_end - index_html_gz_start;</span><br><span class="line"></span><br><span class="line">httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz_start, index_html_gz_len);</span><br></pre></td></tr></table></figure>

<h2 id="在-ESP32-中启动-HTTP-Server"><a href="#在-ESP32-中启动-HTTP-Server" class="headerlink" title="在 ESP32 中启动 HTTP Server"></a>在 ESP32 中启动 HTTP Server</h2><p>第一种方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"index.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">index_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span>&#123;</span><br><span class="line">    httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">    httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    <span class="keyword">return</span> httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz, index_html_gz_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">index_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_start[] <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_start"</span>);</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_end[]   <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_end"</span>);</span><br><span class="line">	<span class="keyword">size_t</span> index_html_gz_len = index_html_gz_end - index_html_gz_start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">    httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    <span class="keyword">return</span> httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz_start, index_html_gz_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"app_httpd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"esp_http_server.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_httpd_main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">httpd_handle_t</span> camera_httpd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">httpd_config_t</span> <span class="built_in">config</span> = HTTPD_DEFAULT_CONFIG();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">httpd_uri_t</span> index_uri = &#123;</span><br><span class="line">        .uri       = <span class="string">"/"</span>,</span><br><span class="line">        .method    = HTTP_GET,</span><br><span class="line">        .handler   = index_handler,</span><br><span class="line">        .user_ctx  = <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Starting web server on port: '%d'"</span>, <span class="built_in">config</span>.server_port);</span><br><span class="line">    <span class="keyword">if</span> (httpd_start(&amp;camera_httpd, &amp;<span class="built_in">config</span>) == ESP_OK) &#123;</span><br><span class="line">        httpd_register_uri_handler(camera_httpd, &amp;index_uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ul>
<li><a href="https://github.com/espressif/esp-who/blob/master/examples/single_chip/camera_web_server/main/app_httpd.c" target="_blank" rel="noopener">web server</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十三）ESP32 ping 功能</title>
    <url>/InfiniteYuanBlog/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89ESP32%20ping%20%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">pingResults</span><span class="params">(<span class="keyword">ping_target_id_t</span> msgType, esp_ping_found * pf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"AvgTime:%.1fmS Sent:%d Rec:%d min(mS):%d max(mS):%d Resp(mS):%d Timeouts:%d Total Time:%d\n"</span>, (<span class="keyword">float</span>)pf-&gt;total_time/pf-&gt;recv_count, pf-&gt;send_count, pf-&gt;recv_count,  pf-&gt;min_time, pf-&gt;max_time ,pf-&gt;resp_time, pf-&gt;timeout_count, pf-&gt;total_time);</span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start_Ping_ESP32</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">uint32_t</span> ip_pinG = ipaddr_addr(<span class="string">"163.177.151.109"</span>);<span class="comment">//百度IP地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_count = <span class="number">2000</span>;<span class="comment">//ping的次数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_timeout = <span class="number">1000</span>; <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_delay = <span class="number">2000</span>; <span class="comment">//ping 的间隔</span></span><br><span class="line">    ping_deinit();</span><br><span class="line">    esp_ping_set_target(PING_TARGET_IP_ADDRESS_COUNT, &amp;ping_count, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_RCV_TIMEO, &amp;ping_timeout, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_DELAY_TIME, &amp;ping_delay, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_IP_ADDRESS, &amp;ip_pinG, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_RES_FN, &amp;pingResults, <span class="keyword">sizeof</span>(pingResults));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span> res = <span class="number">0</span>;</span><br><span class="line">    res = ping_init();</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"PING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error:%d\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十二）LittlevGL 添加自定义字体和物理按键</title>
    <url>/InfiniteYuanBlog/2019/05/12/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89LittlevGL%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E7%89%A9%E7%90%86%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<h1 id="LittlevGL-添加自定义字体"><a href="#LittlevGL-添加自定义字体" class="headerlink" title="LittlevGL 添加自定义字体"></a>LittlevGL 添加自定义字体</h1><ol>
<li>获取字库 <code>ttf</code> 文件<br>可以从一些网站上获取字库文件，比如<blockquote>
<p>请注意字体许可证</p>
</blockquote>
</li>
<li>生成源文件<br>使用 LittlevGL 提供的字库文件<a href="https://littlevgl.com/ttf-font-to-c-array" target="_blank" rel="noopener">转换工具</a>，将 <code>ttf</code> 字库文件转换为源文件。</li>
</ol>
<a id="more"></a>
<ol start="3">
<li>将生成的源文件添加到 LittlevGL 工程中，添加以下代码声明字体：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern lv_font_t my_font_name;</span><br></pre></td></tr></table></figure>
或者<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LV_FONT_DECLARE(my_font_name);</span><br></pre></td></tr></table></figure>
源代码中使用这个字体可以：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style.text.font &#x3D; &amp;my_font_name;</span><br></pre></td></tr></table></figure>
或者将这个字体添加到当前使用的字体中：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lv_font_add(&amp;my_font_name, &amp;current_use);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LV_FONT_DECLARE(my_font_name);</span><br><span class="line"></span><br><span class="line">void lv_chinese_fonts1(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*Concatenate the fonts into one*&#x2F;</span><br><span class="line">&#x2F;&#x2F;    lv_font_add(&amp;arial_cyrillic_20, &amp;arial_ascii_20); 相同高度才可以添加到一起</span><br><span class="line">&#x2F;&#x2F;    lv_font_add(&amp;arial_math_20, &amp;arial_ascii_20);</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 创建一个新的样式，并且修改新样式的文本字体 *&#x2F;</span><br><span class="line">    static lv_style_t style1; </span><br><span class="line">    lv_style_copy(&amp;style1, &amp;lv_style_plain);</span><br><span class="line">    style1.text.font &#x3D; &amp;my_font_name; &#x2F;* 设置自定义字体 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;*Create a label and set new text*&#x2F;</span><br><span class="line">    lv_obj_t * label &#x3D; lv_label_create(lv_scr_act(), NULL); &#x2F;* 创建标签 *&#x2F;</span><br><span class="line">    lv_obj_set_pos(label, 10, 10);       &#x2F;* 设置相对位置 *&#x2F;</span><br><span class="line">    lv_label_set_style(label, &amp;style1);  &#x2F;* 设置样式 *&#x2F;</span><br><span class="line">    lv_label_set_text(label, &quot;Hello World!\n 世界你好,我是littleVGL!&quot;);      &#x2F;* 显示汉字 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LittlevGL-添加自定义符号"><a href="#LittlevGL-添加自定义符号" class="headerlink" title="LittlevGL 添加自定义符号"></a>LittlevGL 添加自定义符号</h1><p>流程：</p>
<ul>
<li>寻找合适的 <code>ttf</code> 文件（包含目标符号，可在 linux 下通过 FontForge 软件打开 <code>ttf</code> 文件，查看包含那些字符）</li>
<li>使用 LittlevGL 提供的字库文件<a href="https://littlevgl.com/ttf-font-to-c-array" target="_blank" rel="noopener">转换工具</a>，将选中的符号转换为 <code>c</code> 源文件。在转换的页面 <code>Range</code> 中输入目标符号的 Unicode 编码，怎么查询可以通过百度</li>
<li>将源文件添加到工程中，和上面添加字体类似，首先声明字体，然后添加到字体中或者直接使用。</li>
<li>定义一个宏指向这个目标符号，宏的内容需要为 <code>UTF-8编码</code>，通过 <a href="https://www.qqxiuzi.cn/bianma/Unicode-UTF.php" target="_blank" rel="noopener">Unicode和UTF编码转换</a> 可以进行转换</li>
</ul>
<p>例如：<br><img src="https://img-blog.csdnimg.cn/20190515163138800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="摄氏度符号"></p>
<p>这样就需要在程序中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* MACROS *&#x2F;</span><br><span class="line">#define SYMBOL_TEMP &quot;\xE2\x84\x83&quot; &#x2F;&#x2F; E28483</span><br><span class="line"></span><br><span class="line">&#x2F;* STATIC VARIABLES *&#x2F;</span><br><span class="line">LV_FONT_DECLARE(tempreture_symbol_40);</span><br><span class="line"></span><br><span class="line">&#x2F;* Add font to current font *&#x2F;</span><br><span class="line">lv_font_add(&amp;tempreture_symbol_40, &amp;lv_font_dejavu_40);</span><br><span class="line"></span><br><span class="line">&#x2F;* Use this symbol *&#x2F;</span><br><span class="line">lv_label_set_text(temp_l, &quot;21.5 &quot;SYMBOL_TEMP);</span><br></pre></td></tr></table></figure>

<h1 id="LittlevGL-添加物理按键"><a href="#LittlevGL-添加物理按键" class="headerlink" title="LittlevGL 添加物理按键"></a>LittlevGL 添加物理按键</h1><p>注册物理按键驱动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t my_btn_read()</span><br><span class="line">&#123;</span><br><span class="line">    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool my_input_read(lv_indev_data_t *data)</span><br><span class="line">&#123;</span><br><span class="line">    static int8_t last_btn &#x3D; 0;    &#x2F;* Store the last pressed button *&#x2F;</span><br><span class="line">    int8_t btn_pr &#x3D; my_btn_read(); &#x2F;* Get the ID (0,1,2...) of the pressed button *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (btn_pr &gt; 0)</span><br><span class="line">    &#123;                                    &#x2F;* Is there a button press? *&#x2F;</span><br><span class="line">        last_btn &#x3D; btn_pr;               &#x2F;* Save the ID of the pressed button *&#x2F;</span><br><span class="line">        data-&gt;state &#x3D; LV_INDEV_STATE_PR; &#x2F;* Set the pressed state *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        data-&gt;state &#x3D; LV_INDEV_STATE_REL; &#x2F;* Set the released state *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data-&gt;btn &#x3D; last_btn; &#x2F;* Set the last button *&#x2F;</span><br><span class="line"></span><br><span class="line">    return false; &#x2F;* No buffering so no more data read *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">void my_button_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static lv_indev_t *indev;</span><br><span class="line">    lv_indev_drv_t indev_drv;</span><br><span class="line"></span><br><span class="line">    lv_indev_drv_init(&amp;indev_drv);</span><br><span class="line"></span><br><span class="line">    indev_drv.read &#x3D; my_input_read;</span><br><span class="line">    indev_drv.type &#x3D; LV_INDEV_TYPE_BUTTON;</span><br><span class="line">    indev &#x3D; lv_indev_drv_register(&amp;indev_drv);</span><br><span class="line"></span><br><span class="line">    &#x2F;*points_array: these points will be assigned to the buttons to press a specific point on the screen.*&#x2F;</span><br><span class="line">    static lv_point_t points_array[] &#x3D; &#123;&#123;20, 20&#125;&#125;;</span><br><span class="line">    lv_indev_set_button_points(indev, points_array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个按键，保证上面的点在按钮的区域内：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static lv_obj_t *btn &#x3D; lv_btn_create(lv_scr_act(), NULL);  </span><br><span class="line">lv_obj_set_size(btn, 40, 40);</span><br><span class="line">lv_obj_set_pos(btn, 0, 0);</span><br><span class="line">lv_btn_set_action(btn, LV_BTN_ACTION_CLICK, btn_click_action);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十五）使用 LittlevGL 实现 2048 小游戏</title>
    <url>/InfiniteYuanBlog/2020/05/17/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E4%BD%BF%E7%94%A8%20LittlevGL%20%E5%AE%9E%E7%8E%B0%202048%20%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="使用-LittlevGL-实现-2048-小游戏"><a href="#使用-LittlevGL-实现-2048-小游戏" class="headerlink" title="使用 LittlevGL 实现 2048 小游戏"></a>使用 LittlevGL 实现 2048 小游戏</h1><p>2048 这款益智小游戏，游戏的规则十分简单，简单易上手的数字小游戏，但又十分虐心。曾经也是风靡一时。</p>
<p>现在我们在 ESP32 上自己动手实现 2048 这款小游戏吧。</p>
<a id="more"></a>

<h2 id="1-使用-LittlevGL"><a href="#1-使用-LittlevGL" class="headerlink" title="1 使用 LittlevGL"></a>1 使用 LittlevGL</h2><p>esp32-lvgl-gui 仓库已经适配了 LittlevGL V5.3，并适配了几款屏幕(ILI9341、ST7789、SSD1306、NT35510) 和 触摸驱动(FT5X06、XPT2046)。</p>
<p>使用时，在 <code>menuconfig</code> 中选择你所使用的 屏幕 和 触摸驱动。</p>
<p>编译代码：</p>
<ol>
<li>添加头文件：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* lvgl includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iot_lvgl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* game include */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"game.h"</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化 LittlevGL：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Initialize LittlevGL */</span></span><br><span class="line">    lv_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tick interface， Initialize a Timer for 1 ms period and in its interrupt call*/</span></span><br><span class="line">    <span class="comment">// esp_register_freertos_tick_hook(lv_tick_task_callback);</span></span><br><span class="line">    lvgl_tick_timer = xTimerCreate(</span><br><span class="line">        <span class="string">"lv_tickinc_task"</span>,</span><br><span class="line">        <span class="number">1</span> / portTICK_PERIOD_MS,            <span class="comment">//period time</span></span><br><span class="line">        pdTRUE,                            <span class="comment">//auto load</span></span><br><span class="line">        (<span class="keyword">void</span> *)<span class="literal">NULL</span>,                      <span class="comment">//timer parameter</span></span><br><span class="line">        lv_tick_task_callback);            <span class="comment">//timer callback</span></span><br><span class="line">    xTimerStart(lvgl_tick_timer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Display interface */</span></span><br><span class="line">    lvgl_lcd_display_init();	           <span class="comment">/*Initialize your display*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Input device interface */</span></span><br><span class="line">    input_device = lvgl_indev_init();                     <span class="comment">/*Initialize your indev*/</span></span><br><span class="line"></span><br><span class="line">    lvgl_timer = xTimerCreate(</span><br><span class="line">        <span class="string">"lv_task"</span>,</span><br><span class="line">        <span class="number">10</span> / portTICK_PERIOD_MS,           <span class="comment">//period time</span></span><br><span class="line">        pdTRUE,                            <span class="comment">//auto load</span></span><br><span class="line">        (<span class="keyword">void</span> *)<span class="literal">NULL</span>,                      <span class="comment">//timer parameter</span></span><br><span class="line">        lvgl_task_time_callback);          <span class="comment">//timer callback</span></span><br><span class="line">    xTimerStart(lvgl_timer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2048 game init</span></span><br><span class="line">    game_init(<span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// game logic handle task</span></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        user_task,   <span class="comment">//Task Function</span></span><br><span class="line">        <span class="string">"user_task"</span>, <span class="comment">//Task Name</span></span><br><span class="line">        <span class="number">1024</span>*<span class="number">4</span>,      <span class="comment">//Stack Depth</span></span><br><span class="line">        <span class="literal">NULL</span>,        <span class="comment">//Parameters</span></span><br><span class="line">        <span class="number">1</span>,           <span class="comment">//Priority</span></span><br><span class="line">        <span class="literal">NULL</span>);       <span class="comment">//Task Handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2048-游戏逻辑"><a href="#2-2048-游戏逻辑" class="headerlink" title="2 2048 游戏逻辑"></a>2 2048 游戏逻辑</h2><h3 id="2-1-界面初始化"><a href="#2-1-界面初始化" class="headerlink" title="2.1 界面初始化"></a>2.1 界面初始化</h3><p>将游戏相关界面初始化分为以下几步：</p>
<ol>
<li>Step 1: 画游戏背景</li>
<li>Step 2: 画游戏分数显示框</li>
<li>Step 3: 画游戏网格</li>
<li>Step 4: 画游戏网格中每个单元格的内容</li>
</ol>
<h3 id="2-2-滑动处理"><a href="#2-2-滑动处理" class="headerlink" title="2.2 滑动处理"></a>2.2 滑动处理</h3><h4 id="2-2-1-判断滑动方向"><a href="#2-2-1-判断滑动方向" class="headerlink" title="2.2.1 判断滑动方向"></a>2.2.1 判断滑动方向</h4><p>通过调用 LittlevGL 的 API 读取触摸状态(抬起/按下、坐标点)，计算水平/竖直方向滑动的差值，判断为哪个方向上的滑动(上/下/左/右)，执行相应的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">lv_indev_drv_t</span> input_device;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">user_task</span><span class="params">(<span class="keyword">void</span> *pvParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> pressing = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">lv_indev_data_t</span> touchpad_data;</span><br><span class="line">    <span class="keyword">lv_point_t</span> last_data;</span><br><span class="line">    <span class="keyword">int16_t</span> x_diff, y_diff;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(<span class="number">50</span> / portTICK_PERIOD_MS);</span><br><span class="line">        input_device.<span class="built_in">read</span>(&amp;touchpad_data); <span class="comment">// 读取触摸驱动的值</span></span><br><span class="line">        <span class="keyword">if</span> (touchpad_data.state == LV_INDEV_STATE_REL) &#123; <span class="comment">// 当前为 `抬起` 状态</span></span><br><span class="line">            pressing = <span class="literal">false</span>; <span class="comment">// 计算坐标偏移量</span></span><br><span class="line">            x_diff = touchpad_data.<span class="built_in">point</span>.x - last_data.x;</span><br><span class="line">            y_diff = touchpad_data.<span class="built_in">point</span>.y - last_data.y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(x_diff) &gt; SENSITIVE || <span class="built_in">fabs</span>(y_diff) &gt; SENSITIVE) &#123; <span class="comment">// 判断滑动距离是否超过判断阈值</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(x_diff) &gt; <span class="built_in">fabs</span>(y_diff)) &#123; <span class="comment">// 判断是否为水平滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (x_diff &gt; <span class="number">0</span>) &#123; <span class="comment">// 判单是否为向右滑动</span></span><br><span class="line">                        move_right();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向左滑动</span></span><br><span class="line">                        move_left();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 竖直方向滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (y_diff &gt; <span class="number">0</span>) &#123; <span class="comment">// 判单是否为向下滑动</span></span><br><span class="line">                        move_down();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向上滑动</span></span><br><span class="line">                        move_up();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last_data.x = touchpad_data.<span class="built_in">point</span>.x;</span><br><span class="line">            last_data.y = touchpad_data.<span class="built_in">point</span>.y;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (touchpad_data.state == LV_INDEV_STATE_PR) &#123; <span class="comment">// 当前为 `按下` 状态</span></span><br><span class="line">            <span class="keyword">if</span> (!pressing) &#123; <span class="comment">// 按下状态，记录初次按下的坐标点</span></span><br><span class="line">                last_data.x = touchpad_data.<span class="built_in">point</span>.x;</span><br><span class="line">                last_data.y = touchpad_data.<span class="built_in">point</span>.y;</span><br><span class="line">                pressing = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-滑动逻辑处理"><a href="#2-2-2-滑动逻辑处理" class="headerlink" title="2.2.2 滑动逻辑处理"></a>2.2.2 滑动逻辑处理</h4><ol>
<li>判断同一行/列滑动方向上是否存在相等的数值</li>
<li>相同的单元格，数值相加为相邻单元格中的后一个(滑动方向上)的数值</li>
<li>画出总的得分</li>
<li>判断游戏是否结束</li>
<li>刷新界面上的单元格</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> num_matrix[<span class="number">5</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 保存所有的单元格中的数值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> score_num = <span class="number">0</span>; <span class="comment">// 总得分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_up</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t, nx = <span class="number">-1</span>, ny = <span class="number">0</span>, nn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i)</span><br><span class="line">        tmp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num_matrix[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[++k] = num_matrix[i][j];</span><br><span class="line">                num_matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &lt;= k - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[t] == tmp[t + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t] *= <span class="number">2</span>;</span><br><span class="line">                tmp[t + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                score_num += tmp[t];</span><br><span class="line">                <span class="keyword">if</span> (nx == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nx = t;</span><br><span class="line">                    ny = j;</span><br><span class="line">                    nn = tmp[t];</span><br><span class="line">                &#125;</span><br><span class="line">                t += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t++;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            <span class="keyword">if</span> (tmp[i])</span><br><span class="line">                num_matrix[t++][j] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画总分</span></span><br><span class="line">    draw_score_num(score_num);</span><br><span class="line">    <span class="comment">// 刷新网格中单元格的内容</span></span><br><span class="line">    gen_num();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>GitHub 源码：<a href="https://github.com/InfiniteYuan/esp32-lvgl-gui/tree/master/lvgl_2048" target="_blank" rel="noopener">esp32-lvgl-gui</a></li>
<li>Twitter 视频：<a href="https://twitter.com/InfiniteYuan/status/1048106496649641985?s=20" target="_blank" rel="noopener">Twitter</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十四）ESP32 I2C Slave 实现</title>
    <url>/InfiniteYuanBlog/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89ESP32%20I2C%20Slave%20%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文章将介绍使用 ESP32 作为 I2C 实现 Random Read/Write 和  Sequential Read/Write 时序。</p>
<p>首先通过下面的图了解下 Random Read 时序，I2C Master 通过这个时序读取任意数据地址开始的数据。<br><img src="https://img-blog.csdnimg.cn/20191123145556881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="Random Read"></p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">___________________________________________________________________________________________________________________________________________________</span><br><span class="line">| start | slave_addr + write_bit + ack | data address |start | slave_addr + read_bit + ack |  <span class="built_in">read</span> n<span class="number">-1</span> bytes + ack | <span class="built_in">read</span> <span class="number">1</span> <span class="keyword">byte</span> + nack | <span class="built_in">stop</span> |</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>RANDOM READ</strong>: A random read requires a “dummy” byte write sequence to load in the data word address. Once the device address word and data word address are clocked in and acknowledged by the EEPROM, the microcontroller must generate another start condition.<br>The microcontroller now initiates a current address read by sending a device address with the read/write select bit high. The EEPROM acknowledges the device address and serially clocks out the data word. The microcontroller does not respond with a zero but does generate a following stop condition </p>
</blockquote>
<ul>
<li>现有的 I2C Slave 无法实现类似 Random Read 时序<ul>
<li>原因分析：esp-idf 提供的 <code>i2c_slave_write_buffer</code> <code>i2c_slave_read_buffer</code> API 都是操作 RingBuffer 实现，而 Random Read 需要 Slave 在 接收到 <code>slave_addr + read_bit + data address</code> 前将数据放入 I2C 的硬件 FIFO 中。若是通过 API 进行判断当前 Master 想要操作的 数据地址，会因为这个 API 都是操作 RingBuffer 而有所延迟，导致 Master 接收到错误的数据（因为此时硬件 FIFO 还没有数据）。</li>
<li>解决办法：<ul>
<li>在接收到 <code>slave_addr + write_bit + data address</code> 时将可能需要发送到主机的数据放入 TX FIFO 中，当主机继续发送 <code>slave_addr + read_bit + data address</code> 并 提供读数据时钟 时，I2C Slave 硬件会将 TX FIFO 中的数据发送到 Master。若主机不再发送 <code>slave_addr + read_bit + data address</code>，就将 FIFO 清空避免在之后的操作中造成错误。</li>
<li>通过自定义中断处理程序，在相应的中断中进行处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="I2C-中断介绍"><a href="#I2C-中断介绍" class="headerlink" title="I2C 中断介绍"></a>I2C 中断介绍</h1><ol>
<li>想要针对某个 I2C 或者 某种模式，使用自定义的中断处理程序，需要修改 <code>esp-idf/components/driver/i2c.c</code> 中的代码，这里仅仅针对 master 使用驱动中提供的中断处理程序，当模式为 Slave 时，使用自定义的中断处理程序。</li>
</ol>
<blockquote>
<p>在 release/3.2 中，无法直接使用 <code>i2c_isr_register</code> 覆盖之前的中断处理程序。通过简单修改驱动源文件，并在应用程序中调用 <code>i2c_isr_register</code> 实现使用自定义的中断处理程序。</p>
</blockquote>
<p>修改 <code>esp-idf/components/driver/i2c.c</code> 文件中 <code>i2c_driver_install</code>  函数中的这段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == I2C_MODE_MASTER) &#123;</span><br><span class="line">    <span class="comment">//hook isr handler</span></span><br><span class="line">    i2c_isr_register(i2c_num, i2c_isr_handler_default, p_i2c_obj[i2c_num], intr_alloc_flags, &amp;p_i2c_obj[i2c_num]-&gt;intr_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用程序中使用自定义的中断处理程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> IRAM_ATTR <span class="title">i2c_slave_isr_handler_default</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	…</span><br><span class="line">	…</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief i2c slave initialization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">i2c_slave_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i2c_slave_port = I2C_SLAVE_NUM;</span><br><span class="line">    <span class="keyword">i2c_config_t</span> conf_slave;</span><br><span class="line">    conf_slave.sda_io_num = I2C_SLAVE_SDA_IO;</span><br><span class="line">    conf_slave.sda_pullup_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf_slave.scl_io_num = I2C_SLAVE_SCL_IO;</span><br><span class="line">    conf_slave.scl_pullup_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf_slave.mode = I2C_MODE_SLAVE;</span><br><span class="line">    conf_slave.slave.addr_10bit_en = <span class="number">0</span>;</span><br><span class="line">    conf_slave.slave.slave_addr = ESP_SLAVE_ADDR;</span><br><span class="line">    i2c_param_config(i2c_slave_port, &amp;conf_slave);</span><br><span class="line">    i2c_driver_install(i2c_slave_port, conf_slave.mode, I2C_SLAVE_RX_BUF_LEN, I2C_SLAVE_TX_BUF_LEN, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i2c_isr_register(I2C_SLAVE_NUM, i2c_slave_isr_handler_default, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>) != ESP_OK) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"i2c_isr_register error"</span>);</span><br><span class="line">        <span class="keyword">return</span> ESP_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Slave-中断处理程序"><a href="#Slave-中断处理程序" class="headerlink" title="Slave 中断处理程序"></a>Slave 中断处理程序</h1><p>需要使用的几个中断：</p>
<ul>
<li><strong>I2C_SLAVE_TRAN_COMP_INT</strong>：从机收到设备地址和数据地址时将触发（device address + W/R bit + data address），在这里需要判断 Write/Read。若是 Write，需要清空 TX FIFO，并提前将需要操作的数据放入 TX FIFO 中（根据数据地址），尽可能放满 TX FIFO</li>
<li><strong>I2C_TRANS_COMPLETE_INT</strong>：从机检测到 STOP 时将触发，这个中断中需要将 RX FIFO 中的数据取到数据缓冲区中</li>
<li><strong>I2C_TXFIFO_EMPTY_INT</strong>：硬件 TX FIFO 为空时将触发，（PS：实际测试触发时，FIFO 大小为 27 byte），将可能操作的数据继续放入 TX FIFO 中</li>
<li><strong>I2C_RXFIFO_FULL_INT</strong>：硬件 RX FIFO 满时将触发，将 RX FIFO 中的数据取到数据缓冲区中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> IRAM_ATTR <span class="title">i2c_slave_isr_handler_default</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i2c_num = I2C_SLAVE_NUM;</span><br><span class="line">    <span class="keyword">uint32_t</span> status = I2C_INSTANCE[i2c_num]-&gt;int_status.val;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    portBASE_TYPE HPTaskAwoken = pdFALSE;</span><br><span class="line">    <span class="keyword">while</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        status = I2C_INSTANCE[i2c_num]-&gt;int_status.val;</span><br><span class="line">        <span class="keyword">if</span> (status &amp; I2C_ACK_ERR_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"ae\n"</span>);</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_ena.ack_err = <span class="number">0</span>;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.ack_err = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_TRANS_COMPLETE_INT_ST_M) &#123; <span class="comment">// receive data after receive device address + W/R bit and data address</span></span><br><span class="line">            <span class="comment">// ets_printf("tc, ");</span></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.trans_complete = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> rx_fifo_cnt = I2C_INSTANCE[i2c_num]-&gt;status_reg.rx_fifo_cnt;</span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                <span class="comment">// ets_printf("R\n");</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                <span class="comment">// ets_printf("W ");</span></span><br><span class="line">                ets_printf(<span class="string">"Slave Recv"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; rx_fifo_cnt; idx++) &#123;</span><br><span class="line">                    slave_data[w_r_index++] = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">                &#125;</span><br><span class="line">                ets_printf(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_full = <span class="number">1</span>;</span><br><span class="line">            slave_event = SLAVE_IDLE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_SLAVE_TRAN_COMP_INT_ST_M) &#123; <span class="comment">// slave receive device address + W/R bit + data address</span></span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                ets_printf(<span class="string">"sc, Slave Send\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                <span class="comment">// ets_printf("sc W\n");</span></span><br><span class="line">                w_r_index = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">                <span class="keyword">switch</span> (slave_event) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SLAVE_IDLE:</span><br><span class="line">                        ets_printf(<span class="string">"sc, I2W\n"</span>);</span><br><span class="line">                        <span class="comment">// reset tx fifo to avoid send last byte when master send read command next.</span></span><br><span class="line">                        i2c_reset_tx_fifo(i2c_num);</span><br><span class="line"></span><br><span class="line">                        slave_event = SLAVE_WRITE;</span><br><span class="line">                        slave_send_index = w_r_index;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> tx_fifo_rem = I2C_FIFO_LEN - I2C_INSTANCE[i2c_num]-&gt;status_reg.tx_fifo_cnt;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tx_fifo_rem; i++) &#123;</span><br><span class="line">                            WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), slave_data[slave_send_index++]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        I2C_INSTANCE[i2c_num]-&gt;int_ena.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                        I2C_INSTANCE[i2c_num]-&gt;int_clr.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.slave_tran_comp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_TXFIFO_EMPTY_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"tfe, "</span>);</span><br><span class="line">            <span class="keyword">int</span> tx_fifo_rem = I2C_FIFO_LEN - I2C_INSTANCE[i2c_num]-&gt;status_reg.tx_fifo_cnt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                ets_printf(<span class="string">"R\r\n"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tx_fifo_rem; i++) &#123;</span><br><span class="line">                    WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), slave_data[slave_send_index++]);</span><br><span class="line">                &#125;</span><br><span class="line">                I2C_INSTANCE[i2c_num]-&gt;int_ena.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                I2C_INSTANCE[i2c_num]-&gt;int_clr.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                ets_printf(<span class="string">"W\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_RXFIFO_OVF_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"rfo\n"</span>);</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_ovf = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_RXFIFO_FULL_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"rff\n"</span>);</span><br><span class="line">            <span class="keyword">int</span> rx_fifo_cnt = I2C_INSTANCE[i2c_num]-&gt;status_reg.rx_fifo_cnt;</span><br><span class="line">            <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; rx_fifo_cnt; idx++) &#123;</span><br><span class="line">                slave_data[w_r_index++] = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">            &#125;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_full = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ets_printf("%x\n", status);</span></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.val = status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//We only need to check here if there is a high-priority task needs to be switched.</span></span><br><span class="line">    <span class="keyword">if</span>(HPTaskAwoken == pdTRUE) &#123;</span><br><span class="line">        portYIELD_FROM_ISR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h1><ul>
<li><a href="https://github.com/InfiniteYuan/ESP32-I2C-Slave/tree/master" target="_blank" rel="noopener">ESP32-I2C-Slave</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf" target="_blank" rel="noopener">I2C Specification</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十）使用 ESP32+Camera 二维码识别</title>
    <url>/InfiniteYuanBlog/2019/03/14/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32+Camera%20%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="使用-ESP32-Camera-进行二维码识别"><a href="#使用-ESP32-Camera-进行二维码识别" class="headerlink" title="使用 ESP32 Camera 进行二维码识别"></a>使用 ESP32 Camera 进行二维码识别</h1><ul>
<li>GitHub: <a href="https://github.com/InfiniteYuan/esp32-camera-qr-recoginize/tree/master/examples/single_chip/qrcode_recoginize" target="_blank" rel="noopener">esp32-camera-qr-recoginize</a></li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><a href="https://github.com/espressif/esp-who" target="_blank" rel="noopener">ESP-WHO</a></li>
<li><a href="https://github.com/espressif/esp-idf" target="_blank" rel="noopener">ESP-IDF</a></li>
</ul>
<a id="more"></a>

<h2 id="使用-quirc-二维码识别库"><a href="#使用-quirc-二维码识别库" class="headerlink" title="使用 quirc 二维码识别库"></a>使用 quirc 二维码识别库</h2><ul>
<li><a href="https://github.com/dlbeer/quirc" target="_blank" rel="noopener">quirc</a></li>
</ul>
<h2 id="摄像头初始化"><a href="#摄像头初始化" class="headerlink" title="摄像头初始化"></a>摄像头初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_PIXEL_FORM PIXFORMAT_GRAYSCALE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_FRAME_SIZE FRAMESIZE_VGA</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_CAMERA_MODEL_CUSTOM</span></span><br><span class="line">    <span class="comment">/* IO13, IO14 is designed for JTAG by default,</span></span><br><span class="line"><span class="comment">     * to use it as generalized input,</span></span><br><span class="line"><span class="comment">     * firstly declair it as pullup input */</span></span><br><span class="line">    <span class="keyword">gpio_config_t</span> conf;</span><br><span class="line">    conf.mode = GPIO_MODE_INPUT;</span><br><span class="line">    conf.pull_up_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf.pull_down_en = GPIO_PULLDOWN_DISABLE;</span><br><span class="line">    conf.intr_type = GPIO_INTR_DISABLE;</span><br><span class="line">    conf.pin_bit_mask = <span class="number">1L</span>L &lt;&lt; <span class="number">13</span>;</span><br><span class="line">    gpio_config(&amp;conf);</span><br><span class="line">    conf.pin_bit_mask = <span class="number">1L</span>L &lt;&lt; <span class="number">14</span>;</span><br><span class="line">    gpio_config(&amp;conf);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">config</span>.ledc_channel = LEDC_CHANNEL_0;</span><br><span class="line">    <span class="built_in">config</span>.ledc_timer = LEDC_TIMER_0;</span><br><span class="line">    <span class="built_in">config</span>.pin_d0 = Y2_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d1 = Y3_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d2 = Y4_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d3 = Y5_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d4 = Y6_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d5 = Y7_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d6 = Y8_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d7 = Y9_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_xclk = XCLK_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_pclk = PCLK_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_vsync = VSYNC_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_href = HREF_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_sscb_sda = SIOD_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_sscb_scl = SIOC_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_pwdn = PWDN_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_reset = RESET_GPIO_NUM;</span><br><span class="line">    <span class="comment">// Only support 10 MHz current. Camera will output bad image when XCLK is 20 MHz.</span></span><br><span class="line">    <span class="built_in">config</span>.xclk_freq_hz = <span class="number">10000000</span>;</span><br><span class="line">    <span class="built_in">config</span>.pixel_format = CAMERA_PIXEL_FORM;</span><br><span class="line">    <span class="built_in">config</span>.frame_size = CAMERA_FRAME_SIZE;</span><br><span class="line">    <span class="built_in">config</span>.jpeg_quality = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">config</span>.fb_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera init</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_camera_init(&amp;<span class="built_in">config</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Camera init failed with error 0x%x"</span>, err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create QR-code recognize task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    app_qr_recognize(&amp;<span class="built_in">config</span>);</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Free heap: %u"</span>, xPortGetFreeHeapSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a>二维码识别</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr_recoginze</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">camera_config_t</span> *camera_config = (<span class="keyword">camera_config_t</span> *)parameter;</span><br><span class="line">    <span class="comment">// Use VGA Size currently, but quirc can support other frame size.(eg: FRAMESIZE_SVGA,FRAMESIZE_VGA，</span></span><br><span class="line">    <span class="comment">// FRAMESIZE_CIF,FRAMESIZE_QVGA,FRAMESIZE_HQVGA,FRAMESIZE_QCIF,FRAMESIZE_QQVGA2,FRAMESIZE_QQVGA,etc)</span></span><br><span class="line">    <span class="keyword">if</span> (camera_config-&gt;frame_size &gt; FRAMESIZE_VGA) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Camera Frame Size err %d"</span>, (camera_config-&gt;frame_size));</span><br><span class="line">        vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save image width and height, avoid allocate memory repeatly.</span></span><br><span class="line">    <span class="keyword">uint16_t</span> old_width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> old_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct a new QR-code recognizer.</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Construct a new QR-code recognizer(quirc)."</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quirc</span> *<span class="title">qr_recognizer</span> = <span class="title">quirc_new</span>();</span></span><br><span class="line">    <span class="keyword">if</span> (!qr_recognizer) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Can't create quirc object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">camera_fb_t</span> *fb = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> *<span class="built_in">image</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> id_count = <span class="number">0</span>;</span><br><span class="line">    UBaseType_t uxHighWaterMark;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入口处检测一次 */</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"uxHighWaterMark = %d"</span>, uxTaskGetStackHighWaterMark( <span class="literal">NULL</span> ));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">"uxHighWaterMark = %d"</span>, uxTaskGetStackHighWaterMark( <span class="literal">NULL</span> ));</span><br><span class="line">        <span class="comment">// Capture a frame</span></span><br><span class="line">        fb = esp_camera_fb_get();</span><br><span class="line">        <span class="keyword">if</span> (!fb) &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">"Camera capture failed"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old_width != fb-&gt;<span class="built_in">width</span> || old_height != fb-&gt;<span class="built_in">height</span>) &#123;</span><br><span class="line">            ESP_LOGD(TAG, <span class="string">"Recognizer size change w h len: %d, %d, %d"</span>, fb-&gt;<span class="built_in">width</span>, fb-&gt;<span class="built_in">height</span>, fb-&gt;len);</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">"Resize the QR-code recognizer."</span>);</span><br><span class="line">            <span class="comment">// Resize the QR-code recognizer.</span></span><br><span class="line">            <span class="keyword">if</span> (quirc_resize(qr_recognizer, fb-&gt;<span class="built_in">width</span>, fb-&gt;<span class="built_in">height</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">"Resize the QR-code recognizer err."</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                old_width = fb-&gt;<span class="built_in">width</span>;</span><br><span class="line">                old_height = fb-&gt;<span class="built_in">height</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** These functions are used to process images for QR-code recognition.</span></span><br><span class="line"><span class="comment">         * quirc_begin() must first be called to obtain access to a buffer into</span></span><br><span class="line"><span class="comment">         * which the input image should be placed. Optionally, the current</span></span><br><span class="line"><span class="comment">         * width and height may be returned.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * After filling the buffer, quirc_end() should be called to process</span></span><br><span class="line"><span class="comment">         * the image for QR-code recognition. The locations and content of each</span></span><br><span class="line"><span class="comment">         * code may be obtained using accessor functions described below.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">image</span> = quirc_begin(qr_recognizer, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">image</span>, fb-&gt;buf, fb-&gt;len);</span><br><span class="line">        quirc_end(qr_recognizer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the number of QR-codes identified in the last processed image.</span></span><br><span class="line">        id_count = quirc_count(qr_recognizer);</span><br><span class="line">        <span class="keyword">if</span> (id_count == <span class="number">0</span>) &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">"Error: not a valid qrcode"</span>);</span><br><span class="line">            esp_camera_fb_return(fb);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print information of QR-code</span></span><br><span class="line">        dump_info(qr_recognizer, id_count);</span><br><span class="line">        esp_camera_fb_return(fb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Destroy QR-Code recognizer (quirc)</span></span><br><span class="line">    quirc_destroy(qr_recognizer);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Deconstruct QR-Code recognizer(quirc)"</span>);</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例结果"><a href="#示例结果" class="headerlink" title="示例结果"></a>示例结果</h2><p><img src="https://img-blog.csdnimg.cn/20190315190639946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="示例结果"></p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（四）OV7670 摄像头图像采集</title>
    <url>/InfiniteYuanBlog/2018/01/16/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89OV7670%20%E6%91%84%E5%83%8F%E5%A4%B4%E5%9B%BE%E5%83%8F%E9%87%87%E9%9B%86/</url>
    <content><![CDATA[<h1 id="ESP32-Camera-Demo"><a href="#ESP32-Camera-Demo" class="headerlink" title="ESP32 Camera Demo"></a>ESP32 Camera Demo</h1><p><a href="https://github.com/InfiniteYuan/esp32_ov7670_video" target="_blank" rel="noopener">GitHub 源码地址</a><br>使用的硬件有：</p>
<ul>
<li><code>ESP-WROVER-KIT</code>开发板</li>
<li>OV7670 摄像头</li>
<li>ST7789 控制器的 LCD 屏幕</li>
</ul>
<p>该工程实现的功能有：</p>
<ul>
<li>通过手机端浏览器访问 ESP32 HTTP 服务器，查看当前摄像头采集的图像</li>
<li>摄像头采集图像、LCD 实时显示刷新速率达到 22fps</li>
</ul>
<a id="more"></a>

<h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p>按照默认的<code>make menuconfig</code>中的默认配置连接即可。</p>
<blockquote>
<p>注: 如果使用<code>ESP-WROVER-KIT</code>开发板，请注意把 LCD 的 reset 引脚上拉，否则 LCD 无法正常复位。</p>
</blockquote>
<blockquote>
<p>注: 如果 LCD 的背光灯没有正常亮起，可以将背光灯引脚直接接到高/低电平。</p>
</blockquote>
<h2 id="硬件实物图"><a href="#硬件实物图" class="headerlink" title="硬件实物图"></a>硬件实物图</h2><p>该工程默认使用的为<code>ESP-WROVER-KIT</code>开发板;<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgyODA0MDM5?x-oss-process=image/format,png" alt="LCD屏幕"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgzMDQ2MjIw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>若选用<code>ESP-WROVER-KIT</code>开发板，下载时，请选择 ttyUSB1 ;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j8 flash</span><br></pre></td></tr></table></figure>

<h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><p>以下是需要注意的相关配置：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgzMTE3Njk4?x-oss-process=image/format,png" alt="这里写图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgzMTI4Mzg3?x-oss-process=image/format,png" alt="这里写图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgzMTM5OTYx?x-oss-process=image/format,png" alt="这里写图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgzMTUxNDU1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
</search>
