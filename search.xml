<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo Blog</title>
    <url>/InfiniteYuanBlog/2012/07/22/hexo_blog_log/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<a id="more"></a>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（一）开发环境搭建</title>
    <url>/InfiniteYuanBlog/2018/11/20/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="ESP32-开发环境搭建"><a href="#ESP32-开发环境搭建" class="headerlink" title="ESP32 开发环境搭建"></a>ESP32 开发环境搭建</h1><p>ESP32 整体的开发资料相对比较多,官方网站在 github 上提供了详细的开发环境搭建步骤:<a href="https://esp-idf.readthedocs.io/en/latest/index.html#" target="_blank" rel="noopener">ESP-IDF Programming Guide</a></p>
<a id="more"></a>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 学习笔记（二）GPIO &amp; RTC GPIO</title>
    <url>/InfiniteYuanBlog/2018/11/20/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89GPIO%20&amp;%20RTC%20GPIO/</url>
    <content><![CDATA[<h1 id="GPIO-amp-RTC-GPIO"><a href="#GPIO-amp-RTC-GPIO" class="headerlink" title="GPIO &amp; RTC GPIO"></a>GPIO &amp; RTC GPIO</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP32 芯片具有 40 个物理 GPIO pads (焊盘).某些 GPIO pad 既不能使用,在芯片封装上也没有相应的引脚(请参阅技术参考手册).所以只有 34 个物理 GPIO pads 可供使用.每个 pad 都可用作一个通用 IO,或连接一个内部的外设信号.IO_MUX、RTC IO_MUX 和 GPIO 交换矩阵用于将信号从外设传输至 GPIO pad.这些模块共同组成了芯片的 IO 控制.</p>
<p>注意:</p>
<ul>
<li>管脚 SCK/CLK,SDO/SD0,SDI/SD1,SHD/SD2,SWP/SD3,和 SCS/CMD,即 GPIO6 至 GPIO11 用于连接模组上集成的 SPI flash,不建议用于其他功能.</li>
<li>ESP32-D2WD 的管脚 GPIO16,GPIO17,SD_CMD,SD_CLK,SD_DATA_0 和 SD_DATA_1 用于连接嵌入式 Flash,不建议用于其他功能.</li>
<li>GPIO 34-39 只能设置为输入模式,没有软件上拉或下拉功能.</li>
<li>这 34 个物理 GPIO pad 的序列号为:0-19, 21-23, 25-27, 32-39.其中 GPIO 34-39 仅用作输入管脚,其他的既可以作为输入又可以作为输出管脚.</li>
</ul>
<a id="more"></a>

<p>当 GPIO 被连接到 “RTC” 低功耗和模拟子系统时,还有独立的 “RTC GPIO” 支持. 这些引脚功能可在深度睡眠,<a href="https://esp-idf.readthedocs.io/zh_CN/latest/api-guides/ulp.html" target="_blank" rel="noopener">超低功耗协处理器</a>运行时或使用 ADC/DAC/等 模拟功能时使用.</p>
<p>下图描述了数字 pad(控制信号:FUNC_SEL、IE、OE、WPU、WDU 等)和 162 个外设输入以及 176 个外设输出信号(控制信号:SIG_IN_SEL、SIG_OUT_SEL、IE、OE 等)和快速外设输入/输出信号(控制信号:IE、OE 等)以及 RTC IO_MUX 之间的信号选择和连接关系.<br><img src="https://img-blog.csdn.net/20180811133142567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图1: IO_MUX、RTC IO_MUX 和GPIO 交换矩阵结构框图"></p>
<center>图1: IO_MUX、RTC IO_MUX 和GPIO 交换矩阵结构框图</center>

<ol>
<li>IO_MUX 中每个 GPIO pad 有一组寄存器.每个 pad 可以配置成 GPIO 功能(连接 GPIO 交换矩阵)或者直连功能(旁路 GPIO 交换矩阵,快速信号如以太网、SDIO、SPI、JTAG、UART 等会旁路 GPIO 交换矩阵以实现更好的高频数字特性.所以高速信号会直接通过 IO_MUX 输入和输出.)</li>
<li>GPIO 交换矩阵是外设输入和输出信号和 pad 之间的全交换矩阵.<ul>
<li>芯片输入方向:162 个外设输入信号都可以选择任意一个 GPIO pad 的输入信号.</li>
<li>芯片输出方向:每个 GPIO pad 的输出信号可来自 176 个外设输出信号中的任意一个.</li>
</ul>
</li>
<li>RTC IO_MUX 用于控制 GPIO pad 的低功耗和模拟功能.只有部分 GPIO pad 具有这些功能.</li>
</ol>
<h2 id="通过-GPIO-交换矩阵的外设输入"><a href="#通过-GPIO-交换矩阵的外设输入" class="headerlink" title="通过 GPIO 交换矩阵的外设输入"></a>通过 GPIO 交换矩阵的外设输入</h2><p>为实现通过 GPIO 交换矩阵接收外设输入信号,需要配置 GPIO 交换矩阵从 34 个 GPIO(0-19,21-23,25-27,32-39)中获取外设输入信号的索引号(0-18,23-36,39-58,61-90,95-124,140-155,164-181,190-195,198-206).</p>
<p>输入信号通过 IO_MUX 从 GPIO pad 中读取.IO_MUX 必须设置相应 pad 为 GPIO 功能.这样 GPIO pad 的输入信号就可进入 GPIO 交换矩阵然后通过 GPIO 交换矩阵进入选择的外设输入.<br><img src="https://img-blog.csdn.net/20180811135015590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图2: 通过IO_MUX、GPIO 交换矩阵的外设输入"></p>
<center>图2: 通过IO_MUX、GPIO 交换矩阵的外设输入</center>

<h2 id="通过-GPIO-交换矩阵的外设输出"><a href="#通过-GPIO-交换矩阵的外设输出" class="headerlink" title="通过 GPIO 交换矩阵的外设输出"></a>通过 GPIO 交换矩阵的外设输出</h2><p>为实现通过 GPIO 交换矩阵输出外设信号,需要配置 GPIO 交换矩阵将输出索引号为 0-18,23-37,61-121,140-215,224-228 的外设信号输出到 28 个 GPIO (0-19, 21-23, 25-27, 32-33).</p>
<p>输出信号从外设输出到 GPIO 交换矩阵,然后到达 IO_MUX.IO_MUX 必须设置相应 pad 为 GPIO 功能.这样输出 GPIO 信号就能连接到相应 pad.</p>
<p>图3 所示为 176 个输出信号中的某一个信号通过 GPIO 交换矩阵到达 IO_MUX 然后连接到某个 pad.<br><img src="https://img-blog.csdn.net/20180811135319400?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图3: 通过GPIO 交换矩阵输出信号"></p>
<center>图3: 通过GPIO 交换矩阵输出信号</center>

<h2 id="IO-MUX-的直接-I-O-功能"><a href="#IO-MUX-的直接-I-O-功能" class="headerlink" title="IO_MUX 的直接 I/O 功能"></a>IO_MUX 的直接 I/O 功能</h2><p>快速信号如以太网、SDIO、SPI、JTAG、UART 等会使用直连功能(旁路 GPIO 交换矩阵)以实现更好的高频数字特性.所以高速信号会直接通过 IO_MUX 输入和输出.</p>
<p>这样比使用 GPIO 交换矩阵的灵活度要低,即每个 GPIO pad 的 IO_MUX 寄存器只有较少的功能选择,但可以实现更好的高频数字特性.</p>
<p>为实现外设 I/O 旁路 GPIO 交换矩阵必须配置两个寄存器:</p>
<ul>
<li>GPIO pad 的 IO_MUX 必须设置为相应的 pad 功能,表1列出了 pad 功能.</li>
<li>对于输入信号,必须置位 SIG_IN_SEL 寄存器,直接将输入信号输出到外设.</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180811140112726?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="IO_MUX Pad 列表"></p>
<center>表1: IO_MUX Pad 列表</center>

<h2 id="RTC-IO-MUX-的低功耗和模拟-I-O-功能"><a href="#RTC-IO-MUX-的低功耗和模拟-I-O-功能" class="headerlink" title="RTC IO_MUX 的低功耗和模拟 I/O 功能"></a>RTC IO_MUX 的低功耗和模拟 I/O 功能</h2><p>18 个 GPIO 管脚具有低功耗(低功耗 RTC)性能和模拟功能,由 ESP32 的 RTC 子系统控制.这些功能不使用 IO_MUX 和 GPIO 交换矩阵,而是使用 RTC_MUX 将 I/O 指向 RTC 子系统.</p>
<p>当这些管脚被配置为 RTC GPIO 管脚,作为输出管脚时仍然能够在芯片处于 Deep-sleep 睡眠模式下保持输出电平值或者作为输入管脚使用时可以将芯片从 Deep-sleep 中唤醒.</p>
<p>每个 pad 的模拟和 RTC 功能是由 RTC_GPIO_PINx 寄存器中的 RTC_IO_TOUCH_PADx_TO_GPIO 位控制的.此位默认置为 1,通过 IO_MUX 子系统输入输出信号,如前文所述.</p>
<p>如果清零 RTC_IO_TOUCH_PADx_TO_GPIO 位,则输入输出信号会经过 RTC 子系统.在这种模式下,RTC_GPIO_PINx 寄存器用于数字 I/O,pad 的模拟功能也可以实现.</p>
<h2 id="Light-sleep-模式管脚功能"><a href="#Light-sleep-模式管脚功能" class="headerlink" title="Light-sleep 模式管脚功能"></a>Light-sleep 模式管脚功能</h2><p>当 ESP32 处于 Light-sleep 模式时管脚可以有不同的功能.如果某一 GPIO pad 的 IO_MUX 寄存器中 GPIOxx_SLP_SEL 位置为 1,芯片处于 Light-sleep 模式下将由另一组不同的寄存器控制 pad.</p>
<p>如果 GPIOxx_SLP_SEL 置为 0,则芯片在正常工作和 Light-sleep 模式下,管脚的功能一样.</p>
<h2 id="Pad-Hold-特性"><a href="#Pad-Hold-特性" class="headerlink" title="Pad Hold 特性"></a>Pad Hold 特性</h2><p>每个 IO pad(包括 RTC pad)都有单独的 hold 功能,由 RTC 寄存器控制.pad 的 hold 功能被置上后,pad 在置上 hold 那一刻的状态被强制保持,无论内部信号如何变化,修改 IO_MUX 配置或者 GPIO 配置,都不会改变 pad 的状态.应用如果希望在看门狗超时触发内核复位和系统复位时或者 Deep-sleep 时 pad 的状态不被改变,就需要提前把 hold 置上.</p>
<ul>
<li>对于数字 pad 而言, 若要在深度睡眠掉电之后保持 pad 输入输出的状态值,需要在掉电之前把寄存器 REG_DG_PAD_FORCE_UNHOLD 设置成 0.对于 RTC pad 而言,pad 的输入输出值,由寄存器 RTC_CNTL_HOLD_FORCE_REG 中相应的位来控制 Hold 和 Unhold pad 的值.</li>
<li>在芯片被唤醒之后,若要关闭 Hold 功能,将寄存器 REG_DG_PAD_FORCE_UNHOLD 设置成 1.若想继续保持 pad 的值,可把 RTC_CNTL_HOLD_FORCE_REG 寄存器中相应的位设置成1.</li>
</ul>
<p>示例：</p>
<p>RTC GPIO （deep sleep）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtc_gpio_init(27);</span><br><span class="line">rtc_gpio_set_direction(27, RTC_GPIO_MODE_OUTPUT_ONLY);</span><br><span class="line">rtc_gpio_set_level(27, 1);</span><br><span class="line">rtc_gpio_pullup_en(27);</span><br><span class="line">rtc_gpio_hold_en(27);</span><br></pre></td></tr></table></figure>

<p>Digital GPIO：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * The state of digital gpio cannot be held during Deep-sleep, and it will resume the hold function</span><br><span class="line">  * when the chip wakes up from Deep-sleep. If the digital gpio also needs to be held during Deep-sleep,</span><br><span class="line">  * &#96;gpio_deep_sleep_hold_en&#96; should also be called.</span><br><span class="line">  *</span><br><span class="line">  * Power down or call gpio_hold_dis will disable this function.</span><br><span class="line">  *&#x2F;</span><br><span class="line">gpio_pad_select_gpio(26);</span><br><span class="line">gpio_set_direction(26, GPIO_MODE_OUTPUT);</span><br><span class="line">gpio_set_level(26, 1);</span><br><span class="line"></span><br><span class="line">gpio_hold_en(26);</span><br><span class="line">gpio_deep_sleep_hold_en();</span><br></pre></td></tr></table></figure>

<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>GPIO 输出/输入中断示例:<a href="https://github.com/espressif/esp-idf/tree/f9a4496/examples/peripherals/gpio" target="_blank" rel="noopener">peripherals/gpio</a>.</p>
<h2 id="API-Reference-Normal-GPIO"><a href="#API-Reference-Normal-GPIO" class="headerlink" title="API Reference - Normal GPIO"></a>API Reference - Normal GPIO</h2><h3 id="Header-File"><a href="#Header-File" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/f9a4496/components/driver/include/driver/gpio.h" target="_blank" rel="noopener">driver/include/driver/gpio.h</a></li>
</ul>
<h2 id="API-Reference-RTC-GPIO"><a href="#API-Reference-RTC-GPIO" class="headerlink" title="API Reference - RTC GPIO"></a>API Reference - RTC GPIO</h2><h3 id="Header-File-1"><a href="#Header-File-1" class="headerlink" title="Header File"></a>Header File</h3><ul>
<li><a href="https://github.com/espressif/esp-idf/blob/7abed5f/components/driver/include/driver/rtc_io.h" target="_blank" rel="noopener">driver/include/driver/rtc_io.h</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/v3.2/api-reference/peripherals/gpio.html" target="_blank" rel="noopener">GPIO &amp; RTC GPIO</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 学习笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（一）关于 ESP-IDF 编程的一些说明</title>
    <url>/InfiniteYuanBlog/2018/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%B3%E4%BA%8E%20ESP-IDF%20%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="关于-ESP-IDF-编程的一些说明"><a href="#关于-ESP-IDF-编程的一些说明" class="headerlink" title="关于 ESP-IDF 编程的一些说明"></a>关于 ESP-IDF 编程的一些说明</h1><h2 id="应用启动流程"><a href="#应用启动流程" class="headerlink" title="应用启动流程"></a>应用启动流程</h2><p>本文档说明了在调用 ESP-IDF 应用程序的 <code>app_main</code> 函数之前发生的一些步骤.</p>
<p>启动过程如下：<br> <strong>1. 位于 ROM 中的第一阶段引导程序将第二阶段引导程序映像从 flash 0x1000 地址加载到 RAM( IRAM 和 DRAM ).<br> 2. 第二阶段引导程序从 flash 中加载分区表和主应用程序映像.主应用程序包含 RAM 段和通过 flash cache 映射的只读段.<br> 3. 主应用程序映像执行.此时,可以启动第二个 CPU 和 RTOS 调度器.</strong><br>以下各节将详细介绍此过程.</p>
<a id="more"></a>

<h2 id="第一阶段引导程序"><a href="#第一阶段引导程序" class="headerlink" title="第一阶段引导程序"></a>第一阶段引导程序</h2><p><strong>SoC 复位后,PRO CPU 会立即开始运行,执行复位向量代码,而 APP CPU 将保持复位状态.</strong> 在启动过程中, PRO CPU 会进行所有有关的初始化.APP CPU 复位状态在应用程序启动代码的 <code>call_start_cpu0</code> 函数中被取消.复位向量代码位于 ESP32 芯片掩模 ROM 中的 0x40000400 地址,并且无法修改.<br>复位向量调用的启动代码通过检查 <code>GPIO_STRAP_REG</code> 寄存器的引导引脚状态来确定引导模式.根据复位原因,有以下情况：</p>
<ol>
<li>从深度睡眠(<code>deep sleep</code>)模式复位：如果 <code>RTC_CNTL_STORE6_REG</code> 中的值非零,并且 <code>RTC_CNTL_STORE7_REG</code> 中的 RTC 存储器的 CRC 值有效,则使用 <code>RTC_CNTL_STORE6_REG</code> 作为入口地址并立即跳转到该地址.如果 <code>RTC_CNTL_STORE6_REG</code> 为零,或者 <code>RTC_CNTL_STORE7_REG</code> 包含无效的  CRC 值,或者通过 <code>RTC_CNTL_STORE6_REG</code> 调用的代码执行完毕,则继续启动,就像上电复位一样.注意：此时若要运行自定义的代码,需要提供深度睡眠存根机制.请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档.<ol start="2">
<li>对于上电复位,软件 SOC 复位和看门狗 SOC 复位：检查 <code>GPIO_STRAP_REG</code> 寄存器,是否要求 UART 或 SDIO 下载模式.如果是这种情况,配置 UART 或 SDIO,并等待下载代码.否则,继续启动,就好像是由于软件 CPU 复位.</li>
<li>对于软件 CPU 复位和看门狗 CPU 复位：根据 EFUSE 值配置 SPI flash,并尝试从 flash 中加载代码.在下面的段落中会更详细地描述了该步骤.如果从 flash 中加载代码失败,解压 BASIC 解释器到 RAM 中并启动它.请注意,发生这种情况时 RTC 看门狗仍然是开启的,因此除非解释器接收到任何输入,否则看门狗将在几百毫秒内复位 SOC,重复整个过程.如果解释器收到来自 UART 的任何输入,它将禁用看门狗.</li>
</ol>
</li>
</ol>
<p><strong>应用程序二进制映像从 flash 的 0x1000 地址开始加载.</strong> 闪存的第一个 4kB 扇区用于存储安全引导IV和应用程序映像的签名.有关详细信息,请查看安全启动文档.</p>
<h2 id="第二阶段引导程序"><a href="#第二阶段引导程序" class="headerlink" title="第二阶段引导程序"></a>第二阶段引导程序</h2><p>在 ESP-IDF 中,位于 flash 0x1000 地址的二进制映像是第二阶段引导程序. 第二阶段引导程序源代码可在 ESP-IDF 的 <code>components/bootloader</code> 目录中找到.请注意,第二阶段引导程序这样的安排并不是 ESP32 芯片唯一可行的安排.可以编写一个功能齐全的应用程序,当 flash 偏移到 0x1000 地址时可以工作,但这超出了本文档的范围.ESP-IDF 中使用第二阶段引导程序来增加 flash 布局的灵活性(使用分区表),并允许与闪存加密,安全引导和无线更新(OTA)相关的操作执行.</p>
<p><strong>当第一阶段引导程序完成校验并加载第二阶段引导程序时,它会跳转到在二进制映像头中找到的第二阶段引导程序的入口地址.</strong></p>
<p><strong>第二阶段引导程序读取在 0x8000 地址的分区表.</strong> 更多有关信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">分区表</a>文档.<strong>引导程序找到 factory 和 OTA 分区,并根据 OTA 信息分区中的数据决定引导哪个分区.</strong></p>
<p>对于所选分区,第二阶段引导程序将映射到 IRAM 和 DRAM 的数据和代码段拷贝到其加载地址.对于在 DROM 和 IROM 区域中具有加载地址的节,flash MMU 将提供正确的映射.请注意,第二阶段引导程序为 PRO 和 APP CPU 配置了 flash MMU,但它仅为 PRO CPU 启用 flash MMU.原因是第二阶段引导程序代码被加载到 APP CPU 缓存所使用的内存区域.为 APP CPU 启用缓存的任务将交给应用程序.加载代码并配置 flash MMU 后,第二阶段引导程序将跳转到二进制映像头中的应用程序入口地址.</p>
<p>目前,无法将应用程序定义的挂钩添加到引导程序以自定义应用程序分区的选择逻辑.例如,这可能需要根据 GPIO 的状态加载不同的应用程序映像.此类自定义功能将在未来添加到 ESP-IDF 中.目前,可以通过将 bootloader 组件拷贝到应用程序目录并在那里进行必要的更改来自定义引导程序.在这种情况下,ESP-IDF 构建系统将编译应用程序目录中的组件而不是 ESP-IDF 自身目录中的组件.</p>
<h2 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h2><p>ESP-IDF 应用程序入口地址是在 <code>components/esp32/cpu_start.c</code>中的<code>call_start_cpu0</code>函数.这个函数的两个主要功能是启用堆分配器并使 APP CPU 跳转到其入口地址<code>call_start_cpu1</code>.PRO CPU 上的代码设置 APP CPU 的入口地址、取消 APP CPU 复位,并等待全局标志被 APP CPU 上运行的代码设置,以表示 APP CPU 已经启动.这个函数执行后,PRO CPU 跳转到<code>start_cpu0</code>函数,APP CPU 跳转到<code>start_cpu1</code>函数.</p>
<p><code>start_cpu0</code>和<code>start_cpu1</code>都是弱函数,这意味着如果需要对初始化序列进行一些特定于应用程序的更改,则可以在应用程序中覆盖它们.<code>start_cpu0</code>默认启用或初始化 <code>menuconfig</code> 中选择的组件.请参阅<code>components/esp32/cpu_start.c</code>中此函数的源代码,以获取最新的执行步骤.请注意,在此阶段将调用应用程序中存在的任何 C ++ 全局构造函数.初始化完所有必要组件后,将创建主任务并启动 FreeRTOS 调度器.</p>
<p>当 PRO CPU 在 <code>start_cpu0</code>函数中进行初始化时,APP CPU 将在<code>start_cpu1</code>函数中等待调度器在 PRO CPU 上启动.在 PRO CPU 上启动调器器后,APP CPU 上的代码也会开启调度器.</p>
<p>主任务是运行 <code>app_main</code>函数. 可以在 <code>menuconfig</code> 中配置主任务堆栈大小和优先级. 应用程序可以将此任务用于特定应用程序的初始化,例如启动其他任务. 应用程序还可以将主任务用于事件循环和其他通用活动. 如果 <code>app_main</code> 函数返回,主任务会被删除.</p>
<h2 id="应用内存布局"><a href="#应用内存布局" class="headerlink" title="应用内存布局"></a>应用内存布局</h2><p>ESP32 芯片具有灵活的内存映射功能.本节将介绍  ESP-IDF 在默认情况下是如何使用这些功能的.<br>ESP-IDF 中的应用程序代码可以放入以下内存区域之一.</p>
<h3 id="IRAM-指令RAM"><a href="#IRAM-指令RAM" class="headerlink" title="IRAM(指令RAM)"></a>IRAM(指令RAM)</h3><p>ESP-IDF 为指令 RAM 分配内部 SRAM0 区域的一部分(在技术参考手册中定义).除了第一个 64 kB 块用于 PRO 和 APP CPU 高速缓存之外,该存储器范围的其余部分(即从 <code>0x40080000</code> 到 <code>0x400A0000</code> )用于存储需要从 RAM 中运行的应用程序部分.</p>
<p>使用链接描述文件将 ESP-IDF 的一些组件和 WiFi 协议栈的一些部分放入该区域.</p>
<p>如果需要将一些应用程序代码放入 IRAM,可以使用 <code>IRAM_ATTR</code> 定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;esp_attr.h&quot;</span><br><span class="line">void IRAM_ATTR gpio_isr_handler(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是部分应用可能或应该放在 IRAM 中的情况.</p>
<ul>
<li>如果在注册中断处理程序时使用<code>ESP_INTR_FLAG_IRAM</code>,则必须将中断处理程序放在 IRAM 中.在这种情况下,ISR 可能只调用放在 IRAM 中的函数或存在于 ROM 中的函数.注意：所有 FreeRTOS API 目前都放在 IRAM 中,因此可以安全地从中断处理程序中调用.如果将 ISR 放在 IRAM 中,则必须使用 <code>DRAM_ATTR</code> 将 ISR 使用的所有常量数据和从 ISR 调用的函数(包括但不限于 <code>const char</code> 数组)放在 DRAM 中.</li>
<li>可以将一些关键性的时序代码放在 IRAM 中以减少从闪存加载代码相关的损耗.ESP32 通过 32 kB 高速缓存从闪存中读取代码和数据.在某些情况下,将函数放入到 IRAM 中可以减少由高速缓存未命中引起的延迟.</li>
</ul>
<h3 id="IROM-从Flash执行的代码"><a href="#IROM-从Flash执行的代码" class="headerlink" title="IROM(从Flash执行的代码)"></a>IROM(从Flash执行的代码)</h3><p>如果函数未明确放入到 IRAM 或 RTC 内存中,则将其放置到闪存中.Flash 技术参考手册中介绍了 Flash MMU 用于允许代码从闪存执行的机制. ESP-IDF 从 0x400D0000 - 0x40400000 区域开始放置应该从闪存执行的代码.启动时,第二阶段引导加载程序初始化 Flash MMU 以将代码所在的 flash 中的位置映射到该区域的开头.使用 0x40070000 - 0x40080000 范围内的两个 32kB 块透明地缓存对该区域的访问.<br>请注意,使用 Window ABI CALLx 指令可能无法访问 0x40000000 - 0x40400000 区域外的代码,因此如果应用程序使用 0x40400000 - 0x40800000 或 0x40800000 - 0x40C00000 区域,需要特别小心. ESP-IDF 默认不使用这些区域.</p>
<h3 id="RTC-高速存储器"><a href="#RTC-高速存储器" class="headerlink" title="RTC 高速存储器"></a>RTC 高速存储器</h3><p>从深度睡眠模式唤醒后,将要运行的代码必须放入 RTC 存储器.请查看<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档中的详细说明.</p>
<h3 id="DRAM-数据-RAM"><a href="#DRAM-数据-RAM" class="headerlink" title="DRAM (数据 RAM)"></a>DRAM (数据 RAM)</h3><p>链接器将非常量静态数据和零初始化数据放入 256 kB 的 0x3FFB0000 - 0x3FFF0000 区域中.请注意,如果使用蓝牙堆栈,此区域将减少 64kB(通过将开始地址移至 0x3FFC0000).如果使用跟踪存储器,该区域的长度也会减少 16 kB 或 32kB.放置静态数据后,在此区域中的所有剩下的空间都将用于运行时堆.</p>
<p>常量数据也可以放入 DRAM 中,例如,如果它用在 ISR 中(参见上面 IRAM 部分的注释).为此,可以使用 DRAM_ATTR 定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DRAM_ATTR const char[] format_string &#x3D; &quot;%p %x&quot;;</span><br><span class="line">char buffer[64];</span><br><span class="line">sprintf(buffer, format_string, ptr, val);</span><br></pre></td></tr></table></figure>
<p>不必说,不建议在 ISR 中使用 printf 和其他输出功能.为了进行调试,从中断服务程序打印log时使用 <code>ESP_EARLY_LOGx</code> 宏.在这种情况下,必须确保将 TAG 和格式字符串都放入到 DRAM 中.</p>
<p><code>__NOINIT_ATTR</code>宏可以用作将数据放入<code>.noinit</code>部分的属性.放入此部分的值不会在启动时初始化,并在软件重新启动后保留其值.<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__NOINIT_ATTR uint32_t noinit_data;</span><br></pre></td></tr></table></figure>

<h3 id="DROM-存储在-Flash-中的数据"><a href="#DROM-存储在-Flash-中的数据" class="headerlink" title="DROM(存储在 Flash 中的数据)"></a>DROM(存储在 Flash 中的数据)</h3><p>默认情况下,链接器将常量数据放入到一个 4 MB 的区域中(0x3F400000 - 0x3F800000),该区域被用于通过 Flash MMU 和缓存访问外部闪存.但是对于文字常量不同,它们由编译器嵌入到应用程序代码中.</p>
<h3 id="RTC-低速存储器"><a href="#RTC-低速存储器" class="headerlink" title="RTC 低速存储器"></a>RTC 低速存储器</h3><p>从 RTC 存储器中运行的代码使用的全局和静态变量(即深度睡眠存根代码)必须放入到 RTC 慢速存储器中. 请查看<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a>文档中的详细说明.</p>
<p><code>RTC_NOINIT_ATTR</code>宏可用于将数据放入到这种类型的内存中.放在此部分中的数据,在从深度睡眠中醒来后也会保持其值.<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTC_NOINIT_ATTR uint32_t rtc_noinit_data;</span><br></pre></td></tr></table></figure>

<h3 id="DMA-能力要求"><a href="#DMA-能力要求" class="headerlink" title="DMA 能力要求"></a>DMA 能力要求</h3><p>大多数 DMA 控制器(例如 SPI,sdmmc 等)都要求发送/接收缓冲区应放在 DRAM 中并进行字对齐.我们建议将 DMA 缓冲区放在静态变量中而不是堆栈中.使用<code>DMA_ATTR</code>宏声明全局/本地静态变量,如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DMA_ATTR uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;</span><br><span class="line"></span><br><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    DMA_ATTR static uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在堆栈中放置DMA缓冲区仍然是允许的,但必须记住：</p>
<ol>
<li>如果堆栈在 pSRAM 中,切勿尝试这样做.如果任务的堆栈放在 pSRAM 中,则必须执行<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/external-ram.html" target="_blank" rel="noopener">支持外部 RAM </a>文档(至少在 menuconfig 中启用 <code>SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY</code> 选项)中所述的几个步骤.确保你的任务不在 pSRAM 中.</li>
<li>在将变量放在适当的位置之前的函数中使用 <code>WORD_ALIGNED_ATTR</code> 宏,如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void app_main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t stuff;</span><br><span class="line">    WORD_ALIGNED_ATTR uint8_t buffer[]&#x3D;&quot;I want to send something&quot;;   &#x2F;&#x2F;or the buffer will be placed right after stuff.</span><br><span class="line">    &#x2F;&#x2F; initialization code...</span><br><span class="line">    spi_transaction_t temp &#x3D; &#123;</span><br><span class="line">        .tx_buffer &#x3D; buffer,</span><br><span class="line">        .length &#x3D; 8*sizeof(buffer),</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_device_transmit( spi, &amp;temp );</span><br><span class="line">    &#x2F;&#x2F; other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://esp-idf.readthedocs.io/en/latest/api-guides/general-notes.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（七）ESP32 Core Dump</title>
    <url>/InfiniteYuanBlog/2018/09/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%83%EF%BC%89ESP32%20Core%20Dump/</url>
    <content><![CDATA[<h1 id="ESP32-Core-Dump"><a href="#ESP32-Core-Dump" class="headerlink" title="ESP32 Core Dump"></a>ESP32 Core Dump</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-IDF 支持在不可恢复的软件错误上生成 Core Dump。这个技术可以对软件发生故障时的软件状态进行事后分析。在系统崩溃进入 Panic 状态时，根据配置打印一些信息并停止或重新启动。用户可以选择生成 Core Dump，以便稍后在 PC 上分析故障原因。Core Dump 包含软件发生故障时系统中所有任务的快照。快照包括任务控制块(TCB)和堆栈。因此。有可能找出什么任务，在什么指令(代码行)和该任务的什么调用堆栈导致崩溃。ESP-IDF 提供特殊脚本 <code>espcoredump.py</code>，以帮助用户检索和分析 Core Dump。此工具提供两个用于 Core Dump 分析的命令:</p>
<ul>
<li><code>info_corefile</code> - 打印崩溃的任务的寄存器，调用堆栈，系统中可用任务的列表，内存区域和存储在 Core Dump (TCB 和堆栈)中的内存内容。</li>
<li><code>dbg_corefile</code> - 创建 Core Dump ELF 文件并使用此文件运行 GDB 调试会话。用户可以手动检查内存，变量和任务状态。请注意，由于并非所有内存都保存在 Core Dump 中，因此只有堆栈上分配的变量值才有意义。</li>
</ul>
<a id="more"></a>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>有许多与 Core Dump 相关的配置选项，用户可以在应用程序的配置菜单中选择 (<code>make menuconfig</code>)。</p>
<ol>
<li>Core Dump 数据目标(Components -&gt; ESP32-specific config -&gt; Core dump destination):<ul>
<li>禁用 Core Dump 生成</li>
<li>将 Core Dump 保存到 Flash</li>
<li>将 Core Dump 打印到 UART</li>
</ul>
</li>
<li>核心转储中的最大任务快照数(Components -&gt; ESP32-specific config -&gt; Core dump -&gt; Maximum number of tasks)。</li>
<li>Core Dump 打印到 UART 之前的延迟时间(Components -&gt; ESP32-specific config -&gt; Core dump print to UART delay).。值以 ms 为单位。</li>
</ol>
<h2 id="将-Core-Dump-保存到-Flash"><a href="#将-Core-Dump-保存到-Flash" class="headerlink" title="将 Core Dump 保存到 Flash"></a>将 Core Dump 保存到 Flash</h2><p>选择此选项后，Core Dump 将保存到 Flash 上的特殊分区。当使用随 ESP-IDF 提供的默认分区表文件时，它会自动在 Flash 上分配必要的空间，但如果用户想要将自己的布局文件与 Core Dump 功能一起使用，则应为 Core Dump 定义单独的分区，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size</span><br><span class="line"># Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000</span><br><span class="line">factory,  app,  factory, 0x10000, 1M</span><br><span class="line">coredump, data, coredump,,        64K</span><br></pre></td></tr></table></figure>

<p>分区名称没有特殊要求。可以根据用户应用需求选择，但分区类型应为“数据”，子类型应为“coredump”。此外，在选择分区大小时请注意，Core Dump 数据结构会引入 20 字节的常量开销和 12 字节的每任务开销。此开销不包括每个任务的 TCB 和堆栈的大小，因此，partirion 大小应至少为 20 + max task stack number x(12 + TCB size + max task stack size) 字节。</p>
<p>从 Flash 分析 Core Dump 的通用命令示例是:<br><code>espcoredump.py -p &lt;/path/to/serial/port&gt; info_corefile &lt;/path/to/program/elf/file&gt;</code><br>或<br> <code>espcoredump.py -p &lt;/path/to/serial/port&gt; dbg_corefile &lt;/path/to/program/elf/file&gt;</code></p>
<h2 id="将-Core-Dump-打印到UART"><a href="#将-Core-Dump-打印到UART" class="headerlink" title="将 Core Dump 打印到UART"></a>将 Core Dump 打印到UART</h2><p>选择此选项时，在系统崩溃进入 Panic 状态时，将在 UART 上打印 <strong>base64 编码的 Core Dump</strong>。在这种情况下，用户应手动将 Core Dump 文本正文保存到某个文件，然后运行以下命令:<br><code>espcoredump.py info_corefile -t b64 -c &lt;/path/to/saved/base64/text&gt; &lt;/path/to/program/elf/file&gt;</code><br>或<br> <code>espcoredump.py dbg_corefile -t b64 -c &lt;/path/to/saved/base64/text&gt; &lt;/path/to/program/elf/file&gt;</code></p>
<p>Base64 编码的 Core Dump 体将位于以下页眉和页脚之间:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; CORE DUMP START &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&lt;body of base64-encoded core dump, save it to file on disk&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; CORE DUMP END &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>CORE DUMP START 和 CORE DUMP END 行不得包含在 Core Dump 文本文件中。</p>
<h2 id="Backtraces-中的-ROM-函数"><a href="#Backtraces-中的-ROM-函数" class="headerlink" title="Backtraces 中的 ROM 函数"></a>Backtraces 中的 ROM 函数</h2><p>可能的情况是，在崩溃时，一些任务或/和崩溃的任务本身在其调用堆栈中具有一个或多个 ROM 功能。由于 ROM 不是程序 ELF 的一部分，GDB 不可能解析这样的调用堆栈，因为它试图分析函数的序言来实现它。在这种情况下，调用堆栈打印将在第一个 ROM 函数中被错误消息打破。要解决此问题，您可以使用 Espressif 提供的 <a href="https://dl.espressif.com/dl/esp32_rom.elf" target="_blank" rel="noopener">ROM ELF</a> 并将其传递给 ‘espcoredump.py’。</p>
<h2 id="运行-‘espcoredump-py’"><a href="#运行-‘espcoredump-py’" class="headerlink" title="运行 ‘espcoredump.py’"></a>运行 ‘espcoredump.py’</h2><p>通用命令语法:</p>
<p><code>espcoredump.py [options] command [args]</code></p>
<p><code>Script Options:</code>    </p>
<ul>
<li>–chip,-c {auto,esp32}. Target chip type. Supported values are auto and esp32.</li>
<li>–port,-p PORT. Serial port device.</li>
<li>–baud,-b BAUD. Serial port baud rate used when flashing/reading.</li>
</ul>
<p><code>Commands:</code>    </p>
<ul>
<li>info_corefile. Retrieve core dump and print useful info.</li>
<li>dbg_corefile. Retrieve core dump and start GDB session with it.</li>
</ul>
<p><code>Command Arguments:</code></p>
<ul>
<li>–gdb,-g GDB. Path to gdb to use for data retrieval.</li>
<li>–core,-c CORE. Path to core dump file to use (if skipped core dump will be read from flash).</li>
<li>–core-format,-t CORE_FORMAT. Specifies that file passed with “-c” is an ELF (“elf”), dumped raw binary (“raw”) or base64-encoded (“b64”) format.</li>
<li>–off,-o OFF. Ofsset of coredump partition in flash (type “make partition_table” to see it).</li>
<li>–save-core,-s SAVE_CORE. Save core to file. Othwerwise temporary core file will be deleted. Ignored with “-c”.</li>
<li>–rom-elf,-r ROM_ELF. Path to ROM ELF file to use (if skipped “esp32_rom.elf” is used).</li>
<li>–print-mem,-m Print memory dump. Used only with “info_corefile”.</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/core_dump.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（三）分区表</title>
    <url>/InfiniteYuanBlog/2018/08/29/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>单个 ESP32 的 flash 可以包含多个应用程序,以及许多不同类型的数据(校准数据,文件系统,参数存储等). 因此,分区表被下载到 flash 中的 0x8000 地址(默认偏移量).</p>
<p>分区表长度为 0xC00 字节(最多 95 个分区表条目). 在表数据之后附加 MD5 校验和. 如果分区表由于安全引导而签名,则签名将附加在分区表之后.</p>
<p>分区表中的每个条目都有一个 <code>name</code> (label),<code>type</code>(app,data 或其他),<code>subtype</code>以及加载分区的 flash 中的 <code>offset</code> (偏移量).</p>
<p>使用分区表的最简单方法是 <code>make menuconfig</code> 并选择一个简单的预定义分区表:</p>
<ul>
<li>“Single factory app, no OTA”</li>
<li>“Factory app, two OTA definitions”</li>
</ul>
<p>在这两种情况下,<code>factory</code> 应用程序下载到 0x10000 地址. 如果您 <code>make partition_table</code>,那么它将打印分区表的摘要.</p>
<a id="more"></a>

<h2 id="内置分区表"><a href="#内置分区表" class="headerlink" title="内置分区表"></a>内置分区表</h2><p>以下是 <code>Single factory app, no OTA</code> 的分区表配置信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Espressif ESP32 Partition Table</span><br><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  app,  factory, 0x10000, 1M,</span><br></pre></td></tr></table></figure>
<ul>
<li>flash 中的 0x10000(64KB) 偏移量被标记为 <code>factory</code> 应用程序. 默认情况下,引导加载程序将运行此应用程序.</li>
<li>在分区表中还定义了两个用于存储 NVS 库分区和 PHY 初始化数据的数据区域.</li>
</ul>
<p>以下是 <code>Factory app, two OTA definitions</code> 的分区表配置信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Espressif ESP32 Partition Table</span><br><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x4000,</span><br><span class="line">otadata,  data, ota,     0xd000,  0x2000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  0,    0,       0x10000, 1M,</span><br><span class="line">ota_0,    0,    ota_0,  0x110000, 1M,</span><br><span class="line">ota_1,    0,    ota_1,  0x210000, 1M,</span><br></pre></td></tr></table></figure>
<ul>
<li>现在有三个应用程序分区定义.</li>
<li>这三种 <code>Type</code> 都设置为 <code>app</code>,但在 0x10000 位置的 <code>factory</code> 应用程序和后面的两个 <code>OTA</code> 应用程序的子类型有所不同.</li>
<li>还有一个新的 <code>ota data</code> 区域,用于保存 OTA 更新的数据. 引导加载程序会查询此数据,以便了解要执行的应用程序. 如果 <code>ota data</code> 为空,它将执行 <code>factory</code> 应用程序.</li>
</ul>
<h2 id="创建自定义分区表"><a href="#创建自定义分区表" class="headerlink" title="创建自定义分区表"></a>创建自定义分区表</h2><p>如果在 menuconfig 中选择 “Custom partition table CSV”,还应该输入要用于分区表的 CSV 文件的名称(在项目目录中). CSV 文件中有将要用于分区表配置的任意数量的定义.</p>
<p>CSV 格式与上面摘要中打印的格式相同. 但是,CSV 中并非所有字段都是必需的. 例如,以下是 OTA 分区表的“输入” CSV:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Custom partition table</span><br><span class="line"># Name,   Type, SubType, Offset, Size, Flags</span><br><span class="line">nvs,      data, nvs,     ,       0x4000,</span><br><span class="line">otadata,  data, ota,     ,       0x2000,</span><br><span class="line">phy_init, data, phy,     ,       0x1000,</span><br><span class="line">factory,  app,  factory, ,       1M,</span><br><span class="line">ota_0,    app,  ota_0,   ,       1M,</span><br><span class="line">ota_1,    app,  ota_1,   ,       1M,</span><br></pre></td></tr></table></figure>
<ul>
<li>字段之间的空格被忽略,任何以＃(注释)开头的行也是如此.</li>
<li>CSV 文件中的每个非注释行都是分区定义.</li>
<li>每个分区的 “Offset” 字段为空. <code>gen_esp32part.py</code> 工具填充每个空白偏移量,从分区表开始并确保每个分区正确对齐.</li>
</ul>
<h3 id="名字字段"><a href="#名字字段" class="headerlink" title="名字字段"></a>名字字段</h3><p>名称字段可以是任何有意义的名称. 这对 ESP32 来说并不重要. 超过 16 个字符的名称将被截取.</p>
<h3 id="类型字段"><a href="#类型字段" class="headerlink" title="类型字段"></a>类型字段</h3><p>分区类型字段可以指定为 app(0) 或 data(1). 或者它可以是数字 0-254(或十六进制 0x00-0xFE). 类型 0x00-0x3F 保留用于 esp-idf 核心功能.</p>
<p>如果您的应用程序需要存储数据,请在 0x40-0xFE 范围内添加自定义分区类型.</p>
<p>引导加载程序忽略 app(0) 和 data(1) 以外的任何分区类型.</p>
<h3 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a>子类型</h3><p>8 位子类型字段特定于给定的分区类型.</p>
<p>esp-idf 当前仅指定 “app” 和 “data” 分区类型的子类型字段的含义.</p>
<h3 id="App-子类型"><a href="#App-子类型" class="headerlink" title="App 子类型"></a>App 子类型</h3><p>当 type 为 “app” 时,子类型字段可以指定为 factory(0),ota_0(0x10)… ota_15(0x1F) 或 test(0x20).</p>
<ul>
<li>factory(0) 是默认的应用程序分区. 引导加载程序将执行工厂应用程序,除非它看到类型为 data/ota 的分区,在这种情况下,它会读取此分区以确定要引导的 OTA 映像.<ul>
<li>OTA 永远不会更新 <code>factory</code> 分区.</li>
<li>如果要保留 OTA 项目中的闪存使用率,可以删除 <code>factory</code> 分区并改为使用 ota_0.</li>
</ul>
</li>
<li>ota_0(0x10)… ota_15(0x1F) 是 OTA app 区域. 有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html" target="_blank" rel="noopener">OTA文档</a>,然后使用 OTA 数据分区配置引导加载程序应引导的应用程序. 如果使用 OTA,则应用程序应至少具有两个 OTA 应用程序槽(<code>ota_0</code>＆<code>ota_1</code>). 有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html" target="_blank" rel="noopener">OTA文档</a>.</li>
<li>test(0x2) 是 <code>factory</code> 测试程序的保留子类型. esp-idf 引导程序当前不支持它.</li>
</ul>
<h3 id="数据子类型"><a href="#数据子类型" class="headerlink" title="数据子类型"></a>数据子类型</h3><p>当 type 为 “data” 时,子类型字段可以指定为 ota(0),phy(1),nvs(2).</p>
<ul>
<li>ota(0) 是<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html#ota-data-partition" target="_blank" rel="noopener">OTA数据分区</a>,它存储有关当前所选 OTA 应用程序的信息.此分区的大小应为 0x2000 字节.有关更多详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/system/ota.html#ota-data-partition" target="_blank" rel="noopener">OTA文档</a>.</li>
<li>phy(1) 用于存储 PHY 初始化数据.这允许 PHY 到每个设备被配置,而不是在固件.<ul>
<li>在默认配置中,不使用 phy 分区,并且 PHY 初始化数据被编译到 app 本身.因此,可以从分区表中删除此分区以节省空间.</li>
<li>要从此分区加载 PHY 数据,请运行 <code>make menuconfig</code> 并启用 <code>CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</code> 选项.您还需要使用 <code>phy init</code> 数据刷新(flash)设备,因为 esp-idf 构建系统不会自动执行此操作.</li>
</ul>
</li>
<li>nvs(2) 用于<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/storage/nvs_flash.html" target="_blank" rel="noopener">非易失性存储(NVS)API</a>.<ul>
<li>NVS 用于存储每个设备 PHY 校准数据(与初始化数据不同).</li>
<li>如果使用<a href="https://esp-idf.readthedocs.io/en/latest/api-reference/wifi/esp_wifi.html" target="_blank" rel="noopener">esp_wifi_set_storage(WIFI_STORAGE_FLASH)</a>初始化功能,则 NVS 用于存储 WiFi 数据.</li>
<li>NVS API 还可用于其他应用程序数据.</li>
<li>强烈建议您在项目中包含至少 0x3000 字节的 NVS 分区.</li>
<li>如果使用 NVS API 存储大量数据,请将 NVS 分区默认的 0x6000 字节大小增加.</li>
</ul>
</li>
</ul>
<p>其他数据子类型保留用于将来的 esp-idf 用途.</p>
<h3 id="偏移量-amp-大小"><a href="#偏移量-amp-大小" class="headerlink" title="偏移量 &amp; 大小"></a>偏移量 &amp; 大小</h3><p>具有空白偏移的分区将在前一个分区之后开始,或者第一个分区是在分区表之后开始.</p>
<p>应用程序分区必须处于与 0x10000(64K) 对齐的偏移量. 如果将偏移字段留空,工具将自动对齐分区. 如果为应用程序分区指定未对齐的偏移量,该工具将返回错误.</p>
<p>大小和偏移量可以指定为十进制数,带前缀 0x 的十六进制数,或大小乘数 K 或 M(1024 和 1024 * 1024 字节).</p>
<p>如果希望分区表中的分区与表本身的任何起始偏移量(<code>CONFIG_PARTITION_TABLE_OFFSET</code>)一起使用,请将所有分区的偏移字段(在 CSV 文件中)留空. 类似地,如果更改分区表偏移,则要注意所有空白分区偏移可能会更改为匹配,并且任何固定偏移现在可能与分区表冲突(导致错误).</p>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>目前仅支持一个加密的标志. 如果此字段设置为加密,则在启用 Flash 加密时将对此分区进行加密.</p>
<p>(请注意,无论是否设置此标志,应用程序类型分区都将始终加密.)</p>
<h2 id="生成二进制分区表"><a href="#生成二进制分区表" class="headerlink" title="生成二进制分区表"></a>生成二进制分区表</h2><p>下载到 ESP32 的分区表是二进制格式,而不是 CSV 格式. 工具 <code>partition_table/gen_esp32part.py</code> 用于在 CSV 和二进制格式之间进行转换.</p>
<p>如果在 <code>make menuconfig</code> 中配置分区表 CSV 名称,然后生成 <code>partition_table</code>,则此转换将在构建过程中完成.</p>
<p>要手动将 CSV 转换为二进制:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python gen_esp32part.py input_partitions.csv binary_partitions.bin</span><br></pre></td></tr></table></figure>
<p>要将二进制格式转换回 CSV:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python gen_esp32part.py binary_partitions.bin input_partitions.csv</span><br></pre></td></tr></table></figure>
<p>在 stdout 上显示二进制分区表的内容(这是生成 <code>make partition_table</code> 时显示的摘要的方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python gen_esp32part.py binary_partitions.bin</span><br></pre></td></tr></table></figure>

<h3 id="MD5-校验和"><a href="#MD5-校验和" class="headerlink" title="MD5 校验和"></a>MD5 校验和</h3><p>分区表的二进制格式包含基于分区表计算的 MD5 校验和. 此校验和用于在引导期间检查分区表的完整性.</p>
<p>可以通过 <code>gen_esp32part.py</code> 的 <code>--disable-md5sum</code> 选项或 <code>CONFIG_PARTITION_TABLE_MD5</code> 选项禁用 MD5 校验和生成. 例如,当使用传统引导加载程序无法处理 MD5 校验和且引导失败并且错误消息无效幻数 0xebeb 时,这很有用.</p>
<h2 id="烧录分区表"><a href="#烧录分区表" class="headerlink" title="烧录分区表"></a>烧录分区表</h2><ul>
<li><code>make partition_table-flash</code>:将使用 `esptool.py 下载分区表.</li>
<li><code>make flash</code>:会下载所有固件,包括分区表.</li>
</ul>
<p>手动下载命令也会打印在 <code>make partition_table</code> 中.</p>
<p>请注意,更新分区表不会擦除已根据旧分区表存储的数据. 您可以使用 <code>make erase_flash</code> (或 <code>esptool.py erase_flash</code>)来擦除整个闪存内容.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/partition-tables.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（九）ESP-IDF FreeRTOS SMP Changes</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B9%9D%EF%BC%89ESP-IDF%20FreeRTOS%20SMP%20Changes/</url>
    <content><![CDATA[<h1 id="ESP-IDF-FreeRTOS-SMP-Changes"><a href="#ESP-IDF-FreeRTOS-SMP-Changes" class="headerlink" title="ESP-IDF FreeRTOS SMP Changes"></a>ESP-IDF FreeRTOS SMP Changes</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>vanilla FreeRTOS 是设计运行在单核上. 但 ESP32 是双核的,包含 Protocol CPU (称为 <strong>CPU 0</strong> 或<strong>PRO_CPU</strong>)和 Application CPU (称为 <strong>CPU 1</strong> 或 <strong>APP_CPU</strong>). 这两个核实际上是相同的,并且共享相同的内存. 这允许任务在两个核之间交替运行.</p>
<p>ESP-IDF FreeRTOS 是 vanilla FreeRTOS 的修改版本,支持对称多处理 (SMP). ESP-IDF FreeRTOS 基于 FreeRTOS v8.2.0 的 Xtensa 端口. 本指南概述了 vanilla FreeRTOS 和 ESP-IDF FreeRTOS 之间的主要区别. 可以通过 <a href="http://www.freertos.org/a00106.html" target="_blank" rel="noopener">http://www.freertos.org/a00106.html</a> 找到 vanilla FreeRTOS 的 API 参考.</p>
<p>有关 ESP-IDF FreeRTOS 独有功能的信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/freertos_additions.html" target="_blank" rel="noopener">ESP-IDF FreeRTOS 附加功能</a>.</p>
<p><a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7">反向移植特性</a>:虽然 ESP-IDF FreeRTOS 基于 FreeRTOS v8.2.0 的 Xtensa 端口,但许多 FreeRTOS v9.0.0 功能已被移植到 ESP-IDF.</p>
<p><a href="#%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA">任务和任务创建</a>:使用 <code>xTaskCreatePinnedToCore()</code> 或 <code>xTaskCreateStaticPinnedToCore()</code> 在 ESP-IDF FreeRTOS 中创建任务.这两个函数的最后一个参数是 xCoreID.此参数指定任务运行在那个核上.  <strong>PRO_CPU</strong> 为 0, <strong>APP_CPU</strong> 为 1,或者 tskNO_AFFINITY 允许任务在两者上运行.</p>
<p>循环调度:ESP-IDF FreeRTOS 调度器将在 Ready 状态下具有相同优先级的多个任务之间实施循环调度时跳过任务.要避免此行为,请确保这些任务进入阻塞状态,或者分布在更广泛的优先级中.</p>
<p>挂起调度器:在 ESP-IDF 中挂起调度器 FreeRTOS 只会影响调用核上的调度器.换句话说,在 <strong>PRO_CPU</strong> 上调用 <code>vTaskSuspendAll()</code> 不会阻止 <strong>APP_CPU</strong> 进行调度,反之亦然.使用临界区或信号量代替同时访问保护.</p>
<p><a href="#%E6%BB%B4%E7%AD%94%E4%B8%AD%E6%96%AD%E5%90%8C%E6%AD%A5">滴答中断同步</a>:<strong>PRO_CPU</strong> 和 <strong>APP_CPU</strong> 的滴答中断不同步. 不要期望使用 <code>vTaskDelay()</code> 或 <code>vTaskDelayUntil()</code> 作为在两个核之间同步任务执行的准确方法. 使用计数信号量,因为它们的上下文切换不会因抢占而与滴答中断相关联.</p>
<p><a href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E7%A6%81%E7%94%A8%E4%B8%AD%E6%96%AD">临界区和禁用中断</a>:在 ESP-IDF FreeRTOS 中,临界区是使用互斥锁实现的.进入临界区涉及获取互斥锁,然后禁用调度器和调用核的中断.然而,另一个核不受影响.如果另一个核尝试使用相同的互斥锁,它将自旋直到调用核通过退出临界区释放互斥锁.</p>
<p><a href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97">浮点运算</a>:ESP32 支持单精度浮点运算 (<code>float</code>) 的硬件加速.然而,硬件加速的使用导致 ESP-IDF FreeRTOS 中的一些行为限制.因此,如果没有这样做,使用 float 的任务将自动固定到核.此外, float 不能用于中断服务程序.</p>
<p><a href="#%E4%BB%BB%E5%8A%A1%E5%88%A0%E9%99%A4">任务删除</a>:任务删除行为已从 FreeRTOS v9.0.0 反向移植并修改为 SMP 兼容.调用 <code>vTaskDelete()</code> 时,将立即释放任务内存,以删除当前未运行且未固定到其他核的任务.否则,释放任务存储器仍将被委托给空闲任务.</p>
<p><a href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%8C%87%E9%92%88%E5%92%8C%E5%88%A0%E9%99%A4%E5%9B%9E%E8%B0%83">线程本地存储指针和删除回调</a>:ESP-IDF FreeRTOS 已经反向移植了线程本地存储指针 (TLSP) 功能.但是,添加了删除回调的额外功能.在删除任务期间会自动调用删除回调,并用于释放 TLSP 指向的内存.调用 <code>vTaskSetThreadLocalStoragePointerAndDelCallback()</code> 来设置 TLSP 和删除回调.</p>
<p><a href="%E9%85%8D%E7%BD%AE-esp-idf-freertos">配置 ESP-IDF FreeRTOS</a>:可以使用 <code>make meunconfig</code> 配置 ESP-IDF FreeRTOS 的几个方面,例如在 Unicore 模式下运行 ESP-IDF,或配置每个任务将具有的线程本地存储指针的数量.</p>
<a id="more"></a>

<h2 id="反向移植特性"><a href="#反向移植特性" class="headerlink" title="反向移植特性"></a>反向移植特性</h2><p>以下功能已从 FreeRTOS v9.0.0 反向移植到 ESP-IDF.</p>
<h3 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h3><p>此特性已从 FreeRTOS v9.0.0 反向移植到 ESP-IDF. 必须在 menuconfig 中启用 <code>CONFIG_SUPPORT_STATIC_ALLOCATION</code> 选项才能使静态分配功能可用. 启用后,可以调用以下函数…</p>
<ul>
<li><code>xTaskCreateStatic()</code> (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li>
<li><code>xQueueCreateStatic</code></li>
<li><code>xSemaphoreCreateBinaryStatic</code></li>
<li><code>xSemaphoreCreateCountingStatic</code></li>
<li><code>xSemaphoreCreateMutexStatic</code></li>
<li><code>xSemaphoreCreateRecursiveMutexStatic</code></li>
<li><code>xTimerCreateStatic()</code> (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li>
<li><code>xEventGroupCreateStatic()</code></li>
</ul>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul>
<li><code>vTaskSetThreadLocalStoragePointer()</code>  (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li>
<li><code>pvTaskGetThreadLocalStoragePointer()</code>  (查看下面的<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95">反向移植记录</a>)</li>
<li><code>vTimerSetTimerID()</code></li>
<li><code>xTimerGetPeriod()</code></li>
<li><code>xTimerGetExpiryTime()</code></li>
<li><code>pcQueueGetName()</code></li>
<li><code>uxSemaphoreGetCount</code></li>
</ul>
<h3 id="反向移植记录"><a href="#反向移植记录" class="headerlink" title="反向移植记录"></a>反向移植记录</h3><ol>
<li><code>xTaskCreateStatic()</code> 以与 <code>xTaskCreate()</code> 类似的方式与 SMP 兼容(请参阅<a href="#%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA">任务和任务创建</a>). 因此也可以调用 <code>xTaskCreateStaticPinnedToCore()</code>.</li>
<li>尽管 vanilla FreeRTOS 允许静态分配 Timer 功能的守护进程任务,但守护进程任务总是在 ESP-IDF 中动态分配. 因此,在 ESP-IDF FreeRTOS 中使用静态分配的计时器时,不需要定义 <code>vApplicationGetTimerTaskMemory</code>.</li>
<li>在 ESP-IDF FreeRTOS 中修改了线程本地存储指针功能,以包括删除回调(请参阅<a href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%8C%87%E9%92%88%E5%92%8C%E5%88%A0%E9%99%A4%E5%9B%9E%E8%B0%83">线程本地存储指针和删除回调</a>). 因此,也可以调用函数 <code>vTaskSetThreadLocalStoragePointerAndDelCallback()</code>.</li>
</ol>
<h2 id="任务和任务创建"><a href="#任务和任务创建" class="headerlink" title="任务和任务创建"></a>任务和任务创建</h2><p>ESP-IDF FreeRTOS 中的任务设计为在特定核上运行,因此通过将 <code>PinnedToCore</code> 附加到 vanilla FreeRTOS 中的任务创建功能的名称,ESP-IDF FreeRTOS 中添加了两个新的任务创建功能. <code>xTaskCreate()</code> 和 <code>xTaskCreateStatic()</code> 的 vanilla FreeRTOS 函数导致在 ESP-IDF FreeRTOS 中添加了 <code>xTaskCreatePinnedToCore()</code> 和 <code>xTaskCreateStaticPinnedToCore()</code> (参见<a href="#%E5%8F%8D%E5%90%91%E7%A7%BB%E6%A4%8D%E7%89%B9%E6%80%A7">反向移植特性</a>).</p>
<p>有关更多详细信息,请参阅 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/freertos/task.c" target="_blank" rel="noopener">freertos/task.c</a></p>
<p>除了称为 <code>xCoreID</code> 的额外参数外,ESP-IDF FreeRTOS 任务创建功能几乎与它们的vanilla对应物相同. 此参数指定应在其上运行任务的核,并且可以是以下值之一.</p>
<ul>
<li><code>0</code> 将任务固定在 <strong>PRO_CPU</strong> 上运行</li>
<li><code>1</code> 将任务固定在 <strong>APP_CPU</strong> 上运行</li>
<li><code>tskNO_AFFINITY</code>允许在两个 CPU 上运行任务</li>
</ul>
<p>例如,<code>xTaskCreatePinnedToCore(tsk_callback,“APP_CPU Task”,1000,NULL,10,NULL,1)</code> 创建优先级为 10 的任务,该堆栈大小为 1000 字节运行在 <strong>APP_CPU</strong> 上. 应该注意的是,vanilla FreeRTOS 中的 <code>uxStackDepth</code> 参数根据字数指定任务的堆栈深度,而 ESP-IDF FreeRTOS 以字节的形式指定堆栈深度.</p>
<p>请注意,vanilla FreeRTOS函数 <code>xTaskCreate()</code> 和 <code>xTaskCreateStatic()</code> 已在 ESP-IDF FreeRTOS 中定义为内联函数,它们分别使用 tskNO_AFFINITY 作为 xCoreID 值调用 <code>xTaskCreatePinnedToCore()</code> 和 <code>xTaskCreateStaticPinnedToCore()</code>.</p>
<p>ESP-IDF 中的每个任务控制块 (TCB) 将 <code>xCoreID</code> 存储为成员. 因此,当每个核调用调度器选择要运行的任务时,<code>xCoreID</code> 成员将允许调度器确定是否允许让任务在调用调度器的核上运行.</p>
<h2 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h2><p>vanilla FreeRTOS 在 <code>vTaskSwitchContext()</code> 函数中实现调度. 此函数负责从处于就绪状态的任务列表中选择要执行的最高优先级任务,称为就绪任务列表(将在下一节中介绍). 在 ESP-IDF FreeRTOS 中,每个核将独立调用 <code>vTaskSwitchContext()</code>以从两个核之间共享的就绪任务列表中选择要运行的任务. vanilla 和 ESP-IDF FreeRTOS 之间的调度行为存在一些差异,例如 循环调度调度,调度程序暂停和滴答中断同步的差异.</p>
<h3 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h3><p>鉴于 Ready 状态和优先级相同的多个任务,vanilla FreeRTOS 在每个任务之间实现循环调度. 这将导致每次调用调度程序时轮流运行这些任务(例如每个滴答中断). 另一方面,当循环调度具有相同优先级的多个 Ready 状态任务时,ESP-IDF FreeRTOS 调度器可以跳过任务.</p>
<p>循环调度期间跳过任务的问题源于在 FreeRTOS 中实现就绪任务列表的方式. 在 vanilla FreeRTOS 中,<code>pxReadyTasksList</code> 用于存储处于 Ready 状态的任务列表. 该列表实现为长度为 <code>configMAX_PRIORITIES</code> 的数组,其中数组的每个元素都是链表. 每个链表都是 <code>List_t</code> 类型,并包含处于 Ready 状态的相同优先级任务的 TCB. 下图说明了 <code>pxReadyTasksList</code> 结构.</p>
<p><img src="https://img-blog.csdn.net/20180902140458206?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="pxReadyTasksList"><br> <center> Illustration of FreeRTOS Ready Task List Data Structure</center></p>
<p>每个链表还包含一个 <code>pxIndex</code>,它指向查询列表时返回的最后一个 TCB. 该索引允许 <code>vTaskSwitchContext()</code> 在 <code>pxIndex</code> 之后立即开始遍历 TCB 上的列表,从而在相同优先级的任务之间实现循环调度.</p>
<p>在 ESP-IDF FreeRTOS 中,就绪任务列表在核之间共享,因此 <code>pxReadyTasksList</code> 将包含固定到不同核的任务. 当核调用调度程序时,它能够查看列表中每个 TCB 的 <code>xCoreID</code> 成员,以确定是否允许在调用调度程序的核上运行该任务. ESP-IDF FreeRTOS <code>pxReadyTasksList</code> 如下图所示.</p>
<p><img src="https://img-blog.csdn.net/20180902140927284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Illustration of FreeRTOS Ready Task List Data Structure in ESP-IDF"><br> <center> Illustration of FreeRTOS Ready Task List Data Structure in ESP-IDF </center> </p>
<p>因此,当 <strong>PRO_CPU</strong> 调用调度程序时,它只会将任务视为蓝色或紫色. 而当 <strong>APP_CPU</strong> 调用调度程序时,它只会考虑橙色或紫色的任务.</p>
<p>虽然每个 TCB 在 ESP-IDF FreeRTOS 中都有一个 <code>xCoreID</code>,但每个优先级的链表只有一个 <code>pxIndex</code>. 因此,当从特定核调用调度程序并遍历链接列表时,它将跳过固定到另一个核的所有 TCB,并将 <code>pxIndex</code> 指向所选任务. 如果另一个核接着调用调度程序,它将在 <code>pxIndex</code> 之后立即遍历从 TCB 开始的链表. 因此,<strong>在当前调度程序调用中不会考虑从由其他核先前调用调度程序跳过的 TCB</strong>. 下图说明了此问题.</p>
<p><img src="https://img-blog.csdn.net/20180902141125129?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Illustration of pxIndex behavior in ESP-IDF FreeRTOS"><br> <center>Illustration of pxIndex behavior in ESP-IDF FreeRTOS </center></p>
<p>参考上面的图示,假设优先级 9 是最高优先级,并且优先级9中的任何任务都不会被阻塞,因此将始终处于运行或就绪状态.</p>
<ol>
<li><strong>PRO_CPU</strong> 调用调度程序并选择要运行的任务 A,因此将 <code>pxIndex</code> 移动到指向任务 A.</li>
<li><strong>APP_CPU</strong> 调用调度程序并在作为任务 B 的 <code>pxIndex</code> 之后开始遍历任务.但是没有选择任务 B 运行,因为它没有固定到 <strong>APP_CPU</strong> 因此它被跳过并且选择了任务 C.  <code>pxIndex</code> 现在指向任务 C.</li>
<li><strong>PRO_CPU</strong> 调用调度程序并开始从任务 D 开始遍历.它跳过任务 D 并选择任务 E 运行并将 <code>pxIndex</code> 指向任务 E.请注意,任务 B 未被遍历,因为最后一次 <strong>APP_CPU</strong> 调用调度程序时它被跳过遍历清单.</li>
<li>如果 <strong>APP_CPU</strong> 再次调用调度程序,则会发生与任务 D 相同的情况,因为 <code>pxIndex</code> 现在指向任务E</li>
</ol>
<p>任务跳过问题的一个解决方案是确保每个任务都进入阻塞状态,以便从就绪任务列表中删除它们.另一种解决方案是跨多个优先级分配任务,以便不给予给定优先级多个固定到不同核的任务.</p>
<h3 id="挂起调度器"><a href="#挂起调度器" class="headerlink" title="挂起调度器"></a>挂起调度器</h3><p>在 vanilla FreeRTOS 中,通过 <code>vTaskSuspendAll()</code> 挂起调度程序将阻止 <code>vTaskSwitchContext</code> 从上下文切换调用,直到调度程序已使用 <code>xTaskResumeAll()</code> 恢复.但是仍然允许为 ISR 提供服务.因此,在恢复调度程序之前,将不会执行由当前正在运行的任务或 ISRS 导致的任务状态的任何更改. vanilla FreeRTOS 中的调度程序暂停是一种常见的保护方法,可以同时访问任务之间共享的数据,同时仍允许对 ISR 进行服务.</p>
<p>在 ESP-IDF FreeRTOS 中,<code>xTaskResumeAll()</code> 只会阻止调用 <code>vTaskSwitchContext()</code> 来切换调用挂起的核上下文.因此,如果 <strong>PRO_CPU</strong> 调用 <code>vTaskSuspendAll()</code>, <strong>APP_CPU</strong> 仍然可以切换上下文.如果数据在固定到不同核的任务之间共享,则调度程序暂停不是防止同时访问的有效方法.在保护 ESP-IDF FreeRTOS 中的共享资源时,请考虑使用关键部分(禁用中断)或信号量(不禁用中断).</p>
<p>通常,最好使用其他 RTOS 原语(如互斥信号量)来防止任务之间共享的数据,而不是 <code>vTaskSuspendAll()</code>.</p>
<h3 id="滴答中断同步"><a href="#滴答中断同步" class="headerlink" title="滴答中断同步"></a>滴答中断同步</h3><p>在 ESP-IDF FreeRTOS 中,由于来自每个核的调度程序调用是独立的,因此在相同的滴答计数上取消阻塞的不同核上的任务可能不会在完全相同的时间运行,并且每个核的滴答中断是不同步的.</p>
<p>在 vanilla FreeRTOS 中,滴答中断触发对 <code>xTaskIncrementTick()</code> 的调用,该调用负责增加滴答计数器,检查调用 <code>vTaskDelay()</code> 的任务是否已经完成延迟时间,并将这些任务从 Delayed Task List 移动​​到 Ready Task 名单.如果需要上下文切换,则滴答中断将调用调度程序.</p>
<p>在 ESP-IDF FreeRTOS 中,由于 <strong>PRO_CPU</strong> 负责增加共享滴答计数,因此参考 <strong>PRO_CPU</strong> 上的滴答中断来解除延迟任务的阻塞.但是,每个核的滴答中断可能不会同步(频率相同但异相),因此当 <strong>PRO_CPU</strong> 收到滴答中断时, <strong>APP_CPU</strong> 可能尚未收到它.因此,如果相同优先级的多个任务在相同的滴答计数上被解除阻塞,则固定到 <strong>PRO_CPU</strong> 的任务将立即运行,而固定到 <strong>APP_CPU</strong> 的任务必须等到 <strong>APP_CPU</strong> 收到其不同步滴答中断.收到滴答中断后, <strong>APP_CPU</strong> 将调用上下文切换,最后将上下文切换到新解锁的任务.</p>
<p>因此,不应将任务延迟用作 ESP-IDF FreeRTOS 中任务之间的同步方法.相反,请考虑使用计数信号量同时取消阻止多个任务.</p>
<h2 id="临界区和禁用中断"><a href="#临界区和禁用中断" class="headerlink" title="临界区和禁用中断"></a>临界区和禁用中断</h2><p>Vanilla FreeRTOS 在 <code>vTaskEnterCritical</code> 中实现了关键部分,它们禁用调度程序并调用 <code>portDISABLE_INTERRUPTS</code>.这可以防止在关键部分中进行上下文切换和ISR服务.因此,关键部分被用作防止 vanilla FreeRTOS 同时访问的有效保护方法.</p>
<p>另一方面, ESP32 没有内核的硬件方法来禁用彼此的中断.调用 <code>portDISABLE_INTERRUPTS()</code> 对其他内核的中断没有影响.因此,禁用中断不是防止同时访问共享数据的有效保护方法,因为即使当前内核已禁用其自身的中断,它也会使其他内核可以自由访问数据.</p>
<p>因此, ESP-IDF FreeRTOS 使用互斥锁实现关键部分,进入或退出关键部分的调用必须提供与需要访问保护的共享资源相关联的互斥锁.当进入 ESP-IDF FreeRTOS 中的关键部分时,调用内核将禁用其调度程序和中断,类似于 vanilla FreeRTOS 实现.但是,调用核也将使用互斥锁,而另一个核在关键部分不受影响.如果另一个核尝试使用相同的互斥锁,它将旋转直到释放互斥锁.因此,关键部分的 ESP-IDF FreeRTOS 实现允许核具有对共享资源的受保护访问,而不会禁用其他核.另一个核只有在尝试同时访问同一资源时才会受到影响.</p>
<p>ESP-IDF FreeRTOS 关键部分功能已经修改如下……</p>
<ul>
<li><code>taskENTER_CRITICAL(mux)</code>,<code>taskENTER_CRITICAL_ISR(mux)</code>,<code>portENTER_CRITICAL(mux)</code>,<code>portENTER_CRITICAL_ISR(mux)</code> 都是宏定义来调用 <code>vTaskEnterCritical()</code></li>
<li><code>taskEXIT_CRITICAL(mux)</code>,<code>taskEXIT_CRITICAL_ISR(mux)</code>,<code>portEXIT_CRITICAL(mux)</code>,<code>portEXIT_CRITICAL_ISR(mux)</code> 都是宏定义来调用 <code>vTaskExitCritical()</code></li>
</ul>
<p>有关更多详细信息,请参阅 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/freertos/include/freertos/portmacro.h" target="_blank" rel="noopener">freertos/include/freertos/portmacro.h</a> 和 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/freertos/task.c" target="_blank" rel="noopener">freertos/task.c</a></p>
<p>应该注意的是,当修改 vanilla FreeRTOS 代码与 ESP-IDF FreeRTOS 兼容时,修改关键部分的类型是微不足道的,因为它们都被定义为调用相同的函数.只要在进入和退出时提供相同的互斥锁,呼叫类型就无关紧要了.</p>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><p>ESP32 通过连接到每个内核的浮点单元 (FPU,也称为协处理器)支持单精度浮点运算 (<code>float</code>) 的硬件加速.使用 FPU 对 ESP-IDF FreeRTOS 施加了一些行为限制.</p>
<p>ESP-IDF FreeRTOS 为 FPU 实现了延迟上下文切换.换句话说,当发生上下文切换时,不会立即保存核心 FPU 寄存器的状态.因此,利用 <code>float</code> 的任务必须在创建时固定到特定的核心.如果没有, ESP-IDF FreeRTOS 会自动将有问题的任务固定到任务首次使用 <code>float</code> 任务的任何核心上.同样由于惰性上下文切换,中断服务例程也必须不使用 <code>float</code>.</p>
<p>ESP32 不支持双精度浮点运算 (<code>double</code>) 的硬件加速.相反, <code>double</code> 是通过软件实现的,因此关于 <code>float</code> 的行为限制不适用于 <code>double</code>.请注意,由于缺少硬件加速,与 <code>float</code> 相比,双重操作可能会消耗更多的 CPU 时间.</p>
<h2 id="任务删除"><a href="#任务删除" class="headerlink" title="任务删除"></a>任务删除</h2><p>在 v9.0.0 之前删除 FreeRTOS 任务将任务内存的释放完全委托给空闲任务. 目前,如果正在删除的任务当前没有运行或没有固定到另一个核心(相对于核心 <code>vTaskDelete()</code> 被调用),任务内存的释放将立即发生(在 <code>vTaskDelete()</code> 内). 如果满足相同的条件,TLSP删除回调也将立即运行.</p>
<p>但是,调用 <code>vTaskDelete()</code> 来删除当前正在运行或固定到另一个核心的任务仍将导致释放被委派给空闲任务的内存.</p>
<h2 id="线程本地存储指针和删除回调"><a href="#线程本地存储指针和删除回调" class="headerlink" title="线程本地存储指针和删除回调"></a>线程本地存储指针和删除回调</h2><p>线程本地存储指针 (TLSP) 是直接存储在 TCB 中的指针. TLSP 允许每个任务拥有自己唯一的数据结构指针集.但是, vanilla FreeRTOS 中的任务删除行为不会自动释放 TLSP 指向的内存.因此,如果在删除任务之前用户未明确释放 TLSP 指向的内存,则会发生内存泄漏.</p>
<p>ESP-IDF FreeRTOS 提供了 Deletion Callbacks 的附加功能.删除任务删除期间自动调用回调以释放 TLSP 指向的内存.每个 TLSP 都可以拥有自己的 Deletion Callback.请注意,由于 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/freertos-smp.html#task-deletion" target="_blank" rel="noopener">Task Deletion</a> 行为,可能存在在空闲任务的上下文中调用 Deletion Callbacks 的实例.因此,删除回调不应该试图阻止,并且关键部分应该尽可能短,以最小化优先级倒置.</p>
<p>删除回调的类型为 <code>void(* TlsDeleteCallbackFunction_t)(int,void *)</code>,其中第一个参数是关联 TLSP 的索引号,第二个参数是 TLSP 本身.</p>
<p>通过调用 <code>vTaskSetThreadLocalStoragePointerAndDelCallback()</code> 将删除回调与 TLSP 一起设置.调用 vanilla FreeRTOS 函数 <code>vTaskSetThreadLocalStoragePointer()</code> 只会将 TLSP 关联的 Deletion Callback 设置为 NULL,这意味着在删除任务期间不会为该 TLSP 调用回调.如果删除回调为 NULL,则用户应在删除任务之前手动释放相关 TLSP 指向的内存,以避免内存泄漏.</p>
<p>menuconfig 中的 <code>CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS</code> 可用于配置TCB将具有的 TLSP 和删除回调数.</p>
<p>有关更多详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/freertos.html" target="_blank" rel="noopener">FreeRTOS API 参考</a>.</p>
<h2 id="配置-ESP-IDF-FreeRTOS"><a href="#配置-ESP-IDF-FreeRTOS" class="headerlink" title="配置 ESP-IDF FreeRTOS"></a>配置 ESP-IDF FreeRTOS</h2><p>可以使用 <code>Component_Config/FreeRTOS</code> 下的 <code>make menuconfig</code> 配置 ESP-IDF FreeRTOS. 以下部分重点介绍了一些 ESP-IDF FreeRTOS 配置选项.有关 ESP-IDF FreeRTOS 配置的完整列表,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/kconfig.html" target="_blank" rel="noopener">FreeRTOS</a></p>
<p><code>CONFIG_FREERTOS_UNICORE</code> 将仅在 <strong>PRO_CPU</strong> 上运行 ESP-IDF FreeRTOS.请注意,这不等于运行 vanilla FreeRTOS.将修改 ESP-IDF 中多个组件的行为,例如 <a href="https://github.com/espressif/esp-idf/blob/a557e8c/components/esp32/cpu_start.c" target="_blank" rel="noopener">esp32/cpu_start.c</a>.有关在单核上运行 ESP-IDF FreeRTOS 的效果的更多详细信息,请在 ESP-IDF 组件中搜索 <code>CONFIG_FREERTOS_UNICORE</code> 的出现.</p>
<p><code>CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS</code> 将定义每个任务在 ESP-IDF FreeRTOS 中将具有的线程本地存储指针的数量.</p>
<p><code>CONFIG_SUPPORT_STATIC_ALLOCATION</code> 将在 ESP-IDF FreeRTOS 中启用 <code>xTaskCreateStaticPinnedToCore()</code> 的反向移植功能</p>
<p><code>CONFIG_FREERTOS_ASSERT_ON_UNTESTED_FUNCTION</code> 将触发 ESP-IDF FreeRTOS 中特定功能的暂停,这些功能尚未在 SMP 上下文中进行全面测试.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/freertos-smp.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（二）构建系统</title>
    <url>/InfiniteYuanBlog/2018/07/22/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h1><p>本文档解释了 Espressif 物联网开发框架构建系统和“组件”的概念.</p>
<p>如果您想知道如何组织新的 <code>ESP-IDF</code> 项目,请阅读本文档.</p>
<p>我们建议使用 <a href="https://github.com/espressif/esp-idf-template" target="_blank" rel="noopener">esp-idf-template</a> 项目作为项目的起点.</p>
<a id="more"></a>

<h2 id="使用构建系统"><a href="#使用构建系统" class="headerlink" title="使用构建系统"></a>使用构建系统</h2><p>esp-idf 中的 <code>README</code> 文件有如何使用构建系统构建项目的说明.</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>一个 <code>ESP-IDF</code> 项目可以看作是多个组件的组合.例如,对于显示当前湿度的网络服务器,可能有:</p>
<ul>
<li>ESP32 基础库( libc,rom bindings 等)</li>
<li>WiFi 驱动</li>
<li>TCP / IP 协议堆栈</li>
<li>FreeRTOS 操作系统</li>
<li>Web 服务器</li>
<li>湿度传感器驱动</li>
<li>主程序</li>
</ul>
<p><code>ESP-IDF</code> 使这些组件结构更清晰并具有可配置性.为此,在编译项目时,构建环境将查找 <code>ESP-IDF</code> 目录、项目目录和(可选)其他自定义组件目录中的所有组件.之后,它允许用户使用基于文本的菜单系统去自定义每个组件来配置 <code>ESP-IDF</code> 项目.在配置完项目中的组件之后,构建程序将编译项目.</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>“项目”是一个目录,其中包含构建单个 “app” (可执行文件)所需的文件和配置,以及其他附加文件,如:分区表,数据/文件系统分区和引导程序.</li>
<li>“项目配置”保存在项目根目录中的 <code>sdkconfig</code>  文件中.通过 <code>make menuconfig</code> 修改此文件以自定义项目配置.单个项目只包含一个项目配置.</li>
<li>“app” 是由 esp-idf 构建的可执行文件.单个项目通常会构建两个应用程序 - 一个“项目应用程序”(主要可执行文件,即您的自定义固件)和一个“引导程序”(启动项目应用程序的初始引导程序).</li>
<li>“组件”是独立代码的模块化部分,它们被编译成静态库(.a文件)并链接到应用程序.有些是由 esp-idf 本身提供的,有些则可能来自其他地方.</li>
</ul>
<p>有些东西不是项目的一部分:</p>
<ul>
<li>“ESP-IDF” 不是该项目的一部分.相反,它是独立的,并通过 <code>IDF_PATH</code> 环境变量链接到项目,该变量保存 <code>esp-idf</code> 目录的路径.这允许 IDF 框架与您的项目分离.</li>
<li>用于编译的工具链不是项目的一部分.工具链应安装在系统命令行 <code>PATH</code> 中,或者工具链的路径设置为项目配置中编译器前缀的一部分.</li>
</ul>
<h3 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h3><p>一个示例项目目录结构可能如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- myProject&#x2F;</span><br><span class="line">            - Makefile</span><br><span class="line">            - sdkconfig</span><br><span class="line">            - components&#x2F; - component1&#x2F; - component.mk</span><br><span class="line">                                        - Kconfig</span><br><span class="line">                                        - src1.c</span><br><span class="line">                          - component2&#x2F; - component.mk</span><br><span class="line">                                        - Kconfig</span><br><span class="line">                                        - src1.c</span><br><span class="line">                                        - include&#x2F; - component2.h</span><br><span class="line">            - main&#x2F;       - src1.c</span><br><span class="line">                          - src2.c</span><br><span class="line">                          - component.mk</span><br><span class="line"></span><br><span class="line">            - build&#x2F;</span><br></pre></td></tr></table></figure>
<p>“myProject” 示例包含以下元素:</p>
<ul>
<li>顶层项目 Makefile .此 Makefile 设置 <code>PROJECT_NAME</code> 变量,并(可选)定义项目范围的 make 变量.它包括核心的 <code>$(IDF_PATH)/make/project.mk</code> Makefile 文件,它实现了 <code>ESP-IDF</code> 构建系统的其余部分.</li>
<li>“sdkconfig” 项目配置文件.当 “make menuconfig” 运行时,将创建/更新此文件,并保存项目中所有组件的配置(包括 esp-idf 本身).“sdkconfig” 文件可能会也可能不会添加到项目的源代码管理系统中.</li>
<li>可选的 “components” 目录包含属于项目一部分的组件.项目不必包含此类自定义组件,但它可用于构造可重用代码或包括不属于 ESP-IDF 的第三方组件.</li>
<li>“main” 目录是一个特殊的“伪组件(pseudo-component)”,它包含项目本身的源代码.“main” 是默认名称,Makefile 变量<code>COMPONENT_DIRS</code>包含此组件,但您可以修改此变量(或设置 <code>EXTRA_COMPONENT_DIRS</code>)以查找其他位置的组件.</li>
<li>“build” 目录是项目编译时创建的,包含项目编译时产生的文件.运行 make 后,该目录被创建,并包含临时目标文件和库以及最终的二进制输出文件 <code>bin</code>.此目录通常不会添加到源代码管理中,也不会随项目源代码一起发布.</li>
</ul>
<p>组件目录包含一个组件 makefile 文件 - <code>component.mk</code>.这可能包含变量定义,以控制组件的构建过程,以及它与整个项目的集成.有关更多详细信息,请参阅[组件Makefile](#组件 Makefile).</p>
<p>每个组件还可以包括一个 <code>Kconfig</code> 文件,用于定义通过项目配置设置的组件配置选项.某些组件还可能包含 <code>Kconfig.projbuild</code> 和 <code>Makefile.projbuild</code> 文件,这些文件是用于覆盖项目部分的特殊文件.</p>
<h3 id="项目-Makefile"><a href="#项目-Makefile" class="headerlink" title="项目 Makefile"></a>项目 Makefile</h3><p>每个项目都有一个 Makefile,其中包含整个项目的构建配置.默认情况下,项目 Makefile 可以非常小.</p>
<h4 id="最小示例-Makefile"><a href="#最小示例-Makefile" class="headerlink" title="最小示例 Makefile"></a>最小示例 Makefile</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROJECT_NAME :&#x3D; myProject</span><br><span class="line"></span><br><span class="line">include $(IDF_PATH)&#x2F;make&#x2F;project.mk</span><br></pre></td></tr></table></figure>

<h4 id="强制项目变量"><a href="#强制项目变量" class="headerlink" title="强制项目变量"></a>强制项目变量</h4><ul>
<li>PROJECT_NAME:项目名称.二进制输出文件将使用此名称 - 即 myProject.bin, myProject.elf.</li>
</ul>
<h4 id="可选项目变量"><a href="#可选项目变量" class="headerlink" title="可选项目变量"></a>可选项目变量</h4><p>这些变量都有默认值,并可以被自定义操作覆盖.查看 <code>make/project.mk</code> 以获取所有实现细节.</p>
<ul>
<li><code>PROJECT_PATH</code>:顶级项目目录.默认为包含 Makefile 的目录.许多其他项目变量都基于此变量.项目路径不能包含空格.</li>
<li><code>BUILD_DIR_BASE</code>:所有 objects/libraries/binaries 文件的构建输出目录.默认为<code>$(PROJECT_PATH)/build</code>.</li>
<li><code>COMPONENT_DIRS</code>:搜索组件的目录.默认为<code>$(IDF_PATH)/components</code>( idf 组件),<code>$(PROJECT_PATH)/components</code>(项目组件),<code>$(PROJECT_PATH)/main</code> 和 <code>EXTRA_COMPONENT_DIRS</code> (其他组件).如果您不想在这些位置搜索组件,请覆盖此变量.</li>
<li><code>EXTRA_COMPONENT_DIRS</code>:用于搜索组件的其他目录的可选列表.</li>
<li><code>COMPONENTS</code>:要构建到项目中的组件名称列表.默认为<code>COMPONENT_DIRS</code>目录中的所有组件.</li>
<li><code>EXCLUDE_COMPONENTS</code>:在构建过程中要排除的组件名称的可选列表.请注意,这会减少构建时间,但不会减少二进制大小.</li>
<li><code>TEST_EXCLUDE_COMPONENTS</code>:在单元测试的构建过程中要排除的可选组件名称列表.</li>
</ul>
<p>这些 Makefile 变量中的任何路径都应该是绝对路径.您可以使用<code>$(PROJECT_PATH)/ xxx</code>,<code>$(IDF_PATH)/ xxx</code>转换相对路径,或使用 Make 函数<code>$(abspath xxx)</code>.</p>
<p>这些都变量应该在 Makefile 中的 <code>include $(IDF_PATH)/make/project.mk</code> 行之前设置.</p>
<h3 id="组件-Makefile"><a href="#组件-Makefile" class="headerlink" title="组件 Makefile"></a>组件 Makefile</h3><p>每个项目都包含一个或多个组件,这些组件可以是 esp-idf 的一部分,也可以从其他组件目录添加.</p>
<p>组件是包含 <code>component.mk</code> 文件的任何目录.</p>
<h3 id="搜索组件"><a href="#搜索组件" class="headerlink" title="搜索组件"></a>搜索组件</h3><p>在<code>COMPONENT_DIRS</code>中的目录列表中搜索项目的组件.此列表中的目录可以是组件本身(即它们包含 <code>component.mk</code> 文件),也可以是子目录为组件的顶级目录(包含组件的目录).</p>
<p>运行 <code>make list-components</code> 后,会输出这些变量,这可以帮助调试组件目录是否被找到.</p>
<h4 id="具有相同名称的多个组件"><a href="#具有相同名称的多个组件" class="headerlink" title="具有相同名称的多个组件"></a>具有相同名称的多个组件</h4><p>当 esp-idf 找到所有要编译的组件时,它将按照 <code>COMPONENT_DIRS</code> 指定的顺序执行此操作; 默认情况下,首先是 idf 组件,第二个是项目组件,最后是 <code>EXTRA_COMPONENT_DIRS</code> 中的组件.如果这些目录中的两个或多个包含具有相同名称的组件子目录,则使用搜索的最后一个位置中的组件.例如,这允许通过简单地将组件从 esp-idf 组件目录复制到项目组件树然后在那里修改它来覆盖具有修改版本的 esp-idf 组件.如果以这种方式使用,esp-idf 目录本身可以保持不变.</p>
<h4 id="最小组件-Makefile"><a href="#最小组件-Makefile" class="headerlink" title="最小组件 Makefile"></a>最小组件 Makefile</h4><p>最小的 <code>component.mk</code> 文件是一个空文件.如果文件为空,则设置默认组件行为:</p>
<ul>
<li>与 makefile 在相同的目录中的所有源文件(<code>*.c</code>,<code>*.cpp</code>,<code>*.cc</code>,<code>*.S</code>)将被编译到组件库中</li>
<li>子目录 “include” 将被添加到所有其他组件的全局 include 搜索路径中.</li>
<li>组件库将链接到项目应用程序中.</li>
</ul>
<p>有关更完整的示例组件 makefile,请参阅[示例组件 makefile](#示例组件 Makefile).</p>
<p>请注意,空的 <code>component.mk</code> 文件(调用默认组件构建行为)和没有 <code>component.mk</code> 文件(这意味着不会发生默认组件构建行为)之间存在差异.组件可能没有 <code>component.mk</code> 文件,如果它只包含影响项目配置或构建过程的其他文件.</p>
<h4 id="预设组件变量"><a href="#预设组件变量" class="headerlink" title="预设组件变量"></a>预设组件变量</h4><p>以下特定组件的变量可在<code>component.mk</code>中使用,但不应修改:</p>
<ul>
<li><code>COMPONENT_PATH</code>:组件目录.计算包含 <code>component.mk</code> 的目录的绝对路径.组件路径不能包含空格.</li>
<li><code>COMPONENT_NAME</code>:组件的名称.默认为组件目录的名称.</li>
<li><code>COMPONENT_BUILD_DIR</code>:组件构建目录.计算 <code>$(BUILD_DIR_BASE)</code> 中要构建此组件源文件的目录的绝对路径.每次构建组件时,这也是当前工作目录,因此 make 等目标中的相对路径都是相对于此目录.</li>
<li><code>COMPONENT_LIBRARY</code>:将为此组件构建的静态库文件的名称(相对于组件构建目录).默认为 <code>$(COMPONENT_NAME).a</code>.</li>
</ul>
<p>以下变量在项目级别设置,但会导出在组件构建中使用:</p>
<ul>
<li><code>PROJECT_NAME</code>:项目名称,在项目 Makefile 中设置</li>
<li><code>PROJECT_PATH</code>:包含项目 Makefile 的项目目录的绝对路径.</li>
<li><code>COMPONENTS</code>:此构建中包含的所有组件的名称.</li>
<li><code>CONFIG_ *</code>:项目配置中的每个值都有一个 make 中可用的对应变量.所有名称都以 <code>CONFIG_</code> 开头.</li>
<li><code>CC</code>,<code>LD</code>,<code>AR</code>,<code>OBJCOPY</code>:gcc xtensa 交叉工具链中每个工具的完整路径.</li>
<li><code>HOSTCC</code>,<code>HOSTLD</code>,<code>HOSTAR</code>:来自主机本机工具链的每个工具的全名.</li>
<li><code>IDF_VER</code>:ESP-IDF 版本,使用 git 命令 <code>git describe</code> 从 <code>$(IDF_PATH)/version.txt</code> 文件(如果存在)中检索.这里推荐的格式是单独的一行指定主要 IDF 发布版本,例如标记版本的 <code>v2.0</code> 或任意提交的 <code>v2.0-275-g0efaa4f</code>.应用程序可以通过调用 <code>esp_get_idf_version()</code> 来使用它.</li>
<li><code>PROJECT_VER</code>: 项目版本<ul>
<li>如果 <code>PROJECT_VER</code> 变量在项目 Makefile 文件中设置，则将使用其值。</li>
<li>否则，如果 <code>$PROJECT_PATH/version.txt</code> 存在，其内容将用作 <code>PROJECT_VER</code>。</li>
<li>否则，如果项目位于 Git 存储库中，则将使用git describe的输出。</li>
<li>否则，<code>PROJECT_VER</code> 将为“1”。</li>
</ul>
</li>
</ul>
<p>如果您修改 <code>component.mk</code> 中的任何这些变量,那么这不会阻止构建其他组件,但它可能使您的组件难以构建或者调试.</p>
<h4 id="可选项目范围的组件变量"><a href="#可选项目范围的组件变量" class="headerlink" title="可选项目范围的组件变量"></a>可选项目范围的组件变量</h4><p>可以在 <code>component.mk</code> 中设置以下变量来控制整个项目中的构建设置:</p>
<ul>
<li><code>COMPONENT_ADD_INCLUDEDIRS</code>:相对于组件目录的路径,将添加到项目中所有组件的 “include” 搜索路径.如果未被覆盖,则默认<code>include</code>.如果仅需要编译此特定组件的 “include” 目录,请将其添加到 <code>COMPONENT_PRIV_INCLUDEDIRS</code></li>
<li><code>COMPONENT_ADD_LDFLAGS</code>:为 LDFLAGS 添加链接器参数以用于应用程序可执行文件.默认为 <code>-l$(COMPONENT_NAME)</code>.如果将预编译库添加到此目录,请将它们添加为绝对路径 <code>-e$(COMPONENT_PATH)/libwhatever.a</code></li>
<li><code>COMPONENT_DEPENDS</code>:应在此组件之前编译的组件名称的可选列表.对于链接时依赖性,这不是必需的,因为所有组件”include”目录始终可用.如果一个组件生成一个”include”文件,然后您想要包含在另一个组件中,则这是必要的.大多数组件不需要设置此变量.</li>
<li><code>COMPONENT_ADD_LINKER_DEPS</code>:相对组件路径的文件的可选列表，如果它们发生更改，应触发 ELF 文件的重新链接。 通常用于链接描述文件和二进制库。大多数组件不需要设置此变量。</li>
</ul>
<p>以下变量仅适用于属于 esp-idf 本身的组件:</p>
<ul>
<li><code>COMPONENT_SUBMODULES</code>:组件使用的 git 子模块路径(相对于 COMPONENT_PATH)的可选列表.这些将由构建过程检查(并在必要时初始化).如果组件位于 IDF_PATH 目录之外,则忽略此变量.</li>
</ul>
<h4 id="可选特定的组件变量"><a href="#可选特定的组件变量" class="headerlink" title="可选特定的组件变量"></a>可选特定的组件变量</h4><p>可以在<code>component.mk</code>中设置以下变量来控制该组件的构建:</p>
<ul>
<li><code>COMPONENT_PRIV_INCLUDEDIRS</code>:目录路径,必须相对于组件目录,该组件目录将仅添加到此组件源文件的”include”搜索路径中.</li>
<li><code>COMPONENT_EXTRA_INCLUDES</code>:编译组件源文件时使用的任何额外包含路径.这些将以’-I’为前缀,并按原样传递给编译器.与<code>COMPONENT_PRIV_INCLUDEDIRS</code>变量类似,但这些路径不会相对于组件目录进行扩展.</li>
<li><code>COMPONENT_SRCDIRS</code>:目录路径,必须相对于组件目录,将用以搜索源文件(<code>* .cpp</code>,<code>* .c</code>,<code>* .S</code>).默认为’.’,即组件目录本身.覆盖它以指定包含源文件的不同目录列表.</li>
<li><code>COMPONENT_OBJS</code>:要编译的对象文件.默认值是<code>COMPONENT_SRCDIRS</code>中找到的每个源文件的 a.o 文件.覆盖此列表允许您排除<code>COMPONENT_SRCDIRS</code>中的源文件,否则将被编译.请参阅指定源文件</li>
<li><code>COMPONENT_EXTRA_CLEAN</code>:相对于组件构建目录的路径,使用<code>component.mk</code>文件中的自定义make规则生成的任何文件,以及作为make clean的一部分需要删除的文件.有关示例,请参阅<a href="#_428">源代码生成</a>.</li>
<li><code>COMPONENT_OWNBUILDTARGET</code>＆<code>COMPONENT_OWNCLEANTARGET</code>:这些目标允许您完全覆盖组件的默认构建行为.有关详细信息,请参阅[完全覆盖组件 Makefile](#完全覆盖组件 Makefile).</li>
<li><code>COMPONENT_CONFIG_ONLY</code>:如果设置,则此标志指示组件根本不生成任何内置输出(即未构建 <code>COMPONENT_LIBRARY</code>),并忽略大多数其他组件变量.此标志用于 IDF 内部组件,其中仅包含 KConfig.projbuild 和/或 Makefile.projbuild 文件以配置项目,但没有源文件.</li>
<li><code>CFLAGS</code>:传递给 C 编译器的标志.根据项目设置定义一组默认 <code>CFLAGS</code>.可以通过 <code>CFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li>
<li><code>CPPFLAGS</code>:传递给 C 预处理器的标志(用于. c , .cpp 和 .S 文件).根据项目设置定义一组默认的 <code>CPPFLAGS</code>.可以通过 <code>CPPFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li>
<li><code>CXXFLAGS</code>:传递给 C++ 编译器的标志.根据项目设置定义一组默认的 <code>CXXFLAGS</code>.可以通过 <code>CXXFLAGS +=</code> 进行组件特定的添加.也可以(尽管不推荐)完全覆盖该组件的变量.</li>
</ul>
<p>要将编译标志应用于单个源文件,可以将变量覆盖添加为目标,即:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apps&#x2F;dhcpserver.o: CFLAGS +&#x3D; -Wno-unused-variable</span><br></pre></td></tr></table></figure>

<h3 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h3><p>每个组件还可以有一个 Kconfig 文件,与 <code>component.mk</code> 在同一目录下.Kconfig 中包含要添加到此组件的 “make menuconfig” 的配置设置.</p>
<p>运行 menuconfig 时,可在 “Component Settings” 菜单下找到这些设置.</p>
<p>要创建组件 KConfig 文件,最简单的方法是使用 esp-idf 中的 KConfig 文件做修改.</p>
<p>有关示例,请参阅<a href="#添加条件配置">添加条件配置</a>.</p>
<h3 id="示例：添加二进制库、组件配置文件-Kconfig"><a href="#示例：添加二进制库、组件配置文件-Kconfig" class="headerlink" title="示例：添加二进制库、组件配置文件 Kconfig"></a>示例：添加二进制库、组件配置文件 Kconfig</h3><p><img src="https://img-blog.csdnimg.cn/20190131111141734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Component Makefile</span><br><span class="line">#</span><br><span class="line">ifdef CONFIG_BT_ENABLED</span><br><span class="line"></span><br><span class="line">COMPONENT_SRCDIRS :&#x3D; .</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_INCLUDEDIRS :&#x3D; include</span><br><span class="line"></span><br><span class="line"># add pre-compiled libraries</span><br><span class="line">LIBS :&#x3D; btdm_app</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_LDFLAGS     :&#x3D; -lbt -L $(COMPONENT_PATH)&#x2F;lib \</span><br><span class="line">                           $(addprefix -l,$(LIBS))</span><br><span class="line"></span><br><span class="line"># re-link program if BT binary libs change</span><br><span class="line">COMPONENT_ADD_LINKER_DEPS :&#x3D; $(patsubst %,$(COMPONENT_PATH)&#x2F;lib&#x2F;lib%.a,$(LIBS))</span><br><span class="line"></span><br><span class="line">COMPONENT_SUBMODULES +&#x3D; lib</span><br><span class="line"></span><br><span class="line">ifeq ($(GCC_NOT_5_2_0), 1)</span><br><span class="line"># TODO: annotate fallthroughs in Bluedroid code with comments</span><br><span class="line">CFLAGS +&#x3D; -Wno-implicit-fallthrough</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifdef CONFIG_BLUEDROID_ENABLED</span><br><span class="line"></span><br><span class="line">COMPONENT_PRIV_INCLUDEDIRS +&#x3D;   bluedroid&#x2F;bta&#x2F;include                   \</span><br><span class="line">                                bluedroid&#x2F;bta&#x2F;ar&#x2F;include</span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_INCLUDEDIRS +&#x3D;    bluedroid&#x2F;api&#x2F;include&#x2F;api</span><br><span class="line"></span><br><span class="line">COMPONENT_SRCDIRS +&#x3D;    bluedroid&#x2F;bta&#x2F;dm                      \</span><br><span class="line">                        bluedroid&#x2F;bta&#x2F;gatt </span><br><span class="line"></span><br><span class="line">ifeq ($(GCC_NOT_5_2_0), 1)</span><br><span class="line">bluedroid&#x2F;bta&#x2F;sdp&#x2F;bta_sdp_act.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;btc&#x2F;core&#x2F;btc_config.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;stack&#x2F;btm&#x2F;btm_sec.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">bluedroid&#x2F;stack&#x2F;smp&#x2F;smp_keys.o: CFLAGS +&#x3D; -Wno-unused-const-variable</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<h3 id="预处理器定义"><a href="#预处理器定义" class="headerlink" title="预处理器定义"></a>预处理器定义</h3><p>ESP-IDF 构建系统在命令行上添加以下 C 预处理器定义:</p>
<ul>
<li><code>ESP_PLATFORM</code> - 可用于检测在 ESP-IDF 内发生的构建.</li>
<li><code>IDF_VER</code> - ESP-IDF 版本,有关详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/build-system.html#preset-component-variables" target="_blank" rel="noopener">预设组件变量</a>.</li>
<li><code>PROJECT_VER</code>：项目版本，有关详细信息,请参阅<a href="https://esp-idf.readthedocs.io/en/latest/api-guides/build-system.html#preset-component-variables" target="_blank" rel="noopener">预设组件变量</a>.</li>
<li><code>PROJECT_NAME</code>：项目名称，在项目 Makefile 中设置.</li>
</ul>
<h3 id="构建过程内部"><a href="#构建过程内部" class="headerlink" title="构建过程内部"></a>构建过程内部</h3><h4 id="顶级-Project-Makefile"><a href="#顶级-Project-Makefile" class="headerlink" title="顶级:Project Makefile"></a>顶级:Project Makefile</h4><ul>
<li>“make” 总是从项目目录和项目 makefile 运行,通常名为 Makefile.</li>
<li>项目 makefile 设置 <code>PROJECT_NAME</code>,并可选择自定义其他可选项目变量</li>
<li>项目 makefile 包含 <code>$(IDF_PATH)/make/project.mk</code>,其中包含项目级的 Make 逻辑.</li>
<li><code>project.mk</code> 填写默认的项目级 make 变量,并包含项目配置中的 make 变量.如果生成的包含项目配置的 makefile 已过期,则会重新生成(通过 <code>project_config.mk</code> 中的 targets),然后 make 进程从顶部重新开始.</li>
<li><code>project.mk</code> 根据默认组件目录或可选项目变量中设置的自定义组件列表构建需要要构建的组件列表.</li>
<li>每个组件都可以设置一些<a href="#可选项目范围的组件变量">可选项目范围的组件变量</a>.这些包含在 <code>component_project_vars.mk</code> 生成的 makefile 中 - 每个组件有一个.这些生成的 makefile 包含在 <code>project.mk</code>中.如果有任何缺失或过时,它们将被重新生成(通过对组件 makefile 的递归调用),然后 make 进程从顶部重新开始.</li>
<li>组件中的 Makefile.projbuild 文件包含在 make 进程中,以添加额外的目标或配置.</li>
<li>默认情况下,项目 makefile 还为每个组件生成顶级构建和清理目标,并设置 app 和 clean 目标以调用这些子目标.</li>
<li>为了编译每个组件,对组件 makefile 执行递归 make.</li>
</ul>
<p>为了更好地理解项目构建过程,请通读 <code>project.mk</code> 文件本身.</p>
<h4 id="第二级-组件Makefile"><a href="#第二级-组件Makefile" class="headerlink" title="第二级:组件Makefile"></a>第二级:组件Makefile</h4><ul>
<li>每次调用组件 makefile 都是通过 <code>$(IDF_PATH)/make/component_wrapper.mk</code> 包装器 makefile 进行的.</li>
<li>此组件包装器包含所有组件 <code>Makefile.componentbuild</code> 文件,使这些文件中的任何配方,变量等可用于每个组件.</li>
<li>调用<code>component_wrapper.mk</code>时将当前目录设置为组件构建目录,并将<code>COMPONENT_MAKEFILE</code>变量设置为<code>component.mk</code>的绝对路径.</li>
<li><code>component_wrapper.mk</code>为所有组件变量设置默认值,然后包括可以覆盖或修改这些变量的component.mk文件.</li>
<li>如果未定义 <code>COMPONENT_OWNBUILDTARGET</code> 和 <code>COMPONENT_OWNCLEANTARGET</code>,则会为组件的源文件和必备组件 <code>COMPONENT_LIBRARY</code> 静态库文件创建缺省构建和清除目标.</li>
<li><code>component_project_vars.mk</code> 文件在 <code>component_wrapper.mk</code> 中有自己的目标,如果由于组件 makefile 或项目配置的更改而需要重建此文件,则从 <code>project.mk</code> 进行评估.</li>
</ul>
<p>为了更好地理解组件制作过程,请通读 <code>component_wrapper.mk</code> 文件和 esp-idf 中包含的一些 <code>component.mk</code> 文件.</p>
<h3 id="以非交互方式运行"><a href="#以非交互方式运行" class="headerlink" title="以非交互方式运行"></a>以非交互方式运行</h3><p>在不希望交互式提示的情况下运行 <code>make</code> 时(例如:在 IDE 或自动构建系统中)将 <code>BATCH_BUILD = 1</code> 附加到 make 参数(或将其设置为环境变量).</p>
<p>设置 <code>BATCH_BUILD</code> 意味着以下内容:</p>
<ul>
<li>详细输出(与 <code>V = 1</code> 相同,见下文).如果您不想要详细输出,设置 <code>V = 0</code>.</li>
<li>如果项目配置缺少新配置项(来自新组件或 esp-idf 更新),则项目使用默认值,而不是提示用户输入每个项目.</li>
<li>如果构建系统需要调用<code>menuconfig</code>,则会打印错误并且构建失败.</li>
</ul>
<h3 id="高级-Make-用法"><a href="#高级-Make-用法" class="headerlink" title="高级 Make 用法"></a>高级 Make 用法</h3><ul>
<li><code>make app</code>，<code>make bootloader</code>，<code>make partition table</code> 可用于仅根据需要从项目中构建 <code>app</code>，<code>bootloader</code> 或 <code>partition table</code>。</li>
<li><code>make erase_flash</code> 和 <code>make erase_ota</code> 将分别使用 <code>esptool.py</code> 从 Flash 中擦除整个 Flash 和 OTA 分区选择配置。</li>
<li><code>make size</code> 打印有关应用程序的一些大小信息。<code>make size-components</code> 和 <code>make size-files</code> 是类似的目标，分别打印更详细的每个组件或每个源文件信息。</li>
</ul>
<h3 id="调试-Make-Process"><a href="#调试-Make-Process" class="headerlink" title="调试 Make Process"></a>调试 Make Process</h3><p>调试 esp-idf 构建系统的一些技巧:</p>
<ul>
<li>将 <code>V = 1</code> 附加到 make 参数(或将其设置为环境变量)将使 make 回显所有已执行的命令,以及为 sub-make 输入的每个目录.</li>
<li>运行 <code>make -w</code> 将导致 make 在为 sub-make 输入时回显每个目录 - 与 <code>V = 1</code> 相同但不回显所有命令.</li>
<li>运行 <code>make --trace</code> (可能除了上述参数之一)将打印出构建时的每个目标,以及导致它构建的依赖项.</li>
<li>运行 <code>make -p</code> 会打印每个 makefile 中每个生成的目标的(非常详细的)摘要.</li>
</ul>
<p>有关更多调试技巧和一般制作信息,请参阅 GNU制作手册.</p>
<h4 id="警告未定义的变量"><a href="#警告未定义的变量" class="headerlink" title="警告未定义的变量"></a>警告未定义的变量</h4><p>默认情况下,如果引用了未定义的变量(如<code>$(DOES_NOT_EXIST)</code>),构建过程将打印警告.这对于查找变量名称中的错误非常有用.</p>
<p>如果您不想要此行为,可以在 SDK 工具配置下的 menuconfig 顶级菜单中禁用它.</p>
<p>请注意,如果在 Makefile 中使用<code>ifdef</code>或<code>ifndef</code>,则此选项不会触发警告.</p>
<h3 id="覆盖项目的部分内容"><a href="#覆盖项目的部分内容" class="headerlink" title="覆盖项目的部分内容"></a>覆盖项目的部分内容</h3><h4 id="Makefile-projbuild"><a href="#Makefile-projbuild" class="headerlink" title="Makefile.projbuild"></a>Makefile.projbuild</h4><p>对于具有必须在顶级项目 make pass 中进行求值的构建要求的组件,可以在组件目录中创建名为 <code>Makefile.projbuild</code> 的文件.在计算 <code>project.mk</code> 时会包含此 makefile.</p>
<p>例如,如果您的组件需要为整个项目添加 CFLAGS (不仅仅是为了自己的源文件),那么您可以在 Makefile.projbuild 中设置 <code>CFLAGS +=</code>.</p>
<p><code>Makefile.projbuild</code> 文件在 esp-idf 中大量使用,用于定义项目范围的构建功能,例如 <code>esptool.py</code> 命令行参数和 <code>bootloader</code> “特殊应用程序”.</p>
<p>请注意,<code>Makefile.projbuild</code> 对于最常见的组件使用不是必需的 - 例如向项目添加 include 目录,或者将 LDFLAGS 添加到最终链接步骤.可以通过 <code>component.mk</code> 文件本身自定义这些值.有关详细信息,请参阅<a href="#可选项目范围的组件变量">可选项目范围的组件变量</a>.</p>
<p>在此文件中设置变量或目标时要小心.由于这些值包含在顶级项目 makefile 中,因此它们可以影响或破坏所有组件的功能！</p>
<h4 id="KConfig-projbuild"><a href="#KConfig-projbuild" class="headerlink" title="KConfig.projbuild"></a>KConfig.projbuild</h4><p>这相当于 <code>Makefile.projbuild</code> 的组件配置 KConfig 文件.如果要在 menuconfig 的顶层包含配置选项,而不是在 “Component Configuration” 子菜单中,则可以在 <code>component.mk</code> 文件旁边的 KConfig.projbuild 文件中定义这些选项.</p>
<p>在此文件中添加配置值时要小心,因为它们将包含在整个项目配置中.在可能的情况下,通常最好为组件配置创建 KConfig 文件.</p>
<h4 id="Makefile-componentbuild"><a href="#Makefile-componentbuild" class="headerlink" title="Makefile.componentbuild"></a>Makefile.componentbuild</h4><p>对于组件例如,包括从其他文件生成源文件的工具,必须能够将配置,宏或变量定义添加到每个组件的组件构建过程中.这是通过在组件目录中包含 Makefile.componentbuild 来完成的.在包含组件的 component.mk 之前,此文件会包含在 component_wrapper.mk 中.与 Makefile.projbuild 类似,请注意这些文件:因为它们包含在每个组件构建中,所以只有在编译完全不同的组件时才会出现 Makefile.componentbuild 错误.</p>
<h4 id="仅配置组件"><a href="#仅配置组件" class="headerlink" title="仅配置组件"></a>仅配置组件</h4><p>一些不包含源文件的特殊组件,只有 <code>Kconfig.projbuild</code> 和 <code>Makefile.projbuild</code>,可以在 component.mk 文件中设置标志 <code>COMPONENT_CONFIG_ONLY</code>.如果设置了此标志,则忽略大多数其他组件变量,并且不会为组件运行构建步骤.</p>
<h3 id="示例组件-Makefile"><a href="#示例组件-Makefile" class="headerlink" title="示例组件 Makefile"></a>示例组件 Makefile</h3><p>因为构建环境试图设置大多数时间都能工作的合理默认值,所以 component.mk 可能非常小甚至是空的(请参阅<a href="#最小组件Makefile">最小组件 Makefile</a>).但是,某些功能通常需要覆盖组件变量.</p>
<p>以下是<code>component.mk</code> makefile 的一些更高级的示例:</p>
<h4 id="添加源文件目录"><a href="#添加源文件目录" class="headerlink" title="添加源文件目录"></a>添加源文件目录</h4><p>默认情况下,将忽略子目录.如果您的项目在子目录而不是组件的根目录中有源文件,那么您可以通过设置<code>COMPONENT_SRCDIRS</code> 告诉构建系统:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_SRCDIRS:&#x3D; src1 src2</span><br></pre></td></tr></table></figure>
<p>这将编译 src1/ 和 src2/ 子目录中的所有源文件.</p>
<h4 id="指定源文件"><a href="#指定源文件" class="headerlink" title="指定源文件"></a>指定源文件</h4><p>标准 component.mk 逻辑将源目录中的所有 .S 和 .c 文件添加为无条件编译的源.通过将 <code>COMPONENT_OBJS</code> 变量手动设置为需要生成的对象的名称,可以绕过该逻辑并对要编译的对象进行硬编码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_OBJS :&#x3D; file1.o file2.o thing&#x2F;filea.o thing&#x2F;fileb.o anotherthing&#x2F;main.o</span><br><span class="line">COMPONENT_SRCDIRS :&#x3D; . thing anotherthing</span><br></pre></td></tr></table></figure>
<p>请注意,还必须设置 <code>COMPONENT_SRCDIRS</code>.</p>
<h4 id="添加条件配置"><a href="#添加条件配置" class="headerlink" title="添加条件配置"></a>添加条件配置</h4><p>配置系统可有条件地编译某些文件,具体取决于 <code>make menuconfig</code> 中选择的选项.为此, ESP-IDF 具有 <code>compile_only_if</code> 和 <code>compile_only_if_not</code> 宏:</p>
<p><code>Kconfig</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config FOO_ENABLE_BAR</span><br><span class="line">    bool &quot;Enable the BAR feature.&quot;</span><br><span class="line">    help</span><br><span class="line">        This enables the BAR feature of the FOO component.</span><br></pre></td></tr></table></figure>
<p><code>component.mk</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(call compile_only_if,$(CONFIG_FOO_ENABLE_BAR),bar.o)</span><br></pre></td></tr></table></figure>
<p>从示例中可以看出,<code>compile_only_if</code> 宏将条件和目标文件列表作为参数.如果条件为真(在这种情况下:如果在 menuconfig 中启用了 BAR 功能),将始终编译目标文件(在本例中为 bar.o).相反的情况也是如此:如果条件不成立, bar.o 将永远不会被编译.<code>compile_only_if_not</code> 执行相反的操作:如果条件为false则编译,如果条件为 true 则不编译.</p>
<p>这也可用于选择或删除一种实现,如下所示:</p>
<p><code>Kconfig</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config ENABLE_LCD_OUTPUT</span><br><span class="line">    bool &quot;Enable LCD output.&quot;</span><br><span class="line">    help</span><br><span class="line">        Select this if your board has a LCD.</span><br><span class="line"></span><br><span class="line">config ENABLE_LCD_CONSOLE</span><br><span class="line">    bool &quot;Output console text to LCD&quot;</span><br><span class="line">    depends on ENABLE_LCD_OUTPUT</span><br><span class="line">    help</span><br><span class="line">        Select this to output debugging output to the lcd</span><br><span class="line"></span><br><span class="line">config ENABLE_LCD_PLOT</span><br><span class="line">    bool &quot;Output temperature plots to LCD&quot;</span><br><span class="line">    depends on ENABLE_LCD_OUTPUT</span><br><span class="line">    help</span><br><span class="line">        Select this to output temperature plots</span><br></pre></td></tr></table></figure>

<p>component.mk:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># If LCD is enabled, compile interface to it, otherwise compile dummy interface</span><br><span class="line">$(call compile_only_if,$(CONFIG_ENABLE_LCD_OUTPUT),lcd-real.o lcd-spi.o)</span><br><span class="line">$(call compile_only_if_not,$(CONFIG_ENABLE_LCD_OUTPUT),lcd-dummy.o)</span><br><span class="line"></span><br><span class="line">#We need font if either console or plot is enabled</span><br><span class="line">$(call compile_only_if,$(or $(CONFIG_ENABLE_LCD_CONSOLE),$(CONFIG_ENABLE_LCD_PLOT)), font.o)</span><br></pre></td></tr></table></figure>
<p>请注意使用 Make ‘or’ 功能来包含字体文件.其他替换函数,如 ‘and’ 以及 ‘if’ 也适用于此处.也可以使用不来自 menuconfig 的变量: ESP-IDF 使用默认的构建配置来判断一个空的变量或只包含空格为false,而其中包含任何非空格的变量为true.</p>
<p>(注意:本文档的旧版本建议有条件地将目标文件名添加到 <code>COMPONENT_OBJS</code>.虽然这仍然可行,但只有当组件的所有目标文件都明确命名时才会起作用,并且不会通过 <code>make clear</code> 中的取消选择的目标文件通过.)</p>
<h4 id="源代码生成"><a href="#源代码生成" class="headerlink" title="源代码生成"></a>源代码生成</h4><p>某些组件将出现源文件未随组件本身提供但必须从另一个文件生成的情况.假设我们的组件有一个头文件,该文件由 BMP 文件的转换后的二进制数据组成,使用名为 bmp2h 的假设工具进行转换.然后将头文件包含在名为 graphics_lib.c 的 C 源文件中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_EXTRA_CLEAN :&#x3D; logo.h</span><br><span class="line"></span><br><span class="line">graphics_lib.o: logo.h</span><br><span class="line"></span><br><span class="line">logo.h: $(COMPONENT_PATH)&#x2F;logo.bmp</span><br><span class="line">    bmp2h -i $^ -o $@</span><br></pre></td></tr></table></figure>
<p>在此示例中,将在当前目录(构建目录)中生成 <code>graphics_lib.o</code> 和 <code>logo.h</code>,而 logo.bmp 随组件一起提供并位于组件路径下.因为 logo.h 是一个生成的文件,所以当调用 make clean 时需要清理它,这就是为什么它被添加到 <code>COMPONENT_EXTRA_CLEAN</code> 变量中.</p>
<h4 id="Cosmetic-Improvements"><a href="#Cosmetic-Improvements" class="headerlink" title="Cosmetic Improvements"></a>Cosmetic Improvements</h4><p>因为 logo.h 是一个生成的文件,所以当调用 make clean 时需要清理它,这就是为什么它被添加到 <code>COMPONENT_EXTRA_CLEAN</code> 变量中.</p>
<p>将 logo.h 添加到 <code>graphics_lib.o</code> 依赖项会导致在编译 <code>graphics_lib.c</code> 之前生成它.</p>
<p>如果另一个组件中的源文件包含 <code>logo.h</code>,则必须将此组件的名称添加到另一个组件的 <code>COMPONENT_DEPENDS</code> 列表中,以确保组件按顺序构建.</p>
<h4 id="嵌入二进制数据"><a href="#嵌入二进制数据" class="headerlink" title="嵌入二进制数据"></a>嵌入二进制数据</h4><p>有时您有一个文件,包含组件需要使用的二进制数据或文本数据 - 但您不希望将文件重新格式化为 C 文件.</p>
<p>您可以在 component.mk 中设置变量 <code>COMPONENT_EMBED_FILES</code>,以这种方式给出要嵌入的文件的名称:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_EMBED_FILES:&#x3D; server_root_cert.der</span><br></pre></td></tr></table></figure>
<p>或者,如果文件是字符串,则可以使用变量 <code>COMPONENT_EMBED_TXTFILES</code>.这将把文本文件的内容嵌入为以 null 结尾的字符串:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_EMBED_TXTFILES:&#x3D; server_root_cert.pem</span><br></pre></td></tr></table></figure>
<p>文件的内容将被添加到 flash 中的 .rodata 部分,并通过符号名称提供,如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern const uint8_t server_root_cert_pem_start [] asm(“_ binary_server_root_cert_pem_start”);</span><br><span class="line">extern const uint8_t server_root_cert_pem_end [] asm(“_ binary_server_root_cert_pem_end”);</span><br></pre></td></tr></table></figure>
<p>名称是根据文件的全名生成的,如 <code>COMPONENT_EMBED_FILES</code> 中所示.字符 <code>/</code>,<code>.</code>等用下划线代替.符号名称中的 <code>_binary</code> 前缀由 <code>objcopy</code> 添加,对于文本和二进制文件都是相同的.</p>
<p>有关使用此技术的示例,请参阅<a href="https://github.com/espressif/esp-idf/tree/be81d2c/examples/protocols/https_request" target="_blank" rel="noopener">protocols/https_request</a>-证书文件内容在编译时从文本 .pem 文件加载.</p>
<h3 id="完全覆盖组件-Makefile"><a href="#完全覆盖组件-Makefile" class="headerlink" title="完全覆盖组件 Makefile"></a>完全覆盖组件 Makefile</h3><p>显然,在某些情况下,所有这些不足以满足某个组件,例如,当组件基本上是另一个第三方组件的包装器时,该第三方组件最初不打算在此构建系统下编译.在这种情况下,可以通过设置 <code>COMPONENT_OWNBUILDTARGET</code> 和可能的 <code>COMPONENT_OWNCLEANTARGET</code> 并在 <code>component.mk</code> 目标中定义名为 <code>build</code> 和 <code>clean</code> 的自己的目标来完全放弃 esp-idf 构建系统.构建目标可以执行任何操作,只要它为项目生成过程创建 $(COMPONENT_LIBRARY) 以链接到应用程序二进制文件.</p>
<p>(实际上,即使这不是必需的-如果重写 <code>COMPONENT_ADD_LDFLAGS</code> 变量,则组件可以指示链接器链接其他二进制文件.)</p>
<h3 id="自定义-sdkconfig-默认值"><a href="#自定义-sdkconfig-默认值" class="headerlink" title="自定义 sdkconfig 默认值"></a>自定义 sdkconfig 默认值</h3><p>例如,您不希望指定完整 sdkconfig 配置的项目或其他项目,但您确实希望覆盖 esp-idf 默认值中的某些键值,则可以在项目目录中创建文件 <code>sdkconfig.defaults</code>.运行 <code>make defconfig</code> 或从头创建新配置时将使用此文件.</p>
<p>要覆盖此文件的名称,请设置 <code>SDKCONFIG_DEFAULTS</code> 环境变量.</p>
<h3 id="保存-flash-参数"><a href="#保存-flash-参数" class="headerlink" title="保存 flash 参数"></a>保存 flash 参数</h3><p>在某些情况下,我们希望在没有 IDF 的情况下烧写目标板.对于这种情况,我们希望保存构建的二进制文件, <code>esptool.py</code> 和 <code>esptool write_flash</code> 参数.编写脚本以保存二进制文件和 <code>esptool.py</code> 很简单.我们可以使用命令 <code>make print_flash_cmd</code>,它会打印 flash 参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader &#x2F; bootloader.bin 0x10000 example_app.bin 0x8000 partition_table_unit_test_app.bin</span><br></pre></td></tr></table></figure>
<p>然后使用 flash 参数作为 <code>esptool write_flash</code> 参数的 arguemnts:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python esptool.py --chip esp32 --port &#x2F; dev &#x2F; ttyUSB0 --baud 921600 - before default_reset - after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader &#x2F; bootloader.bin 0x10000 example_app .bin 0x8000 partition_table_unit_test_app.bin</span><br></pre></td></tr></table></figure>

<h2 id="构建-Bootloader"><a href="#构建-Bootloader" class="headerlink" title="构建 Bootloader"></a>构建 Bootloader</h2><p>引导程序默认构建为 “make all” 的一部分,或者可以通过 “make bootloader-clean” 独立构建.还有 “make bootloader-list-components” 来查看引导加载程序构建中包含的组件.</p>
<p>IDF <code>components/bootloader</code> 中的组件是特殊的,因为第二阶段引导加载程序是主项目的单独.ELF和.BIN文件.但是,它与主项目共享其配置和构建目录.</p>
<p>这是通过在 <code>components/bootloader/subproject</code> 下添加子项目来完成的.这个子项目有自己的 Makefile,但它希望通过 <code>components/bootloader/Makefile.projectbuild</code> 文件中的一些粘合剂从项目自己的 Makefile 中调用.有关详细信息,请参阅这些文件</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（五）严重错误</title>
    <url>/InfiniteYuanBlog/2018/09/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%A5%E9%87%8D%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在某些情况下,程序的执行,没有按照定义的方式持续执行.在 ESP-IDF 中,这些情况包括:</p>
<ul>
<li>CPU 异常:Illegal Instruction, Load/Store Alignment Error, Load/Store Prohibited error, Double Exception.(非法指令,加载/存储对齐错误,加载/存储禁止错误,双重异常)</li>
<li>系统级别检查和安全措施:<ul>
<li>Interrupt watchdog timeout 中断看门狗超时</li>
<li>Task watchdog timeout  任务监视程序超时(如果设置了 <code>CONFIG_TASK_WDT_PANIC</code>,则仅 fatal)</li>
<li>Cache access error 缓存访问错误</li>
<li>Brownout detection event 掉电检测事件</li>
<li>Stack overflow 堆栈溢出</li>
<li>Stack smashing protection check 堆栈粉碎保护检查</li>
<li>Heap integrity check 堆完整性检查</li>
</ul>
</li>
<li>Failed assertions 断言失败,通过 <code>assert</code> ,<code>configASSERT</code> 和类似的宏.</li>
</ul>
<p>本指南介绍了 ESP-IDF 中用于处理这些错误的过程,并提供了有关错误故障排除的建议.</p>
<a id="more"></a>

<h2 id="Panic-处理"><a href="#Panic-处理" class="headerlink" title="Panic 处理"></a>Panic 处理</h2><p>概述中列出的每个错误原因都将由 Panic 处理程序处理.</p>
<p>Panic 处理程序将首先将错误原因打印到控制台. 对于 CPU 异常,消息类似于:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Guru Meditation Error: Core 0 panic&#39;ed (IllegalInstruction). Exception was unhandled.</span><br></pre></td></tr></table></figure>

<p>对于某些系统级别检查(中断监视程序,缓存访问错误),该消息将类似于:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Guru Meditation Error: Core 0 panic&#39;ed (Cache disabled but cached memory region accessed)</span><br></pre></td></tr></table></figure>

<p>在所有情况下,错误原因将打印在括号中. 有关可能的错误原因列表,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html#guru-meditation-errors" target="_blank" rel="noopener">Guru Meditation Errors</a>.</p>
<p>可以使用 <code>CONFIG_ESP32_PANIC</code> 配置选项设置 Panic 处理程序的后续行为. 可用选项包括:</p>
<ul>
<li><p>打印寄存器并重新启动(<code>CONFIG_ESP32_PANIC_PRINT_REBOOT</code>) - 默认选项.<br> 这将在异常点打印寄存器值,打印回溯,然后重新启动芯片.</p>
</li>
<li><p>打印寄存器并暂停(<code>CONFIG_ESP32_PANIC_PRINT_HALT</code>)<br> 与上述选项类似,但暂停而不是重新启动. 重启程序需要外部重置.</p>
</li>
<li><p>无提示重启(<code>CONFIG_ESP32_PANIC_SILENT_REBOOT</code>)<br> 不要打印寄存器或回溯,立即重启芯片.</p>
</li>
<li><p>调用 GDB 存根(<code>CONFIG_ESP32_PANIC_GDBSTUB</code>)<br>  启动 GDB 服务器,它可以通过控制台 UART 端口与 GDB 通信. 有关详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html#gdb-stub" target="_blank" rel="noopener">GDB 存根</a>.</p>
</li>
</ul>
<p>Panic 处理程序的行为受另外两个配置选项的影响.</p>
<ul>
<li>如果启用了 <code>CONFIG_ESP32_DEBUG_OCDAWARE</code> (这是默认设置),则 Panic 处理程序将检测 JTAG 调试器是否已连接. 如果是,则执行将暂停,控制权将传递给调试器. 在这种情况下,寄存器和回溯不会转储到控制台,并且不使用 GDBStub/Core Dump 功能.</li>
<li>如果启用了核心转储功能(<code>CONFIG_ESP32_ENABLE_COREDUMP_TO_FLASH</code> 或 <code>CONFIG_ESP32_ENABLE_COREDUMP_TO_UART</code> 选项),则系统状态(任务堆栈和寄存器)将被转储到 Flash 或 UART,以供以后分析.</li>
</ul>
<p>下图说明了 Panic 处理程序的行为:</p>
<p><img src="https://img-blog.csdn.net/20180901140838695?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Panic 处理程序流程图"></p>
<h2 id="寄存器转储和回溯"><a href="#寄存器转储和回溯" class="headerlink" title="寄存器转储和回溯"></a>寄存器转储和回溯</h2><p>除非启用了 <code>CONFIG_ESP32_PANIC_SILENT_REBOOT</code> 选项,否则 Panic 处理程序会将一些 CPU 寄存器和回溯打印到控制台:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Core 0 register dump:</span><br><span class="line">PC      : 0x400e14ed  PS      : 0x00060030  A0      : 0x800d0805  A1      : 0x3ffb5030</span><br><span class="line">A2      : 0x00000000  A3      : 0x00000001  A4      : 0x00000001  A5      : 0x3ffb50dc</span><br><span class="line">A6      : 0x00000000  A7      : 0x00000001  A8      : 0x00000000  A9      : 0x3ffb5000</span><br><span class="line">A10     : 0x00000000  A11     : 0x3ffb2bac  A12     : 0x40082d1c  A13     : 0x06ff1ff8</span><br><span class="line">A14     : 0x3ffb7078  A15     : 0x00000000  SAR     : 0x00000014  EXCCAUSE: 0x0000001d</span><br><span class="line">EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0xffffffff</span><br><span class="line"></span><br><span class="line">Backtrace: 0x400e14ed:0x3ffb5030 0x400d0802:0x3ffb5050</span><br></pre></td></tr></table></figure>

<p>打印的寄存器值是异常帧中的寄存器值,即 CPU 异常或其他严重错误发生时的值.</p>
<p>如果由于 <code>abort()</code> 调用而执行了 Panic 处理程序,则不会打印寄存器转储.</p>
<p>在某些情况下,例如中断看门狗超时, Panic 处理程序可能会打印额外的 CPU 寄存器 (EPC1-EPC4) 以及在另一个 CPU 上运行的代码的寄存器/回溯.</p>
<p>Backtrace 行包含 PC:SP 对,其中 PC 是程序计数器,SP 是堆栈指针,用于当前任务的每个堆栈帧. 如果在 ISR 内发生严重错误,则回溯可能包括来自被中断的任务和来自 ISR 的 PC:SP 对.</p>
<p>如果使用 IDF Monitor,程序计数器值将转换为代码位置(函数名称,文件名和行号),输出将与其他行进行注释:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Core 0 register dump:</span><br><span class="line">PC      : 0x400e14ed  PS      : 0x00060030  A0      : 0x800d0805  A1      : 0x3ffb5030</span><br><span class="line">0x400e14ed: app_main at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.cpp:36</span><br><span class="line"></span><br><span class="line">A2      : 0x00000000  A3      : 0x00000001  A4      : 0x00000001  A5      : 0x3ffb50dc</span><br><span class="line">A6      : 0x00000000  A7      : 0x00000001  A8      : 0x00000000  A9      : 0x3ffb5000</span><br><span class="line">A10     : 0x00000000  A11     : 0x3ffb2bac  A12     : 0x40082d1c  A13     : 0x06ff1ff8</span><br><span class="line">0x40082d1c: _calloc_r at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;esp-idf&#x2F;components&#x2F;newlib&#x2F;syscalls.c:51</span><br><span class="line"></span><br><span class="line">A14     : 0x3ffb7078  A15     : 0x00000000  SAR     : 0x00000014  EXCCAUSE: 0x0000001d</span><br><span class="line">EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0xffffffff</span><br><span class="line"></span><br><span class="line">Backtrace: 0x400e14ed:0x3ffb5030 0x400d0802:0x3ffb5050</span><br><span class="line">0x400e14ed: app_main at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.cpp:36</span><br><span class="line"></span><br><span class="line">0x400d0802: main_task at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;esp-idf&#x2F;components&#x2F;esp32&#x2F;cpu_start.c:470</span><br></pre></td></tr></table></figure>

<p>要查找发生严重错误的位置,请查看“Backtrace”的下一行. 严重错误位置是顶行,后续行显示调用堆栈.</p>
<h2 id="GDB-存根"><a href="#GDB-存根" class="headerlink" title="GDB 存根"></a>GDB 存根</h2><p>如果启用了 <code>CONFIG_ESP32_PANIC_GDBSTUB</code> 选项,则发生严重错误时, Panic 处理程序不会重置芯片. 相反,它将启动 GDB 远程协议服务器,通常称为 GDB Stub. 发生这种情况时,可以指示主机上运行的 GDB 实例连接到 ESP32 UART 端口.</p>
<p>如果使用 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/idf-monitor.html" target="_blank" rel="noopener">IDF Monitor</a>,则在 UART 上检测到 GDB Stub 提示时会自动启动 GDB. 输出看起来像这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entering gdb stub now.</span><br><span class="line">$T0b#e6GNU gdb (crosstool-NG crosstool-ng-1.22.0-80-gff1f415) 7.10</span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;--host&#x3D;x86_64-build_apple-darwin16.3.0 --target&#x3D;xtensa-esp32-elf&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;bugs&#x2F;&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;documentation&#x2F;&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;build&#x2F;example.elf...done.</span><br><span class="line">Remote debugging using &#x2F;dev&#x2F;cu.usbserial-31301</span><br><span class="line">0x400e1b41 in app_main ()</span><br><span class="line">    at &#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.cpp:36</span><br><span class="line">36      *((int*) 0) &#x3D; 0;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>GDB 提示可用于检查 CPU 寄存器,本地和静态变量以及内存中的任意位置. 无法设置断点,更改 PC 或继续执行. 要重置程序,请退出 GDB 并执行外部重置:IDF Monitor 中的 <code>Ctrl-T Ctrl-R</code>,或使用开发板上的外部重置按钮.</p>
<h2 id="Guru-Meditation-错误"><a href="#Guru-Meditation-错误" class="headerlink" title="Guru Meditation 错误"></a>Guru Meditation 错误</h2><p>本节解释了不同错误原因的含义,打印在 <code>Guru Meditation Error:Core panic&#39;ed message</code> 之后的括号中.</p>
<blockquote>
<p>有关“Guru Meditation”的历史渊源,请参阅 <a href="https://en.wikipedia.org/wiki/Guru_Meditation" target="_blank" rel="noopener">Wikipedia 文章</a>.</p>
</blockquote>
<h3 id="IllegalInstruction-非法指令"><a href="#IllegalInstruction-非法指令" class="headerlink" title="IllegalInstruction (非法指令)"></a>IllegalInstruction (非法指令)</h3><p>该 CPU 异常表示执行的指令不是有效指令. 此错误的最常见原因有:</p>
<ul>
<li>FreeRTOS 任务功能已经返回. 在 FreeRTOS 中,如果任务函数需要终止,它应该调用 vTaskDelete() 函数并删除它自己,而不是返回.</li>
<li>无法从 SPI Flash 加载下一条指令. 这种情况通常发生在:<ul>
<li>应用程序已将 SPI Flash 引脚重新配置为其他功能(GPIO,UART 等). 有关 SPI Flash 引脚的详细信息,请参阅硬件设计指南和芯片或模块的数据表.</li>
<li>某些外部设备意外连接到 SPI Flash 引脚,干扰了 ESP32 和 SPI Flash 之间的通信.</li>
</ul>
</li>
</ul>
<h3 id="InstrFetchProhibited-禁止指令加载"><a href="#InstrFetchProhibited-禁止指令加载" class="headerlink" title="InstrFetchProhibited (禁止指令加载)"></a>InstrFetchProhibited (禁止指令加载)</h3><p>此 CPU 异常表示 CPU 无法加载指令,因为指令的地址不属于指令 RAM 或 ROM 中的有效区域.</p>
<p>通常这意味着尝试调用函数指针,该指针不指向有效代码. PC (程序计数器)寄存器可用作指示器:它将为零或将包含垃圾值(不是 0x4xxxxxxx).</p>
<h3 id="LoadProhibited-StoreProhibited-禁止加载，禁止存储"><a href="#LoadProhibited-StoreProhibited-禁止加载，禁止存储" class="headerlink" title="LoadProhibited,StoreProhibited(禁止加载，禁止存储)"></a>LoadProhibited,StoreProhibited(禁止加载，禁止存储)</h3><p>当应用程序尝试读取或写入无效的内存位置时,会发生此 CPU 异常. 写入/读取的地址可在寄存器转储中的 <code>EXCVADDR</code> 寄存器中找到. 如果此地址为零,则通常表示应用程序尝试取消引用 NULL 指针. 如果此地址接近于零,则通常意味着应用程序尝试访问结构的成员,但指向该结构的指针为 NULL. 如果该地址是别的(垃圾值,不在 <code>0x3fxxxxxx</code> - <code>0x6xxxxxxx</code> 范围内),则可能意味着用于访问数据的指针未初始化或已损坏.</p>
<h3 id="IntegerDivideByZero-除以-0"><a href="#IntegerDivideByZero-除以-0" class="headerlink" title="IntegerDivideByZero(除以 0)"></a>IntegerDivideByZero(除以 0)</h3><p>应用程序尝试将整数除以零.</p>
<h3 id="LoadStoreAlignment-对齐方式不对"><a href="#LoadStoreAlignment-对齐方式不对" class="headerlink" title="LoadStoreAlignment(对齐方式不对)"></a>LoadStoreAlignment(对齐方式不对)</h3><p>应用程序尝试读取或写入内存位置,并且地址对齐与加载/存储大小不匹配. 例如,32 位加载只能从 4 字节对齐的地址完成,而 16 位加载只能从 2 字节的对齐地址完成.</p>
<h3 id="LoadStoreError-加载-存储错误"><a href="#LoadStoreError-加载-存储错误" class="headerlink" title="LoadStoreError(加载/存储错误)"></a>LoadStoreError(加载/存储错误)</h3><p>应用程序尝试从仅支持 32 位加载/存储的内存区域进行 8 位或 16 位加载/存储. 例如,取消引用指向内存存储器的 <code>char *</code> 指针将导致这样的错误.</p>
<h3 id="Unhandled-debug-exception-堆栈错误"><a href="#Unhandled-debug-exception-堆栈错误" class="headerlink" title="Unhandled debug exception(堆栈错误)"></a>Unhandled debug exception(堆栈错误)</h3><p>通常会出现以下消息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Debug exception reason: Stack canary watchpoint triggered (task_name)</span><br></pre></td></tr></table></figure>

<p>此错误表示应用程序已写入 <code>task_name</code> 任务堆栈的末尾. 请注意,并非每个堆栈溢出都可以保证触发此错误. 任务可能会在堆栈 <code>canary</code> 位置之外写入堆栈,在这种情况下,不会触发观察点.</p>
<h3 id="Interrupt-wdt-timeout-on-CPU0-CPU1-看门狗超时"><a href="#Interrupt-wdt-timeout-on-CPU0-CPU1-看门狗超时" class="headerlink" title="Interrupt wdt timeout on CPU0 / CPU1(看门狗超时)"></a>Interrupt wdt timeout on CPU0 / CPU1(看门狗超时)</h3><p>表示发生了中断看门狗超时. 有关详细信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/wdts.html" target="_blank" rel="noopener">看门狗</a>.</p>
<h3 id="Cache-disabled-but-cached-memory-region-accessed-Cache-禁止"><a href="#Cache-disabled-but-cached-memory-region-accessed-Cache-禁止" class="headerlink" title="Cache disabled but cached memory region accessed(Cache 禁止)"></a>Cache disabled but cached memory region accessed(Cache 禁止)</h3><p>在某些情况下,ESP-IDF 将暂时禁止通过高速缓存访问外部 SPI Flash 和 SPI RAM. 例如,spi_flash API 用于读取/写入/擦除/mmap SPI Flash 区域. 在这些情况下,任务被挂起,并且未注册 <code>ESP_INTR_FLAG_IRAM</code> 的中断处理程序被禁用. 确保使用此标志注册的任何中断处理程序都具有 IRAM/DRAM 中的所有代码和数据. 有关更多详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/spi_flash.html#iram-safe-interrupt-handlers" target="_blank" rel="noopener">SPI Flash API 文档</a>.</p>
<h2 id="其他严重错误"><a href="#其他严重错误" class="headerlink" title="其他严重错误"></a>其他严重错误</h2><h3 id="Brownout-欠压"><a href="#Brownout-欠压" class="headerlink" title="Brownout(欠压)"></a>Brownout(欠压)</h3><p>ESP32 有一个内置的掉电检测器,默认启用. 如果电源电压低于安全水平,掉电检测器可以触发系统复位. 可以使用 <code>CONFIG_BROWNOUT_DET</code> 和 <code>CONFIG_BROWNOUT_DET_LVL_SEL</code> 选项配置掉电检测器. 当掉电检测器触发时,将打印以下消息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Brownout detector was triggered</span><br></pre></td></tr></table></figure>

<p>打印消息后,芯片将复位.</p>
<p>请注意,如果电源电压快速下降,则控制台上只能看到部分消息.</p>
<h3 id="Corrupt-Heap"><a href="#Corrupt-Heap" class="headerlink" title="Corrupt Heap"></a>Corrupt Heap</h3><p>ESP-IDF 堆实现包含许多堆结构的运行时检查. 可以在 menuconfig 中启用其他检查(“Heap Stisoning”). 如果其中一项检查失败,将打印类似于以下内容的消息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CORRUPT HEAP: Bad tail at 0x3ffe270a. Expected 0xbaad5678 got 0xbaac5678</span><br><span class="line">assertion &quot;head !&#x3D; NULL&quot; failed: file &quot;&#x2F;Users&#x2F;user&#x2F;esp&#x2F;esp-idf&#x2F;components&#x2F;heap&#x2F;multi_heap_poisoning.c&quot;, line 201, function: multi_heap_free</span><br><span class="line">abort() was called at PC 0x400dca43 on core 0</span><br></pre></td></tr></table></figure>

<p>有关详细信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/heap_debug.html" target="_blank" rel="noopener">堆内存调试文档</a>.</p>
<h3 id="Stack-Smashing"><a href="#Stack-Smashing" class="headerlink" title="Stack Smashing"></a>Stack Smashing</h3><p>可以使用 <code>CONFIG_STACK_CHECK_MODE</code> 选项在 ESP-IDF 中启用 Stack Smashing 保护(基于 GCC  <code>-fstack-protector *</code> 标志). 如果检测到 Stack Smashing,将打印类似于以下内容的消息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack smashing protect failure!</span><br><span class="line"></span><br><span class="line">abort() was called at PC 0x400d2138 on core 0</span><br><span class="line"></span><br><span class="line">Backtrace: 0x4008e6c0:0x3ffc1780 0x4008e8b7:0x3ffc17a0 0x400d2138:0x3ffc17c0 0x400e79d5:0x3ffc17e0 0x400e79a7:0x3ffc1840 0x400e79df:0x3ffc18a0 0x400e2235:0x3ffc18c0 0x400e1916:0x3ffc18f0 0x400e19cd:0x3ffc1910 0x400e1a11:0x3ffc1930 0x400e1bb2:0x3ffc1950 0x400d2c44:0x3ffc1a80</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>回溯应该指向 Stack Smashing 发生的函数. 检查功能代码以获得对本地阵列的无限制访问.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（八）Flash 加密</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%AB%EF%BC%89Flash%20%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="Flash-加密"><a href="#Flash-加密" class="headerlink" title="Flash 加密"></a>Flash 加密</h1><p>Flash 加密功能用于加密 ESP32 连接的 SPI  Flash 的内容。启用 Flash 加密后，通过物理方式读取 SPI Flash 的内容不足以恢复大多数 Flash 内容。</p>
<p>Flash 加密与安全启动功能是分离的，您可以使用 Flash 加密而无需启用<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html" target="_blank" rel="noopener">安全启动</a>。但是，我们建议将这两种功能一起用于安全的环境。在没有安全启动的情况下，需要执行其他配置以确保 Flash 加密的有效性。有关更多详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-without-secure-boot" target="_blank" rel="noopener">使用无安全启动的 Flash 加密</a>.</p>
<blockquote>
<p>启用闪存加密会限制您进一步更新 ESP32 的选项。请务必阅读本文档(包括 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-limitations" target="_blank" rel="noopener">Flash 加密限制</a>)并了解启用闪存加密的含义。</p>
</blockquote>
<a id="more"></a>

<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><ul>
<li><p>使用带有 256 位密钥的 AES 加密闪存的内容。闪存加密密钥存储在芯片内部的 efuse 中，并且(默认情况下)受软件访问保护。</p>
</li>
<li><p>通过 ESP32 的闪存缓存映射功能，Flash 访问是透明的 - 映射到地址空间的任何闪存区域在读取时都将被透明地解密。</p>
</li>
<li><p>通过使用明文数据烧录 ESP32 来应用加密，并且(如果启用了加密)引导加载程序会在首次启动时对数据进行加密。</p>
</li>
<li><p>并非所有闪存都是加密的。以下类型的闪存数据已加密:</p>
<ul>
<li><p>引导程序</p>
</li>
<li><p>安全启动引导加载程序摘要(如果启用了安全启动)</p>
</li>
<li><p>分区表</p>
</li>
<li><p>所有 “app” 类型分区</p>
</li>
<li><p>分区表中标有 “encrypted” 标志的任何分区</p>
<p> 可能希望一些数据分区保持未加密以便于访问，或者使用对于数据被加密时无效的闪存友好更新算法。由于 NVS 库与闪存加密不直接兼容，因此无法加密用于非易失性存储的 NVS 分区。有关更多详细信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html#nvs-encryption" target="_blank" rel="noopener">NVS 加密</a>。</p>
</li>
</ul>
</li>
<li><p>闪存加密密钥存储在 ESP32 芯片内部的 efuse 密钥块 1 中。默认情况下，此密钥具有读写保护功能，因此软件无法访问或更改密钥。</p>
</li>
<li><p>默认情况下，Efuse Block 1 编码方案为 “None”，并且在该块中存储 256 位密钥。在某些 ESP32 上，编码方案设置为 3/4 编码 (CODING_SCHEME efuse 的值为 1)，并且必须在该块中存储 192 位密钥。有关详细信息，请参见 《ESP32 技术参考手册》第 20.3.1.3 节 “系统参数 coding_scheme”。在所有情况下，算法都在 256 位密钥上运行，通过重复一些位（<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-algorithm" target="_blank" rel="noopener">具体细节</a>）来扩展  192 位密钥。当 <code>esptool.py</code> 连接到芯片或 <code>espefuse.py summary</code> 输出时，编码方案显示在 Features 行中。</p>
</li>
<li><p>闪存加密算法是 AES-256，其中密钥是“调整”的，每个 32 字节闪存块的偏移地址。这意味着每个 32 字节块(两个连续的 16 字节 AES 块)使用从闪存加密密钥派生的唯一密钥进行加密。</p>
</li>
<li><p>虽然芯片上运行的软件可以透明地解密闪存内容，但默认情况下，当启用闪存加密时，UART 引导加载程序无法解密(或加密)数据。</p>
</li>
<li><p>如果可以启用闪存加密，则编写<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#using-encrypted-flash" target="_blank" rel="noopener">使用加密闪存</a>的代码时，编程人员必须采取一定的预防措施。</p>
</li>
</ul>
<h2 id="2-Flash-加密初始化"><a href="#2-Flash-加密初始化" class="headerlink" title="2 Flash 加密初始化"></a>2 Flash 加密初始化</h2><p>这是默认(推荐) Flash 加密初始化过程。可以为开发或其他目的自定义此过程，有关详细信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-advanced-features" target="_blank" rel="noopener">Flash 加密高级功能</a>。</p>
<blockquote>
<p>在首次启动时启用闪存加密后，硬件通过串行重新闪存最多允许3次后续闪存烧录。必须遵循特殊过程(在<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#updating-encrypted-flash-serial" target="_blank" rel="noopener">串口烧录</a>中记录)才能执行这些更新。</p>
</blockquote>
<ul>
<li>如果启用了安全启动，则使用纯文本数据进行物理重新刷新需要“可重新映射”的安全启动摘要(请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-and-secure-boot" target="_blank" rel="noopener">Flash 加密和安全启动</a>)。</li>
<li>OTA 更新可用于更新 Flash 内容，而不计入此限制。</li>
<li>在开发中启用闪存加密时，请使用预生成的闪存加密密钥，以允许使用预加密数据进行无限次重新闪存。</li>
</ul>
<p>启用闪存加密的过程:</p>
<ul>
<li>必须在启用闪存加密支持的情况下编译引导加载程序。在 <code>make menuconfig</code> 中，导航到“安全功能”，然后选择“是”以“启动时启用闪存加密”。</li>
<li>如果同时启用安全启动，最好同时选择这些选项。首先阅读<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html" target="_blank" rel="noopener">安全启动</a>文档。</li>
<li>正常构建并刷新引导加载程序，分区表和工厂应用程序映像。这些分区最初写入未加密的闪存。</li>
</ul>
<blockquote>
<p>启用安全启动和闪存加密时，引导加载程序应用程序二进制 <code>bootloader.bin</code> 可能会变得太大。请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html#secure-boot-bootloader-size" target="_blank" rel="noopener">Bootloader 大小</a>。</p>
</blockquote>
<ul>
<li>首次启动时，引导加载程序会看到 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 设置为 0 (出厂默认值)，因此它使用硬件随机数生成器生成闪存加密密钥。该密钥存储在efuse中。密钥是读写保护，以防止进一步的软件访问。</li>
<li>然后，引导加载程序就地对所有加密分区进行加密。就地加密可能需要一些时间(对于大型分区，最多需要一分钟.)</li>
</ul>
<blockquote>
<p>第一次启动加密通道运行时，请勿中断ESP32的电源。如果电源中断，闪存内容将被破坏，并且需要再次使用未加密的数据烧录。像这样的重新烧录不会计入烧录限制。</p>
</blockquote>
<ul>
<li>烧录完成后。在 UART 引导加载程序运行时，激活(默认情况下)以禁用加密的闪存访问。有关高级详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#uart-bootloader-encryption" target="_blank" rel="noopener">启用 UART Bootloader 加密/解密</a>。</li>
<li><code>FLASH_CRYPT_CONFIG efuse</code> 也会被烧制到最大值(0xF)，以最大化闪存算法中调整的关键位数。有关高级详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#setting-flash-crypt-config" target="_blank" rel="noopener">设置 FLASH_CRYPT_CONFIG</a>。</li>
<li>最后，<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 以初始值 1 进行刻录。这个 efuse 激活透明闪存加密层，并限制后续重新刷新的次数。有关 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 的详细信息，请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#updating-encrypted-flash" target="_blank" rel="noopener">更新加密的 Flash</a> 部分。</li>
<li>引导加载程序重置自身以重新加密的闪存重新引导。</li>
</ul>
<h2 id="3-使用加密的-Flash"><a href="#3-使用加密的-Flash" class="headerlink" title="3 使用加密的 Flash"></a>3 使用加密的 Flash</h2><p>ESP32 应用程序代码可以通过调用 <code>esp_flash_encryption_enabled()</code> 来检查当前是否启用了闪存加密。</p>
<p>启用闪存加密后，从代码访问闪存内容时需要注意一些事项。</p>
<h3 id="3-1-Flash-加密的范围"><a href="#3-1-Flash-加密的范围" class="headerlink" title="3.1 Flash 加密的范围"></a>3.1 Flash 加密的范围</h3><p>只要将 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-crypt-cnt" target="_blank" rel="noopener">FLASH_CRYPT_CNT efuse</a> 设置为设置了奇数位的值，就会透明地解密通过 MMU 的闪存缓存访问的所有闪存内容。这包括:</p>
<ul>
<li>Flash 中的可执行应用程序代码 (IROM)。</li>
<li>存储在闪存 (DROM) 中的所有只读数据。</li>
<li>通过 <code>esp_spi_flash_mmap()</code> 访问的任何数据。</li>
<li>ROM 引导加载程序读取软件引导加载程序映像。</li>
</ul>
<blockquote>
<p>MMU Flash 缓存无条件地解密所有数据。在闪存中未加密存储的数据将通过闪存缓存“透明地解密”，并且看起来像随机垃圾这样的软件。</p>
</blockquote>
<h3 id="3-2-读取加密的-Flash"><a href="#3-2-读取加密的-Flash" class="headerlink" title="3.2 读取加密的 Flash"></a>3.2 读取加密的 Flash</h3><p>要在不使用闪存缓存 MMU 映射的情况下读取数据，我们建议使用分区读取函数 <code>esp_partition_read()</code>。使用此功能时，只有从加密分区读取数据时才会解密数据。其他分区将以未加密方式读取。通过这种方式，软件可以以相同的方式访问加密和非加密的闪存。</p>
<p>通过其他 SPI 读取 APIs 读取的数据不会被解密:</p>
<ul>
<li>通过 <code>esp_spi_flash_read()</code> 读取的数据不会被解密</li>
<li>通过 ROM 函数 <code>SPIRead()</code> 读取的数据不会被解密 (esp-idf 应用程序不支持此功能)</li>
<li>使用非易失性存储 (NVS) API 存储的数据始终存储并读取解密。</li>
</ul>
<h3 id="3-3-写加密的-Flash"><a href="#3-3-写加密的-Flash" class="headerlink" title="3.3 写加密的 Flash"></a>3.3 写加密的 Flash</h3><p>在可能的情况下，我们建议使用分区写入函数 <code>esp_partition_write</code>。使用此功能时，只有在写入加密分区时才会加密数据。数据将被写入未加密的其他分区。通过这种方式，软件可以以相同的方式访问加密和非加密的闪存.</p>
<p>当 <code>write_encrypted</code> 参数设置为 true 时，<code>esp_spi_flash_write</code> 函数将写入数据。否则，数据将以未加密的方式写入.</p>
<p>ROM 函数 <code>esp_rom_spiflash_write_encrypted</code> 将加密数据写入闪存，ROM 函数 <code>SPIWrite</code> 将未加密写入闪存。(esp-idf 应用程序不支持这些功能).</p>
<p>未加密数据的最小写入大小为 4 个字节(对齐为 4 个字节)。由于数据是以块为单位加密的，因此加密数据的最小写入大小为 16 字节(对齐为16字节).</p>
<h2 id="4-更像加密的-Flash"><a href="#4-更像加密的-Flash" class="headerlink" title="4 更像加密的 Flash"></a>4 更像加密的 Flash</h2><h3 id="4-1-OTA-更新"><a href="#4-1-OTA-更新" class="headerlink" title="4.1 OTA 更新"></a>4.1 OTA 更新</h3><p>只要使用 <code>esp_partition_write</code> 函数，对加密分区的 OTA 更新将自动加密写入.</p>
<h3 id="4-2-串口烧录"><a href="#4-2-串口烧录" class="headerlink" title="4.2 串口烧录"></a>4.2 串口烧录</h3><p><code>FLASH_CRYPT_CNT efuse</code> 允许通过串口烧录(或其他物理方法)使用新的明文数据更新闪存，最多 3 次.</p>
<p>该过程涉及烧录明文数据，然后碰撞 <code>FLASH_CRYPT_CNT efuse</code> 的值，这会导致引导加载程序重新加密此数据.</p>
<h4 id="4-2-1-限制更新"><a href="#4-2-1-限制更新" class="headerlink" title="4.2.1 限制更新"></a>4.2.1 限制更新</h4><p>这种类型只有 4 个明文串行更新周期，包括初始加密闪存.</p>
<p>禁用第四次加密后，<code>FLASH_CRYPT_CNT efuse</code> 的最大值为 0xFF，永久禁用加密.</p>
<p>通过预生成的 Flash 加密密钥使用 OTA 更新或重新刷新可以超过此限制.</p>
<h4 id="4-2-2-串口烧录的注意事项"><a href="#4-2-2-串口烧录的注意事项" class="headerlink" title="4.2.2 串口烧录的注意事项"></a>4.2.2 串口烧录的注意事项</h4><ul>
<li>通过串口重新烧录时，重新刷新最初用明文数据写入的每个分区(包括 bootloader)。可以跳过不是“当前选择的” OTA 分区的应用程序分区(除非在那里找到明文应用程序映像，否则不会重新加密这些分区.)但是，标有“加密”标志的任何分区都将无条件地重新分区。加密，意味着任何已加密的数据将被加密两次并被破坏.<ul>
<li>使用 <code>make flash</code> 应烧录所有需要闪存的分区.</li>
</ul>
</li>
<li>如果启用了安全启动，则除非您使用“可重新启动”选项进行安全启动，否则无法通过串口重新刷新纯文本数据。请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html#flash-encryption-and-secure-boot" target="_blank" rel="noopener">Flash加密和安全启动</a>.</li>
</ul>
<h3 id="4-3-串口重新烧录程序"><a href="#4-3-串口重新烧录程序" class="headerlink" title="4.3 串口重新烧录程序"></a>4.3 串口重新烧录程序</h3><ul>
<li>正常的构建应用程序.</li>
<li>正常的使用明文数据刷新设备 (make flash 或 esptool.py 命令.)闪存所有先前加密的分区，包括引导加载程序(参见上一节).</li>
<li>此时，设备将无法启动(消息为 flash read err，1000)，因为它希望看到加密的引导加载程序，但引导加载程序是纯文本.</li>
<li>通过运行命令 <code>espefuse.py burn_efuse FLASH_CRYPT_CNT</code> 来刻录 <code>FLASH_CRYPT_CNT efuse</code>。 <code>espefuse.py</code> 会自动将位数递增 1，从而禁用加密.</li>
<li>重置设备，它将重新加密明文分区，然后再次刻录 <code>FLASH_CRYPT_CNT efuse</code> 以重新启用加密.</li>
</ul>
<h4 id="4-3-1-禁用串口更新"><a href="#4-3-1-禁用串口更新" class="headerlink" title="4.3.1 禁用串口更新"></a>4.3.1 禁用串口更新</h4><p>要防止通过串口进行进一步的明文更新，请在启用闪存加密后(即首次启动完成后)使用 <code>espefuse.py</code> 写保护 <code>FLASH_CRYPT_CNT efuse</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espefuse.py --port PORT write_protect_efuse FLASH_CRYPT_CNT</span><br></pre></td></tr></table></figure>

<p>这可以防止进一步修改以禁用或重新启用闪存加密.</p>
<h3 id="4-4-通过预生成的-Flash-加密密钥重新烧录"><a href="#4-4-通过预生成的-Flash-加密密钥重新烧录" class="headerlink" title="4.4 通过预生成的 Flash 加密密钥重新烧录"></a>4.4 通过预生成的 Flash 加密密钥重新烧录</h3><p>可以在主机上预生成闪存加密密钥，并将其刻录到 ESP32 的 efuse 密钥块中。这允许数据在主机上预加密并烧录到 ESP32，而无需明文闪存更新.</p>
<p>这对于开发很有用，因为它消除了 4 次刷新限制。它还允许在启用安全启动的情况下重新刷新应用程序，因为每次都不需要重新启动引导加载程序.</p>
<blockquote>
<p>此方法仅用于协助开发，而不用于生产设备。如果为生产预生成闪存加密，请确保密钥是从高质量的随机数源生成的，并且不要跨多个设备共享相同的闪存加密密钥.</p>
</blockquote>
<h4 id="4-4-1-预生成-Flash-加密密钥"><a href="#4-4-1-预生成-Flash-加密密钥" class="headerlink" title="4.4.1 预生成 Flash 加密密钥"></a>4.4.1 预生成 Flash 加密密钥</h4><p>Flash 加密密钥是 32 字节的随机数据。您可以使用 <code>espsecure.py</code> 生成随机密钥:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espsecure.py generate_flash_encryption_key my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure>

<p>(这些数据的随机性仅与操作系统一样好，而且是Python安装的随机数据源.)</p>
<p>或者，如果您使用安全启动并具有安全启动签名密钥，则可以生成安全启动专用签名密钥的确定性SHA-256摘要，并将其用作闪存加密密钥:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espsecure.py digest_private_key --keyfile secure_boot_signing_key.pem my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure>

<p>(如果为安全启动启用可重新映射模式，则使用相同的 32 个字节作为安全启动摘要键.)</p>
<p>以这种方式从安全启动签名密钥生成闪存加密密钥意味着您只需要存储一个密钥文件。然而，该方法根本不适用于生产设备.</p>
<h4 id="4-4-2-刻录-Flash-加密密钥"><a href="#4-4-2-刻录-Flash-加密密钥" class="headerlink" title="4.4.2 刻录 Flash 加密密钥"></a>4.4.2 刻录 Flash 加密密钥</h4><p>生成闪存加密密钥后，需要将其刻录到 ESP32 的 efuse 密钥块。这必须在首次加密启动之前完成，否则 ESP32 将生成软件无法访问或修改的随机密钥.</p>
<p>要将密钥刻录到设备(仅限一次):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espefuse.py --port PORT burn_key flash_encryption my_flash_encryption_key.bin</span><br></pre></td></tr></table></figure>

<h4 id="4-4-3-带有预生成密钥的第一次烧录"><a href="#4-4-3-带有预生成密钥的第一次烧录" class="headerlink" title="4.4.3 带有预生成密钥的第一次烧录"></a>4.4.3 带有预生成密钥的第一次烧录</h4><p>烧录密钥后，按照与默认 Flash 加密初始化相同的步骤操作，并为第一次启动时刷新纯文本图像。引导加载程序将使用预先烧制的密钥启用闪存加密并加密所有分区.</p>
<h4 id="4-4-4-使用预生成密钥重新烧录"><a href="#4-4-4-使用预生成密钥重新烧录" class="headerlink" title="4.4.4 使用预生成密钥重新烧录"></a>4.4.4 使用预生成密钥重新烧录</h4><p>在首次启动时启用加密后，重新烧录加密镜像需要额外的手动步骤。这是我们预先加密我们希望在闪存中更新的数据的地方.</p>
<p>假设这是用于刷新明文数据的常规命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esptool.py --port &#x2F;dev&#x2F;ttyUSB0 --baud 115200 write_flash 0x10000 build&#x2F;my-app.bin</span><br></pre></td></tr></table></figure>

<p>二进制应用程序映像 build/my-app.bin 写入偏移量 0x10000。此文件名和偏移量需要用于加密数据，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espsecure.py encrypt_flash_data --keyfile my_flash_encryption_key.bin --address 0x10000 -o build&#x2F;my-app-encrypted.bin build&#x2F;my-app.bin</span><br></pre></td></tr></table></figure>

<p>此示例命令将使用提供的密钥加密 my-app.bin，并生成加密文件 my-app-encrypted.bin。确保 address 参数与计划闪存二进制文件的地址匹配.</p>
<p>然后，使用esptool.py刷新加密的二进制文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esptool.py --port &#x2F;dev&#x2F;ttyUSB0 --baud 115200 write_flash 0x10000 build&#x2F;my-app-encrypted.bin</span><br></pre></td></tr></table></figure>

<p>不需要进一步的步骤或 efuse 操作，因为我们闪存时数据已经加密.</p>
<h2 id="5-禁用-Flash-加密"><a href="#5-禁用-Flash-加密" class="headerlink" title="5 禁用 Flash 加密"></a>5 禁用 Flash 加密</h2><p>如果由于某种原因意外启用了闪存加密，则下一次明文数据闪存将使ESP32软化(设备将连续重启，打印错误闪存读错误， 1000).</p>
<p>您可以通过编写 <code>FLASH_CRYPT_CNT efuse</code> 再次禁用闪存加密:</p>
<ul>
<li>首先，运行 <code>make menuconfig</code> 并取消选中“安全功能”下的“启用闪存加密启动”.</li>
<li>退出 <code>menuconfig</code> 并保存新配置.</li>
<li>再次运行 <code>make menuconfig</code> 并仔细检查你是否真的禁用了这个选项！ 如果启用此选项，则引导加载程序将在引导时立即重新启用加密.</li>
<li>运行 <code>make flash</code> 以构建并刷新新的引导加载程序和应用程序，而不启用闪存加密.</li>
<li>运行 <code>espefuse.py</code> (在 components/esptool_py/esptool 中)以禁用 <code>FLASH_CRYPT_CNT efuse</code>)::</li>
</ul>
<p>重置 ESP32 并禁用闪存加密，引导加载程序将正常启动.</p>
<h2 id="6-Flash-加密的局限性"><a href="#6-Flash-加密的局限性" class="headerlink" title="6 Flash 加密的局限性"></a>6 Flash 加密的局限性</h2><p>Flash 加密可防止加密闪存的明文读出，从而保护固件免受未经授权的读取和修改.了解闪存加密系统的局限性非常重要:</p>
<ul>
<li>Flash 加密仅与密钥一样强大.因此，我们建议在首次启动时在设备上生成密钥(默认行为).如果在设备外生成密钥(请参阅通过预生成的 Flash 加密密钥重新刷新)，请确保遵循正确的步骤.</li>
<li>并非所有数据都是加密存储的.如果在闪存上存储数据，请检查您使用的方法(库，API 等)是否支持闪存加密.</li>
<li>Flash 加密不会阻止攻击者理解闪存的高级布局.这是因为相同的 AES 密钥用于每对相邻的 16 字节 AES 块.当这些相邻的 16 字节块包含相同的内容(例如空或填充区域)时，这些块将加密以产生匹配的加密块对.这可能允许攻击者在加密设备之间进行高级别比较(即判断两个设备是否可能运行相同的固件版本).</li>
<li>出于同样的原因，攻击者总能知道一对相邻的 16 字节块 (32 字节对齐)何时包含相同的内容.如果将敏感数据存储在闪存中，请记住这一点，设计闪存存储器，以免发生这种情况(使用计数器字节或每 16 字节一些其他不相同的值就足够了).</li>
</ul>
<h2 id="7-Flash-加密和安全启动"><a href="#7-Flash-加密和安全启动" class="headerlink" title="7 Flash 加密和安全启动"></a>7 Flash 加密和安全启动</h2><p>建议一起使用闪存加密和安全启动。但是，如果启用了安全启动，则重新刷新设备会有其他限制:</p>
<ul>
<li>OTA 更新不受限制(前提是新应用程序使用安全启动签名密钥正确签名).</li>
<li>只有选择了 Reflashable Secure Boot 模式并且预先生成安全启动密钥并将其刻录到 ESP32 (参见安全启动文档)，才能进行明文串口烧录更新。在此配置中， make bootloader 将生成预先消化的引导加载程序和安全引导摘要文件，以便在偏移量 0x0 处烧录。当遵循明文串行重新刷新步骤时，必须在烧录其他明文数据之前重新刷新该文件.</li>
<li>如果未重新启动引导加载程序，仍可以通过预生成的 Flash 加密密钥重新刷新。重新刷新引导加载程序需要在安全引导配置中启用相同的 Reflashable 选项.</li>
</ul>
<h2 id="8-使用没有安全启动的-Flash-加密"><a href="#8-使用没有安全启动的-Flash-加密" class="headerlink" title="8 使用没有安全启动的 Flash 加密"></a>8 使用没有安全启动的 Flash 加密</h2><p>如果在没有安全启动的情况下使用闪存加密，则可以使用串行重新烧录加载未经授权的代码。有关详细信息，请参阅串行烧录 然后，这个未授权的代码可以读取所有加密的分区(以解密的形式)，使闪存加密无效。这可以通过写保护 <code>FLASH_CRYPT_CNT efuse</code> 来避免，从而禁止串口重新烧录。FLASH_CRYPT_CNT可以使用命令对efuse进行写保护:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espefuse.py --port PORT write_protect_efuse FLASH_CRYPT_CNT</span><br></pre></td></tr></table></figure>

<p>或者，应用程序可以在其启动过程中调用 <code>esp_flash_write_protect_crypt_cnt()</code>.</p>
<h2 id="9-Flash-加密高级功能"><a href="#9-Flash-加密高级功能" class="headerlink" title="9 Flash 加密高级功能"></a>9 Flash 加密高级功能</h2><p>以下信息对于高级使用闪存加密非常有用:</p>
<h3 id="9-1-加密分区标志"><a href="#9-1-加密分区标志" class="headerlink" title="9.1 加密分区标志"></a>9.1 加密分区标志</h3><p>某些分区默认是加密的。否则，可以将任何分区标记为需要加密:</p>
<p>在分区表描述 CSV 文件中，有一个标志字段.</p>
<p>通常留空，如果在此字段中写入 “encrypted” ，则分区将在分区表中标记为已加密，此处写入的数据将被视为已加密(与应用程序分区相同):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000</span><br><span class="line">factory,  app,  factory, 0x10000, 1M</span><br><span class="line">secret_data, 0x40, 0x01, 0x20000, 256K, encrypted</span><br></pre></td></tr></table></figure>

<ul>
<li>默认分区表都不包含任何加密数据分区.</li>
<li>没有必要将 “app” 分区标记为已加密，它们始终被视为已加密.</li>
<li>如果未启用闪存加密，则“加密”标志不执行任何操作.</li>
<li>如果您希望保护此数据不受物理访问读取或修改的影响，则可以将 phy_init 数据标记为可选的phy分区.</li>
<li>无法将 nvs 分区标记为已加密.</li>
</ul>
<h3 id="9-2-启用-UART-Bootloader-加密-解密"><a href="#9-2-启用-UART-Bootloader-加密-解密" class="headerlink" title="9.2 启用 UART Bootloader 加密/解密"></a>9.2 启用 UART Bootloader 加密/解密</h3><p>默认情况下，首次启动时，闪存加密过程将刻录 <code>DISABLE_DL_ENCRYPT</code> ， <code>DISABLE_DL_DECRYPT</code> 和 <code>DISABLE_DL_CACHE</code> :</p>
<p>在 UART 引导加载程序引导模式下运行时， <code>DISABLE_DL_ENCRYPT</code> 禁用闪存加密操作.<br> <code>DISABLE_DL_DECRYPT</code> 在 UART 引导加载程序模式下运行时禁用透明闪存解密，即使 <code>FLASH_CRYPT_CNT efuse</code> 设置为在正常操作中启用它也是如此.<br>在 UART 引导加载程序模式下运行时， <code>DISABLE_DL_CACHE</code> 禁用整个 MMU 闪存缓存.<br>可以仅刻录其中一些 efuses，并在第一次引导之前对其余部分进行写保护(使用未设置值 0)，以便保留它们。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">espefuse.py --port PORT burn_efuse DISABLE_DL_DECRYPT</span><br><span class="line">espefuse.py --port PORT write_protect_efuse DISABLE_DL_ENCRYPT</span><br></pre></td></tr></table></figure>

<p>(注意，这些 efuse 中的所有 3 个都是通过一个写保护位禁用的，因此写保护将保护所有这些保护位.因此，在写保护之前必须设置任何位.)</p>
<blockquote>
<p>由于 esptool.py 不支持写入或读取加密闪存，因此写保护这些 efuse 以保持它们不被设置目前不是非常有用.</p>
</blockquote>
<blockquote>
<p>如果未设置 <code>DISABLE_DL_DECRYPT(0)</code>， 这有效地使闪存加密无效，因为具有物理访问权限的攻击者可以使用UART引导加载程序模式(使用自定义存根代码)来读取闪存内容.</p>
</blockquote>
<h3 id="9-3-设置-FLASH-CRYPT-CONFIG"><a href="#9-3-设置-FLASH-CRYPT-CONFIG" class="headerlink" title="9.3 设置 FLASH_CRYPT_CONFIG"></a>9.3 设置 <code>FLASH_CRYPT_CONFIG</code></h3><p><code>FLASH_CRYPT_CONFIG efuse</code> 确定闪存加密密钥中用块偏移“调整”的位数。有关详细信息，请参阅 Flash 加密算法.</p>
<p>引导加载程序的首次引导始终将此值设置为最大 0xF.</p>
<p>可以手动编写这些 efuse， 并在首次启动之前写保护，以便选择不同的调整值。不建议这样做.</p>
<p>强烈建议在值为零时永远不要写保护 <code>FLASH_CRYPT_CONFIG</code>。如果此 efuse 设置为零，则不会调整闪存加密密钥中的任何位，并且闪存加密算法等同于 AES ECB 模式.</p>
<h2 id="10-技术细节"><a href="#10-技术细节" class="headerlink" title="10 技术细节"></a>10 技术细节</h2><p>以下部分提供有关闪存加密操作的一些参考信息.</p>
<h3 id="10-1-FLASH-CRYPT-CNT-efuse"><a href="#10-1-FLASH-CRYPT-CNT-efuse" class="headerlink" title="10.1 FLASH_CRYPT_CNT efuse"></a>10.1 <code>FLASH_CRYPT_CNT efuse</code></h3><p><code>FLASH_CRYPT_CNT</code> 是一个 8 位 efuse 字段，用于控制闪存加密。Flash 加密根据此 efuse 中设置为 “1” 的位数启用或禁用:</p>
<ul>
<li>设置偶数位 (0,2,4,6,8) 时:禁用闪存加密，无法解密任何加密数据.<ul>
<li>如果引导加载程序是使用“启动时启用闪存加密”构建的，那么它将看到这种情况并立即重新加密闪存，无论它何时找到未加密的数据.完成后，它会将 efuse 中的另一位设置为 “1”，这意味着现在设置了奇数个位.<ul>
<li>在第一次纯文本引导时，位计数具有全新值 0，并且引导加载程序在加密后将其更改为位计数 1 (值 0x01).</li>
<li>在下一次明文闪存更新后，将位计数手动更新为 2 (值 0x03).重新加密引导加载程序后，将 efuse 位计数更改为 3 (值 0x07).</li>
<li>在下一个明文闪存之后，将位计数手动更新为 4 (值 0x0F).重新加密引导加载程序后，将 efuse 位计数更改为 5 (值 0x1F).</li>
<li>在最后的明文闪存之后，位计数被手动更新为 6 (值 0x3F).重新加密引导加载程序后，将 efuse 位计数更改为7 (值 0x7F).</li>
</ul>
</li>
</ul>
</li>
<li>设置奇数位 (1,3,5,7) 时:启用透明读取加密闪存.</li>
<li>设置完所有 8 位后(efuse 值 0xFF):禁用透明读取加密闪存，永久无法访问任何加密数据。Bootloader 通常会检测到这种情况并停止.为避免使用此状态加载未经授权的代码，必须使用安全引导或 <code>FLASH_CRYPT_CNT efuse</code> 必须写保护.</li>
</ul>
<h3 id="10-2-Flash-加密算法"><a href="#10-2-Flash-加密算法" class="headerlink" title="10.2 Flash 加密算法"></a>10.2 Flash 加密算法</h3><ul>
<li><p>AES-256 以 16 字节数据块运行.闪存加密引擎以 32 字节块，两个串联的 AES 块加密和解密数据.</p>
</li>
<li><p>AES 算法在闪存加密中反转使用，因此闪存加密“加密”操作是 AES 解密，“解密”操作是AES加密.这是出于性能原因，并未改变算法的有效性.</p>
</li>
<li><p>主闪存加密密钥存储在 efuse(BLOCK1) 中，默认情况下不受进一步写入或软件读取的影响.</p>
</li>
<li><p>每个 32 字节块(两个相邻的 16 字节 AES 块)使用唯一密钥加密.密钥源自efuse中的主闪存加密密钥，与闪存中该块的偏移量进行异或(“键调整”).</p>
</li>
<li><p>具体的调整取决于 <code>FLASH_CRYPT_CONFIG efuse</code> 的设置.这是一个 4 位 efuse， 其中每个位都能对特定范围的关键位进行异或运算:</p>
<ul>
<li>位 1， 该值的 0-66 位被异或.</li>
<li>位 2， 该值的 67-131 位被异或.</li>
<li>位 3， 该值的 132-194 被异或.</li>
<li>位 4， 该值的 195-256 位被异或.<br>建议始终保留 <code>FLASH_CRYPT_CONFIG</code> 以设置默认值 0xF，以便所有关键位与块偏移进行异或.有关详细信息，请参阅设置 <code>FLASH_CRYPT_CONFIG</code>.</li>
</ul>
</li>
<li><p>块偏移的高 19 位(第 5 位到第 23 位)与主闪存加密密钥进行异或.选择此范围有两个原因:最大闪存大小为 16MB(24 位)，每个块为 32 字节，因此最低有效 5 位 始终为零.</p>
</li>
<li><p>从 19 个块偏移位中的每一个到闪存加密密钥的 256 位存在特定映射，以确定哪个位与哪个位进行异或.请参阅 espsecure.py 源代码中的变量 <code>_FLASH_ENCRYPTION_TWEAK_PATTERN</code> 以获取完整的映射.</p>
</li>
<li><p>要查看 Python 中实现的完整闪存加密算法，请参阅 espsecure.py 源代码中的 <code>_flash_encryption_operation()</code> 函数.</p>
</li>
</ul>
<h2 id="11-参考资料"><a href="#11-参考资料" class="headerlink" title="11 参考资料"></a>11 参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（六）深度睡眠唤醒存根</title>
    <url>/InfiniteYuanBlog/2018/09/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E7%9D%A1%E7%9C%A0%E5%94%A4%E9%86%92%E5%AD%98%E6%A0%B9/</url>
    <content><![CDATA[<h1 id="深度睡眠唤醒存根"><a href="#深度睡眠唤醒存根" class="headerlink" title="深度睡眠唤醒存根"></a>深度睡眠唤醒存根</h1><p>ESP32 支持在深度睡眠时运行“深度睡眠唤醒存根”。芯片唤醒后立即运行此功能 - 在任何正常初始化，引导加载程序或 ESP-IDF 代码运行之前。唤醒存根运行后，SoC 可以返回休眠状态或继续正常启动 ESP-IDF。</p>
<p>深度睡眠唤醒存根代码被加载到“RTC 快速存储器”中，它使用的任何数据也必须加载到 RTC 存储器中。RTC 存储区域在深度睡眠期间保持其内容。</p>
<a id="more"></a>

<h2 id="唤醒存根规则"><a href="#唤醒存根规则" class="headerlink" title="唤醒存根规则"></a>唤醒存根规则</h2><p>必须仔细编写唤醒存根代码:</p>
<ul>
<li>由于 SoC 刚刚从睡眠状态中醒来，大多数外设都处于复位状态。SPI Flash 未映射。</li>
<li>唤醒存根代码只能调用 ROM 中或加载到 RTC 快速存储器中实现的功能(见下文)。</li>
<li>唤醒存根代码只能访问 RTC 存储器中加载的数据。所有其他 RAM 将无法使用并具有随机内容。唤醒存根可以使用其他 RAM 进行临时存储，但是当 SoC 重新进入休眠状态或启动 ESP-IDF 时,内容将被覆盖。</li>
<li>RTC 内存必须包含存根使用的任何只读数据(.rodata)。</li>
<li>每当 SoC 重新启动时，RTC 存储器中的数据都会被初始化，除非从深度睡眠中唤醒。从深度睡眠中醒来时，保持睡眠前存在的值。</li>
<li>唤醒存根代码是 esp-idf 应用程序的一部分。在 esp-idf 的正常运行期间，函数可以调用唤醒存根函数或访问 RTC 存储器。就好像这些是应用程序的常规部分。</li>
</ul>
<h2 id="实现存根"><a href="#实现存根" class="headerlink" title="实现存根"></a>实现存根</h2><p>esp-idf 中的唤醒存根的函数 <code>esp_wake_deep_sleep()</code>。只要 SoC 从深度睡眠中唤醒，该函数就会运行。esp-idf 中提供了此函数的默认版本，但默认函数是弱链接的，因此如果您的应用程序包含名为 <code>esp_wake_deep_sleep()</code> 的函数，那么这将覆盖这个默认版本。</p>
<p>如果提供自定义唤醒存根，它首先要做的就是调用 <code>esp_default_wake_deep_sleep()</code>。</p>
<p>没有必要在您的应用程序中实现 <code>esp_wake_deep_sleep()</code> 以使用深度睡眠。只有你想在唤醒时立即有特殊行为才有必要。</p>
<p>如果要在运行时在不同的深度睡眠存根之间进行交换，也可以通过调用 <code>esp_set_deep_sleep_wake_stub()</code> 函数来执行此操作。如果仅使用默认的 <code>esp_wake_deep_sleep()</code> 函数，则不需要这样做。</p>
<p>所有这些函数都在 components/esp32 下的 <code>esp_deepsleep.h</code> 头文件中声明。</p>
<h2 id="将代码加载到-RTC-内存中"><a href="#将代码加载到-RTC-内存中" class="headerlink" title="将代码加载到 RTC 内存中"></a>将代码加载到 RTC 内存中</h2><p>唤醒存根代码必须驻留在 RTC 快速存储器中。这可以通过两种方式之一完成。</p>
<p>第一种方法是使用 <code>RTC_IRAM_ATTR</code> 属性将函数放入 RTC 内存:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RTC_IRAM_ATTR esp_wake_deep_sleep(void) &#123;</span><br><span class="line">    esp_default_wake_deep_sleep();</span><br><span class="line">    &#x2F;&#x2F; Add additional functionality here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法是将函数放入名称以 <code>rtc_wake_stub</code> 开头的任何源文件中。文件名 <code>rtc_wake_stub *</code> 中其内容将通过链接器自动放入 <code>RTC</code> 存储器中。</p>
<p>对于非常简短的代码，或者对于要混合“普通”和 “RTC” 代码的源文件，第一种方法更简单。当你想为 <code>RTC</code> 内存编写更长的代码时，第二种方法更简单。</p>
<h2 id="将数据加载到-RTC-内存中"><a href="#将数据加载到-RTC-内存中" class="headerlink" title="将数据加载到 RTC 内存中"></a>将数据加载到 RTC 内存中</h2><p>存根代码使用的数据必须驻留在 <code>RTC</code> 慢速存储器中。ULP 也使用该存储器。</p>
<p>可以通过以下两种方式之一来指定此数据:</p>
<p>第一种方法是使用 <code>RTC_DATA_ATTR</code> 和 <code>RTC_RODATA_ATTR</code> 来指定应加载到 RTC 慢速内存中的任何数据(可写或只读，相应):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RTC_DATA_ATTR int wake_count;</span><br><span class="line"></span><br><span class="line">void RTC_IRAM_ATTR esp_wake_deep_sleep(void) &#123;</span><br><span class="line">    esp_default_wake_deep_sleep();</span><br><span class="line">    static RTC_RODATA_ATTR const char fmt_str[] &#x3D; &quot;Wake count %d\n&quot;;</span><br><span class="line">    ets_printf(fmt_str, wake_count++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过名为 <code>CONFIG_ESP32_RTCDATA_IN_FAST_MEM</code> 的 menuconfig 选项配置放置此数据的 RTC 存储区。此选项允许为 ULP 程序保留较慢的存储区域，一旦启用，标记为 <code>RTC_DATA_ATTR</code> 和 <code>RTC_RODATA_ATTR</code> 的数据将被放置在 RTC 快速存储器段中，否则将转至 RTC 慢速存储器（默认选项）。此选项取决于 <code>CONFIG_FREERTOS_UNICORE</code>，因为 RTC 快速存储器只能由 PRO_CPU 访问。</p>
<p>类似的属性 <code>RTC_FAST_ATTR</code> 和 <code>RTC_SLOW_ATTR</code> 用于指定将数据分别强制放入 <code>RTC_FAST</code> 和 <code>RTC_SLOW</code> 存储器。<code>PRO_CPU</code> 仅允许对标记为 <code>RTC_FAST_ATTR</code> 的数据进行访问，并且用户有责任确保它。</p>
<p>不幸的是，以这种方式使用的任何字符串常量必须声明为数组并用 <code>RTC_RODATA_ATTR</code> 标记，如上例所示。</p>
<p>第二种方法是将数据放入名称以 <code>rtc_wake_stub</code> 开头的任何源文件中。</p>
<p>例如，<code>rtc_wake_stub_counter.c</code> 中的等效示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int wake_count;</span><br><span class="line"></span><br><span class="line">void RTC_IRAM_ATTR esp_wake_deep_sleep(void) &#123;</span><br><span class="line">    esp_default_wake_deep_sleep();</span><br><span class="line">    ets_printf(&quot;Wake count %d\n&quot;, wake_count++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您需要使用字符串或编写其他更复杂的代码，第二种方法是更好的选择。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十一）高级中断</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E9%AB%98%E7%BA%A7%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h1 id="高级中断"><a href="#高级中断" class="headerlink" title="高级中断"></a>高级中断</h1><p>Xtensa 架构支持 32 个中断,分为 8 个级别,以及各种异常. 在 ESP32 上,中断复用器允许使用<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/intr_alloc.html" target="_blank" rel="noopener">中断分配器</a>将大多数中断源路由到这些中断. 通常,中断将以 C 语言写入,但 ESP-IDF 也允许在汇编中写入高级中断,从而允许非常低的中断延迟.</p>
<a id="more"></a>

<h2 id="中断级别"><a href="#中断级别" class="headerlink" title="中断级别"></a>中断级别</h2><table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">标识</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">N/A</td>
<td align="center">异常和0级中断. 由 ESP-IDF 处理</td>
</tr>
<tr>
<td align="center">2-3</td>
<td align="center">N/A</td>
<td align="center">中级中断. 由 ESP-IDF 处理</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">xt_highint4</td>
<td align="center">通常由 ESP-IDF 调试逻辑使用</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">xt_highint4</td>
<td align="center">随意使用</td>
</tr>
<tr>
<td align="center">NMI</td>
<td align="center">xt_nmi</td>
<td align="center">随意使用</td>
</tr>
<tr>
<td align="center">dbg</td>
<td align="center">xt_debugexception</td>
<td align="center">调试异常. 被称为例如 BREAK 指令.</td>
</tr>
</tbody></table>
<p>使用这些标识是通过创建一个程序集文件(后缀 .S)并定义命名符号来完成的,如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    .section .iram1,&quot;ax&quot;</span><br><span class="line">    .global     xt_highint5</span><br><span class="line">    .type       xt_highint5,@function</span><br><span class="line">    .align      4</span><br><span class="line">xt_highint5:</span><br><span class="line">    ... your code here</span><br><span class="line">    rsr     a0, EXCSAVE_5</span><br><span class="line">    rfi     5</span><br></pre></td></tr></table></figure>

<p>有关实际示例,请参阅 <code>components/esp32/panic_highint_hdl.S</code> 文件; Panic 处理程序中断在那里实现.</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>不要从高级别中断调用 C 代码; 因为这些中断仍然在关键部分运行,这可能会导致崩溃. (恐慌处理程序中断会调用正常的C代码,但这没关系,因为之后无意返回正常的代码流.)</p>
</li>
<li><p>确保汇编代码被链接.如果中断处理程序符号是代码中其余代码使用的唯一符号,则链接器将采用默认的ISR,而不是将程序集文件链接到最终项目. 要解决此问题,请在汇编文件中定义符号,如下所示：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     .global ld_include_my_isr_file</span><br><span class="line">ld_include_my_isr_file:</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>(此符号在此处称为 <code>ld_include_my_isr_file</code>,但可以具有未在其他任何位置定义的任意名称.)然后,在 <code>component.mk</code> 中,将此文件作为未解析的符号添加到 ld 命令行参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPONENT_ADD_LDFLAGS :&#x3D; -u ld_include_my_isr_file</span><br></pre></td></tr></table></figure>

<p>这应该导致链接器始终包含定义 <code>ld_include_my_isr_file</code> 的文件,从而导致始终链接 ISR.</p>
<ul>
<li>可以使用 <code>esp_intr_alloc</code> 和相关函数路由和处理高级中断. 但是,<code>esp_intr_alloc</code> 的处理程序和处理程序参数必须为 NULL.</li>
<li>理论上,中等优先级中断也可以这种方式处理. 目前, ESP-IDF 不支持这一点.</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/hlinterrupts.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十三）外部 RAM</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%A4%96%E9%83%A8%20RAM/</url>
    <content><![CDATA[<h1 id="外部-RAM"><a href="#外部-RAM" class="headerlink" title="外部 RAM"></a>外部 RAM</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ESP32 有几百 KiB 的内部 RAM，与 ESP32 的其余部分位于同一个芯片上。 出于某些目的，这是不够的，因此ESP32还能够使用高达 4MB 的外部 SPI RAM 存储器作为存储器。 外部存储器包含在存储器映射中，并且在某些限制内，可以与内部数据 RAM 相同的方式使用。</p>
<a id="more"></a>

<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>ESP32 支持与 SPI Flash 芯片并联的SPI（P）SRAM。 虽然 ESP32 能够支持多种类型的 RAM 芯片，但 ESP32 SDK 目前仅支持 ESP-PSRAM32 芯片。</p>
<p>ESP-PSRAM32 芯片是 1.8V 器件，只能与 1.8V 闪存器件并联使用。 确保在启动时将 MTDI 引脚设置为高信号电平，或者将 ESP32 中的保险丝编程为始终使用 1.8V 的 VDD_SIO 电平。 不这样做有损坏 PSRAM 和/或 Flash 芯片的风险。</p>
<p><strong>要将 ESP-PSRAM 芯片连接到 ESP32D0W *，请连接以下信号：</strong></p>
<ul>
<li>PSRAM /CE (pin 1) - ESP32 GPIO 16</li>
<li>PSRAM SO (pin 2) - flash DO</li>
<li>PSRAM SIO[2] (pin 3) - flash WP</li>
<li>PSRAM SI (pin 5) - flash DI</li>
<li>PSRAM SCLK (pin 6) - ESP32 GPIO 17</li>
<li>PSRAM SIO[3] (pin 7) - flash HOLD</li>
<li>PSRAM Vcc (pin 8) - ESP32 VCC_SDIO</li>
</ul>
<p>ESP32D2W * 芯片的连接是 TBD。</p>
<blockquote>
<p>Espressif 销售 ESP-WROVER 模块，该模块包含 ESP32,1.8V Flash 和集成在模块中的 ESP-PSRAM32，可以包含在最终产品 PCB 中。</p>
</blockquote>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p><strong>ESP-IDF 完全支持将外部存储器集成到您的应用程序中。 ESP-IDF 可以配置为以多种方式处理外部 RAM：</strong></p>
<ul>
<li>只初始化 RAM。 这允许应用程序通过解除指向外部 RAM 存储器区域（0x3F800000 及以上）的指针来手动放置数据。</li>
<li>初始化 RAM 并将其添加到功能分配器。 这允许程序使用 <code>heap_caps_malloc（size，MALLOC_CAP_SPIRAM）</code> 专门分配一块外部 RAM。 可以使用此内存，然后使用正常的 <code>free（）</code> 调用释放。</li>
<li>初始化 RAM，将其添加到功能分配器，并将内存添加到可由 <code>malloc（）</code> 返回的 RAM 池中。 这允许任何应用程序使用外部 RAM 而无需重写代码以使用 <code>heap_caps_malloc</code>。</li>
</ul>
<p>可以从 menuconfig 菜单中选择所有这些选项。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p><strong>使用外部 RAM 有一些限制：</strong></p>
<ul>
<li>禁用闪存缓存时（例如，因为正在写闪存），外部 RAM 也变得无法访问;对它的任何读取或写入都将导致非法的缓存访问异常。这也是 ESP-IDF 永远不会在外部 RAM 中分配任务堆栈的原因。</li>
<li>外部 RAM 不能用作存储 DMA 事务描述符的位置，也不能用作 DMA 传输的读取或写入缓冲区。必须使用 <code>heap_caps_malloc（size，MALLOC_CAP_DMA）</code> 分配将与 DMA 结合使用的任何缓冲区（并且可以使用标准的 <code>free（）</code> 调用释放。）</li>
<li>外部 RAM 使用与外部闪存相同的缓存区域。这意味着外部 RAM 中经常访问的变量几乎可以像内部 RAM 一样快速地读取和修改。但是，当访问大块数据（&gt;32K）时，缓存可能不足，速度将回落到外部 RAM 的访问速度。此外，访问大块数据可以“推出”缓存的闪存，可能会使代码执行速度变慢。</li>
<li>外部 RAM 不能用作任务堆栈内存;因此，<code>xTaskCreate</code> 和类似函数将始终为堆栈和任务 TCB 分配内部存储器，而 <code>xTaskCreateStatic</code> 类型函数将检查传递的缓冲区是否是内部的。但是，对于不以任何方式直接或间接调用 ROM 中的代码的任务， menuconfig 选项 <code>CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY</code> 将消除 <code>xTaskCreateStatic</code> 中的检查，从而允许外部 RAM 中的任务堆栈。但是，不建议使用此方法。</li>
</ul>
<p>因为有一些对内部存储器有特定需求的情况，但也可以使用 <code>malloc（）</code> 来耗尽内部存储器，因此有一个专门为无法从外部存储器中解析的请求而保留的池;分配任务堆栈，DMA 缓冲区和在禁用缓存时仍可访问的内存从此池中提取。此池的大小可在 menuconfig 中配置。</p>
<h2 id="芯片版本"><a href="#芯片版本" class="headerlink" title="芯片版本"></a>芯片版本</h2><p>ESP32 的某些修订存在一些问题，这些问题会对外部 RAM 的使用产生影响。 这些内容记录在 ESP32 ECO 文档中。 特别是， ESP-IDF 以下列方式处理提到的错误：</p>
<h3 id="ESP32-rev-v0"><a href="#ESP32-rev-v0" class="headerlink" title="ESP32 rev v0"></a>ESP32 rev v0</h3><p>ESP-IDF 没有针对此版本硅片中的错误的解决方法，它不能用于将外部 PSRAM 映射到 ESP32s 主存储器映射中。</p>
<h3 id="ESP32-rev-v1"><a href="#ESP32-rev-v1" class="headerlink" title="ESP32 rev v1"></a>ESP32 rev v1</h3><p>当某些机器指令序列在外部存储器位置 （ESP32 ECO 3.2） 上运行时，此芯片版本中的错误会带来危险。 为了解决这个问题，编译 ESP-IDF 的 gcc 编译器已经扩展了一个标志： -mfix-esp32-psram-cache-issue。 将此标志传递给命令行上的 gcc，编译器可以解决这些序列，并只输出可以安全执行的代码。</p>
<p>在 ESP-IDF 中，当您选择 <code>CONFIG_SPIRAM_CACHE_WORKAROUND</code> 时，将启用此标志。 ESP-IDF 还采取其他措施确保不使用 PSRAM 访问和违规指令集的组合：它链接到使用 gcc 标志重新编译的 Newlib 版本，不使用某些 ROM 函数并为 WiFi 分配静态内存叠加。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/external-ram.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十二）Bootloader (引导加载程序)</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89Bootloader%20(%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F)/</url>
    <content><![CDATA[<h1 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h1><p>引导加载程序执行以下功能：</p>
<ol>
<li>内部模块的最初初始配置;</li>
<li>根据分区表和 ota_data(如果有),选择要引导的应用程序分区;</li>
<li>将此映像加载到  RAM(IRAM 和 DRAM) 并将管理传输到它.</li>
</ol>
<p>引导加载程序位于 Flash 中的地址 0x1000.</p>
<a id="more"></a>

<h2 id="恢复出厂设置"><a href="#恢复出厂设置" class="headerlink" title="恢复出厂设置"></a>恢复出厂设置</h2><p>用户可以编写基本工作固件并将其加载到 factory 分区.接下来,通过 OTA(无线)更新固件.更新的固件将加载到 OTA 应用程序分区位置,并更新 OTA 数据分区以从此分区引导.如果您希望能够回滚到出厂固件并清除设置,则需要设置 <code>CONFIG_BOOTLOADER_FACTORY_RESET</code>.恢复出厂设置机制允许将设备重置为 factory 设置：</p>
<ul>
<li>清除一个或多个数据分区.</li>
<li>从 “factory” 分区启动.</li>
</ul>
<p><code>CONFIG_BOOTLOADER_DATA_FACTORY_RESET</code> 允许客户选择在执行恢复出厂设置时将擦除哪些数据分区.可以通过逗号分隔的可选空格指定分区的名称以便于阅读. (像这样：“nvs,phy_init,nvs_custom,……”).确保分区表中指定的名称和此处的名称相同.此处无法指定 “app” 类型的分区.</p>
<p><code>CONFIG_BOOTLOADER_OTA_DATA_ERASE</code> - 设备将在恢复出厂设置后从 “factory” 分区启动. OTA 数据分区将被清除.</p>
<p><code>CONFIG_BOOTLOADER_NUM_PIN_FACTORY_RESET</code> - 用于恢复出厂设置的 GPIO 输入数用于触发恢复出厂设置,此 GPIO 必须在复位时拉低以触发此操作.</p>
<p><code>CONFIG_BOOTLOADER_HOLD_TIME_GPIO</code> - 这是 GPIO 保持复位/测试模式的时间(默认为 5 秒).复位后,GPIO 必须在此段时间内保持低电平,然后才能执行恢复出厂设置或测试分区引导(如果适用).</p>
<p>分区表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,   Size, Flags</span><br><span class="line"># Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild</span><br><span class="line">nvs,      data, nvs,     0x9000,   0x4000</span><br><span class="line">otadata,  data, ota,     0xd000,   0x2000</span><br><span class="line">phy_init, data, phy,     0xf000,   0x1000</span><br><span class="line">factory,  0,    0,       0x10000,  1M</span><br><span class="line">test,     0,    test,    ,         512K</span><br><span class="line">ota_0,    0,    ota_0,   ,         512K</span><br><span class="line">ota_1,    0,    ota_1,   ,         512K</span><br></pre></td></tr></table></figure>

<h2 id="从-TEST-固件启动"><a href="#从-TEST-固件启动" class="headerlink" title="从 TEST 固件启动"></a>从 TEST 固件启动</h2><p>用户可以编写一个特殊的固件用于生产中的测试,并根据需要运行它. 分区表还需要一个专用分区用于此测试固件(请参阅分区表). 要触发测试应用,您需要设置 <code>CONFIG_BOOTLOADER_APP_TEST</code>.</p>
<p><code>CONFIG_BOOTLOADER_NUM_PIN_APP_TEST</code> - 引导TEST 分区的 GPIO 输入的编号. 选定的 GPIO 将配置为启用内部上拉的输入. 要触发测试应用程序,必须在复位时将此 GPIO 拉低. 停用 GPIO 输入并重启设备后,旧应用程序将启动(工厂或任何 OTA 位置的应用程序).</p>
<p><code>CONFIG_BOOTLOADER_HOLD_TIME_GPIO</code> - 这是 GPIO 的复位/测试模式保持时间(默认为 5 秒). 复位后,GPIO 必须在此段时间内保持低电平,然后才能执行恢复出厂设置或测试分区引导(如果适用).</p>
<h2 id="自定义引导加载程序"><a href="#自定义引导加载程序" class="headerlink" title="自定义引导加载程序"></a>自定义引导加载程序</h2><p>当前的引导加载程序实现允许客户覆盖它. 为此,您必须复制文件夹 <code>/esp-idf/components/bootloader</code>,然后编辑 <code>/your_project/components/bootloader/subproject/main/bootloader_main.c</code>. 在引导加载程序空间中,您无法使用其他组件的驱动程序和函数. 如有必要,则应将所需功能放在文件夹引导程序中(请注意,这会增加其大小). 有必要监视其大小,因为内存中可能存在覆盖层,导致损坏. 目前,引导加载程序仅限于地址 0x8000 的分区表.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/bootloader.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十五）ESP-MESH</title>
    <url>/InfiniteYuanBlog/2019/02/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89ESP-MESH/</url>
    <content><![CDATA[<h1 id="ESP-MESH"><a href="#ESP-MESH" class="headerlink" title="ESP-MESH"></a>ESP-MESH</h1><p>本指南提供有关 ESP-MESH 协议的信息。有关 API 使用的更多信息，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/network/esp_mesh.html" target="_blank" rel="noopener">MESH API 参考</a>。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ESP-MESH 是一种基于 Wi-Fi 协议构建的网络协议。ESP-MESH 允许在大的物理区域（室内和室外）上分布的多个设备（以下称为节点）在单个 WLAN（无线局域网）下互连。ESP-MESH 具有自组织和自我修复功能，意味着网络可以自主构建和维护。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://img-blog.csdnimg.cn/20190201111240103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="传统的 Wi-Fi 网络架构"><br>传统的 Wi-Fi 网络是一点对多点网络，其中称为接入点（AP）的单个中心节点直接连接到所有其他节点（station）。AP 负责仲裁和转发节点之间的传输。一些 AP 还通过路由器中继与外部 IP 网络的传输。传统的 Wi-Fi 网络由于要求每个站必须在一定范围内以直接与 AP 连接而具有有限覆盖区域的缺点。此外，传统的 Wi-Fi 网络易于过载，因为网络中允许的最大站数受到 AP 容量的限制。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201113539338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>ESP-MESH 与传统的 Wi-Fi 网络的不同之处在于节点不需要连接到中心节点。相反，允许节点与相邻节点连接。节点相互负责传递彼此的传输。这允许 ESP-MESH 网络具有更大的覆盖区域，因为节点仍然可以实现互连而无需在中心节点的范围内。同样，ESP-MESH 也不易受到过载的影响，因为网络上允许的节点数量不再受单个中心节点的限制。</p>
<a id="more"></a>

<h2 id="ESP-MESH概念"><a href="#ESP-MESH概念" class="headerlink" title="ESP-MESH概念"></a>ESP-MESH概念</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>节点</td>
<td>任何属于或可以属于 ESP-MESH 网络的设备</td>
</tr>
<tr>
<td>根节点</td>
<td>网络中的顶级节点</td>
</tr>
<tr>
<td>子节点</td>
<td>当节点 X 连接到另一节点 Y 时，节点 X 是子节点，其中连接使节点 X 比根节点更远离节点 Y（就连接数而言）。</td>
</tr>
<tr>
<td>父节点</td>
<td>子节点的相反概念</td>
</tr>
<tr>
<td>子孙节点</td>
<td>通过从父节点到子节点重复进行都可以访问的任何节点（例：父-&gt;子-&gt;子孙）</td>
</tr>
<tr>
<td>同级节点</td>
<td>共享同一父节点的节点</td>
</tr>
<tr>
<td>连接</td>
<td>AP 与站之间的传统 Wi-Fi 关联。ESP-MESH 中的节点将使用其工作站接口与另一个节点的 SoftAP 接口关联，从而形成连接。连接过程包括 Wi-Fi 中的认证和关联过程。</td>
</tr>
<tr>
<td>上游连接</td>
<td>从节点到其父节点的连接</td>
</tr>
<tr>
<td>下游连接</td>
<td>从节点到其子节点之一的连接</td>
</tr>
<tr>
<td>无线跳数</td>
<td>源节点和目标节点之间的路径部分，对应于单个无线连接。遍历单个连接的数据包称为单跳，而遍历多个连接称为多跳。</td>
</tr>
<tr>
<td>子网</td>
<td>一个子网是 ESP-MESH 网络的细分，它由一个节点及其所有后代节点组成。因此，根节点的子网由 ESP-MESH 网络中的所有节点组成。</td>
</tr>
<tr>
<td>MAC 地址</td>
<td>媒体访问控制地址，用于唯一标识 ESP-MESH 网络中的每个节点或路由器。</td>
</tr>
<tr>
<td>DS</td>
<td>分配系统（外部 IP 网络）</td>
</tr>
</tbody></table>
<h3 id="树状网络拓扑结构"><a href="#树状网络拓扑结构" class="headerlink" title="树状网络拓扑结构"></a>树状网络拓扑结构</h3><p>ESP-MESH 基于 Wi-Fi 协议构建，可以被视为将许多单独的 Wi-Fi 网络组合到单个 WLAN 中的网络协议。在 Wi-Fi 中，Station 在任何时候都限于与 AP（上游连接）的单个连接，而 AP 可以同时连接到多个 Station（下游连接）。然而，ESP-MESH 允许节点同时充当 Station 和 AP。因此，ESP-MESH 中的节点可以使用其 SoftAP 接口具有多个下游连接，同时使用其 Station 接口具有单个上游连接。这就是具有由多个层组成的父子层次结构的树状网络拓扑结构。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201114600123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 树状网络拓扑结构"><br>ESP-MESH 是多跳网络，意味着节点可以通过一个或多个无线“跳跃”将数据包发送到网络中的其他节点。因此，ESP-MESH 中的节点不仅传输自己的数据包，还同时用作其他节点的中继。如果物理层上的任何两个节点之间存在路径（通过一个或多个无线跳），则 ESP-MESH 网络内的 <strong>任何两个节点（节点对）</strong> 都可以进行通信。</p>
<blockquote>
<p>ESP-MESH 网络中的大小（节点总数）取决于网络中允许的最大层数，以及每个节点可以拥有的最大下游连接数。可以通过配置这两个变量限制网络的大小。</p>
</blockquote>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p><img src="https://img-blog.csdnimg.cn/20190201115649174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 节点类型"><br><strong>根节点：</strong> 根节点是网络中的顶级节点，并且是 ESP-MESH 网络和外部 IP 网络之间的唯一接口。 根节点连接到传统的 Wi-Fi 路由器，并将数据包中继到外部 IP 网络或从中继到 ESP-MESH 网络内的节点。 ESP-MESH 网络中只能有一个根节点，根节点的上游连接只可能与路由器连接。参考上图，节点 A 是网络的根节点。</p>
<p><strong>叶节点：</strong> 叶节点是不允许具有任何子节点（没有下游连接）的节点。因此，叶子节点只能发送或接收自己的数据包，但不能转发其他节点的数据包。如果节点位于网络的最大允许层上，则将其指定为叶节点。这可以防止节点形成任何下游连接，从而确保网络不会添加额外的层。由于需要为任何下游连接提供 SoftAP 接口，因此一些没有 SoftAP 接口（仅限 Station）的节点也将被指定为叶节点。参考上图，节点 L/M/N 位于网络最大允许层上，因此已被指定为叶节点。</p>
<p><strong>中间父节点：</strong> 既不是根节点也不是叶节点的连接节点是中间父节点。中间父节点必须具有单个上游连接（单个父节点），但可以具有零到多个下游连接（零到多个子节点）。因此，中间父节点可以发送和接收数据包，但也可以转发从其上游和下游连接发送的数据包。参考上图，节点 B 到 J 是中间父节点。没有下游连接的中间父节点（例如节点 E/F/G/I/J）不等同于叶节点，因为它们在将来仍然允许形成下游连接。</p>
<p><strong>空闲节点：</strong> 尚未加入网络的节点被指定为空闲节点。空闲节点将尝试与中间父节点形成上游连接，或尝试在正确的情况下成为根节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>）。参考上图，节点 K 和 O 是空闲节点。</p>
<h3 id="信标帧-Beacon-帧-和-RSSI-阈值"><a href="#信标帧-Beacon-帧-和-RSSI-阈值" class="headerlink" title="信标帧(Beacon 帧)和 RSSI 阈值"></a>信标帧(Beacon 帧)和 RSSI 阈值</h3><p>ESP-MESH 中能够形成下游连接（即具有 SoftAP 接口）的每个节点将<strong>周期性地发送 Wi-Fi 信标帧</strong>。节点使用信标帧来允许其他节点检测其存在并知道其状态。空闲节点将监听信标帧以生成潜在父节点的列表，空闲节点将与其中一个形成上游连接。<strong>ESP-MESH 使用信标帧中的供应商信息（Vendor IE）元素来存储（传输）元数据</strong>，例如：</p>
<ul>
<li>节点类型（根节点，中间父节点，叶节点，空闲节点）</li>
<li>当前节点层</li>
<li>网络中允许的最大层数</li>
<li>当前子节点数</li>
<li>要接受的最大下游连接数</li>
</ul>
<p>潜在上游连接的信号强度由潜在父节点的信标帧的 RSSI（接收信号强度指示）表示。为了防止节点形成弱上游连接，ESP-MESH 为信标帧实现了 RSSI 阈值机制。如果节点检测到 RSSI 低于预先配置的阈值的信标帧，则在形成上游连接时将忽略发送该信标帧的节点。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201120120285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="RSSI 阈值的影响"><br>上图中的面板 A 展示了 RSSI 阈值如何影响空闲节点具有的候选父节点的数量。</p>
<p>上图中的面板 B 展示了 RF 屏蔽对象如何降低潜在父节点的 RSSI。由于 RF 屏蔽对象，节点 X 的 RSSI 高于阈值的区域显着减小。这导致空闲节点忽略节点 X，即使节点 X 在物理上相邻。由于更强的 RSSI，空闲节点将改为与物理上远的节点Y形成上游连接。</p>
<blockquote>
<p>节点在技术上仍然接收 MAC 层上的所有信标帧。RSSI 阈值是 ESP-MESH 功能，它只是过滤掉所有接收到的低于预先配置阈值的信号帧。</p>
</blockquote>
<h3 id="首选父节点"><a href="#首选父节点" class="headerlink" title="首选父节点"></a>首选父节点</h3><p>当空闲节点具有多个候选父节点（潜在父节点）时，空闲节点将与首选父节点形成上游连接。<strong>首选父节点基于以下标准确定</strong>：</p>
<ul>
<li>候选父节点位于哪个层</li>
<li>候选父节点当前具有的下游连接（子节点）的数量</li>
</ul>
<p>首选父节点的选择将始终优先考虑网络最浅层（包括根节点）上的候选父节点。这有助于在形成上游连接时最小化ESP-MESH网络中的层总数。例如，给定第二层节点和第三层节点，第二层节点将始终是首选的。</p>
<p>如果在同一层内存在多个候选父节点，则具有最少子节点的候选父节点将是首选的。该标准具有平衡同一层的节点之间的下游连接数的效果。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201140919219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="首选父节点"><br>上图中的面板 A 展示了在给定五个候选父节点 B/C/D/E/F 的情况下空闲节点 G 如何选择首选父节点的示例。最浅层上的节点是首选的，因此节点 B/C 优先选择做为父节点，因为它们是第二层节点，而节点 D/E/F 在第三层上。选择节点 C 作为首选父节点，因为与节点 B 相比，它具有更少的下游连接（更少的子节点）。</p>
<p>上图中的面板 B 展示了根节点在空闲节点 G 的范围内的情况。换句话说，当节点 G 接收时，根节点的信标帧高于 RSSI 阈值。根节点始终是最浅节点，因此，在 ESP-MESH网络中，给定多个候选父节点时，根节点总是首选的父节点。</p>
<blockquote>
<p>用户还可以定义自己的算法以选择首选父节点，或强制节点仅与特定父节点连接（请参阅<a href="https://github.com/espressif/esp-idf/tree/2790d4a/examples/mesh/manual_networking" target="_blank" rel="noopener">手动 MESH 网络示例</a>）。</p>
</blockquote>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>ESP-MESH 网络中的每个节点将单独维护自己的路由表，用于将 ESP-MESH 数据包（请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#esp-mesh-packet" target="_blank" rel="noopener">ESP-MESH 数据包</a>）正确路由到正确目标节点。特定节点的路由表将包括特定节点的子网内所有节点的 MAC 地址（包括特定节点本身的 MAC 地址）。每个路由表在内部划分为多个子表，每个子表对应于每个子节点的子网。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201142029243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH路由表示例"><br>使用上面的图作为示例，节点 B 的路由表将包括节点 B 到 I 的 MAC 地址（即，等同于节点 B 的子网）。节点 B 的路由表在内部划分为两个子表，包含节点 C 到 F 和节点 G 到 I（即分别等同于节点 C 和 G 的子网）。</p>
<p><strong>ESP-MESH 利用路由表来确定是否应根据以下规则向上游或下游转发 ESP-MESH 数据包。</strong></p>
<ol>
<li>如果数据包的目标 MAC 地址在当前节点的路由表中并且不是当前节点，请选择包含目标 MAC 地址的子表，并将数据包下游转发到与子表对应的子节点。</li>
<li>如果目标 MAC 地址不在当前节点的路由表中，则将数据包上游转发到当前节点的父节点。重复执行此操作将导致数据包到达根节点，其中路由表应包含网络中的所有节点。</li>
</ol>
<blockquote>
<p>用户可以调用 <code>esp_mesh_get_routing_table()</code> 来获取节点的路由表，或者调用 <code>esp_mesh_get_routing_table_size()</code> 来获取节点的路由表的大小。<br><code>esp_mesh_get_subnet_nodes_list()</code> 可用于获取特定子节点的相应子表。同样，<code>esp_mesh_get_subnet_nodes_num()</code> 可用于获取子表的大小。</p>
</blockquote>
<h2 id="构建-ESP-MESH-网络"><a href="#构建-ESP-MESH-网络" class="headerlink" title="构建 ESP-MESH 网络"></a>构建 ESP-MESH 网络</h2><h3 id="一般过程"><a href="#一般过程" class="headerlink" title="一般过程"></a>一般过程</h3><blockquote>
<p>在 ESP-MESH 网络构建过程开始之前，配置的某些部分必须在网络中的每个节点上保持一致（请参阅 <code>mesh_cfg_t</code>）。每个节点必须配置相同的 Mesh 网络 ID，路由器配置和 SoftAP 配置。</p>
</blockquote>
<p>ESP-MESH 网络构建过程涉及根节点选择，然后逐层形成下游连接，直到所有节点都加入网络。网络的确切布局可以取决于诸如根节点选择，父节点选择和异步上电复位等因素。但是，ESP-MESH 网络构建过程可以概括为以下步骤：</p>
<p><img src="https://img-blog.csdnimg.cn/2019020114281399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 网络构建过程"></p>
<ol>
<li><p>根节点选择</p>
<p><strong>根节点可以在配置期间指定</strong>（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#user-designated-root-node" target="_blank" rel="noopener">用户指定的根节点部分</a>），或者<strong>根据每个节点和路由器之间的信号强度动态选择</strong>（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>）。选择后，根节点将与路由器连接并开始允许形成下游连接。参考上图，节点 A 被选择为根节点，因此节点 A 与路由器形成上游连接。</p>
</li>
<li><p>第二层形成</p>
<p>一旦根节点连接到路由器，根节点范围内的空闲节点将开始与根节点连接，从而形成网络的第二层。连接后，第二层节点成为中间父节点（假设允许的最大层数 &gt; 2），因此形成下一层。参考上图，节点 B 到 D 在根节点的范围内。因此，节点 B 到 D 与根节点形成上游连接，并成为中间父节点。</p>
</li>
<li><p>形成剩余层</p>
<p>剩余的空闲节点将与范围内的中间父节点连接，从而在网络中形成新层。连接后，空闲节点将成为中间父节点或叶节点，具体取决于网络允许的最大层数。重复该步骤，直到网络中不再有空闲节点或者直到达到网络的最大允许层为止。参考上图，节点 E/F/G 分别与节点 B/C/D 连接，并成为中间父节点本身。</p>
</li>
<li><p>限制树深度</p>
<p>为防止网络超出允许的最大层数，最大层上的节点一旦连接就会自动成为叶子节点。这防止任何其他空闲节点与叶节点连接，从而防止形成新的层形式。但是，如果空闲节点没有其他可能的父节点，它将无限期地保持空闲状态。参考上图，网络的最大允许层数设置为 4。因此，当节点 H 连接时，它成为叶节点以防止形成任何下游连接。</p>
</li>
</ol>
<h3 id="自动根节点选择"><a href="#自动根节点选择" class="headerlink" title="自动根节点选择"></a>自动根节点选择</h3><p><strong>根节点的自动选择涉及所有空闲节点之间基于其与路由器的信号强度的选举过程。每个空闲节点将通过 Wi-Fi 信标帧发送其 MAC 地址和路由器 RSSI 值</strong>。MAC 地址用于唯一地标识网络中的每个节点，而路由器 RSSI 用于指示节点参考路由器的信号强度。</p>
<p>然后，<strong>每个节点将同时扫描来自其他空闲节点的信标帧</strong>。<strong>如果节点检测到具有更强路由器 RSSI 的信标帧，则该节点将开始发送该信标帧的内容</strong>（即，对具有更强路由器 RSSI 的节点进行投票）。<strong>传输和扫描的过程将重复预先配置的最小迭代次数</strong>（默认为 10 次迭代），<strong>这将导致具有最强路由器 RSSI 的信标帧在整个网络中传播</strong>。</p>
<p>在所有迭代之后，每个节点将单独检查其投票百分比（投票数/参与选举的节点数）以确定它是否应该成为根节点。<strong>如果节点的投票百分比大于预配置的阈值（默认为 90％），则该节点将成为根节点</strong>。</p>
<p>下图演示了在自动选择根节点时如何构建 ESP-MESH 网络。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201144333598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="根节点选择示例"></p>
<ol>
<li>在上电复位时，每个节点开始发送由其自己的 MAC 地址和路由器 RSSI 组成的信标帧。</li>
<li>在多次传输和扫描迭代中，具有最强路由器 RSSI 的信标帧在整个网络中传播。节点 C 具有最强的路由器RSSI（-10db），因此其信标帧在整个网络中传播。参与选举的所有节点都对节点 C 进行投票，从而给节点 C 一个 100％ 的投票百分比。因此，节点 C 成为根节点并与路由器连接。</li>
<li>一旦节点 C 与路由器连接，节点 A/B/D/E 就与节点 C 连接，因为它是首选的父节点（即最浅节点）。节点 A/B/D/E 构成网络的第二层。</li>
<li>节点 F 和 G 分别与节点 D 和 E 连接，网络构建过程完成。</li>
</ol>
<blockquote>
<p>可以使用 <code>esp_mesh_set_attempts（）</code> 配置选举过程的最小迭代次数。用户应该基于网络内的节点数量来调整迭代次数（即，网络越大，所需的扫描迭代次数越多）。</p>
</blockquote>
<blockquote>
<p>也可以使用 <code>esp_mesh_set_vote_percentage()</code> 配置投票百分比阈值。设置低投票百分比阈值可导致两个或更多节点成为同一 ESP-MESH 网络内的根节点，从而导致建立多个网络。如果是这种情况，ESP-MESH 具有自主解决根节点冲突的内部机制。多个根节点的网络将组合成具有单个根节点的单个网络。但是，根节点冲突，其中两个或多个根节点具有相同的路由器 SSID 但不处理不同的路由器 BSSID。</p>
</blockquote>
<h3 id="用户指定根节点"><a href="#用户指定根节点" class="headerlink" title="用户指定根节点"></a>用户指定根节点</h3><p><strong>根节点也可以由用户指定，这将使指定的根节点直接与路由器连接并放弃选举过程。当指定根节点时，网络中的所有其他节点也必须放弃选举过程以防止发生根节点冲突。</strong> 下图演示了当用户指定根节点时如何构建 ESP-MESH 网络。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201145101139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="指定根节点示例（根节点= A，最大层数= 4）"></p>
<ol>
<li>节点 A 被用户指定为根节点，因此直接与路由器连接。所有其他节点放弃选举过程。</li>
<li>节点 C/D 连接节点 A 作为其首选父节点。两个节点构成网络的第二层。</li>
<li>同样，节点 B/E 与节点 C 连接，节点 F 与节点 D 连接。节点 B/E/F 构成网络的第三层。</li>
<li>节点 G 与节点 E 连接，形成网络的第四层。但是，此网络中允许的最大层数配置为 4，因此节点 G 成为叶节点以防止形成任何新层。</li>
</ol>
<blockquote>
<p>在指定根节点时，根节点应调用 <code>esp_mesh_set_parent()</code> 以直接与路由器连接。同样，所有其他节点应调用 <code>esp_mesh_fix_root()</code> 以放弃选举过程。</p>
</blockquote>
<h3 id="父节点选择"><a href="#父节点选择" class="headerlink" title="父节点选择"></a>父节点选择</h3><p>默认情况下，ESP-MESH 是自组织的，这意味着每个节点将自动选择与哪个潜在父节点形成上游连接。自主选择的父节点称为首选父节点。用于选择首选父节点的标准旨在减少 ESP-MESH 网络中的层数，并平衡潜在父节点之间的下游连接数（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#preferred-parent-node" target="_blank" rel="noopener">首选父节点</a>）。</p>
<p>但是，ESP-MESH 还允许用户禁用自组织行为，这将允许用户定义自己的父节点选择标准，或配置节点以具有指定的父节点（请参阅<a href="https://github.com/espressif/esp-idf/tree/2790d4a/examples/mesh/manual_networking" target="_blank" rel="noopener">手动 MESH 网络示例</a>）。</p>
<h3 id="异步上电复位"><a href="#异步上电复位" class="headerlink" title="异步上电复位"></a>异步上电复位</h3><p>ESP-MESH 网络建设可能受节点上电顺序的影响。如果网络中的某些节点异步上电（即相隔几分钟），则网络的最终结构可能与所有节点同步通电的理想情况不同。上电延迟的节点将遵循以下规则：</p>
<p>规则1：如果网络中已存在根节点，则延迟节点将不会尝试选择新的根节点，即使它与路由器具有更强的 RSSI。通过连接首选父节点，延迟节点将像任何其他空闲节点一样加入网络。如果延迟节点是指定的根节点，则网络中的所有其他节点将保持空闲，直到延迟节点通电。</p>
<p>规则2：如果延迟节点形成上游连接并成为中间父节点，则它也可以成为其他节点的新首选父节点（即，是较浅的节点）。这将导致其他节点切换其上游连接以与延迟节点连接（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#parent-node-switching" target="_blank" rel="noopener">父节点切换</a>）。</p>
<p>规则3：如果空闲节点具有在通电时被延迟的指定父节点，则空闲节点将不会在没有其指定的父节点的情况下尝试形成任何上游连接。空闲节点将无限期地保持空闲，直到其指定的父节点上电为止。</p>
<p>以下示例演示了异步上电对网络构建的影响。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201150942611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="基于异步电源的网络构建示例"></p>
<ol>
<li>节点 A/C/D/F/G/H 同步上电，通过广播其 MAC 地址和路由器 RSSI 开始根节点选举过程。节点 A 被选为根节点，因为它具有最强的 RSSI。</li>
<li>一旦节点 A 成为根节点，其余节点就开始逐层形成具有其首选选父节点的上游连接。结果是一个有五层的网络。</li>
<li>节点 B/E 在上电时被延迟但是没有尝试成为根节点，即使它们具有比节点 A 更强的路由器 RSSI（-20db 和 -10db）。相反，两个延迟节点形成与其首选父节点的上游连接。节点 A 和 C 分别。连接后，两个节点 B/E 都成为中间父节点。</li>
<li>节点 D/G 切换它们的上游连接，因为节点 B 是新的首选父节点，因为它位于较浅的层（第二层节点）上。由于切换，所得到的网络具有三层而不是原始的五层。</li>
</ol>
<p>同步上电：如果所有节点同步上电，节点 E 将成为根节点，因为它具有最强的路由器 RSSI（-10db）。与在异步通电条件下形成的网络相比，这将导致显着不同的网络布局。但是，如果用户手动切换根节点，仍然可以达到同步开机网络布局（请参阅 <code>esp_mesh_waive_root()</code> ）。</p>
<blockquote>
<p>由异步上电引起的父节点选择的差异在 ESP-MESH 中在某种程度上被自动校正（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#parent-node-switching" target="_blank" rel="noopener">父节点切换</a>）</p>
</blockquote>
<h3 id="环路避免，检测和处理"><a href="#环路避免，检测和处理" class="headerlink" title="环路避免，检测和处理"></a>环路避免，检测和处理</h3><p>环路是特定节点与其后代节点之一（特定节点的子网内的节点）形成上游连接的情况。这导致圆形连接路径，从而破坏树状网络拓扑结构。ESP-MESH 通过排除在选择节点的路由表中已存在的节点（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#routing-tables" target="_blank" rel="noopener">路由表</a>）来防止在父节点选择期间产生环路，从而防止特定节点尝试连接到其子网内的任何节点。</p>
<p>在发生环路的情况下，ESP-MESH利用路径验证机制和能量传输机制来检测环路发生。导致环路的上游连接的父节点将通知子节点环路并启动断开连接。</p>
<h2 id="管理网络"><a href="#管理网络" class="headerlink" title="管理网络"></a>管理网络</h2><p>ESP-MESH 是一个自我修复网络，意味着它可以检测并纠正网络路由中的故障。当具有一个或多个子节点的父节点发生故障或父节点与其子节点之间的连接变得不稳定时，会发生故障。ESP-MESH 中的子节点将自动选择新的父节点并与其形成上游连接以维持网络互连。ESP-MESH 可以处理根节点故障和中间父节点故障。</p>
<h3 id="根节点故障"><a href="#根节点故障" class="headerlink" title="根节点故障"></a>根节点故障</h3><p><strong>如果根节点发生故障，与其连接的节点（第二层节点）将立即检测到根节点的故障。第二层节点最初将尝试与根节点重新连接。但是，在多次尝试失败后，第二层节点将初始化新一轮的根节点选举。具有最强路由器 RSSI 的第二层节点将被选为新的根节点，而剩余的第二层节点将与新的根节点（或相邻的父节点，如果不在范围内）形成上游连接。</strong></p>
<p>如果根节点和多个下游层同时发生故障（例如，根节点，第二层和第三层），仍然起作用的最浅层将初始化根节点选举。以下示例说明了从根节点分解的自我修复示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201153541569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="从根节点故障中自我修复"></p>
<ol>
<li>节点 C 是网络的根节点。节点 A/B/D/E 是连接到节点 C 的第二层节点。</li>
<li>节点 C 发生故障。在多次尝试重新连接失败后，第二层节点通过广播其路由器 RSSI 开始选举过程。节点 B 具有最强的路由器 RSSI。</li>
<li>节点 B 被选为根节点并开始接受下游连接。剩余的第二层节点 A/D/E 形成与节点 B 的上游连接，因此网络被修复并且可以继续正常操作。</li>
</ol>
<blockquote>
<p>如果指定的根节点发生故障，则其余节点将不会自主地尝试选择新的根节点，因为在使用指定的根节点时将永远不会尝试选举过程。</p>
</blockquote>
<h3 id="中间父节点故障"><a href="#中间父节点故障" class="headerlink" title="中间父节点故障"></a>中间父节点故障</h3><p><strong>如果中间父节点发生故障，则断开连接的子节点将首先尝试与父节点重新连接。在多次尝试重新连接失败后，每个子节点将开始扫描潜在的父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#beacon-frames-rssi-thresholding" target="_blank" rel="noopener">信标帧和 RSSI 阈值</a>）。</strong></p>
<p>如果其他可能的父节点可用，则每个子节点将单独选择新的首选父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#preferred-parent-node" target="_blank" rel="noopener">首选父节点</a>）并与其形成上游连接。如果特定子节点没有其他潜在父节点，则它将无限期保持空闲状态。</p>
<p>下图说明了从中间父节点分解的自我修复的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201153956675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="从中间父节点故障中自我修复"></p>
<ol>
<li>网络的以下分支由节点 A 到 G 组成。</li>
<li>节点 C 发生故障。 节点 F/G 检测到故障并尝试与节点 C 重新连接。多次尝试重新连接失败后，节点 F/G 开始选择新的首选父节点。</li>
<li>节点 G 超出任何其他父节点的范围，因此暂时保持空闲。节点 F 在节点 B/E 的范围内，但是节点 B 被选择，因为它是较浅的节点。节点 F 在与节点 B 连接之后成为中间父节点，因此节点 G 可以与节点 F 连接。网络被修复，但是网络路由已经受到影响并且添加了额外的层。</li>
</ol>
<blockquote>
<p>如果子节点具有指定的父节点，则子节点将不会尝试连接新的父节点。子节点将无限期保持空闲状态。</p>
</blockquote>
<h3 id="根节点切换"><a href="#根节点切换" class="headerlink" title="根节点切换"></a>根节点切换</h3><p><strong>除非根节点发生故障，否则 ESP-MESH 不会自动切换根节点。即使根节点的路由器 RSSI 降级到断开点，根节点也将保持不变</strong>。根节点切换是明确开始新选举的行为，使得具有更强路由器 RSSI 的节点将被选为新的根节点。这可以是适应降低根节点性能的有用方法。</p>
<p><strong>要触发根节点切换，当前根节点必须显式调用 <code>esp_mesh_waive_root()</code> 以触发新选举</strong>。当前根节点将发信号通知网络内的所有节点开始发送和扫描信标帧（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#automatic-root-node-selection" target="_blank" rel="noopener">自动根节点选择</a>），同时保持连接到网络（即，不空闲）。如果另一个节点收到的选票多于当前根节点，则将启动根节点切换。否则，根节点将保持不变。</p>
<p>新选择的根节点向当前根节点发送切换请求，该当前根节点将以确认响应，表示两个节点都准备切换。一旦收到确认，新选出的根节点将与其父节点断开连接，并迅速与路由器形成上游连接，从而成为网络的新根节点。先前的根节点将断开与路由器的连接，同时保持其所有下游连接并进入空闲状态。然后，先前的根节点将开始扫描潜在的父节点并选择首选父节点。</p>
<p>下图说明了根节点切换的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201160040642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="根节点切换示例"></p>
<ol>
<li>节点 C 是当前的根节点，但路由器的信号强度降低（-85db）。节点 C 触发新的选举，并且所有节点在仍然连接的同时开始发送和扫描信标帧。</li>
<li>经过多轮传输和扫描后，节点 B 被选为新的根节点。节点 B 向节点 C 发送切换请求，节点 C 以确认响应。</li>
<li>节点 B 与其父节点断开连接，并与路由器连接，成为网络新的根节点。节点 C 与路由器断开连接，进入空闲状态，并开始扫描并选择新的首选父节点。节点 C 在整个过程中维护其所有下游连接。</li>
<li>节点 C 选择节点 B 作为其首选父节点，形成上游连接，并成为第二层节点。交换根节点后网络布局类似，因为节点 C 仍保持相同的子网。但是，由于交换根节点，节点 C 的子网中的每个节点都被放置了一层。如果任何节点由于根节点切换而具有新的优选父节点，则父节点切换可以随后调整网络布局。</li>
</ol>
<blockquote>
<p>根节点切换必须要求选举，因此仅在使用自组织 ESP-MESH 网络时才支持。换句话说，如果使用指定的根节点，则不能发生根节点切换。</p>
</blockquote>
<h3 id="父节点切换"><a href="#父节点切换" class="headerlink" title="父节点切换"></a>父节点切换</h3><p><strong>父节点切换需要子节点将其上游连接切换到较浅层的另一个父节点。父节点切换自动发生，这意味着如果较浅层的潜在父节点变得可用（即，由于<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#asynchronous-power-on-reset" target="_blank" rel="noopener">异步上电复位</a>），子节点将自动改变其上游连接。</strong></p>
<p>所有潜在的父节点周期性地发送信标帧（参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#beacon-frames-rssi-thresholding" target="_blank" rel="noopener">信标帧和 RSSI 阈值</a>），允许子节点扫描较浅的父节点的可用性。由于父节点切换，自组织的 ESP-MESH 网络可以动态调整其网络布局，以确保每个连接具有良好的 RSSI 并且网络中的层数最小化。</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="ESP-MESH数据包"><a href="#ESP-MESH数据包" class="headerlink" title="ESP-MESH数据包"></a>ESP-MESH数据包</h3><p>ESP-MESH 网络数据传输使用 ESP-MESH 数据包。ESP-MESH 数据包完全包含在 Wi-Fi 数据帧的帧体内。ESP-MESH 网络中的多跳数据传输将涉及通过不同的 Wi-Fi 数据帧在每个无线跳上承载的单个 ESP-MESH 数据包。</p>
<p>下图显示了 ESP-MESH 数据包的结构及其与 Wi-Fi 数据帧的关系。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201162512352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 数据包"><br>ESP-MESH 数据包的包头包含源节点和目标节点的 MAC 地址。选项字段包含与特殊类型的 ESP-MESH 数据包有关的信息，例如组传输或源自外部 IP 网络的数据包（请参阅 <code>MESH_OPT_SEND_GROUP</code> 和 <code>MESH_OPT_RECV_DS_ADDR</code>）。</p>
<p>ESP-MESH 数据包的有效负载包含实际的应用程序数据。此数据可以是原始二进制数据，也可以在应用程序层协议（如 HTTP，MQTT 和 JSON）下编码（请参阅 <code>mesh_proto_t</code>）。</p>
<blockquote>
<p>将 ESP-MESH 数据包发送到外部 IP 网络时，包头的目标地址字段将包含目标服务器的 IP 地址和端口，而不是节点的 MAC 地址（请参阅 <code>mesh_addr_t</code>）。此外，根节点将处理输出 TCP/IP 数据包的形成。</p>
</blockquote>
<h3 id="组控制和多播"><a href="#组控制和多播" class="headerlink" title="组控制和多播"></a>组控制和多播</h3><p>多播是一种允许将单个 ESP-MESH 数据包同时传输到网络中的多个节点的功能。ESP-MESH 中的多播可以通过指定目标节点列表或指定预先配置的节点组来实现。两种多播方法都是通过 <code>esp_mesh_send()</code> 调用的。</p>
<p>要通过指定目标节点列表进行多播，用户必须首先将 ESP-MESH 数据包的目标地址设置为多播组地址（01:00:5E:xx:xx:xx）。这表示 ESP-MESH 数据包是具有一组地址的多播数据包，并且该地址应从头选项中获取。然后，用户必须将目标节点的 MAC 地址列为选项（请参阅 <code>mesh_opt_t</code> 和 <code>MESH_OPT_SEND_GROUP</code>）。这种多播方法不需要事先设置，但可能产生大量开销数据，因为每个目标节点的 MAC 地址必须列在数据包包头的选项字段中。</p>
<p>按组进行多播允许将 ESP-MESH 数据包传输到预先配置的节点组。每个组由唯一 ID 标识，并且可以通过 <code>esp_mesh_set_group_id()</code> 将节点放入组中。对组进行组播涉及将 ESP-MESH 数据包中的目的地址设置为目标组 ID。此外，必须设置 <code>MESH_DATA_GROUP</code> 标志。使用组进行多播会产生较少的开销，但需要先前将节点添加到组中。</p>
<blockquote>
<p>在多播期间，网络中的所有节点仍然在 MAC 层上接收 ESP-MESH 数据包。但是，未包含在 MAC 地址列表或目标组中的节点将简单地过滤掉该数据包。</p>
</blockquote>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播是一种允许单个 ESP-MESH 数据包同时传输到网络中所有节点的功能。每个节点基本上将广播包转发到其所有上游和下游连接，使得广播包尽可能快地在整个网络中传播。但是，ESP-MESH 利用以下方法避免在广播期间浪费带宽。</p>
<ol>
<li>当中间父节点从其父节点接收广播包时，它将广播包转发到其每个子节点，同时为其自身存储广播包的副本。</li>
<li>当中间父节点是广播的源节点时，它将向上游发送广播包到父节点并且向下游发送广播包到每个子节点。</li>
<li>当中间父节点从其子节点之一接收广播包时，它将广播包转发到其父节点及其剩余的每个子节点，同时为其自身存储广播包的副本。</li>
<li>当叶节点是广播的源节点时，它将直接将数据包传输到其父节点。</li>
<li>当根节点是广播的源节点时，根节点将数据包传输到其所有子节点。</li>
<li>当根节点从其子节点之一接收广播包时，它将广播包转发到其剩余的每个子节点，同时为其自身存储广播包的副本。</li>
<li>当节点接收到源地址与其自己的 MAC 地址匹配的广播包时，该节点将丢弃该广播包。</li>
<li>当中间父节点从其父节点接收到最初从其子节点之一发送的广播包时，它将丢弃广播包。</li>
</ol>
<h3 id="上游流量控制"><a href="#上游流量控制" class="headerlink" title="上游流量控制"></a>上游流量控制</h3><p>ESP-MESH 依靠父节点来控制其直接子节点的上游数据流。为了防止父节点的消息缓冲区由于上游传输的过载而溢出，父节点将为其每个子节点分配用于上游传输的配额，称为接收窗口。<strong>每个子节点必须在允许向上游传输之前申请接收窗口。</strong> 可以动态调整接收窗口的大小。从子节点到父节点的上游传输包括以下步骤：</p>
<ol>
<li>在每次传输之前，子节点向其父节点发送窗口请求。窗口请求由序列号组成，该序列号对应于待传输的子节点的数据包。</li>
<li>父节点接收窗口请求，并将序列号与子节点发送的先前数据包的序列号进行比较。该比较用于计算发送回子节点的接收窗口的大小。</li>
<li>子节点根据父节点指定的窗口大小发送数据包。如果子节点耗尽其接收窗口，则必须通过在允许继续发送之前发送请求来获得另一个接收窗口。</li>
</ol>
<blockquote>
<p>ESP-MESH 不支持任何下游流量控制。</p>
</blockquote>
<blockquote>
<p>由于父节点切换，在上游传输期间可能发生数据包丢失。</p>
</blockquote>
<p>由于根节点充当外部 IP 网络的唯一接口，因此下游节点了解根节点与外部 IP 网络的连接状态至关重要。如果不这样做，可能会导致节点在与 IP 网络断开连接时尝试将数据上行传递到根节点。这导致不必要的传输和数据包丢失。ESP-MESH 通过提供一种机制来解决此问题，该机制基于根节点和外部 IP 网络之间的连接状态来稳定传出数据的吞吐量。根节点可以通过调用 <code>esp_mesh_post_toDS_state()</code> 将其外部 IP 网络连接状态广播到所有其他节点。</p>
<h3 id="双向数据流"><a href="#双向数据流" class="headerlink" title="双向数据流"></a>双向数据流</h3><p>下图说明了 ESP-MESH 双向数据流中涉及的各种网络层。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201165440991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 双向数据流"><br>由于使用了<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#routing-tables" target="_blank" rel="noopener">路由表</a>，ESP-MESH 能够完全在网状层上处理包转发。仅当根节点向/从外部 IP 网络发送/接收数据包时，才需要 TCP/IP 层。</p>
<h2 id="信道切换"><a href="#信道切换" class="headerlink" title="信道切换"></a>信道切换</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在传统的 Wi-Fi 网络中，信道是预定的频率范围。在基本服务集（BSS）中，服务 AP 及其连接的 Station 必须在相同信道（1 至 14）上发送信标。在同一信道上运行的物理上相邻的 BSS（基本服务集）可能会导致干扰并降低性能。</p>
<p>为了使 BSS 适应不断变化的物理层条件并保持性能，Wi-Fi 包含用于网络信道切换的机制。网络信道切换是尝试将 BSS 移动到新的操作信道，同时在此过程中最小化对 BSS 的干扰。然而，应该认识到，在将所有 Station 移动到新的操作信道时，信道切换可能是不成功的。</p>
<p>在 Wi-Fi 网络中，AP 触发网络信道切换，目的是使 AP 和所有连接的 Station 同步切换到新信道。通过在 AP 的周期性发送的信标帧内嵌入信道切换公告（CSA）元素来实现网络信道切换。CSA 元素用于向所有连接的站点通告关于即将到来的网络信道切换，并且将被包括在多个信标帧中直到切换发生。</p>
<p>CSA 元素包含关于新信道号和信道切换计数的信息，其指示在网络信道切换发生之前剩余的信标帧间隔（TBTT）的数量。因此，每个信标帧递减信道切换计数，并允许连接的 Station 将其信道切换与 AP 同步。</p>
<h3 id="ESP-MESH-网络信道切换"><a href="#ESP-MESH-网络信道切换" class="headerlink" title="ESP-MESH 网络信道切换"></a>ESP-MESH 网络信道切换</h3><p>ESP-MESH 网络信道切换还利用包含 CSA 元素的信标帧。然而，作为多跳网络使得 ESP-MESH 中的切换过程更复杂，因为信标帧可能无法到达网络内的所有节点（即，在单跳中）。因此，ESP-MESH 网络依靠节点转发 CSA 元素，以便它在整个网络中传播。</p>
<p>当具有一个或多个子节点的中间父节点接收到包含 CSA 的信标帧时，该节点将通过将该元素包括在其下一个发送的信标帧中（即，具有相同的新信道号和信道切换计数）来转发 CSA 元素。鉴于 ESP-MESH 网络内的所有节点都接收相同的 CSA，节点可以使用信道切换计数来同步其信道切换，尽管由于 CSA 元素转发而导致短的延迟。</p>
<p>ESP-MESH 网络信道切换可以由路由器或根节点触发。</p>
<h3 id="根节点触发"><a href="#根节点触发" class="headerlink" title="根节点触发"></a>根节点触发</h3><p>只有当 ESP-MESH 网络未连接到路由器时，才会发生根节点触发的信道切换。通过调用 <code>esp_mesh_switch_channel()</code>，根节点将设置初始信道切换计数值并开始在其信标帧中包含 CSA 元素。然后，每个 CSA 元素由第二层节点接收，并在它们自己的信标帧中向下游转发。</p>
<h3 id="路由器触发"><a href="#路由器触发" class="headerlink" title="路由器触发"></a>路由器触发</h3><p>当 ESP-MESH 网络连接到路由器时，整个网络必须使用与路由器相同的信道。因此，当根节点连接到路由器时，将不允许根节点触发通道切换。</p>
<p>当根节点从路由器接收包含 CSA 元素的信标帧时，根节点将 CSA 元素中的信道切换计数值设置为自定义值，然后通过信标帧向下游转发。它还将相对于自定义值递减后续 CSA 元素的通道切换计数。此自定义值可以基于诸如网络层数，当前节点数等因素。</p>
<p>将信道切换计数值设置为自定义值是由于 ESP-MESH 网络及其路由器可能具有不同且变化的信标间隔。因此，路由器提供的信道切换计数值与 ESP-MESH 网络无关。通过使用自定义值，ESP-MESH 网络中的节点能够相对于 ESP-MESH 网络的信标间隔同步切换信道。但是，这也会导致 ESP-MESH 网络的信道切换与路由器及其连接站的信道切换不同步。</p>
<h3 id="网络信道切换的影响"><a href="#网络信道切换的影响" class="headerlink" title="网络信道切换的影响"></a>网络信道切换的影响</h3><ul>
<li>由于 ESP-MESH 网络信道切换与路由器的信道切换不同步，ESP-MESH 网络和路由器之间将存在临时信道差异。<ul>
<li>ESP-MESH 网络的信道切换时间取决于 ESP-MESH 网络的信标间隔和根节点的自定义信道切换计数值。</li>
<li>通道差异可防止在 ESP-MESH 网络切换期间根节点与路由器之间的任何数据交换。</li>
<li>在 ESP-MESH 网络中，根节点和中间父节点将请求其连接的子节点停止传输，直到通过将 CSA 元素中的信道切换模式字段设置为 1 来进行信道切换。</li>
<li>频繁路由器触发的网络信道切换会降低 ESP-MESH 网络的性能。请注意，这可能是由 ESP-MESH 网络本身引起的（例如，由于与 ESP-MESH 网络的无线媒体争用）。如果是这种情况，用户应禁用路由器上的自动信道切换，并使用指定的信道。</li>
</ul>
</li>
<li>当存在临时信道差异时，根节点在技术上保持与路由器的连接。<ul>
<li>在根节点未能通过固定数量的路由器信标间隔从路由器接收任何信标帧或探测响应之后发生断开连接。</li>
<li>断开连接后，根节点将自动重新扫描所有通道以查找是否存在路由器。</li>
</ul>
</li>
<li>如果根节点无法接收任何路由器的 CSA 信标帧（例如，由于路由器给出的切换时间短），路由器将在没有 ESP-MESH 网络知识的情况下切换信道。<ul>
<li>路由器切换通道后，根节点将无法再接收路由器的信标帧和探测响应，并在固定数量的信标间隔后导致断开连接。</li>
<li>断开连接后，根节点将重新扫描路由器的所有通道。</li>
<li>根节点将在整个过程中维护下游连接。</li>
</ul>
</li>
</ul>
<blockquote>
<p>尽管 ESP-MESH 网络信道切换旨在将网络内的所有节点移动到新的操作信道，但应该认识到信道切换可能不能成功地移动所有节点（例如，由于诸如节点故障的原因）。</p>
</blockquote>
<h3 id="通道和路由器切换配置"><a href="#通道和路由器切换配置" class="headerlink" title="通道和路由器切换配置"></a>通道和路由器切换配置</h3><p>ESP-MESH 允许通过配置启用/禁用自主通道切换。同样，也可以通过配置启用/禁用自主路由器切换（即，当根节点自主连接到另一个路由器时）。自主信道切换和路由器切换取决于以下配置参数和运行时条件。</p>
<p><strong>允许通道切换：</strong> 此参数通过 <code>mesh_cfg_t</code> 结构的 <code>allow_channel_switch</code> 字段设置，并允许 ESP-MESH 网络在设置时动态切换通道。</p>
<p><strong>预设信道：</strong> 通过将 <code>mesh_cfg_t</code> 结构的信道字段设置为所需的信道号，ESP-MESH 网络可以拥有预设信道。如果未设置此字段，则会覆盖 <code>allow_channel_switch</code> 参数，以便始终允许通道切换。</p>
<p><strong>允许路由器切换：</strong> 此参数通过 <code>mesh_router_t</code> 的 <code>allow_router_switch</code> 字段设置，并允许 ESP-MESH 在设置时动态切换到其他路由器。</p>
<p><strong>预设路由器BSSID：</strong> ESP-MESH 网络可以通过将 <code>mesh_router_t</code> 结构的 <code>bssid</code> 字段设置为所需路由器的 BSSID 来具有预设路由器。如果未设置此字段，则会覆盖 <code>allow_router_switch</code> 参数，以便始终允许路由器切换。</p>
<p><strong>根节点存在：</strong> 根节点的存在还会影响是允许还是允许通道或路由器切换。</p>
<p>下表说明了参数/条件的不同组合如何影响是否允许信道切换和/或路由器切换。请注意，X 表示参数的“不关心”。</p>
<p><img src="https://img-blog.csdnimg.cn/20190201171947753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>可以基于多个指标评估 ESP-MESH 网络的性能，例如：</p>
<p><strong>网络构建时间：</strong> 从头开始构建 ESP-MESH 网络所需的时间。</p>
<p><strong>恢复时间：</strong> 网络检测节点故障所需的时间，并执行适当的操作来修复网络（例如生成新的根节点或形成新的连接）。</p>
<p><strong>每跳延迟：</strong> 通过一个无线跳数据传输的延迟。换句话说，将数据包从父节点传输到子节点所花费的时间，反之亦然。</p>
<p><strong>网络节点容量：</strong> ESP-MESH 网络可以同时支持的节点总数。<strong>此数字由节点可接受的最大下游连接数和网络中允许的最大层数确定。</strong></p>
<p>下表列出了 ESP-MESH 网络的常见性能数据。但是，用户应注意，基于网络配置和操作环境的安装之间的性能数字可能会有很大差异。</p>
<blockquote>
<p>使用以下测试条件产生上述性能数据。</p>
<ul>
<li>测试设备数量：100</li>
<li>要接受的最大下游连接数：6</li>
<li>最大允许层数：6</li>
</ul>
</blockquote>
<blockquote>
<p>吞吐量取决于数据包错误率和跳数。</p>
</blockquote>
<blockquote>
<p>根节点访问外部IP网络的吞吐量直接受 ESP-MESH 网络中节点数量和路由器带宽的影响。</p>
</blockquote>
<h2 id="进一步说明"><a href="#进一步说明" class="headerlink" title="进一步说明"></a>进一步说明</h2><ul>
<li>数据传输使用 Wi-Fi WPA2-PSK 加密</li>
<li>网状网络 IE 使用 AES 加密</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十六）ESP-MESH 编程指南</title>
    <url>/InfiniteYuanBlog/2019/03/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89ESP-MESH%20%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="ESP-MESH-编程指南"><a href="#ESP-MESH-编程指南" class="headerlink" title="ESP-MESH 编程指南"></a>ESP-MESH 编程指南</h1><p>这是 ESP-MESH 的编程指南，包括 API 参考和编码示例。本指南分为以下几部分：</p>
<ul>
<li>ESP-MESH 编程模型</li>
<li>编写 ESP-MESH 应用程序</li>
<li>自组织网络</li>
<li>应用实例</li>
<li>API 参考</li>
</ul>
<p>有关 ESP-MESH 协议的文档，请参阅 <a href="https://mp.csdn.net/postedit/86743079" target="_blank" rel="noopener">ESP-MESH API 指南</a>。</p>
<a id="more"></a>

<h2 id="ESP-MESH-编程模型"><a href="#ESP-MESH-编程模型" class="headerlink" title="ESP-MESH 编程模型"></a>ESP-MESH 编程模型</h2><h3 id="软件栈"><a href="#软件栈" class="headerlink" title="软件栈"></a>软件栈</h3><p>ESP-MESH 软件栈构建在 Wi-Fi 驱动/FreeRTOS 之上，并且在某些情况下可以使用 LwIP 栈（即根节点）。下图说明了 ESP-MESH 软件栈。<br><img src="https://img-blog.csdnimg.cn/2019030215595528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 软件栈"></p>
<h3 id="系统事件"><a href="#系统事件" class="headerlink" title="系统事件"></a>系统事件</h3><p>应用程序通过 ESP-MESH 事件与 ESP-MESH 交互。由于 ESP-MESH 构建在 Wi-Fi 栈的顶部，因此应用程序也可以通过 Wi-Fi 事件任务与 Wi-Fi 驱动交互。下图说明了 ESP-MESH 应用程序中各种系统事件的接口。<br><img src="https://img-blog.csdnimg.cn/20190302162721734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="ESP-MESH 系统事件"><br><code>mesh_event_id_t</code> 定义所有可能的  ESP-MESH 系统事件，并且可以指示诸如父/子的连接/断开之类的事件。在可以使用 ESP-MESH 系统事件之前，应用程序必须通过 <code>esp_mesh_set_config()</code> 注册 Mesh 事件回调。 回调用于从 ESP-MESH 栈以及 LwIP 栈接收事件，并且应包含与应用程序相关的每个事件的处理程序。</p>
<p>系统事件的典型用例包括使用诸如 <code>MESH_EVENT_PARENT_CONNECTED</code> 和 <code>MESH_EVENT_CHILD_CONNECTED</code> 之类的事件来指示节点何时可以分别开始上游和下游传输数据。 同样，<code>MESH_EVENT_ROOT_GOT_IP</code> 和 <code>MESH_EVENT_ROOT_LOST_IP</code> 可用于指示根节点何时能够和不能将数据传输到外部 IP 网络。</p>
<blockquote>
<p>在自组织模式下使用 ESP-MESH 时，用户必须确保不会调用 Wi-Fi API。这是因为自组织模式将在内部进行 Wi-Fi API 调用以连接/断开/扫描等。来自应用程序的任何 Wi-Fi 调用（包括来自回调函数和 Wi-Fi 事件处理程序的调用）可能干扰 ESP-MESH 的自组织行为。因此，在调用 <code>esp_mesh_start()</code> 之后，并且在调用 <code>esp_mesh_stop()</code> 之前，用户不应该调用 Wi-Fi API。</p>
</blockquote>
<h3 id="LwIP-amp-ESP-MESH"><a href="#LwIP-amp-ESP-MESH" class="headerlink" title="LwIP &amp; ESP-MESH"></a>LwIP &amp; ESP-MESH</h3><p><strong>应用程序可以直接访问 ESP-MESH 栈，而无需通过 LwIP 栈。仅根节点需要 LwIP 栈向/从外部 IP 网络发送/接收数据。</strong> 但是，由于每个节点都可能成为根节点（由于自动根节点选择），每个节点仍必须初始化 LwIP 栈。</p>
<p><strong>每个节点都需要通过调用 <code>tcpip_adapter_init()</code> 来初始化 LwIP 栈。为了防止非根节点访问 LwIP 栈，应用程序应在 LwIP 栈初始化后停止以下服务</strong>：</p>
<ul>
<li>SoftAP 接口上的 DHCP 服务器服务。</li>
<li>Station 接口上的 DHCP 客户端服务。</li>
</ul>
<p>以下代码段演示了如何为 ESP-MESH 应用程序初始化 LwIP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*  tcpip initialization *&#x2F;</span><br><span class="line">tcpip_adapter_init();</span><br><span class="line">&#x2F;*</span><br><span class="line"> * for mesh</span><br><span class="line"> * stop DHCP server on softAP interface by default</span><br><span class="line"> * stop DHCP client on station interface by default</span><br><span class="line"> *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA));</span><br><span class="line">&#x2F;* do not specify system event callback, use NULL instead. *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_event_loop_init(NULL, NULL));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ESP-MESH 要求根节点与路由器连接。因此，如果节点成为根节点，则相应的处理程序必须启动 DHCP 客户端服务并立即获取 IP 地址。这样做将允许其他节点开始向/从外部 IP 网络发送/接收分组。但是，如果使用静态 IP 设置，则不需要此步骤。</p>
</blockquote>
<h2 id="编写-ESP-MESH-应用程序"><a href="#编写-ESP-MESH-应用程序" class="headerlink" title="编写 ESP-MESH 应用程序"></a>编写 ESP-MESH 应用程序</h2><p><strong>启动 ESP-MESH 的先决条件是初始化 LwIP 和 Wi-Fi。</strong> 以下代码片段演示了初始化 ESP-MESH 之前必要的先决条件步骤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpip_adapter_init();</span><br><span class="line">&#x2F;*</span><br><span class="line"> * for mesh</span><br><span class="line"> * stop DHCP server on softAP interface by default</span><br><span class="line"> * stop DHCP client on station interface by default</span><br><span class="line"> *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP));</span><br><span class="line">ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA));</span><br><span class="line">&#x2F;* do not specify system event callback, use NULL instead. *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_event_loop_init(NULL, NULL));</span><br><span class="line"></span><br><span class="line">&#x2F;*  Wi-Fi initialization *&#x2F;</span><br><span class="line">wifi_init_config_t config &#x3D; WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_init(&amp;config));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH));</span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_start());</span><br></pre></td></tr></table></figure>

<p>初始化 LwIP 和 Wi-Fi 后，启动和运行 ESP-MESH 网络的过程可归纳为以下三个步骤：</p>
<ul>
<li>初始化 Mesh</li>
<li>配置 ESP-MESH 网络</li>
<li>启动 Mesh</li>
</ul>
<h3 id="初始化-Mesh"><a href="#初始化-Mesh" class="headerlink" title="初始化 Mesh"></a>初始化 Mesh</h3><p>以下代码段演示了如何初始化 ESP-MESH</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*  mesh initialization *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_init());</span><br></pre></td></tr></table></figure>

<h3 id="配置-ESP-MESH-网络"><a href="#配置-ESP-MESH-网络" class="headerlink" title="配置 ESP-MESH 网络"></a>配置 ESP-MESH 网络</h3><p><strong>ESP-MESH 通过 <code>esp_mesh_set_config()</code> 配置，它使用 <code>mesh_cfg_t</code> 结构接收其参数。</strong> 该结构包含用于配置 ESP-MESH 的以下参数：</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Channel</td>
<td>Range from 1 to 14</td>
</tr>
<tr>
<td>Event Callback</td>
<td>Callback for Mesh Events, see mesh_event_cb_t</td>
</tr>
<tr>
<td>Mesh ID</td>
<td>ID of ESP-MESH Network, see mesh_addr_t</td>
</tr>
<tr>
<td>Router</td>
<td>Router Configuration, see mesh_router_t</td>
</tr>
<tr>
<td>Mesh AP</td>
<td>Mesh AP Configuration, see mesh_ap_cfg_t</td>
</tr>
<tr>
<td>Crypto Functions</td>
<td>Crypto Functions for Mesh IE, see mesh_crypto_funcs_t</td>
</tr>
</tbody></table>
<p>以下代码段演示了如何配置 ESP-MESH。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Enable the Mesh IE encryption by default *&#x2F;</span><br><span class="line">mesh_cfg_t cfg &#x3D; MESH_INIT_CONFIG_DEFAULT();</span><br><span class="line">&#x2F;* mesh ID *&#x2F;</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.mesh_id, MESH_ID, 6);</span><br><span class="line">&#x2F;* mesh event callback *&#x2F;</span><br><span class="line">cfg.event_cb &#x3D; &amp;mesh_event_handler;</span><br><span class="line">&#x2F;* channel (must match the router&#39;s channel) *&#x2F;</span><br><span class="line">cfg.channel &#x3D; CONFIG_MESH_CHANNEL;</span><br><span class="line">&#x2F;* router *&#x2F;</span><br><span class="line">cfg.router.ssid_len &#x3D; strlen(CONFIG_MESH_ROUTER_SSID);</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len);</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.router.password, CONFIG_MESH_ROUTER_PASSWD,</span><br><span class="line">       strlen(CONFIG_MESH_ROUTER_PASSWD));</span><br><span class="line">&#x2F;* mesh softAP *&#x2F;</span><br><span class="line">cfg.mesh_ap.max_connection &#x3D; CONFIG_MESH_AP_CONNECTIONS;</span><br><span class="line">memcpy((uint8_t *) &amp;cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD,</span><br><span class="line">       strlen(CONFIG_MESH_AP_PASSWD));</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_set_config(&amp;cfg));</span><br></pre></td></tr></table></figure>

<h3 id="启动-Mesh"><a href="#启动-Mesh" class="headerlink" title="启动 Mesh"></a>启动 Mesh</h3><p>以下代码段演示了如何启动 ESP-MESH。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* mesh start *&#x2F;</span><br><span class="line">ESP_ERROR_CHECK(esp_mesh_start());</span><br></pre></td></tr></table></figure>

<p><strong>启动 ESP-MESH 后，应用程序应检查 ESP-MESH 事件以确定它何时连接到网络。连接后，应用程序可以使用 <code>esp_mesh_send()</code> 和 <code>esp_mesh_recv()</code> 通过 ESP-MESH 网络开始发送和接收数据包。</strong></p>
<h2 id="自组织网络"><a href="#自组织网络" class="headerlink" title="自组织网络"></a>自组织网络</h2><p>自组织网络是 ESP-MESH 的一项功能，节点可以自动扫描/选择/连接/重新连接到其他节点和路由器。此功能允许 ESP-MESH 网络通过使网络对动态网络拓扑和条件具有鲁棒性来实现高度自治。启用自组织网络后，ESP-MESH 网络中的节点无需自主执行以下操作：</p>
<ul>
<li>选择或选择根节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-building-a-network" target="_blank" rel="noopener">构建网络</a>中的自动根节点选择）</li>
<li>选择首选父节点（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-building-a-network" target="_blank" rel="noopener">构建网络</a>中的父节点选择）</li>
<li>检测到断开连接时自动重新连接（请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/mesh.html#mesh-managing-a-network" target="_blank" rel="noopener">管理网络</a>中的中间父节点故障）</li>
</ul>
<p>启用自组织网络后，ESP-MESH 栈将在内部调用 Wi-Fi 驱动程序 API。因此，应用层不应对 Wi-Fi 驱动程序 API 进行任何调用，同时启用自组织网络，否则可能会干扰 ESP-MESH。</p>
<h3 id="切换自组织网络"><a href="#切换自组织网络" class="headerlink" title="切换自组织网络"></a>切换自组织网络</h3><p>应用程序在运行时通过调用 <code>esp_mesh_set_self_organized()</code> 函数可以启用或禁用自组织网络。该函数具有以下两个参数：</p>
<ul>
<li><code>bool enable</code> 指定是启用还是禁用自组织网络。</li>
<li><code>bool select_parent</code> 指定在启用自组织网络时是否应选择新的父节点。根据节点类型和节点的当前状态，选择新父级具有不同的效果。禁用自组织网络时，此参数未使用。</li>
</ul>
<h3 id="禁用自组织网络"><a href="#禁用自组织网络" class="headerlink" title="禁用自组织网络"></a>禁用自组织网络</h3><p>以下代码段演示了如何禁用自组织网络。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Disable self organized networking</span><br><span class="line">esp_mesh_set_self_organized(false, false);</span><br></pre></td></tr></table></figure>

<p>当禁用自组织网络时，ESP-MESH 将尝试维持节点当前的 Wi-Fi 状态。</p>
<ul>
<li>如果节点先前已连接到其他节点，则它将保持连接状态。</li>
<li>如果节点先前已断开连接并且正在扫描父节点或路由器，则它将停止扫描。</li>
<li>如果节点先前尝试重新连接到父节点或路由器，它将停止重新连接。</li>
</ul>
<h3 id="启用自组织网络"><a href="#启用自组织网络" class="headerlink" title="启用自组织网络"></a>启用自组织网络</h3><p>在启用自组织网络时，ESP-MESH 将尝试维持节点当前的 Wi-Fi 状态。但是，根据节点类型以及是否选择了新父节点，节点的 Wi-Fi 状态可能会发生变化。下表显示了启用自组织网络的效果。</p>
<p><img src="https://img-blog.csdnimg.cn/20190302173636709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以下代码演示了如何启用自组织网络。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Enable self organized networking and select a new parent</span><br><span class="line">esp_mesh_set_self_organized(true, true);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Enable self organized networking and manually reconnect</span><br><span class="line">esp_mesh_set_self_organized(true, false);</span><br><span class="line">esp_mesh_connect();</span><br></pre></td></tr></table></figure>

<h3 id="调用-Wi-Fi-驱动程序-API"><a href="#调用-Wi-Fi-驱动程序-API" class="headerlink" title="调用 Wi-Fi 驱动程序 API"></a>调用 Wi-Fi 驱动程序 API</h3><p>应用程序可能希望在使用 ESP-MESH 时直接调用 Wi-Fi 驱动程序 API 的情况。例如，应用程序可能想要手动扫描相邻的 AP。但是，<strong>在应用程序调用任何 Wi-Fi 驱动程序 API 之前，必须禁用自组织网络。</strong> 这将阻止 ESP-MESH 栈尝试调用任何 Wi-Fi 驱动程序 API ，ESP-MESH 栈的这些调用可能干扰应用程序的调用。</p>
<p>因此，<strong>应该在调用 <code>esp_mesh_set_self_organized()</code> 进行禁用和启用自组织网络之间放置对 Wi-Fi 驱动程序 API 的调用。</strong> 以下代码段演示了应用程序在使用 ESP-MESH 时如何安全地调用 <code>esp_wifi_scan_start()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Disable self organized networking</span><br><span class="line">esp_mesh_set_self_organized(0, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Stop any scans already in progress</span><br><span class="line">esp_wifi_scan_stop();</span><br><span class="line">&#x2F;&#x2F;Manually start scan. Will automatically stop when run to completion</span><br><span class="line">esp_wifi_scan_start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Process scan results</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if still connected</span><br><span class="line">esp_mesh_set_self_organized(1, 0);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if non-root and disconnected</span><br><span class="line">esp_mesh_set_self_organized(1, 1);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Re-enable self organized networking if root and disconnected</span><br><span class="line">esp_mesh_set_self_organized(1, 0);  &#x2F;&#x2F;Don&#39;t select new parent</span><br><span class="line">esp_mesh_connect();                 &#x2F;&#x2F;Manually reconnect to router</span><br></pre></td></tr></table></figure>

<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>ESP-IDF 包含这些 ESP-MESH 示例项目：</p>
<p><a href="https://github.com/espressif/esp-idf/tree/ebdcbe8c6/examples/mesh/internal_communication" target="_blank" rel="noopener">内部通信示例</a>演示了如何设置 ESP-MESH 网络并让根节点向网络中的每个节点发送数据包。</p>
<p><a href="https://github.com/espressif/esp-idf/tree/ebdcbe8c6/examples/mesh/manual_networking" target="_blank" rel="noopener">手动网络示例</a>演示了如何在没有自组织功能的情况下使用 ESP-MESH。此示例显示如何对节点进行编程以手动扫描潜在父节点列表，并根据自定义条件选择父节点。</p>
<h2 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ul>
<li>esp32/include/esp_mesh.h</li>
</ul>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ul>
<li>esp_err_tesp_mesh_init(void)</li>
<li>esp_err_tesp_mesh_deinit(void)</li>
<li>esp_err_tesp_mesh_start(void)</li>
<li>esp_err_tesp_mesh_stop(void)</li>
<li>esp_err_tesp_mesh_send(constmesh_addr_t *to, constmesh_data_t *data, int flag, constmesh_opt_topt[], int opt_count)</li>
<li>esp_err_tesp_mesh_recv(mesh_addr_t *from, mesh_data_t *data, int timeout_ms, int *flag, mesh_opt_topt[], int opt_count)</li>
<li>esp_err_tesp_mesh_recv_toDS(mesh_addr_t *from, mesh_addr_t *to, mesh_data_t *data, int timeout_ms, int *flag, mesh_opt_topt[], int opt_count)</li>
<li>esp_err_tesp_mesh_set_config(constmesh_cfg_t *config)</li>
<li>esp_err_tesp_mesh_get_config(mesh_cfg_t *config)</li>
<li>esp_err_tesp_mesh_set_router(constmesh_router_t *router)</li>
<li>esp_err_tesp_mesh_get_router(mesh_router_t *router)</li>
<li>esp_err_tesp_mesh_set_id(constmesh_addr_t *id)</li>
<li>esp_err_tesp_mesh_get_id(mesh_addr_t *id)</li>
<li>esp_err_tesp_mesh_set_type(mesh_type_ttype)</li>
<li>mesh_type_tesp_mesh_get_type(void)</li>
<li>esp_err_tesp_mesh_set_max_layer(int max_layer)</li>
<li>int esp_mesh_get_max_layer(void)</li>
<li>esp_err_tesp_mesh_set_ap_password(const uint8_t *pwd, int len)</li>
<li>esp_err_tesp_mesh_set_ap_authmode(wifi_auth_mode_tauthmode)</li>
<li>wifi_auth_mode_tesp_mesh_get_ap_authmode(void)</li>
<li>esp_err_tesp_mesh_set_ap_connections(int connections)</li>
<li>int esp_mesh_get_ap_connections(void)</li>
<li>int esp_mesh_get_layer(void)</li>
<li>esp_err_tesp_mesh_get_parent_bssid(mesh_addr_t *bssid)</li>
<li>bool esp_mesh_is_root(void)</li>
<li>esp_err_tesp_mesh_set_self_organized(bool enable, bool select_parent)</li>
<li>bool esp_mesh_get_self_organized(void)</li>
<li>esp_err_tesp_mesh_waive_root(constmesh_vote_t *vote, int reason)</li>
<li>esp_err_tesp_mesh_set_vote_percentage(float percentage)</li>
<li>float esp_mesh_get_vote_percentage(void)</li>
<li>esp_err_tesp_mesh_set_ap_assoc_expire(int seconds)</li>
<li>int esp_mesh_get_ap_assoc_expire(void)</li>
<li>int esp_mesh_get_total_node_num(void)</li>
<li>int esp_mesh_get_routing_table_size(void)</li>
<li>esp_err_tesp_mesh_get_routing_table(mesh_addr_t *mac, int len, int *size)</li>
<li>esp_err_tesp_mesh_post_toDS_state(bool reachable)</li>
<li>esp_err_tesp_mesh_get_tx_pending(mesh_tx_pending_t *pending)</li>
<li>esp_err_tesp_mesh_get_rx_pending(mesh_rx_pending_t *pending)</li>
<li>int esp_mesh_available_txupQ_num(constmesh_addr_t *addr, uint32_t *xseqno_in)</li>
<li>esp_err_tesp_mesh_set_xon_qsize(int qsize)</li>
<li>int esp_mesh_get_xon_qsize(void)</li>
<li>esp_err_tesp_mesh_allow_root_conflicts(bool allowed)</li>
<li>bool esp_mesh_is_root_conflicts_allowed(void)</li>
<li>esp_err_tesp_mesh_set_group_id(constmesh_addr_t *addr, int num)</li>
<li>esp_err_tesp_mesh_delete_group_id(constmesh_addr_t *addr, int num)</li>
<li>int esp_mesh_get_group_num(void)</li>
<li>esp_err_tesp_mesh_get_group_list(mesh_addr_t *addr, int num)</li>
<li>bool esp_mesh_is_my_group(constmesh_addr_t *addr)</li>
<li>esp_err_tesp_mesh_set_capacity_num(int num)</li>
<li>int esp_mesh_get_capacity_num(void)</li>
<li>esp_err_tesp_mesh_set_ie_crypto_funcs(const mesh_crypto_funcs_t *crypto_funcs)</li>
<li>esp_err_tesp_mesh_set_ie_crypto_key(const char *key, int len)</li>
<li>esp_err_tesp_mesh_get_ie_crypto_key(char *key, int len)</li>
<li>esp_err_tesp_mesh_set_root_healing_delay(int delay_ms)</li>
<li>int esp_mesh_get_root_healing_delay(void)</li>
<li>esp_err_tesp_mesh_set_event_cb(constmesh_event_cb_tevent_cb)</li>
<li>esp_err_tesp_mesh_fix_root(bool enable)</li>
<li>bool esp_mesh_is_root_fixed(void)</li>
<li>esp_err_tesp_mesh_set_parent(constwifi_config_t *parent, constmesh_addr_t *parent_mesh_id, mesh_type_tmy_type, int my_layer)</li>
<li>esp_err_tesp_mesh_scan_get_ap_ie_len(int *len)</li>
<li>esp_err_tesp_mesh_scan_get_ap_record(wifi_ap_record_t *ap_record, void *buffer)</li>
<li>esp_err_tesp_mesh_flush_upstream_packets(void)</li>
<li>esp_err_tesp_mesh_get_subnet_nodes_num(constmesh_addr_t *child_mac, int *nodes_num)</li>
<li>esp_err_tesp_mesh_get_subnet_nodes_list(constmesh_addr_t *child_mac, mesh_addr_t *nodes, int nodes_num)</li>
<li>esp_err_tesp_mesh_disconnect(void)</li>
<li>esp_err_tesp_mesh_connect(void)</li>
<li>esp_err_tesp_mesh_flush_scan_result(void)</li>
<li>esp_err_tesp_mesh_switch_channel(const uint8_t *new_bssid, int csa_newchan, int csa_count)</li>
<li>esp_err_tesp_mesh_get_router_bssid(uint8_t *router_bssid)</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/network/esp_mesh.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十四）RF 校准</title>
    <url>/InfiniteYuanBlog/2018/12/09/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89RF%20%E6%A0%A1%E5%87%86/</url>
    <content><![CDATA[<h1 id="RF-校准"><a href="#RF-校准" class="headerlink" title="RF 校准"></a>RF 校准</h1><p>ESP32 在 RF 初始化期间支持三种 RF 校准方法：</p>
<ol>
<li>部分校准</li>
<li>完全校准</li>
<li>没有校准</li>
</ol>
<a id="more"></a>

<h2 id="部分校准"><a href="#部分校准" class="headerlink" title="部分校准"></a>部分校准</h2><p>在 RF 初始化期间，默认情况下使用部分校准方法进行 RF 校准。 它基于存储在 NVS 中的完整校准数据完成。 要使用此方法，请到 <code>menuconfig</code> 并启用 <code>CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE</code>。</p>
<h2 id="完全校准"><a href="#完全校准" class="headerlink" title="完全校准"></a>完全校准</h2><p>在以下条件下触发完全校准：</p>
<ol>
<li>NVS  不存在。</li>
<li>用于存储校准数据的  NVS  分区被擦除。</li>
<li>硬件 MAC  地址已更改。</li>
<li>PHY 库版本已更改。</li>
<li>从 NVS 分区加载的 RF 校准数据被破坏。</li>
</ol>
<p>需要大约  100 ms, 比部分校准用的时间多。如果启动持续时间不重要，建议使用完整的校准方法。要切换到完整校准方法，请转到 <code>menuconfig</code> 并禁用 <code>CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE</code>。如果使用 RF 校准的默认方法，有两种方法可以添加触发完全校准功能作为最后的补救措施。</p>
<ol>
<li>如果您不介意删除存储在  NVS  分区中的所有数据，请擦除 NVS 分区。</li>
<li>在基于某些条件（例如，在某些诊断模式中提供的选项）初始化 WiFi  和 BT/BLE 之前调用 <code>esp_phy_erase_cal_data_in_nvs（）</code>。在这种情况下，仅擦除 NVS 分区的 phy 命名空间。</li>
</ol>
<h2 id="没有校准"><a href="#没有校准" class="headerlink" title="没有校准"></a>没有校准</h2><p>ESP32 从深度睡眠中醒来时，不会使用校准方法。</p>
<h2 id="PHY-初始化数据"><a href="#PHY-初始化数据" class="headerlink" title="PHY 初始化数据"></a>PHY 初始化数据</h2><p>PHY 初始化数据用于 RF 校准。 有两种方法可以获得 PHY 初始化数据。</p>
<ol>
<li>一个是默认的初始化数据，它位于头文件 <code>components/esp32/phy_init_data.h</code> 中。 它在编译后嵌入到应用程序二进制文件中，然后存储到只读存储器（DROM）中。 要使用默认初始化数据，请到 <code>menuconfig</code> 并禁用 <code>CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</code>。</li>
<li>另一种是存储在分区中的初始化数据。 使用自定义分区表时，请确保包含 PHY 数据分区（类型：数据，子类型：phy）。 使用默认分区表，这是自动完成的。 如果初始化数据存储在分区中，则必须在那里闪存，否则将发生运行时错误。 要切换到存储在分区中的初始化数据，请到 <code>menuconfig</code> 并启用 <code>CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</code>。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/RF_calibration.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（十）线程局部存储</title>
    <url>/InfiniteYuanBlog/2018/09/02/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%8D%81%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>线程局部存储 (TLS) 是一种机制,通过该机制分配变量,使每个现存线程有一个变量实例. ESP-IDF 提供了三种利用这些变量的方法:</p>
<p><a href="#freertos-%E5%8E%9F%E7%94%9F-api">FreeRTOS 原生 API</a>: ESP-IDF FreeRTOS 原生 API.<br><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-api">多线程 API</a>:ESP-IDF 的多线程 API.<br><a href="#c11-%E6%A0%87%E5%87%86">C11 标准</a>:C11 标准引入了特殊关键字来将变量声明为线程局部.</p>
<a id="more"></a>

<h2 id="FreeRTOS-原生-API"><a href="#FreeRTOS-原生-API" class="headerlink" title="FreeRTOS 原生 API"></a>FreeRTOS 原生 API</h2><p>ESP-IDF FreeRTOS 提供以下 AP I来管理线程局部变量:</p>
<ul>
<li>vTaskSetThreadLocalStoragePointer()</li>
<li>pvTaskGetThreadLocalStoragePointer()</li>
<li>vTaskSetThreadLocalStoragePointerAndDelCallback()</li>
</ul>
<p>在这种情况下,可分配的最大变量数受 <code>configNUM_THREAD_LOCAL_STORAGE_POINTERS</code> 宏的限制. 变量保存在任务控制块 (TCB) 中,并通过索引访问. 请注意,索引 0 保留用于 ESP-IDF 内部使用. 使用该 API,用户可以分配任意大小的线程局部变量,并将它们分配给任意数量的任务. 不同的任务可以有不同的 TLS 变量集. 如果变量的大小超过 4 个字节,则用户负责为其分配/释放内存. 变量的释放由 FreeRTOS 在删除任务时启动,但用户必须提供函数(回调)才能进行适当的清理.</p>
<h2 id="多线程-API"><a href="#多线程-API" class="headerlink" title="多线程 API"></a>多线程 API</h2><p>ESP-IDF提供以下 多线程 API 来管理线程局部变量:</p>
<ul>
<li>pthread_key_create()</li>
<li>pthread_key_delete()</li>
<li>pthread_getspecific()</li>
<li>pthread_setspecific()</li>
</ul>
<p>此 API 具有上述 API 的所有优点,但消除了一些限制. 变量的数量仅受堆上可用内存大小的限制. 由于动态特性,与原生 API 相比,此 API 引入了额外的性能开销.</p>
<h2 id="C11-标准"><a href="#C11-标准" class="headerlink" title="C11 标准"></a>C11 标准</h2><p>ESP-IDF FreeRTOS 支持根据 C11 标准的线程局部变量(使用 <code>__thread</code> 关键字指定的变量). 有关此 GCC 功能的详细信息,请参阅<a href="https://gcc.gnu.org/onlinedocs/gcc-5.5.0/gcc/Thread-Local.html#Thread-Local" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/gcc-5.5.0/gcc/Thread-Local.html#Thread-Local</a>. 这种变量的存储在任务堆栈上分配. 请注意,程序中所有此类变量的区域将分配到系统中每个任务的堆栈上,即使该任务根本不使用此类变量也是如此. 例如, ESP-IDF 系统任务(如 <code>ipc</code>, <code>timer</code> 任务等)也将分配额外的堆栈空间. 因此应谨慎使用此功能. 有一个权衡: C11 线程局部变量在编程中非常方便,只需使用几个 Xtensa 指令即可访问,但这个好处与系统中所有任务的额外堆栈使用成本有关. 由于变量的静态性质,系统中的所有任务都具有相同的 C11 线程局部变量集.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/thread-local-storage.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 官方文档（四）错误处理</title>
    <url>/InfiniteYuanBlog/2018/09/01/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/ESP32%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%9B%9B%EF%BC%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>识别和处理运行时错误对于开发健壮的应用程序非常重要. ESP-IDF 中可能存在多种运行时错误:</p>
<ul>
<li>可恢复的错误:<ul>
<li>函数通过返回值表示的错误(错误代码)</li>
<li>使用 throw 关键字抛出的 C++ 异常</li>
</ul>
</li>
<li>不可恢复(严重)错误:<ul>
<li>断言失败(使用断言宏和等效方法)和 abort() 调用.</li>
<li>CPU 异常:access to protected regions of memory, illegal instruction(访问受保护的内存区域,非法指令)等.</li>
<li>系统级别检查:watchdog timeout, cache access error, stack overflow, stack smashing, heap corruption(监视程序超时,缓存访问错误,堆栈溢出,堆栈粉碎,堆损坏)等.</li>
</ul>
</li>
</ul>
<p>本指南介绍了与可恢复错误相关的 ESP-IDF 错误处理机制,并提供了一些常见的错误处理模式.</p>
<p>有关诊断不可恢复错误的说明,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误</a>.</p>
<a id="more"></a>

<h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><p>大多数特定的 ESP-IDF 函数使用 <code>esp_err_t</code> 类型来返回错误代码. <code>esp_err_t</code> 是带符号的整数类型. <code>ESP_OK</code> 代码表示成功(无错误),定义为零.</p>
<p>各种 ESP-IDF 头文件使用预处理器定义来定义可能的错误代码. 通常这些定义以 <code>ESP_ERR_</code> 前缀开头. 通用错误的常见错误代码(内存不足,超时,无效参数等)在 <code>esp_err.h</code> 文件中定义. ESP-IDF 中的各种组件可以为特定情况定义附加的错误代码.</p>
<p>有关错误代码的完整列表,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/error-codes.html" target="_blank" rel="noopener">错误代码参考</a>.</p>
<h2 id="将错误代码转换为错误消息"><a href="#将错误代码转换为错误消息" class="headerlink" title="将错误代码转换为错误消息"></a>将错误代码转换为错误消息</h2><p>对于 ESP-IDF 组件中定义的每个错误代码,可以使用 <code>esp_err_to_name()</code> 或 <code>esp_err_to_name_r()</code> 函数将 <code>esp_err_t</code> 值转换为错误代码名称. 例如,将 <code>0x101</code> 传递给 <code>esp_err_to_name()</code> 将返回 “ESP_ERR_NO_MEM” 字符串. 可以在日志输出中使用此类字符串,以便更容易理解发生了哪个错误.</p>
<p>此外,如果未找到匹配的 <code>ESP_ERR_</code> 值,<code>esp_err_to_name_r()</code> 函数将尝试将错误代码解释为<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html" target="_blank" rel="noopener">标准 POSIX 错误代码</a>. 这是使用 <code>strerror_r</code> 函数完成的. POSIX 错误代码(例如 <code>ENOENT</code>,<code>ENOMEM</code>)在 <code>errno.h</code> 中定义,通常从 <code>errno</code> 变量获得. 在 ESP-IDF 中,这个变量是线程本地的:多个 FreeRTOS 任务都有自己的 <code>errno</code> 副本. 设置 <code>errno</code> 的函数仅修改它们运行的任务的值.</p>
<p>默认情况下启用此功能,但可以禁用此功能以减少应用程序二进制文件大小. 请参阅 <code>CONFIG_ESP_ERR_TO_NAME_LOOKUP</code>. 禁用此功能后,仍会定义 <code>esp_err_to_name()</code> 和 <code>esp_err_to_name_r()</code> ,并且可以调用它. 在这种情况下,<code>esp_err_to_name()</code> 将返回<code>UNKNOWN ERROR</code>,并且 <code>esp_err_to_name_r()</code> 将返回 <code>Unknown error 0xXXXX(YYYYY)</code> ,其中<code>0xXXXX</code> 和 <code>YYYYY</code> 分别是错误代码的十六进制和十进制表示.</p>
<h2 id="ESP-ERROR-CHECK-宏"><a href="#ESP-ERROR-CHECK-宏" class="headerlink" title="ESP_ERROR_CHECK 宏"></a><code>ESP_ERROR_CHECK</code> 宏</h2><p><code>ESP_ERROR_CHECK()</code> 宏与 <code>assert</code> 的用途相似,只是它检查 <code>esp_err_t</code> 值而不是 <code>bool</code> 条件. 如果 <code>ESP_ERROR_CHECK()</code> 的参数不等于 <code>ESP_OK</code> ,则在控制台上打印错误消息,并调用 <code>abort()</code>.</p>
<p>错误消息通常如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESP_ERROR_CHECK failed: esp_err_t 0x107 (ESP_ERR_TIMEOUT) at 0x400d1fdf</span><br><span class="line"></span><br><span class="line">file: &quot;&#x2F;Users&#x2F;user&#x2F;esp&#x2F;example&#x2F;main&#x2F;main.c&quot; line 20</span><br><span class="line">func: app_main</span><br><span class="line">expression: sdmmc_card_init(host, &amp;card)</span><br><span class="line"></span><br><span class="line">Backtrace: 0x40086e7c:0x3ffb4ff0 0x40087328:0x3ffb5010 0x400d1fdf:0x3ffb5030 0x400d0816:0x3ffb5050</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/idf-monitor.html" target="_blank" rel="noopener">IDF monitor</a>,则回溯中的地址将转换为文件名和行号.</p>
</blockquote>
<ul>
<li>第一行提到错误代码为十六进制值,以及源代码中用于此错误的标识符. 后者取决于设置的 <code>CONFIG_ESP_ERR_TO_NAME_LOOKUP</code> 选项. 打印出错误的程序中的地址也被打印出来.</li>
<li>后续行显示程序中调用 <code>ESP_ERROR_CHECK()</code> 宏的位置,以及作为参数传递给宏的表达式.</li>
<li>最后,打印回溯. 这是所有错误 <code>panic</code> 处理程序输出的公共部分. 有关回溯的更多信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误 Fatal Errors</a>.</li>
</ul>
<h2 id="错误处理模式"><a href="#错误处理模式" class="headerlink" title="错误处理模式"></a>错误处理模式</h2><ol>
<li><p>尝试恢复. 根据具体情况,这可能意味着在一段时间后重试呼叫,或尝试取消初始化驱动程序并重新初始化,或使用带外机制修复错误条件(例如重置外部外围设备) 这没有回应).</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esp_err_t err;</span><br><span class="line">do &#123;</span><br><span class="line">    err &#x3D; sdio_slave_send_queue(addr, len, arg, timeout);</span><br><span class="line">    &#x2F;&#x2F; keep retrying while the sending queue is full</span><br><span class="line">&#125; while (err &#x3D;&#x3D; ESP_ERR_TIMEOUT);</span><br><span class="line">if (err !&#x3D; ESP_OK) &#123;</span><br><span class="line">    &#x2F;&#x2F; handle other errors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将错误传播给调用者. 在某些中间件组件中,这意味着函数必须以相同的错误代码退出,从而确保回滚任何资源分配.</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	sdmmc_card_t* card &#x3D; calloc(1, sizeof(sdmmc_card_t));</span><br><span class="line">if (card &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    return ESP_ERR_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line">esp_err_t err &#x3D; sdmmc_card_init(host, &amp;card);</span><br><span class="line">if (err !&#x3D; ESP_OK) &#123;</span><br><span class="line">    &#x2F;&#x2F; Clean up</span><br><span class="line">    free(card);</span><br><span class="line">    &#x2F;&#x2F; Propagate the error to the upper layer (e.g. to notify the user).</span><br><span class="line">    &#x2F;&#x2F; Alternatively, application can define and return custom error code.</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换为不可恢复的错误,例如使用 <code>ESP_ERROR_CHECK</code>. 有关详细信息,请参阅 <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/error-handling.html#esp-error-check-macro" target="_blank" rel="noopener"><code>ESP_ERROR_CHECK</code> 宏</a>部分.</p>
<p>在出现错误的情况下终止应用程序通常是中间件组件的不良行为,但有时在应用程序级别可以接受.</p>
<p>许多 ESP-IDF 示例使用 <code>ESP_ERROR_CHECK</code> 来处理来自各种API的错误. 这不是应用程序的最佳实践,并且可以使示例代码更简洁.</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESP_ERROR_CHECK(spi_bus_initialize(host, bus_config, dma_chan));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="C-异常"><a href="#C-异常" class="headerlink" title="C++ 异常"></a>C++ 异常</h2><p>默认情况下禁用对 ESP-IDF 中的 C++ 异常的支持,但可以使用 <code>CONFIG_CXX_EXCEPTIONS</code> 选项启用.</p>
<p>启用异常处理通常会将应用程序二进制大小增加几KB. 此外,可能需要为异常紧急池预留一定量的 RAM. 如果无法从堆中分配异常对象,则将使用此池中的内存. 可以使用 <code>CONFIG_CXX_EXCEPTIONS_EMG_POOL_SIZE</code> 变量设置应急池中的内存量.</p>
<p>如果抛出异常,但没有 <code>catch</code> 块,程序将被 <code>abort</code> 函数终止,并且将打印 <code>backtrace</code>. 有关回溯的更多信息,请参阅<a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/fatal-errors.html" target="_blank" rel="noopener">错误</a>.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/error-handling.html" target="_blank" rel="noopener">原文链接</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 官方文档</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（一）ESP32  移植开源图形库 uGFX</title>
    <url>/InfiniteYuanBlog/2018/01/10/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89ESP32%20%20%E7%A7%BB%E6%A4%8D%E5%BC%80%E6%BA%90%E5%9B%BE%E5%BD%A2%E5%BA%93%20uGFX/</url>
    <content><![CDATA[<h1 id="ESP32-移植开源图形库-ugfx"><a href="#ESP32-移植开源图形库-ugfx" class="headerlink" title="ESP32 移植开源图形库 ugfx"></a>ESP32 移植开源图形库 ugfx</h1><p>ESP32 移植 uGFX 的源码：<a href="https://github.com/InfiniteYuan/esp32-ugfx-gui" target="_blank" rel="noopener">GitHub 源码地址</a><br>欢迎 Star ～</p>
<h2 id="源码工程分析"><a href="#源码工程分析" class="headerlink" title="源码工程分析"></a>源码工程分析</h2><ol>
<li>/3rdparty 这里面包含第三方相关的功能代码</li>
<li>/boards 一些公用开发板的使用资料</li>
<li>/demos 例子应用</li>
<li>/docs 帮助文档</li>
<li>/drivers 底层驱动代码</li>
<li>/src 公共源码</li>
<li>/tools 相关工具</li>
</ol>
<a id="more"></a>

<h2 id="移植过程"><a href="#移植过程" class="headerlink" title="移植过程"></a>移植过程</h2><p>在移植之前，你需要配置 esp32-iot-solution 的环境，可参考： <a href="https://esp-idf.readthedocs.io/en/latest/get-started/index.html" target="_blank" rel="noopener"> ESP-IDF Programming Guide </a></p>
<ul>
<li>从 ugfx 官网下载源码：<a href="https://community.ugfx.io/index.php?/files/" target="_blank" rel="noopener">官网下载链接</a></li>
<li>在工程下单独建立一个 ugfx 文件夹，并在下面新建一个 include 文件夹（其中放入你需要包含的头文件）</li>
<li>拷贝配置头文件 gfxconf.h 和 gfx.h 到 include 文件夹</li>
<li>拷贝源码文件 /src 到 ugfx 文件夹下</li>
<li>添加驱动芯片的驱动文件到 ugfx 文件夹下（例如，你使用的 LCD 屏驱动和 touch 驱动，在 drives 中可以找到一些模板）</li>
<li>增加自己的板级文件 board_SSD1306.c</li>
<li>实现相关缺少函数，相关函数可以在 drivers 的驱动模板中看到。你需要选择性的实现一些函数，另一些函数使用默认的即可。</li>
</ul>
<p>这是我的工程结构，其中实现了：LCD(ST7789)、touch(XPT2046)<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTEwMTgxNzM5NjM3?x-oss-process=image/format,png" alt="这是我的工程结构"><br>在下面的两节，我将介绍我在移植 ugfx 中的部分过程，可供参考</p>
<h2 id="移植-LCD-驱动"><a href="#移植-LCD-驱动" class="headerlink" title="移植 LCD 驱动"></a>移植 LCD 驱动</h2><ul>
<li>由于 ugfx 官方未提供 st7789 的驱动模板，在这里我们使用 drivers/gdisp/ST7735 中的驱动模板，将其拷贝到我们的 ugfx 文件夹下，并从 ST7565 中拷贝一个头文件 board_ST7565_template.h，共需添加五个文件。</li>
<li>接着我们实现一些函数，例如 init_board、post_init_board、setpin_reset、acquire_bus、release_bus、write_cmd、write_data;这些都在 board_ST7565_template.h 中有默认定义，我们需要根据我们的工程情况修改实现方法</li>
<li>我们还需要对文件中的相关宏定义作修改</li>
</ul>
<h2 id="移植-touch-驱动"><a href="#移植-touch-驱动" class="headerlink" title="移植 touch 驱动"></a>移植 touch 驱动</h2><ul>
<li>在移植完上面的 lcd 驱动，相信你已经找到感觉，我们可以直接中 drivers/ginput/ 中拷贝 ads7843 下的文件到 ugfx 文件夹下，接着和移植 lcd 是类似的操作</li>
<li>实现函数，例如：getpin_pressed、read_value、init_board，在实现 aquire_bus、release_bus 的时候，可能编译器会报函数重定义的错，这个时候，我们需要查看是否头文件引用错误等</li>
</ul>
<h2 id="编译、运行"><a href="#编译、运行" class="headerlink" title="编译、运行"></a>编译、运行</h2><p>还需要根据 iot-solution 的规则拷贝 component.mk  到我们的工程文件夹下（参考上图），接着我们可以编译运行，其中会遇到很多文件包含错误，我们需要耐心的一个个去解决；在完成之后我们就可以使用了。</p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（七）LittlevGL PC Simulator 配置</title>
    <url>/InfiniteYuanBlog/2018/08/09/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89LittlevGL%20PC%20Simulator%20%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="LittlevGL-PC-Simulator-配置"><a href="#LittlevGL-PC-Simulator-配置" class="headerlink" title="LittlevGL PC Simulator 配置"></a>LittlevGL PC Simulator 配置</h1><p>视频教程：<a href="http://tuinghe.com/videos/how-to-run-littlev-graphics-library-in-pc-simulator-linux-q5n615u5m54674n4s5d6w5.html" target="_blank" rel="noopener">How to Run Littlev Graphics Library in PC Simulator (Linux)</a></p>
<h2 id="PC-simulator"><a href="#PC-simulator" class="headerlink" title="PC simulator"></a>PC simulator</h2><p>You can try out the Littlev Graphics Library using only your PC without any development board. Write a code, run it on the PC and see the result on the monitor. It is cross-platform: Windows, Linux and OSX is also supported!</p>
<ul>
<li>Needs only few minutes setup</li>
<li>Costs $0. No PCB cost and no pay for any software</li>
<li>A TFT display is simulated and shown on the monitor of your PC</li>
<li>The touch pad is replaced by your mouse</li>
<li>The written code is portable, you can simply copy it when using an embedded hardware</li>
</ul>
<a id="more"></a>

<h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><h3>Install Eclipse CDT</h3>

<p>Eclipse CDT is C/C++ IDE. You can use other IDEs as well but in this tutorial the configuration for Eclipse CDT is shown.<br>Eclipse is a Java based software therefore be sure Jave Runtime Environment is installed on your system.<br>On linux: sudo apt-get install default-jre<br>You can download Eclipse’s CDT from: <a href="https://eclipse.org/cdt/" target="_blank" rel="noopener">https://eclipse.org/cdt/</a>. Start the nstaller and choose <em>Eclipse CDT</em> from the list</p>
<h3>Install SDL 2</h3>

<p>The PC simulator uses the <a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">SDL 2</a> cross platform library to simulate a TFT display and a touch pad.</p>
<h5>Linux</h5>

<p>On Linux you can easily install SDL2 using a terminal:</p>
<ol>
<li>Find the current version of SDL2: <code>apt-cache search libsdl2</code> (e.g. libsdl2-2.0-0)</li>
<li>Install SDL2: <code>sudo apt-get install libsdl2-2.0-0</code> (replace with the found version)</li>
<li>Install SDL2 developement package: <code>sudo apt-get install libsdl2-dev</code></li>
<li>If build essentials are not installed yet: <code>sudo apt-get install build-essential</code></li>
</ol>
<h5>Windows</h5>

<p>If you are using Windows firstly you need to install MinGW (<a href="http://mingw-w64.org/doku.php/download" target="_blank" rel="noopener">64 bit version</a>). After it do the following steps to add SDL2:</p>
<ol>
<li>Download the development libraries of SDL. Go to <a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">https://www.libsdl.org/download-2.0.php</a> and download Development Libraries: SDL2-devel-2.0.5-mingw.tar.gz</li>
<li>Uncompress the file and go to x86_64-w64-mingw32 directory (for 64 bit MinGW) or to i686-w64-mingw32 (for 32 bit MinGW)</li>
<li>Copy …_mingw32/include/SDL2 folder to C:/MinGW/…/x86_64-w64-mingw32/include</li>
<li>Copy …_mingw32/lib/ content to C:/MinGW/…/x86_64-w64-mingw32/lib</li>
<li>Copy …_mingw32/bin/SDL2.dll to {eclipse_worksapce}/pc_simulator/Debug/. Do it later when Eclipse is installed.</li>
</ol>
<blockquote>
<p>Note: If you will use Microsoft Visual Studio instead of Eclipse then you don’t have to install MinGW.</p>
</blockquote>
<h5>OSX</h5>

<p>On OSX you can easily install SDL2 with brew: <code>brew install sdl2</code></p>
<p>If something is not worging I suggest <a href="http://lazyfoo.net/tutorials/SDL/01_hello_SDL/index.php" target="_blank" rel="noopener">this tutoria</a>l to get statered with SDL</p>
<h2 id="Pre-configured-project"><a href="#Pre-configured-project" class="headerlink" title="Pre-configured project"></a>Pre-configured project</h2><p>A pre-configured graphics library project (based on the lates release) is always available in PC simulator project. You can find it on <a href="https://github.com/littlevgl/proj_pc" target="_blank" rel="noopener">GitHub</a> or on the <a href="https://littlevgl.com/download" target="_blank" rel="noopener">Download</a> page. The project is configured for Eclipse CDT.</p>
<p>##Add the pre-configured project to Eclipse CDT<br>Run Eclipse CDT. It will show a dialogue about the <strong>workspace path</strong>. Before accepting it check that path and copy (and unzip) the downloaded pre-configured project there. Now you can accept the workspace path. Of course you can modify this path but in that case copy the projct to the that location.</p>
<p>Close the start up window and go to <strong>File-&gt;Import</strong> and choose <strong>General-&gt;Existing project into Workspace</strong>.<br><strong>Browse the root directory</strong> of the project and click <strong>Finish</strong></p>
<p>On <strong>Windows</strong> you have to do two additional things:</p>
<ul>
<li>Copy the <strong>SDL2.dll</strong> into the project’s Debug folder</li>
<li>Righ click on the project -&gt; Project properties -&gt; C/C++ Build -&gt; Settings -&gt; Libraries -&gt; Add … and add mingw32 above SDLmain and SDL. (The order is important: mingw32, SDLmain, SDL)</li>
</ul>
<h2 id="Compile-and-Run"><a href="#Compile-and-Run" class="headerlink" title="Compile and Run"></a>Compile and Run</h2><p>Now you are ready to run the Littlev Graphics Library on your PC. Click on the Hammer Icon on the top menu bar to Build the project. If you have done everything right you will not get any errors. Note that on some systems additional steps might be required to “see” SDL 2 from Eclipse but in most of cases the configurtions in the downloaded project is enough.</p>
<p>After a success build click on the Play button on the top menu bar to run the project. Now a window should appear in the middle of your screen</p>
<p>Now everything is ready to use the Littlev Graphics Library in the practice or begin the developement on your PC.</p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（三）ESP32  连接 AWS IOT</title>
    <url>/InfiniteYuanBlog/2018/01/12/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89ESP32%20%20%E8%BF%9E%E6%8E%A5%20AWS%20IOT/</url>
    <content><![CDATA[<h1 id="ESP32-AWS-IOT-发布-订阅-示例"><a href="#ESP32-AWS-IOT-发布-订阅-示例" class="headerlink" title="ESP32 AWS IOT 发布/订阅 示例"></a>ESP32 AWS IOT 发布/订阅 示例</h1><p>首先提供源码吧：<a href="https://github.com/InfiniteYuan/esp32-aws-iot" target="_blank" rel="noopener">GitHub源码地址</a><br>这是一个适用于 ESP-IDF 中<a href="https://github.com/aws/aws-iot-device-sdk-embedded-C" target="_blank" rel="noopener">AWS IoT C SDK</a> 的 “subscribe_publish”示例。</p>
<a id="more"></a>

<h1 id="AWS-IOT-配置"><a href="#AWS-IOT-配置" class="headerlink" title="AWS IOT 配置"></a>AWS IOT 配置</h1><p>在运行工程前，我们需要正确配置 AWS IOT ：</p>
<ul>
<li><p>正确配置 esp-iot-solution 和 示例工程</p>
<ul>
<li>拉取最新的 esp-iot-solution</li>
<li>保证能够正确编译一个工程</li>
</ul>
</li>
<li><p>正确配置 AWS 事物模块：事物、证书、策略</p>
<ul>
<li><p>我们可以根据<a href="https://docs.aws.amazon.com/zh_cn/iot/latest/developerguide/iot-console-signin.html" target="_blank" rel="noopener">AWS IoT Developer Guide</a>，从<code>登录 AWS IOT 控制台</code> 这一步，一直配置到 <code>配置您的设备</code>这步，之后再进行下面的配置</p>
</li>
<li><p>安装私钥和证书</p>
<p>  添加 <code>*.pem.key</code> 和 <code>*.pem.crt</code> 文件到 <code>main/cert</code> 目录中，并重命名为<code>private.pem.key</code>和<code>certificate.pem.crt</code>。</p>
</li>
<li><p>设置 AWS 端点主机名</p>
<p>  您的 AWS IOT 帐户具有唯一终端主机名。要找到它，请打开 AWS IOT 控制台，然后单击左下方的“设置”按钮。端点主机名显示在此页面的“自定义端点”标题下。</p>
<p>  之后我们在电脑终端运行<code>make menuconfig</code>并进入<code>component config</code>-&gt;<code>Amazon Web Service IoT Config</code>-&gt;<code>AWS IoT MQTT Hostname</code>，在这里我们输入上一步找到的主机名。</p>
</li>
<li><p>设置客户端 ID</p>
<p>  在电脑终端中运行<code>make menuconfig</code>，在<code>example configuration</code>下，设置 <code>AWS IOT Client ID</code>的值</p>
</li>
<li><p>本地验证证书是否配置正确 </p>
<p>当 ESP32 连接到 AWS IoT 时，根 CA 证书提供信任根。我们已经在文件 <code>main/certs/aws-root-ca.pem</code> 中提供了根 CA 证书（采用 PEM 格式）。</p>
<p>如果要本地验证此根 CA 证书未更改，可以对 AWS MQTT 主机运行以下命令：</p>
<p>运行 <code>openssl s_client -showcerts -connect hostname:8883 &lt; /dev/null</code> 命令去验证证书是否正确</p>
<p>（将主机名替换为您的 AWS MQTT 端点主机。）根 CA 证书是打印的证书列表中的最后一个证书。 您可以复制粘贴它来代替现有的 <code>aws-root-ca.pem</code> 文件。</p>
</li>
</ul>
</li>
<li><p>正确配置 ESP32 网络连接</p>
<p>  在电脑终端运行 <code>make menuconfig</code> 命令，在 <code>Example Configuration</code> 目录中配置 <code>WiFi SSID</code> 和 <code>WiFi Password</code></p>
</li>
</ul>
<h1 id="监视来自设备的数据"><a href="#监视来自设备的数据" class="headerlink" title="监视来自设备的数据"></a>监视来自设备的数据</h1><p>下载完这个工程之后，程序会自动连接 AWS 并开始订阅/发布数据。</p>
<p>这个工程会发布数据到<code>test_topic/node1</code>主题，在 AWS 中提供了一个用于测试订阅/发布数据的接口：</p>
<ul>
<li>在 AWS IOT 控制里，点击右上角的“MQTT Client”。</li>
<li>点击“Generate Client ID去生成一个随机 ID。</li>
<li>点击”Connect”</li>
</ul>
<p>在连接成功后，我们可以订阅 ESP32 发布的数据：</p>
<ul>
<li>点击”Subscribe to Topic”</li>
<li>在”Subscription Topic”中输入<code>test_topic/node1</code></li>
<li>点击”Subscribe”</li>
</ul>
<p>我们可以看到正在运行的示例中发布的 MQTT 数据。</p>
<p>发布数据返回到设备：</p>
<ul>
<li>点击”Publish to Topic”</li>
<li>在”Publish Topic”中输入<code>test_topic/node2</code></li>
<li>在有效负载字段中输入消息</li>
<li>点击“Publish”</li>
</ul>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（九）使用 VS Code 快速开发 ESP32</title>
    <url>/InfiniteYuanBlog/2018/12/17/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BD%BF%E7%94%A8%20VS%20Code%20%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%20ESP32/</url>
    <content><![CDATA[<h1 id="使用-VS-Code-快速开发-ESP32"><a href="#使用-VS-Code-快速开发-ESP32" class="headerlink" title="使用 VS Code 快速开发 ESP32"></a>使用 VS Code 快速开发 ESP32</h1><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><ul>
<li>根据<a href="https://blog.csdn.net/qq_27114397/article/details/79078449" target="_blank" rel="noopener">官方文档</a>进行 <code>esp-idf</code> 开发环境搭建</li>
<li>安装 <a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">VS Code</a> </li>
</ul>
<h2 id="在-VS-Code-中进行开发"><a href="#在-VS-Code-中进行开发" class="headerlink" title="在 VS Code 中进行开发"></a>在 VS Code 中进行开发</h2><ul>
<li>将 <code>esp-idf</code> 中的模板工程 <a href="https://github.com/espressif/esp-idf/tree/master/examples/get-started/hello_world" target="_blank" rel="noopener">hello_world</a> 在 VS Code 中打开</li>
<li>在 VS Code 中开发项目</li>
</ul>
<a id="more"></a>

<h2 id="VS-Code-任务、快捷键配置"><a href="#VS-Code-任务、快捷键配置" class="headerlink" title="VS Code 任务、快捷键配置"></a>VS Code 任务、快捷键配置</h2><h3 id="任务配置"><a href="#任务配置" class="headerlink" title="任务配置"></a>任务配置</h3><ul>
<li>按下 <code>Ctrl+Shift+P</code></li>
<li>输入、选择 <code>Tasks: Configure Task</code>(任务：配置任务)</li>
<li>使用模板创建 <code>tasks.json</code> 文件</li>
<li>选择 <code>others</code></li>
<li>可使用下面的的任务配置模板（实现：快捷编译、下载、擦除 flash、清除编译、打开 monitor、menuconfig）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="string">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"build app"</span>, <span class="comment">// f5</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make -j8"</span>,</span><br><span class="line">            <span class="string">"group"</span>: &#123;</span><br><span class="line">                <span class="string">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="string">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"flash app"</span>, <span class="comment">// f6</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make -j8 flash"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"monitor"</span>, <span class="comment">// f7</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make monitor"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"clean app"</span>, <span class="comment">// f8</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make clean"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"erase flash"</span>, <span class="comment">// f9</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make erase_flash"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"menuconfig"</span>, <span class="comment">// f10</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"cd $&#123;fileDirname&#125; &amp;&amp; cd ../ &amp;&amp; make menuconfig"</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细配置过程：<img src="https://img-blog.csdnimg.cn/20181217181209238.gif" alt="详细配置过程"></p>
<h3 id="快捷键配置"><a href="#快捷键配置" class="headerlink" title="快捷键配置"></a>快捷键配置</h3><p>接下来我们给这些编译命令增加快捷键。</p>
<ul>
<li>按下：<code>Ctrl+Shift+P</code></li>
<li>输入、选择 <code>Preferences: Open Keyboard Shortcuts(JSON)</code> (首选项:打开键盘快捷方式)</li>
<li>高级自定义请打开和编辑 <code>keybindings.json</code></li>
<li>填充参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Override key bindings by placing them into your key bindings file.</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f5"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"build app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f6"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"flash app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f7"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"monitor"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f8"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"clean app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f9"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"erase flash"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"f10"</span>,</span><br><span class="line">        <span class="string">"command"</span>: <span class="string">"workbench.action.tasks.runTask"</span>,</span><br><span class="line">        <span class="string">"args"</span>: <span class="string">"menuconfig"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这样我们就可通过快捷键进行编译、下载等</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>执行的命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>F5</td>
<td><code>make -j8</code></td>
<td>编译</td>
</tr>
<tr>
<td>F6</td>
<td><code>make -j8 flash</code></td>
<td>编译、下载</td>
</tr>
<tr>
<td>F7</td>
<td><code>make monitor</code></td>
<td>监视器</td>
</tr>
<tr>
<td>F8</td>
<td><code>make clean</code></td>
<td>清除编译</td>
</tr>
<tr>
<td>F9</td>
<td><code>make erase_flash</code></td>
<td>擦除 flash</td>
</tr>
<tr>
<td>F10</td>
<td><code>make menuconfig</code></td>
<td>打开 menuconfig</td>
</tr>
</tbody></table>
<blockquote>
<p>NOTE: 这些命令都应该在工程的 <code>main</code> 目录下的文件中执行，例如： 在 VS Code 中打开了 hello_world 工程中 main 目录下的 <code>hello_world_main.c</code> 文件，可以按快捷键 <code>F6</code> 进行编译、下载。暂不支持在其他目录下进行。</p>
</blockquote>
<p>详细配置过程：<br><img src="https://img-blog.csdnimg.cn/20181217182915118.gif" alt="详细配置过程"></p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（二）OLED ssd1306 apds9960 手势控制</title>
    <url>/InfiniteYuanBlog/2018/01/12/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89OLED%20ssd1306%20apds9960%20%E6%89%8B%E5%8A%BF%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="ESP32-OLED-Demo"><a href="#ESP32-OLED-Demo" class="headerlink" title="ESP32 OLED Demo"></a>ESP32 OLED Demo</h1><p>源码地址：<a href="https://github.com/InfiniteYuan/esp32_oled_gestrue" target="_blank" rel="noopener">GitHub 源码地址</a></p>
<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><p>ESP32 OLED demo 实现了以下功能：</p>
<ul>
<li>温湿度数据采集</li>
<li>网络更新实时时间</li>
<li>OLED 分页显示温湿度、实时时间</li>
<li>手势/触摸传感器控制 OLED 显示页面上下翻页</li>
<li>通过触摸传感器手动进入低功耗模式</li>
</ul>
<a id="more"></a>

<p>下图为 ESP32 OLED Demo 的硬件实物图：<br>    <br><br>   <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTEyMTIxNzU2MjAx?x-oss-process=image/format,png" alt="硬件实物图"></p>
<hr>
<h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><p>该 DEMO 使用 ESP32_Button_Module_V2 作为开发板，包含以下元件：</p>
<ul>
<li>接近/环境光线传感器 (APDS9960)</li>
<li>OLED 显示屏 (SSD1306)</li>
<li>温度、湿度传感器 (HTS221)</li>
<li>两个触摸传感器按钮</li>
</ul>
<p>完整硬件原理图：<a href="https://github.com/InfiniteYuan1/esp32_oled_gestrue/blob/master/ESP32_BUTTON_MODULE_V2_20170720A.pdf" target="_blank" rel="noopener">ESP32_BUTTON_MODULE_V2.pdf</a></p>
<p>显示屏、传感器电源开关控制原理图：<br>    <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTEyMTIyMjQ4MjA1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>VDD33 为 LDO VOUT 3.3V 端，做为 ESP32、外设、 flash 电源；VDD33_PeriP 为显示屏、温湿度传感器、手势传感器电源。三极管 SI2301 用做电源开关，控制 VDD33_PeriP 端电压。默认情况下三极管 gate 端保持高电平，电源开关关闭，通过控制 Power_ON 保持低电平以打开电源开关。</p>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>我们使用了以下方法实现了 ESP32 OLED demo：</p>
<ul>
<li>使用 esp-iot-solution 开发工具包</li>
<li>基于 FreeRTOS 实时操作系统，多任务处理</li>
<li>SNTP 协议获取实时时间</li>
<li>通过触摸传感器进入低功耗模式</li>
<li>通过触摸传感器唤醒设备</li>
</ul>
<hr>
<h2 id="低功耗模式说明"><a href="#低功耗模式说明" class="headerlink" title="低功耗模式说明"></a>低功耗模式说明</h2><h3 id="低功耗模式硬件设计"><a href="#低功耗模式硬件设计" class="headerlink" title="低功耗模式硬件设计"></a>低功耗模式硬件设计</h3><p>我们使用了以下方法使设备在低功耗模式下的功耗达到最低。</p>
<ul>
<li>控制显示屏、温湿度传感器、手势传感器的电源开关</li>
<li>选用低功耗 LDO, 静态电流约为 1 μA</li>
<li>对触摸传感器进行功耗管理</li>
</ul>
<h3 id="触摸传感器工作周期"><a href="#触摸传感器工作周期" class="headerlink" title="触摸传感器工作周期"></a>触摸传感器工作周期</h3><p>触摸传感器在工作时，会有两种状态：sleep、measurement，两种状态循环交替进行。在正常的工作模式下我们把 sleep 时间设置得比较短，在进入低功耗模式后，我们把 sleep 时间设置得相对较长，以尽可能地降低功耗。</p>
<p>在进入低功耗模式前调用 <code>touch_pad_set_meas_time(uint16_t sleep_cycle, uint16_t meas_cycle)</code> 接口调整触摸传感器的 sleep 与 measure 时间。</p>
<p>参数说明：</p>
<ul>
<li><p><code>sleep_cycle</code>：<code>sleep_cycle</code> 决定了两次测量的间隔时间，间隔时间 t_sleep = sleep_cycle / (RTC_SLOW_CLK frequency)。</p>
<p>  可以使用 <code>rtc_clk_slow_freq_get_hz()</code> 接口获取 <code>RTC_SLOW_CLK</code> frequency 值。</p>
</li>
<li><p><code>meas_cycle</code>：<code>meas_cycle</code> 决定了测量时间，测量时间 t_meas = meas_cycle / 8M，最大测量时间为 0xffff / 8 M = 8.19 ms。</p>
</li>
</ul>
<h3 id="低功耗模式使用"><a href="#低功耗模式使用" class="headerlink" title="低功耗模式使用"></a>低功耗模式使用</h3><p>长按触摸传感器按钮进入低功耗模式，在低功耗模式下，触摸传感器采样频率会降至最低，所以从低功耗模式下唤醒同样需要稍长时间地触摸传感器按钮。低功耗模式下电流采样如下：</p>
<ul>
<li>低功耗模式下 LDO VOUT 3.3V 端的电流采样图如下 (包含 ESP32、显示屏、传感器消耗的电流) ：  <br>
  ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTEyMTIyMzE0OTQ1?x-oss-process=image/format,png)

</li>
</ul>
<blockquote>
<p>注：在低功耗模式下 LDO VOUT 3.3V 端的平均电流约为 30 μA， 最大电流约为 1.6 mA， 处在波峰时， 触摸传感器位于 measurement 状态。<br><br></p>
</blockquote>
<ul>
<li>低功耗模式下 LDO VIN 5V 端的电流采样图如下 (包含 ESP32、显示屏、传感器、LDO 消耗的电流) ：  <br>
  ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTEyMTIyMzI2Nzg1?x-oss-process=image/format,png)

</li>
</ul>
<blockquote>
<p>注：在低功耗模式下 LDO VIN 5V 端的平均电流约为 45 μA，最大电流约为 2.1 mA。</p>
</blockquote>
<h2 id="OLED-Demo-编译与运行"><a href="#OLED-Demo-编译与运行" class="headerlink" title="OLED Demo 编译与运行"></a>OLED Demo 编译与运行</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>首先需要确保你的电脑上已经安装好 ESP32 工具链，工具链安装请参考 ESP-IDF 中的 <a href="https://github.com/espressif/esp-idf/blob/master/README.md" target="_blank" rel="noopener">README.md</a>。</p>
<h3 id="获取-IoT-Solution-项目代码"><a href="#获取-IoT-Solution-项目代码" class="headerlink" title="获取 IoT Solution 项目代码"></a>获取 IoT Solution 项目代码</h3><p>执行指令，下载 iot-solution 项目仓库：</p>
<ul>
<li><p>可以直接递归获取仓库代码，这样将会自动初始化需要的所有子模块：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-iot-solution.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以手动进行初始化子模块，先运行以下指令：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-iot-solution.git</span><br></pre></td></tr></table></figure>

<ul>
<li><p>然后切换到项目根目录执行以下指令, 下载本项目依赖的一些其它子模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h3><p>子模块代码下载完成后就可以对 Iot Solution 工程中的  oled_screen_module 进行编译和运行。切换到 <code>esp-iot-solution/examples/oled\_screen\_module</code> 目录下，然后进行下列步骤。</p>
<ul>
<li>串口参数设置</li>
</ul>
<p>执行以下指令进行编译配置，如串口号和串口下载速度可以在 <code>Serial flasher config</code> 这一菜单选项中进行配置（如果不需配置, 可跳过这一步）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd YOUR_IOT_SOLUTION_PATH&#x2F;examples&#x2F;oled_screen_module</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>编译，烧写与运行</li>
</ul>
<p>执行下面指令，编译 oled_screen_module，以下命令中的 flash 是下载命令，monitor 表示开启系统打印，可根据实际情况选择添加。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make flash monitor</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：下载程序时，如果无法自动开始下载，可以尝试手动进入下载模式。下载固件完成后，按开发板上的 reset 键重新运行程序，可以查看串口打印。</p>
</blockquote>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（五）XPT2046 触摸</title>
    <url>/InfiniteYuanBlog/2018/01/16/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89XPT2046%20%E8%A7%A6%E6%91%B8/</url>
    <content><![CDATA[<h1 id="ESP32-Touch-TFT"><a href="#ESP32-Touch-TFT" class="headerlink" title="ESP32 Touch TFT"></a>ESP32 Touch TFT</h1><p>GitHub地址：<a href="https://github.com/InfiniteYuan/esp32-touchTFT" target="_blank" rel="noopener">工程源码</a><br>该工程时使用了 lcd、xpt2046、esp32 实现了触摸屏基础功能</p>
<a id="more"></a>

<h1 id="编译、运行"><a href="#编译、运行" class="headerlink" title="编译、运行"></a>编译、运行</h1><p>请参考 esp-idf 的工程配置与运行</p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（八）ESP32 MP3 播放器</title>
    <url>/InfiniteYuanBlog/2018/11/20/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89ESP32%20MP3%20%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<h1 id="ESP32-MP3-播放器"><a href="#ESP32-MP3-播放器" class="headerlink" title="ESP32 MP3 播放器"></a>ESP32 MP3 播放器</h1><p>源码地址：<a href="https://github.com/InfiniteYuan/esp32-MP3" target="_blank" rel="noopener">GitHub</a></p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>开发框架：<a href="https://github.com/espressif/esp-idf" target="_blank" rel="noopener">ESP-IDF</a>、<a href="https://github.com/espressif/esp-adf" target="_blank" rel="noopener">ESP-ADF</a><br>Embedded GUI: <a href="https://github.com/littlevgl/lvgl" target="_blank" rel="noopener">LittlevGL</a></p>
<a id="more"></a>

<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>ESP-IDF:<a href="https://docs.espressif.com/projects/esp-idf/en/latest/get-started/index.html" target="_blank" rel="noopener">搭建步骤</a></li>
<li>ESP-ADF:<a href="https://docs.espressif.com/projects/esp-adf/en/latest/get-started/index.html#setup-esp-idf" target="_blank" rel="noopener">搭建步骤</a></li>
</ul>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><ul>
<li>克隆仓库</li>
<li>进入 esp32-MP3 目录</li>
<li><code>make -j8 flash</code> 编译下载</li>
</ul>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><ul>
<li><a href="https://twitter.com/InfiniteYuan/status/1063739310275350528" target="_blank" rel="noopener">Twitter Video</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（六）移植开源图形库 LittlevGL</title>
    <url>/InfiniteYuanBlog/2018/08/08/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E7%A7%BB%E6%A4%8D%E5%BC%80%E6%BA%90%E5%9B%BE%E5%BD%A2%E5%BA%93%20LittlevGL/</url>
    <content><![CDATA[<h1 id="ESP32-移植开源图形库-LittlevGL"><a href="#ESP32-移植开源图形库-LittlevGL" class="headerlink" title="ESP32 移植开源图形库 LittlevGL"></a>ESP32 移植开源图形库 LittlevGL</h1><p>ESP32 移植 LittlevGL 的源码：<a href="https://github.com/InfiniteYuan/esp32-lvgl-gui" target="_blank" rel="noopener">GitHub 源码地址</a><br>欢迎 Star ～</p>
<h2 id="LittlevGL-介绍"><a href="#LittlevGL-介绍" class="headerlink" title="LittlevGL 介绍"></a>LittlevGL 介绍</h2><blockquote>
<p>littlevGL is a free and open-source graphics library providing everything you need to create embedded GUI with easy-to-use graphical elements, beautiful visual effects and low memory footprint.<br><a href="https://littlevgl.com/" target="_blank" rel="noopener">LittlevGL 官网链接</a><br><a href="https://littlevgl.com/porting" target="_blank" rel="noopener">LittlevGL 移植教程</a><br><a href="https://littlevgl.com/basics" target="_blank" rel="noopener">LittlevGL 官方文档</a><br><a href="https://github.com/littlevgl/lvgl" target="_blank" rel="noopener">LittlevGL GitHub链接</a></p>
</blockquote>
<a id="more"></a>

<h4>关键特性：</h4>

<ul>
<li>Powerful building blocks buttons, charts, lists, sliders, images etc</li>
<li>Advanced graphics with animations, anti-aliasing, opacity, smooth scrolling</li>
<li>Various input devices touch pad, mouse, keyboard, encoder, buttons etc</li>
<li>Multi language support with UTF-8 decoding</li>
<li>Fully customizable graphical elements</li>
<li>Hardware independent to use with any microcontroller or display</li>
<li>Scalable to operate with few memory (50 kB Flash, 10 kB RAM)</li>
<li>OS, External memory and GPU supported but not required</li>
<li>Single frame buffer operation even with advances graphical effects</li>
<li>Written in C for maximal compatibility</li>
<li>Simulator to develop on PC without embedded hardware</li>
<li>Tutorials, examples, themes for rapid development</li>
<li>Documentation and API references online</li>
</ul>
<h2 id="移植过程"><a href="#移植过程" class="headerlink" title="移植过程"></a>移植过程</h2><ol>
<li>在工程目录下新建一个 components 目录，放入 LittlevGL 源码</li>
<li>在 components 目录下新建一个 include 目录，放入 lv_conf.h 文件，由 LittlevGL 源码目录中的 lv_conf_templ.h文件而来</li>
<li>在 components 目录下新建一个  component.mk  文件，将 LittlevGL 相关源码添加到组件的 <code>COMPONENT_SRCDIRS</code>、<code>COMPONENT_ADD_INCLUDEDIRS</code>和<code>COMPONENT_PRIV_INCLUDEDIRS</code>目录变量中</li>
<li>之后在程序中使用了～，可根据 <a href="https://github.com/littlevgl/lv_examples/blob/master/lv_tutorial/0_porting/lv_tutorial_porting.c" target="_blank" rel="noopener">LittlevGL Tutorial</a> 在自己的主程序中实现</li>
</ol>
<h4>大致初始化流程：</h4>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Initialize LittlevGL</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line">lv_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Tick interface</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"><span class="comment">/* Initialize a Timer for 1 ms period and</span></span><br><span class="line"><span class="comment"> * in its interrupt call</span></span><br><span class="line"><span class="comment"> * lv_tick_inc(1); */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Display interface</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"><span class="keyword">lv_disp_drv_t</span> disp_drv;                         <span class="comment">/*Descriptor of a display driver*/</span></span><br><span class="line">lv_disp_drv_init(&amp;disp_drv);                    <span class="comment">/*Basic initialization*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Set up the functions to access to your display*/</span></span><br><span class="line">disp_drv.disp_flush = ex_disp_flush;            <span class="comment">/*Used in buffered mode (LV_VDB_SIZE != 0  in lv_conf.h)*/</span></span><br><span class="line"></span><br><span class="line">disp_drv.disp_fill = ex_disp_fill;              <span class="comment">/*Used in unbuffered mode (LV_VDB_SIZE == 0  in lv_conf.h)*/</span></span><br><span class="line">disp_drv.disp_map = ex_disp_map;                <span class="comment">/*Used in unbuffered mode (LV_VDB_SIZE == 0  in lv_conf.h)*/</span></span><br><span class="line"><span class="comment">/*Finally register the driver*/</span></span><br><span class="line">lv_disp_drv_register(&amp;disp_drv);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment"> * Input device interface</span></span><br><span class="line"><span class="comment"> *************************/</span></span><br><span class="line"><span class="comment">/*Add a touchpad in the example*/</span></span><br><span class="line"><span class="comment">/*touchpad_init();*/</span>                            <span class="comment">/*Initialize your touchpad*/</span></span><br><span class="line"><span class="keyword">lv_indev_drv_t</span> indev_drv;                       <span class="comment">/*Descriptor of an input device driver*/</span></span><br><span class="line">lv_indev_drv_init(&amp;indev_drv);                  <span class="comment">/*Basic initialization*/</span></span><br><span class="line">indev_drv.type = LV_INDEV_TYPE_POINTER;         <span class="comment">/*The touchpad is pointer type device*/</span></span><br><span class="line">indev_drv.<span class="built_in">read</span> = ex_tp_read;                    <span class="comment">/*Library ready your touchpad via this function*/</span></span><br><span class="line">lv_indev_drv_register(&amp;indev_drv);              <span class="comment">/*Finally register the driver*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************</span></span><br><span class="line"><span class="comment"> * Run the task handler of LittlevGL</span></span><br><span class="line"><span class="comment"> *************************************/</span></span><br><span class="line"><span class="comment">/* Periodically call this function.</span></span><br><span class="line"><span class="comment"> * The timing is not critical but should be between 1..10 ms */</span></span><br><span class="line">lv_task_handler();</span><br><span class="line"><span class="comment">/*delay_ms(5)*/</span></span><br></pre></td></tr></table></figure>

<h4>需要实现的函数：</h4>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Display interface</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"> <span class="comment">/*Write the internal buffer (VDB) to the display. 'lv_flush_ready()' has to be called when finished*/</span></span><br><span class="line"> <span class="keyword">void</span> (*disp_flush)(<span class="keyword">int32_t</span> x1, <span class="keyword">int32_t</span> y1, <span class="keyword">int32_t</span> x2, <span class="keyword">int32_t</span> y2, <span class="keyword">const</span> <span class="keyword">lv_color_t</span> * color_p);</span><br><span class="line"> <span class="comment">/*Fill an area with a color on the display*/</span></span><br><span class="line"> <span class="keyword">void</span> (*disp_fill)(<span class="keyword">int32_t</span> x1, <span class="keyword">int32_t</span> y1, <span class="keyword">int32_t</span> x2, <span class="keyword">int32_t</span> y2, <span class="keyword">lv_color_t</span> color);</span><br><span class="line"> <span class="comment">/*Write pixel map (e.g. image) to the display*/</span></span><br><span class="line"> <span class="keyword">void</span> (*disp_map)(<span class="keyword">int32_t</span> x1, <span class="keyword">int32_t</span> y1, <span class="keyword">int32_t</span> x2, <span class="keyword">int32_t</span> y2, <span class="keyword">const</span> <span class="keyword">lv_color_t</span> * color_p);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment"> * Input device interface</span></span><br><span class="line"><span class="comment"> *************************/</span></span><br><span class="line"> <span class="keyword">bool</span> (*<span class="built_in">read</span>)(<span class="keyword">lv_indev_data_t</span> *data);        <span class="comment">/*Function pointer to read data. Return 'true' if there is still data to be read (buffered)*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>在实现 <code>disp_flush</code> 函数时，在函数末尾需要调用 LittlevGL 提供的 <code>lv_flush_ready</code> 函数<br>上述的这些函数可以自行实现，函数体保持一致即可</p>
</blockquote>
<p>欢迎关注本人 <a href="https://github.com/InfiniteYuan" target="_blank" rel="noopener">GitHub</a> ，更新 ESP32 相关开源库</p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十一）使用 ESP32 做为 WebServer</title>
    <url>/InfiniteYuanBlog/2019/04/28/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32%20%E5%81%9A%E4%B8%BA%20WebServer/</url>
    <content><![CDATA[<h1 id="使用-ESP32-做为-WebServer"><a href="#使用-ESP32-做为-WebServer" class="headerlink" title="使用 ESP32 做为 WebServer"></a>使用 ESP32 做为 WebServer</h1><p>在某些场景，我们可能需要在手机上或者其他移动终端访问 ESP32 的数据，这个时候我们需要在手机上展示 ESP32 设备的相关信息，这个时候可以用 APP 在手机上展示数据，或者在手机浏览器中打开存储在 ESP32 上的网页。或者其他的方式。</p>
<p>这篇文章我们将介绍第二种方式。在 ESP32 上存储网页文件，将 ESP32 做为一个简单的 WebServer。</p>
<p>工作流程：(第一种方式)</p>
<ol>
<li>首先通过 gzip 将 HTML 文件压缩为 <code>.gz</code> 文件</li>
<li>使用 filetoarray 工具将 <code>.gz</code> 文件转为头文件</li>
<li>在 ESP32 程序中将头文件中的数组发送出去</li>
</ol>
<p>工作流程：(第二种方式)</p>
<ol>
<li>首先通过 gzip 将 HTML 文件压缩为 <code>.gz</code> 文件</li>
<li>使用 ESP32 构建系统中的<a href="https://blog.csdn.net/qq_27114397/article/details/81152448#_449" target="_blank" rel="noopener">嵌入二进制数据</a>的方式，将其添加到 Flash 中的 <code>.rodata</code> 部分</li>
<li>在 ESP32 程序中将 Flash 中的数组发送出去</li>
</ol>
<a id="more"></a>

<h2 id="filetoarray-工具"><a href="#filetoarray-工具" class="headerlink" title="filetoarray 工具"></a>filetoarray 工具</h2><p>使用这个工具将 <code>.gz</code> 文件转换为包含十六进制数组和其长度的头文件。</p>
<p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">buffer</span>;</span><br><span class="line">    <span class="keyword">long</span> flen;</span><br><span class="line">    <span class="keyword">char</span> *fname;</span><br><span class="line">    <span class="keyword">char</span> pname[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( argc == <span class="number">2</span> ) &#123;</span><br><span class="line">        fname = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(pname, fname);</span><br><span class="line">        <span class="keyword">char</span> *dot = <span class="built_in">strchr</span>(pname, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">while</span> (dot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *dot = <span class="string">'_'</span>;</span><br><span class="line">            dot = <span class="built_in">strchr</span>(pname, <span class="string">'.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Filename not supplied\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(fname, <span class="string">"rb"</span>);</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    flen = ftell(fp);</span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buffer</span> = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((flen + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    fread(<span class="built_in">buffer</span>, flen, <span class="number">1</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n//File: %s, Size: %lu\n"</span>, fname, flen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"#define %s_len %lu\n"</span>, pname, flen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const uint8_t %s[] PROGMEM = &#123;\n"</span>, pname);</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; flen; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 0x%02X"</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="built_in">buffer</span>[i]));</span><br><span class="line">        <span class="keyword">if</span> (i &lt; (flen - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">16</span>) == <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n&#125;;\n\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">buffer</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML-文件到头文件"><a href="#HTML-文件到头文件" class="headerlink" title="HTML 文件到头文件"></a>HTML 文件到头文件</h2><p>使用方式：</p>
<ol>
<li>使用 gzip 将 HTML 文件转换为 <code>.gz</code> 文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gzip index.html</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译 <code>filetoarray.c</code> 源文件，生成可执行文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc filetoarray.c -o filetoarray</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 filetoarray 将  <code>.gz</code> 文件转为头文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./filetoarray index.html.gz &gt; index.h</span><br></pre></td></tr></table></figure>

<h2 id="HTML-文件到-Flash"><a href="#HTML-文件到-Flash" class="headerlink" title="HTML 文件到 Flash"></a>HTML 文件到 Flash</h2><p>使用方式：</p>
<ol>
<li>使用 gzip 将 HTML 文件转换为 <code>.gz</code> 文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gzip index.html</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在工程 <code>main</code> 目录下的 <code>component.mk</code> 中添加</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COMPONENT_EMBED_FILES := www/index.html.gz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在工程源码中这样使用</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_start[] <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_start"</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_end[]   <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_end"</span>);</span><br><span class="line"><span class="keyword">size_t</span> index_html_gz_len = index_html_gz_end - index_html_gz_start;</span><br><span class="line"></span><br><span class="line">httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz_start, index_html_gz_len);</span><br></pre></td></tr></table></figure>

<h2 id="在-ESP32-中启动-HTTP-Server"><a href="#在-ESP32-中启动-HTTP-Server" class="headerlink" title="在 ESP32 中启动 HTTP Server"></a>在 ESP32 中启动 HTTP Server</h2><p>第一种方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"index.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">index_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span>&#123;</span><br><span class="line">    httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">    httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    <span class="keyword">return</span> httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz, index_html_gz_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">index_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_start[] <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_start"</span>);</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> index_html_gz_end[]   <span class="keyword">asm</span>(<span class="string">"_binary_index_html_gz_end"</span>);</span><br><span class="line">	<span class="keyword">size_t</span> index_html_gz_len = index_html_gz_end - index_html_gz_start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    httpd_resp_set_type(req, <span class="string">"text/html"</span>);</span><br><span class="line">    httpd_resp_set_hdr(req, <span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    <span class="keyword">return</span> httpd_resp_send(req, (<span class="keyword">const</span> <span class="keyword">char</span> *)index_html_gz_start, index_html_gz_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"app_httpd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"esp_http_server.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_httpd_main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">httpd_handle_t</span> camera_httpd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">httpd_config_t</span> <span class="built_in">config</span> = HTTPD_DEFAULT_CONFIG();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">httpd_uri_t</span> index_uri = &#123;</span><br><span class="line">        .uri       = <span class="string">"/"</span>,</span><br><span class="line">        .method    = HTTP_GET,</span><br><span class="line">        .handler   = index_handler,</span><br><span class="line">        .user_ctx  = <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Starting web server on port: '%d'"</span>, <span class="built_in">config</span>.server_port);</span><br><span class="line">    <span class="keyword">if</span> (httpd_start(&amp;camera_httpd, &amp;<span class="built_in">config</span>) == ESP_OK) &#123;</span><br><span class="line">        httpd_register_uri_handler(camera_httpd, &amp;index_uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ul>
<li><a href="https://github.com/espressif/esp-who/blob/master/examples/single_chip/camera_web_server/main/app_httpd.c" target="_blank" rel="noopener">web server</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十三）ESP32 ping 功能</title>
    <url>/InfiniteYuanBlog/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89ESP32%20ping%20%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">pingResults</span><span class="params">(<span class="keyword">ping_target_id_t</span> msgType, esp_ping_found * pf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"AvgTime:%.1fmS Sent:%d Rec:%d min(mS):%d max(mS):%d Resp(mS):%d Timeouts:%d Total Time:%d\n"</span>, (<span class="keyword">float</span>)pf-&gt;total_time/pf-&gt;recv_count, pf-&gt;send_count, pf-&gt;recv_count,  pf-&gt;min_time, pf-&gt;max_time ,pf-&gt;resp_time, pf-&gt;timeout_count, pf-&gt;total_time);</span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start_Ping_ESP32</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">uint32_t</span> ip_pinG = ipaddr_addr(<span class="string">"163.177.151.109"</span>);<span class="comment">//百度IP地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_count = <span class="number">2000</span>;<span class="comment">//ping的次数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_timeout = <span class="number">1000</span>; <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_delay = <span class="number">2000</span>; <span class="comment">//ping 的间隔</span></span><br><span class="line">    ping_deinit();</span><br><span class="line">    esp_ping_set_target(PING_TARGET_IP_ADDRESS_COUNT, &amp;ping_count, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_RCV_TIMEO, &amp;ping_timeout, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_DELAY_TIME, &amp;ping_delay, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_IP_ADDRESS, &amp;ip_pinG, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    esp_ping_set_target(PING_TARGET_RES_FN, &amp;pingResults, <span class="keyword">sizeof</span>(pingResults));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span> res = <span class="number">0</span>;</span><br><span class="line">    res = ping_init();</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"PING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error:%d\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十二）LittlevGL 添加自定义字体和物理按键</title>
    <url>/InfiniteYuanBlog/2019/05/12/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89LittlevGL%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E7%89%A9%E7%90%86%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<h1 id="LittlevGL-添加自定义字体"><a href="#LittlevGL-添加自定义字体" class="headerlink" title="LittlevGL 添加自定义字体"></a>LittlevGL 添加自定义字体</h1><ol>
<li>获取字库 <code>ttf</code> 文件<br>可以从一些网站上获取字库文件，比如<blockquote>
<p>请注意字体许可证</p>
</blockquote>
</li>
<li>生成源文件<br>使用 LittlevGL 提供的字库文件<a href="https://littlevgl.com/ttf-font-to-c-array" target="_blank" rel="noopener">转换工具</a>，将 <code>ttf</code> 字库文件转换为源文件。</li>
</ol>
<a id="more"></a>
<ol start="3">
<li>将生成的源文件添加到 LittlevGL 工程中，添加以下代码声明字体：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern lv_font_t my_font_name;</span><br></pre></td></tr></table></figure>
或者<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LV_FONT_DECLARE(my_font_name);</span><br></pre></td></tr></table></figure>
源代码中使用这个字体可以：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style.text.font &#x3D; &amp;my_font_name;</span><br></pre></td></tr></table></figure>
或者将这个字体添加到当前使用的字体中：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lv_font_add(&amp;my_font_name, &amp;current_use);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LV_FONT_DECLARE(my_font_name);</span><br><span class="line"></span><br><span class="line">void lv_chinese_fonts1(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*Concatenate the fonts into one*&#x2F;</span><br><span class="line">&#x2F;&#x2F;    lv_font_add(&amp;arial_cyrillic_20, &amp;arial_ascii_20); 相同高度才可以添加到一起</span><br><span class="line">&#x2F;&#x2F;    lv_font_add(&amp;arial_math_20, &amp;arial_ascii_20);</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 创建一个新的样式，并且修改新样式的文本字体 *&#x2F;</span><br><span class="line">    static lv_style_t style1; </span><br><span class="line">    lv_style_copy(&amp;style1, &amp;lv_style_plain);</span><br><span class="line">    style1.text.font &#x3D; &amp;my_font_name; &#x2F;* 设置自定义字体 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;*Create a label and set new text*&#x2F;</span><br><span class="line">    lv_obj_t * label &#x3D; lv_label_create(lv_scr_act(), NULL); &#x2F;* 创建标签 *&#x2F;</span><br><span class="line">    lv_obj_set_pos(label, 10, 10);       &#x2F;* 设置相对位置 *&#x2F;</span><br><span class="line">    lv_label_set_style(label, &amp;style1);  &#x2F;* 设置样式 *&#x2F;</span><br><span class="line">    lv_label_set_text(label, &quot;Hello World!\n 世界你好,我是littleVGL!&quot;);      &#x2F;* 显示汉字 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LittlevGL-添加自定义符号"><a href="#LittlevGL-添加自定义符号" class="headerlink" title="LittlevGL 添加自定义符号"></a>LittlevGL 添加自定义符号</h1><p>流程：</p>
<ul>
<li>寻找合适的 <code>ttf</code> 文件（包含目标符号，可在 linux 下通过 FontForge 软件打开 <code>ttf</code> 文件，查看包含那些字符）</li>
<li>使用 LittlevGL 提供的字库文件<a href="https://littlevgl.com/ttf-font-to-c-array" target="_blank" rel="noopener">转换工具</a>，将选中的符号转换为 <code>c</code> 源文件。在转换的页面 <code>Range</code> 中输入目标符号的 Unicode 编码，怎么查询可以通过百度</li>
<li>将源文件添加到工程中，和上面添加字体类似，首先声明字体，然后添加到字体中或者直接使用。</li>
<li>定义一个宏指向这个目标符号，宏的内容需要为 <code>UTF-8编码</code>，通过 <a href="https://www.qqxiuzi.cn/bianma/Unicode-UTF.php" target="_blank" rel="noopener">Unicode和UTF编码转换</a> 可以进行转换</li>
</ul>
<p>例如：<br><img src="https://img-blog.csdnimg.cn/20190515163138800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="摄氏度符号"></p>
<p>这样就需要在程序中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* MACROS *&#x2F;</span><br><span class="line">#define SYMBOL_TEMP &quot;\xE2\x84\x83&quot; &#x2F;&#x2F; E28483</span><br><span class="line"></span><br><span class="line">&#x2F;* STATIC VARIABLES *&#x2F;</span><br><span class="line">LV_FONT_DECLARE(tempreture_symbol_40);</span><br><span class="line"></span><br><span class="line">&#x2F;* Add font to current font *&#x2F;</span><br><span class="line">lv_font_add(&amp;tempreture_symbol_40, &amp;lv_font_dejavu_40);</span><br><span class="line"></span><br><span class="line">&#x2F;* Use this symbol *&#x2F;</span><br><span class="line">lv_label_set_text(temp_l, &quot;21.5 &quot;SYMBOL_TEMP);</span><br></pre></td></tr></table></figure>

<h1 id="LittlevGL-添加物理按键"><a href="#LittlevGL-添加物理按键" class="headerlink" title="LittlevGL 添加物理按键"></a>LittlevGL 添加物理按键</h1><p>注册物理按键驱动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint8_t my_btn_read()</span><br><span class="line">&#123;</span><br><span class="line">    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool my_input_read(lv_indev_data_t *data)</span><br><span class="line">&#123;</span><br><span class="line">    static int8_t last_btn &#x3D; 0;    &#x2F;* Store the last pressed button *&#x2F;</span><br><span class="line">    int8_t btn_pr &#x3D; my_btn_read(); &#x2F;* Get the ID (0,1,2...) of the pressed button *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (btn_pr &gt; 0)</span><br><span class="line">    &#123;                                    &#x2F;* Is there a button press? *&#x2F;</span><br><span class="line">        last_btn &#x3D; btn_pr;               &#x2F;* Save the ID of the pressed button *&#x2F;</span><br><span class="line">        data-&gt;state &#x3D; LV_INDEV_STATE_PR; &#x2F;* Set the pressed state *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        data-&gt;state &#x3D; LV_INDEV_STATE_REL; &#x2F;* Set the released state *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data-&gt;btn &#x3D; last_btn; &#x2F;* Set the last button *&#x2F;</span><br><span class="line"></span><br><span class="line">    return false; &#x2F;* No buffering so no more data read *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">void my_button_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static lv_indev_t *indev;</span><br><span class="line">    lv_indev_drv_t indev_drv;</span><br><span class="line"></span><br><span class="line">    lv_indev_drv_init(&amp;indev_drv);</span><br><span class="line"></span><br><span class="line">    indev_drv.read &#x3D; my_input_read;</span><br><span class="line">    indev_drv.type &#x3D; LV_INDEV_TYPE_BUTTON;</span><br><span class="line">    indev &#x3D; lv_indev_drv_register(&amp;indev_drv);</span><br><span class="line"></span><br><span class="line">    &#x2F;*points_array: these points will be assigned to the buttons to press a specific point on the screen.*&#x2F;</span><br><span class="line">    static lv_point_t points_array[] &#x3D; &#123;&#123;20, 20&#125;&#125;;</span><br><span class="line">    lv_indev_set_button_points(indev, points_array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个按键，保证上面的点在按钮的区域内：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static lv_obj_t *btn &#x3D; lv_btn_create(lv_scr_act(), NULL);  </span><br><span class="line">lv_obj_set_size(btn, 40, 40);</span><br><span class="line">lv_obj_set_pos(btn, 0, 0);</span><br><span class="line">lv_btn_set_action(btn, LV_BTN_ACTION_CLICK, btn_click_action);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十五）使用 LittlevGL 实现 2048 小游戏</title>
    <url>/InfiniteYuanBlog/2020/05/17/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E4%BD%BF%E7%94%A8%20LittlevGL%20%E5%AE%9E%E7%8E%B0%202048%20%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="使用-LittlevGL-实现-2048-小游戏"><a href="#使用-LittlevGL-实现-2048-小游戏" class="headerlink" title="使用 LittlevGL 实现 2048 小游戏"></a>使用 LittlevGL 实现 2048 小游戏</h1><p>2048 这款益智小游戏，游戏的规则十分简单，简单易上手的数字小游戏，但又十分虐心。曾经也是风靡一时。</p>
<p>现在我们在 ESP32 上自己动手实现 2048 这款小游戏吧。</p>
<a id="more"></a>

<h2 id="1-使用-LittlevGL"><a href="#1-使用-LittlevGL" class="headerlink" title="1 使用 LittlevGL"></a>1 使用 LittlevGL</h2><p>esp32-lvgl-gui 仓库已经适配了 LittlevGL V5.3，并适配了几款屏幕(ILI9341、ST7789、SSD1306、NT35510) 和 触摸驱动(FT5X06、XPT2046)。</p>
<p>使用时，在 <code>menuconfig</code> 中选择你所使用的 屏幕 和 触摸驱动。</p>
<p>编译代码：</p>
<ol>
<li>添加头文件：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* lvgl includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iot_lvgl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* game include */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"game.h"</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化 LittlevGL：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Initialize LittlevGL */</span></span><br><span class="line">    lv_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tick interface， Initialize a Timer for 1 ms period and in its interrupt call*/</span></span><br><span class="line">    <span class="comment">// esp_register_freertos_tick_hook(lv_tick_task_callback);</span></span><br><span class="line">    lvgl_tick_timer = xTimerCreate(</span><br><span class="line">        <span class="string">"lv_tickinc_task"</span>,</span><br><span class="line">        <span class="number">1</span> / portTICK_PERIOD_MS,            <span class="comment">//period time</span></span><br><span class="line">        pdTRUE,                            <span class="comment">//auto load</span></span><br><span class="line">        (<span class="keyword">void</span> *)<span class="literal">NULL</span>,                      <span class="comment">//timer parameter</span></span><br><span class="line">        lv_tick_task_callback);            <span class="comment">//timer callback</span></span><br><span class="line">    xTimerStart(lvgl_tick_timer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Display interface */</span></span><br><span class="line">    lvgl_lcd_display_init();	           <span class="comment">/*Initialize your display*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Input device interface */</span></span><br><span class="line">    input_device = lvgl_indev_init();                     <span class="comment">/*Initialize your indev*/</span></span><br><span class="line"></span><br><span class="line">    lvgl_timer = xTimerCreate(</span><br><span class="line">        <span class="string">"lv_task"</span>,</span><br><span class="line">        <span class="number">10</span> / portTICK_PERIOD_MS,           <span class="comment">//period time</span></span><br><span class="line">        pdTRUE,                            <span class="comment">//auto load</span></span><br><span class="line">        (<span class="keyword">void</span> *)<span class="literal">NULL</span>,                      <span class="comment">//timer parameter</span></span><br><span class="line">        lvgl_task_time_callback);          <span class="comment">//timer callback</span></span><br><span class="line">    xTimerStart(lvgl_timer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2048 game init</span></span><br><span class="line">    game_init(<span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// game logic handle task</span></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        user_task,   <span class="comment">//Task Function</span></span><br><span class="line">        <span class="string">"user_task"</span>, <span class="comment">//Task Name</span></span><br><span class="line">        <span class="number">1024</span>*<span class="number">4</span>,      <span class="comment">//Stack Depth</span></span><br><span class="line">        <span class="literal">NULL</span>,        <span class="comment">//Parameters</span></span><br><span class="line">        <span class="number">1</span>,           <span class="comment">//Priority</span></span><br><span class="line">        <span class="literal">NULL</span>);       <span class="comment">//Task Handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2048-游戏逻辑"><a href="#2-2048-游戏逻辑" class="headerlink" title="2 2048 游戏逻辑"></a>2 2048 游戏逻辑</h2><h3 id="2-1-界面初始化"><a href="#2-1-界面初始化" class="headerlink" title="2.1 界面初始化"></a>2.1 界面初始化</h3><p>将游戏相关界面初始化分为以下几步：</p>
<ol>
<li>Step 1: 画游戏背景</li>
<li>Step 2: 画游戏分数显示框</li>
<li>Step 3: 画游戏网格</li>
<li>Step 4: 画游戏网格中每个单元格的内容</li>
</ol>
<h3 id="2-2-滑动处理"><a href="#2-2-滑动处理" class="headerlink" title="2.2 滑动处理"></a>2.2 滑动处理</h3><h4 id="2-2-1-判断滑动方向"><a href="#2-2-1-判断滑动方向" class="headerlink" title="2.2.1 判断滑动方向"></a>2.2.1 判断滑动方向</h4><p>通过调用 LittlevGL 的 API 读取触摸状态(抬起/按下、坐标点)，计算水平/竖直方向滑动的差值，判断为哪个方向上的滑动(上/下/左/右)，执行相应的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">lv_indev_drv_t</span> input_device;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">user_task</span><span class="params">(<span class="keyword">void</span> *pvParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> pressing = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">lv_indev_data_t</span> touchpad_data;</span><br><span class="line">    <span class="keyword">lv_point_t</span> last_data;</span><br><span class="line">    <span class="keyword">int16_t</span> x_diff, y_diff;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(<span class="number">50</span> / portTICK_PERIOD_MS);</span><br><span class="line">        input_device.<span class="built_in">read</span>(&amp;touchpad_data); <span class="comment">// 读取触摸驱动的值</span></span><br><span class="line">        <span class="keyword">if</span> (touchpad_data.state == LV_INDEV_STATE_REL) &#123; <span class="comment">// 当前为 `抬起` 状态</span></span><br><span class="line">            pressing = <span class="literal">false</span>; <span class="comment">// 计算坐标偏移量</span></span><br><span class="line">            x_diff = touchpad_data.<span class="built_in">point</span>.x - last_data.x;</span><br><span class="line">            y_diff = touchpad_data.<span class="built_in">point</span>.y - last_data.y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(x_diff) &gt; SENSITIVE || <span class="built_in">fabs</span>(y_diff) &gt; SENSITIVE) &#123; <span class="comment">// 判断滑动距离是否超过判断阈值</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(x_diff) &gt; <span class="built_in">fabs</span>(y_diff)) &#123; <span class="comment">// 判断是否为水平滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (x_diff &gt; <span class="number">0</span>) &#123; <span class="comment">// 判单是否为向右滑动</span></span><br><span class="line">                        move_right();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向左滑动</span></span><br><span class="line">                        move_left();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 竖直方向滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (y_diff &gt; <span class="number">0</span>) &#123; <span class="comment">// 判单是否为向下滑动</span></span><br><span class="line">                        move_down();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向上滑动</span></span><br><span class="line">                        move_up();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last_data.x = touchpad_data.<span class="built_in">point</span>.x;</span><br><span class="line">            last_data.y = touchpad_data.<span class="built_in">point</span>.y;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (touchpad_data.state == LV_INDEV_STATE_PR) &#123; <span class="comment">// 当前为 `按下` 状态</span></span><br><span class="line">            <span class="keyword">if</span> (!pressing) &#123; <span class="comment">// 按下状态，记录初次按下的坐标点</span></span><br><span class="line">                last_data.x = touchpad_data.<span class="built_in">point</span>.x;</span><br><span class="line">                last_data.y = touchpad_data.<span class="built_in">point</span>.y;</span><br><span class="line">                pressing = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-滑动逻辑处理"><a href="#2-2-2-滑动逻辑处理" class="headerlink" title="2.2.2 滑动逻辑处理"></a>2.2.2 滑动逻辑处理</h4><ol>
<li>判断同一行/列滑动方向上是否存在相等的数值</li>
<li>相同的单元格，数值相加为相邻单元格中的后一个(滑动方向上)的数值</li>
<li>画出总的得分</li>
<li>判断游戏是否结束</li>
<li>刷新界面上的单元格</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> num_matrix[<span class="number">5</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 保存所有的单元格中的数值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> score_num = <span class="number">0</span>; <span class="comment">// 总得分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_up</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t, nx = <span class="number">-1</span>, ny = <span class="number">0</span>, nn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i)</span><br><span class="line">        tmp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num_matrix[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[++k] = num_matrix[i][j];</span><br><span class="line">                num_matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &lt;= k - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[t] == tmp[t + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t] *= <span class="number">2</span>;</span><br><span class="line">                tmp[t + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                score_num += tmp[t];</span><br><span class="line">                <span class="keyword">if</span> (nx == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nx = t;</span><br><span class="line">                    ny = j;</span><br><span class="line">                    nn = tmp[t];</span><br><span class="line">                &#125;</span><br><span class="line">                t += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t++;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            <span class="keyword">if</span> (tmp[i])</span><br><span class="line">                num_matrix[t++][j] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画总分</span></span><br><span class="line">    draw_score_num(score_num);</span><br><span class="line">    <span class="comment">// 刷新网格中单元格的内容</span></span><br><span class="line">    gen_num();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>GitHub 源码：<a href="https://github.com/InfiniteYuan/esp32-lvgl-gui/tree/master/lvgl_2048" target="_blank" rel="noopener">esp32-lvgl-gui</a></li>
<li>Twitter 视频：<a href="https://twitter.com/InfiniteYuan/status/1048106496649641985?s=20" target="_blank" rel="noopener">Twitter</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十四）ESP32 I2C Slave 实现</title>
    <url>/InfiniteYuanBlog/2019/11/22/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89ESP32%20I2C%20Slave%20%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文章将介绍使用 ESP32 作为 I2C 实现 Random Read/Write 和  Sequential Read/Write 时序。</p>
<p>首先通过下面的图了解下 Random Read 时序，I2C Master 通过这个时序读取任意数据地址开始的数据。<br><img src="https://img-blog.csdnimg.cn/20191123145556881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="Random Read"></p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">___________________________________________________________________________________________________________________________________________________</span><br><span class="line">| start | slave_addr + write_bit + ack | data address |start | slave_addr + read_bit + ack |  <span class="built_in">read</span> n<span class="number">-1</span> bytes + ack | <span class="built_in">read</span> <span class="number">1</span> <span class="keyword">byte</span> + nack | <span class="built_in">stop</span> |</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>RANDOM READ</strong>: A random read requires a “dummy” byte write sequence to load in the data word address. Once the device address word and data word address are clocked in and acknowledged by the EEPROM, the microcontroller must generate another start condition.<br>The microcontroller now initiates a current address read by sending a device address with the read/write select bit high. The EEPROM acknowledges the device address and serially clocks out the data word. The microcontroller does not respond with a zero but does generate a following stop condition </p>
</blockquote>
<ul>
<li>现有的 I2C Slave 无法实现类似 Random Read 时序<ul>
<li>原因分析：esp-idf 提供的 <code>i2c_slave_write_buffer</code> <code>i2c_slave_read_buffer</code> API 都是操作 RingBuffer 实现，而 Random Read 需要 Slave 在 接收到 <code>slave_addr + read_bit + data address</code> 前将数据放入 I2C 的硬件 FIFO 中。若是通过 API 进行判断当前 Master 想要操作的 数据地址，会因为这个 API 都是操作 RingBuffer 而有所延迟，导致 Master 接收到错误的数据（因为此时硬件 FIFO 还没有数据）。</li>
<li>解决办法：<ul>
<li>在接收到 <code>slave_addr + write_bit + data address</code> 时将可能需要发送到主机的数据放入 TX FIFO 中，当主机继续发送 <code>slave_addr + read_bit + data address</code> 并 提供读数据时钟 时，I2C Slave 硬件会将 TX FIFO 中的数据发送到 Master。若主机不再发送 <code>slave_addr + read_bit + data address</code>，就将 FIFO 清空避免在之后的操作中造成错误。</li>
<li>通过自定义中断处理程序，在相应的中断中进行处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="I2C-中断介绍"><a href="#I2C-中断介绍" class="headerlink" title="I2C 中断介绍"></a>I2C 中断介绍</h1><ol>
<li>想要针对某个 I2C 或者 某种模式，使用自定义的中断处理程序，需要修改 <code>esp-idf/components/driver/i2c.c</code> 中的代码，这里仅仅针对 master 使用驱动中提供的中断处理程序，当模式为 Slave 时，使用自定义的中断处理程序。</li>
</ol>
<blockquote>
<p>在 release/3.2 中，无法直接使用 <code>i2c_isr_register</code> 覆盖之前的中断处理程序。通过简单修改驱动源文件，并在应用程序中调用 <code>i2c_isr_register</code> 实现使用自定义的中断处理程序。</p>
</blockquote>
<p>修改 <code>esp-idf/components/driver/i2c.c</code> 文件中 <code>i2c_driver_install</code>  函数中的这段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == I2C_MODE_MASTER) &#123;</span><br><span class="line">    <span class="comment">//hook isr handler</span></span><br><span class="line">    i2c_isr_register(i2c_num, i2c_isr_handler_default, p_i2c_obj[i2c_num], intr_alloc_flags, &amp;p_i2c_obj[i2c_num]-&gt;intr_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用程序中使用自定义的中断处理程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> IRAM_ATTR <span class="title">i2c_slave_isr_handler_default</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	…</span><br><span class="line">	…</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief i2c slave initialization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_err_t</span> <span class="title">i2c_slave_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i2c_slave_port = I2C_SLAVE_NUM;</span><br><span class="line">    <span class="keyword">i2c_config_t</span> conf_slave;</span><br><span class="line">    conf_slave.sda_io_num = I2C_SLAVE_SDA_IO;</span><br><span class="line">    conf_slave.sda_pullup_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf_slave.scl_io_num = I2C_SLAVE_SCL_IO;</span><br><span class="line">    conf_slave.scl_pullup_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf_slave.mode = I2C_MODE_SLAVE;</span><br><span class="line">    conf_slave.slave.addr_10bit_en = <span class="number">0</span>;</span><br><span class="line">    conf_slave.slave.slave_addr = ESP_SLAVE_ADDR;</span><br><span class="line">    i2c_param_config(i2c_slave_port, &amp;conf_slave);</span><br><span class="line">    i2c_driver_install(i2c_slave_port, conf_slave.mode, I2C_SLAVE_RX_BUF_LEN, I2C_SLAVE_TX_BUF_LEN, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i2c_isr_register(I2C_SLAVE_NUM, i2c_slave_isr_handler_default, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>) != ESP_OK) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"i2c_isr_register error"</span>);</span><br><span class="line">        <span class="keyword">return</span> ESP_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Slave-中断处理程序"><a href="#Slave-中断处理程序" class="headerlink" title="Slave 中断处理程序"></a>Slave 中断处理程序</h1><p>需要使用的几个中断：</p>
<ul>
<li><strong>I2C_SLAVE_TRAN_COMP_INT</strong>：从机收到设备地址和数据地址时将触发（device address + W/R bit + data address），在这里需要判断 Write/Read。若是 Write，需要清空 TX FIFO，并提前将需要操作的数据放入 TX FIFO 中（根据数据地址），尽可能放满 TX FIFO</li>
<li><strong>I2C_TRANS_COMPLETE_INT</strong>：从机检测到 STOP 时将触发，这个中断中需要将 RX FIFO 中的数据取到数据缓冲区中</li>
<li><strong>I2C_TXFIFO_EMPTY_INT</strong>：硬件 TX FIFO 为空时将触发，（PS：实际测试触发时，FIFO 大小为 27 byte），将可能操作的数据继续放入 TX FIFO 中</li>
<li><strong>I2C_RXFIFO_FULL_INT</strong>：硬件 RX FIFO 满时将触发，将 RX FIFO 中的数据取到数据缓冲区中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> IRAM_ATTR <span class="title">i2c_slave_isr_handler_default</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i2c_num = I2C_SLAVE_NUM;</span><br><span class="line">    <span class="keyword">uint32_t</span> status = I2C_INSTANCE[i2c_num]-&gt;int_status.val;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    portBASE_TYPE HPTaskAwoken = pdFALSE;</span><br><span class="line">    <span class="keyword">while</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        status = I2C_INSTANCE[i2c_num]-&gt;int_status.val;</span><br><span class="line">        <span class="keyword">if</span> (status &amp; I2C_ACK_ERR_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"ae\n"</span>);</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_ena.ack_err = <span class="number">0</span>;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.ack_err = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_TRANS_COMPLETE_INT_ST_M) &#123; <span class="comment">// receive data after receive device address + W/R bit and data address</span></span><br><span class="line">            <span class="comment">// ets_printf("tc, ");</span></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.trans_complete = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> rx_fifo_cnt = I2C_INSTANCE[i2c_num]-&gt;status_reg.rx_fifo_cnt;</span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                <span class="comment">// ets_printf("R\n");</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                <span class="comment">// ets_printf("W ");</span></span><br><span class="line">                ets_printf(<span class="string">"Slave Recv"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; rx_fifo_cnt; idx++) &#123;</span><br><span class="line">                    slave_data[w_r_index++] = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">                &#125;</span><br><span class="line">                ets_printf(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_full = <span class="number">1</span>;</span><br><span class="line">            slave_event = SLAVE_IDLE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_SLAVE_TRAN_COMP_INT_ST_M) &#123; <span class="comment">// slave receive device address + W/R bit + data address</span></span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                ets_printf(<span class="string">"sc, Slave Send\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                <span class="comment">// ets_printf("sc W\n");</span></span><br><span class="line">                w_r_index = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">                <span class="keyword">switch</span> (slave_event) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SLAVE_IDLE:</span><br><span class="line">                        ets_printf(<span class="string">"sc, I2W\n"</span>);</span><br><span class="line">                        <span class="comment">// reset tx fifo to avoid send last byte when master send read command next.</span></span><br><span class="line">                        i2c_reset_tx_fifo(i2c_num);</span><br><span class="line"></span><br><span class="line">                        slave_event = SLAVE_WRITE;</span><br><span class="line">                        slave_send_index = w_r_index;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> tx_fifo_rem = I2C_FIFO_LEN - I2C_INSTANCE[i2c_num]-&gt;status_reg.tx_fifo_cnt;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tx_fifo_rem; i++) &#123;</span><br><span class="line">                            WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), slave_data[slave_send_index++]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        I2C_INSTANCE[i2c_num]-&gt;int_ena.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                        I2C_INSTANCE[i2c_num]-&gt;int_clr.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.slave_tran_comp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_TXFIFO_EMPTY_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"tfe, "</span>);</span><br><span class="line">            <span class="keyword">int</span> tx_fifo_rem = I2C_FIFO_LEN - I2C_INSTANCE[i2c_num]-&gt;status_reg.tx_fifo_cnt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (I2C_INSTANCE[i2c_num]-&gt;status_reg.slave_rw) &#123; <span class="comment">// read, slave should to send</span></span><br><span class="line">                ets_printf(<span class="string">"R\r\n"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tx_fifo_rem; i++) &#123;</span><br><span class="line">                    WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), slave_data[slave_send_index++]);</span><br><span class="line">                &#125;</span><br><span class="line">                I2C_INSTANCE[i2c_num]-&gt;int_ena.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">                I2C_INSTANCE[i2c_num]-&gt;int_clr.tx_fifo_empty = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// write, slave should to recv</span></span><br><span class="line">                ets_printf(<span class="string">"W\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_RXFIFO_OVF_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"rfo\n"</span>);</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_ovf = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status &amp; I2C_RXFIFO_FULL_INT_ST_M) &#123;</span><br><span class="line">            ets_printf(<span class="string">"rff\n"</span>);</span><br><span class="line">            <span class="keyword">int</span> rx_fifo_cnt = I2C_INSTANCE[i2c_num]-&gt;status_reg.rx_fifo_cnt;</span><br><span class="line">            <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; rx_fifo_cnt; idx++) &#123;</span><br><span class="line">                slave_data[w_r_index++] = I2C_INSTANCE[i2c_num]-&gt;fifo_data.data;</span><br><span class="line">            &#125;</span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.rx_fifo_full = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ets_printf("%x\n", status);</span></span><br><span class="line">            I2C_INSTANCE[i2c_num]-&gt;int_clr.val = status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//We only need to check here if there is a high-priority task needs to be switched.</span></span><br><span class="line">    <span class="keyword">if</span>(HPTaskAwoken == pdTRUE) &#123;</span><br><span class="line">        portYIELD_FROM_ISR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h1><ul>
<li><a href="https://github.com/InfiniteYuan/ESP32-I2C-Slave/tree/master" target="_blank" rel="noopener">ESP32-I2C-Slave</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf" target="_blank" rel="noopener">I2C Specification</a></li>
</ul>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（十）使用 ESP32+Camera 二维码识别</title>
    <url>/InfiniteYuanBlog/2019/03/14/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E4%BD%BF%E7%94%A8%20ESP32+Camera%20%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="使用-ESP32-Camera-进行二维码识别"><a href="#使用-ESP32-Camera-进行二维码识别" class="headerlink" title="使用 ESP32 Camera 进行二维码识别"></a>使用 ESP32 Camera 进行二维码识别</h1><ul>
<li>GitHub: <a href="https://github.com/InfiniteYuan/esp32-camera-qr-recoginize/tree/master/examples/single_chip/qrcode_recoginize" target="_blank" rel="noopener">esp32-camera-qr-recoginize</a></li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><a href="https://github.com/espressif/esp-who" target="_blank" rel="noopener">ESP-WHO</a></li>
<li><a href="https://github.com/espressif/esp-idf" target="_blank" rel="noopener">ESP-IDF</a></li>
</ul>
<a id="more"></a>

<h2 id="使用-quirc-二维码识别库"><a href="#使用-quirc-二维码识别库" class="headerlink" title="使用 quirc 二维码识别库"></a>使用 quirc 二维码识别库</h2><ul>
<li><a href="https://github.com/dlbeer/quirc" target="_blank" rel="noopener">quirc</a></li>
</ul>
<h2 id="摄像头初始化"><a href="#摄像头初始化" class="headerlink" title="摄像头初始化"></a>摄像头初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_PIXEL_FORM PIXFORMAT_GRAYSCALE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_FRAME_SIZE FRAMESIZE_VGA</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_CAMERA_MODEL_CUSTOM</span></span><br><span class="line">    <span class="comment">/* IO13, IO14 is designed for JTAG by default,</span></span><br><span class="line"><span class="comment">     * to use it as generalized input,</span></span><br><span class="line"><span class="comment">     * firstly declair it as pullup input */</span></span><br><span class="line">    <span class="keyword">gpio_config_t</span> conf;</span><br><span class="line">    conf.mode = GPIO_MODE_INPUT;</span><br><span class="line">    conf.pull_up_en = GPIO_PULLUP_ENABLE;</span><br><span class="line">    conf.pull_down_en = GPIO_PULLDOWN_DISABLE;</span><br><span class="line">    conf.intr_type = GPIO_INTR_DISABLE;</span><br><span class="line">    conf.pin_bit_mask = <span class="number">1L</span>L &lt;&lt; <span class="number">13</span>;</span><br><span class="line">    gpio_config(&amp;conf);</span><br><span class="line">    conf.pin_bit_mask = <span class="number">1L</span>L &lt;&lt; <span class="number">14</span>;</span><br><span class="line">    gpio_config(&amp;conf);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">config</span>.ledc_channel = LEDC_CHANNEL_0;</span><br><span class="line">    <span class="built_in">config</span>.ledc_timer = LEDC_TIMER_0;</span><br><span class="line">    <span class="built_in">config</span>.pin_d0 = Y2_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d1 = Y3_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d2 = Y4_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d3 = Y5_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d4 = Y6_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d5 = Y7_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d6 = Y8_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_d7 = Y9_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_xclk = XCLK_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_pclk = PCLK_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_vsync = VSYNC_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_href = HREF_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_sscb_sda = SIOD_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_sscb_scl = SIOC_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_pwdn = PWDN_GPIO_NUM;</span><br><span class="line">    <span class="built_in">config</span>.pin_reset = RESET_GPIO_NUM;</span><br><span class="line">    <span class="comment">// Only support 10 MHz current. Camera will output bad image when XCLK is 20 MHz.</span></span><br><span class="line">    <span class="built_in">config</span>.xclk_freq_hz = <span class="number">10000000</span>;</span><br><span class="line">    <span class="built_in">config</span>.pixel_format = CAMERA_PIXEL_FORM;</span><br><span class="line">    <span class="built_in">config</span>.frame_size = CAMERA_FRAME_SIZE;</span><br><span class="line">    <span class="built_in">config</span>.jpeg_quality = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">config</span>.fb_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera init</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_camera_init(&amp;<span class="built_in">config</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Camera init failed with error 0x%x"</span>, err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create QR-code recognize task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    app_qr_recognize(&amp;<span class="built_in">config</span>);</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Free heap: %u"</span>, xPortGetFreeHeapSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a>二维码识别</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr_recoginze</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">camera_config_t</span> *camera_config = (<span class="keyword">camera_config_t</span> *)parameter;</span><br><span class="line">    <span class="comment">// Use VGA Size currently, but quirc can support other frame size.(eg: FRAMESIZE_SVGA,FRAMESIZE_VGA，</span></span><br><span class="line">    <span class="comment">// FRAMESIZE_CIF,FRAMESIZE_QVGA,FRAMESIZE_HQVGA,FRAMESIZE_QCIF,FRAMESIZE_QQVGA2,FRAMESIZE_QQVGA,etc)</span></span><br><span class="line">    <span class="keyword">if</span> (camera_config-&gt;frame_size &gt; FRAMESIZE_VGA) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Camera Frame Size err %d"</span>, (camera_config-&gt;frame_size));</span><br><span class="line">        vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save image width and height, avoid allocate memory repeatly.</span></span><br><span class="line">    <span class="keyword">uint16_t</span> old_width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> old_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct a new QR-code recognizer.</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Construct a new QR-code recognizer(quirc)."</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quirc</span> *<span class="title">qr_recognizer</span> = <span class="title">quirc_new</span>();</span></span><br><span class="line">    <span class="keyword">if</span> (!qr_recognizer) &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">"Can't create quirc object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">camera_fb_t</span> *fb = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> *<span class="built_in">image</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> id_count = <span class="number">0</span>;</span><br><span class="line">    UBaseType_t uxHighWaterMark;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入口处检测一次 */</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"uxHighWaterMark = %d"</span>, uxTaskGetStackHighWaterMark( <span class="literal">NULL</span> ));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">"uxHighWaterMark = %d"</span>, uxTaskGetStackHighWaterMark( <span class="literal">NULL</span> ));</span><br><span class="line">        <span class="comment">// Capture a frame</span></span><br><span class="line">        fb = esp_camera_fb_get();</span><br><span class="line">        <span class="keyword">if</span> (!fb) &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">"Camera capture failed"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old_width != fb-&gt;<span class="built_in">width</span> || old_height != fb-&gt;<span class="built_in">height</span>) &#123;</span><br><span class="line">            ESP_LOGD(TAG, <span class="string">"Recognizer size change w h len: %d, %d, %d"</span>, fb-&gt;<span class="built_in">width</span>, fb-&gt;<span class="built_in">height</span>, fb-&gt;len);</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">"Resize the QR-code recognizer."</span>);</span><br><span class="line">            <span class="comment">// Resize the QR-code recognizer.</span></span><br><span class="line">            <span class="keyword">if</span> (quirc_resize(qr_recognizer, fb-&gt;<span class="built_in">width</span>, fb-&gt;<span class="built_in">height</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">"Resize the QR-code recognizer err."</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                old_width = fb-&gt;<span class="built_in">width</span>;</span><br><span class="line">                old_height = fb-&gt;<span class="built_in">height</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** These functions are used to process images for QR-code recognition.</span></span><br><span class="line"><span class="comment">         * quirc_begin() must first be called to obtain access to a buffer into</span></span><br><span class="line"><span class="comment">         * which the input image should be placed. Optionally, the current</span></span><br><span class="line"><span class="comment">         * width and height may be returned.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * After filling the buffer, quirc_end() should be called to process</span></span><br><span class="line"><span class="comment">         * the image for QR-code recognition. The locations and content of each</span></span><br><span class="line"><span class="comment">         * code may be obtained using accessor functions described below.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">image</span> = quirc_begin(qr_recognizer, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">image</span>, fb-&gt;buf, fb-&gt;len);</span><br><span class="line">        quirc_end(qr_recognizer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the number of QR-codes identified in the last processed image.</span></span><br><span class="line">        id_count = quirc_count(qr_recognizer);</span><br><span class="line">        <span class="keyword">if</span> (id_count == <span class="number">0</span>) &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">"Error: not a valid qrcode"</span>);</span><br><span class="line">            esp_camera_fb_return(fb);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print information of QR-code</span></span><br><span class="line">        dump_info(qr_recognizer, id_count);</span><br><span class="line">        esp_camera_fb_return(fb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Destroy QR-Code recognizer (quirc)</span></span><br><span class="line">    quirc_destroy(qr_recognizer);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">"Deconstruct QR-Code recognizer(quirc)"</span>);</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例结果"><a href="#示例结果" class="headerlink" title="示例结果"></a>示例结果</h2><p><img src="https://img-blog.csdnimg.cn/20190315190639946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTE0Mzk3,size_16,color_FFFFFF,t_70" alt="示例结果"></p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 开发笔记（四）OV7670 摄像头图像采集</title>
    <url>/InfiniteYuanBlog/2018/01/16/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ESP32%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89OV7670%20%E6%91%84%E5%83%8F%E5%A4%B4%E5%9B%BE%E5%83%8F%E9%87%87%E9%9B%86/</url>
    <content><![CDATA[<h1 id="ESP32-Camera-Demo"><a href="#ESP32-Camera-Demo" class="headerlink" title="ESP32 Camera Demo"></a>ESP32 Camera Demo</h1><p><a href="https://github.com/InfiniteYuan/esp32_ov7670_video" target="_blank" rel="noopener">GitHub 源码地址</a><br>使用的硬件有：</p>
<ul>
<li><code>ESP-WROVER-KIT</code>开发板</li>
<li>OV7670 摄像头</li>
<li>ST7789 控制器的 LCD 屏幕</li>
</ul>
<p>该工程实现的功能有：</p>
<ul>
<li>通过手机端浏览器访问 ESP32 HTTP 服务器，查看当前摄像头采集的图像</li>
<li>摄像头采集图像、LCD 实时显示刷新速率达到 22fps</li>
</ul>
<a id="more"></a>

<h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p>按照默认的<code>make menuconfig</code>中的默认配置连接即可。</p>
<blockquote>
<p>注: 如果使用<code>ESP-WROVER-KIT</code>开发板，请注意把 LCD 的 reset 引脚上拉，否则 LCD 无法正常复位。</p>
</blockquote>
<blockquote>
<p>注: 如果 LCD 的背光灯没有正常亮起，可以将背光灯引脚直接接到高/低电平。</p>
</blockquote>
<h2 id="硬件实物图"><a href="#硬件实物图" class="headerlink" title="硬件实物图"></a>硬件实物图</h2><p>该工程默认使用的为<code>ESP-WROVER-KIT</code>开发板;<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgyODA0MDM5?x-oss-process=image/format,png" alt="LCD屏幕"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgzMDQ2MjIw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>若选用<code>ESP-WROVER-KIT</code>开发板，下载时，请选择 ttyUSB1 ;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j8 flash</span><br></pre></td></tr></table></figure>

<h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><p>以下是需要注意的相关配置：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgzMTE3Njk4?x-oss-process=image/format,png" alt="这里写图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgzMTI4Mzg3?x-oss-process=image/format,png" alt="这里写图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgzMTM5OTYx?x-oss-process=image/format,png" alt="这里写图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MTgzMTUxNDU1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>ESP32 开发笔记</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
</search>
